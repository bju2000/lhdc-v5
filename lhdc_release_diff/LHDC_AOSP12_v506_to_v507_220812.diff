diff --git a/external/liblhdc/include/lhdc_api.h b/external/liblhdc/include/lhdc_api.h
index 6e92a0703..079719cb7 100755
--- a/external/liblhdc/include/lhdc_api.h
+++ b/external/liblhdc/include/lhdc_api.h
@@ -26,6 +26,7 @@ typedef enum name {
     LHDCBT_QUALITY_MID,
     LHDCBT_QUALITY_HIGH,
     LHDCBT_QUALITY_AUTO,
+    LHDCBT_QUALITY_RESET_AUTO,
     LHDCBT_QUALITY_MAX
 } LHDCBT_QUALITY_T;
 
diff --git a/external/liblhdc/release_note b/external/liblhdc/release_note
index 11af04258..e8bde81d9 100755
--- a/external/liblhdc/release_note
+++ b/external/liblhdc/release_note
@@ -1,7 +1,10 @@
 Release Note.
 =========================================================
+2022/07/20
+1. Upgrade LHDCV4 encoder version to V4.0.6
+
 2022/04/18
-1. Upgrade LHDCV4 encoder version to V4.0.4 - 60e474
+1. Upgrade LHDCV4 encoder version to V4.0.4
 
 2021/11/15
 1. Add to print LHDC version and build time.
diff --git a/external/liblhdc/src/lhdcBT_enc.c b/external/liblhdc/src/lhdcBT_enc.c
index 87df7aada..5c4e15a31 100755
--- a/external/liblhdc/src/lhdcBT_enc.c
+++ b/external/liblhdc/src/lhdcBT_enc.c
@@ -23,6 +23,8 @@
 
 #define LHDC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_lhdc)/sizeof(int))
 #define LLAC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_llac)/sizeof(int))
+#define LHDC_ABR_DEFAULT_BITRATE     (400)
+#define LLAC_ABR_DEFAULT_BITRATE     (400)
 
 #define AR_ALWAYS_ONx  1
 
@@ -162,7 +164,7 @@ static int lhdc_encoder_set_bitrate(lhdc_para_t * handle, int bitrate_inx){
             if (bitrate_inx != LHDCBT_QUALITY_AUTO) {
                 handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(bitrate_inx), handle->hasMinBitrateLimit ? 320 : 128);
             }else{
-                handle->lastBitrate = 400;
+                handle->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
                 lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
                 lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
             }
@@ -649,14 +651,60 @@ int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx){
     enc_t * enc = &lhdcBT->enc;
 
     switch(lhdcBT->enc_type){
-        case ENC_TYPE_LHDC:
-            return lhdc_encoder_set_bitrate(enc->lhdc, bitrate_inx);
+        case ENC_TYPE_LHDC: {
+          lhdc_para_t *lhdc = enc->lhdc;
+          if(lhdc == NULL) {
+            ALOGD("%s: LHDC [Reset BiTrAtE] null ptr!",  __func__);
+            return -1;
+          }
+
+          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
+            if(lhdc->qualityStatus != LHDCBT_QUALITY_AUTO) {
+              ALOGD("%s: LHDC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, lhdc->qualityStatus);
+              return -1;
+            }
+            // change bitrate only, do not update qualityStatus
+            lhdc->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
+            lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, lhdc);
+            lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, lhdc);
+            if (lhdc->version >= 2) {
+              lhdc->updateFramneInfo = true;
+            }
+            LossyEncoderSetTargetByteRate(lhdc->fft_blk, (lhdc->lastBitrate * 1000) / 8);
+            ALOGD("%s: LHDC [Reset BiTrAtE] Reset bitrate to (%d)",  __func__, lhdc->lastBitrate);
+            return 0;
+          } else {
+            // normal case, will update qualityStatus
+            ALOGD("%s: LHDC set bitrate_inx %d", __func__, bitrate_inx);
+            return lhdc_encoder_set_bitrate(lhdc, bitrate_inx);
+          }
+        }
 
         case ENC_TYPE_LLAC: {
+          llac_para_t * llac = enc->llac;
+          if(llac == NULL) {
+            ALOGD("%s: LLAC [Reset BiTrAtE] null ptr!",  __func__);
+            return -1;
+          }
 
+          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
+            if(llac->qualityStatus != LHDCBT_QUALITY_AUTO) {
+              ALOGD("%s: LLAC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, llac->qualityStatus);
+              return -1;
+            }
+            // change bitrate only, do not update qualityStatus
+            llac->lastBitrate = LLAC_ABR_DEFAULT_BITRATE;
+            ALOGD("%s: LLAC [Reset BiTrAtE] Reset bitrate to (%d)", __func__, llac->lastBitrate);
+            llac_enc_set_bitrate(llac->lastBitrate * 1000, &llac->out_nbytes, &llac->real_bitrate, llac->lh4_enc);
+            llac->updateFramneInfo = true;
+            lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, llac);
+            lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, llac);
+            return 0;
+          } else {
             //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
             ALOGD("%s: LLAC not supported", __func__);
             return -1;
+          }
         }
         default:
         break;
diff --git a/external/liblhdcdec/release_note b/external/liblhdcdec/release_note
index 5776bd2c3..5a42cb9e0 100755
--- a/external/liblhdcdec/release_note
+++ b/external/liblhdcdec/release_note
@@ -1,5 +1,8 @@
 Release Note.
 =========================================================
+2022/05/11
+1. Upgrade LHDCV4 decoder version to V4.0.2
+
 2021/11/22
-Add LHDC v3/v4 Decoder v4.0.2 - 758f73
+Add LHDC v3/v4 Decoder
 
diff --git a/external/liblhdcv5/CHANGES b/external/liblhdcv5/CHANGES
index e0373be4a..10de496d1 100755
--- a/external/liblhdcv5/CHANGES
+++ b/external/liblhdcv5/CHANGES
@@ -1,4 +1,7 @@
 Release Note.
 =========================================================
-Monday, Feb 21, 2022, by jimmy.chen@savitech.co
-  Summary for 5.0.4 liblhdcv5 release - cf80fc
+Jul 20, 2022, by jimmy.chen@savitech.co
+  Summary for 5.0.5 liblhdcv5 release  
+  
+Feb 21, 2022, by jimmy.chen@savitech.co
+  Summary for 5.0.1 liblhdcv5 release
\ No newline at end of file
diff --git a/external/liblhdcv5/include/lhdcv5_api.h b/external/liblhdcv5/include/lhdcv5_api.h
index dcc5c7eee..860e4e04b 100755
--- a/external/liblhdcv5/include/lhdcv5_api.h
+++ b/external/liblhdcv5/include/lhdcv5_api.h
@@ -62,6 +62,7 @@ typedef enum __LHDCV5_QUALITY__
   LHDCV5_QUALITY_HIGH,
   LHDCV5_QUALITY_HIGH1,
   LHDCV5_QUALITY_AUTO,
+  LHDCV5_QUALITY_RESET_AUTO,
   LHDCV5_QUALITY_INVALID
 } LHDCV5_QUALITY_T;
 
diff --git a/external/liblhdcv5/src/lhdcv5BT_enc.c b/external/liblhdcv5/src/lhdcv5BT_enc.c
index d3ef0243c..7719fbe7c 100755
--- a/external/liblhdcv5/src/lhdcv5BT_enc.c
+++ b/external/liblhdcv5/src/lhdcv5BT_enc.c
@@ -31,6 +31,8 @@ static uint32_t auto_bitrate_adjust_table_lhdcv5_192k[] = {256, 320, 400, 400, 4
 #define LHDCV5_96K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_96k) / sizeof(uint32_t))
 #define LHDCV5_192K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_192k) / sizeof(uint32_t))
 
+#define LHDCV5_ABR_DEFAULT_BITRATE     (LHDCV5_QUALITY_LOW)
+
 
 static const char * rate_to_string
 (
@@ -177,7 +179,7 @@ static int lhdcv5_encoder_adjust_bitrate
 
   if (lhdcBT == NULL)
   {
-    ALOGW ("%s: Handle is NULL!", __func__);
+    ALOGW ("%s: lhdcBT is NULL!", __func__);
     return LHDCV5_FRET_INVALID_HANDLE_CB;
   }
 
@@ -189,7 +191,7 @@ static int lhdcv5_encoder_adjust_bitrate
 
   if (handle->qualityStatus != LHDCV5_QUALITY_AUTO)
   {
-    ALOGW ("%s: Not ABR", __func__);
+    ALOGW ("%s: Not ABR (%d)", __func__, handle->qualityStatus);
     return LHDCV5_FRET_SUCCESS;
   }
 
@@ -569,21 +571,31 @@ int32_t lhdcv5BT_set_bitrate
   }
 
   if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
-      (bitrate_inx > LHDCV5_QUALITY_AUTO))
+      (bitrate_inx >= LHDCV5_QUALITY_INVALID))
   {
     ALOGW ("%s: Invalid bit rate index (%u)!", __func__, bitrate_inx);
     return LHDCV5_FRET_INVALID_INPUT_PARAM;
   }
 
-  func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
+  if (bitrate_inx == LHDCV5_QUALITY_RESET_AUTO) {
+    bitrate_inx_set = LHDCV5_ABR_DEFAULT_BITRATE;
+    ALOGD ("%s: [Reset BiTrAtE] reset to bitrate (%s)", __func__, rate_to_string (bitrate_inx_set));
+    bitrate_inx = LHDCV5_ABR_DEFAULT_BITRATE;
+    // change bitrate only, not update quality index
+    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, false);
+  } else {
+    // also update quality index
+    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
+  }
 
   if (func_ret != LHDCV5_FRET_SUCCESS)
   {
-    ALOGW ("%s: failed to set bit rate (%d)!", __func__, func_ret);
+    ALOGW ("%s: failed to set bitrate (%d)!", __func__, func_ret);
     return LHDCV5_FRET_ERROR;
   }
 
-  ALOGD ("%s: Update target bitrate(%s)",  __func__, rate_to_string (bitrate_inx_set));
+  ALOGD ("%s: Update target bitrate(%s)",  __func__,
+      rate_to_string (bitrate_inx_set));
 
   return LHDCV5_FRET_SUCCESS;
 }
diff --git a/external/liblhdcv5dec/CHANGES b/external/liblhdcv5dec/CHANGES
index cf1bb70e4..123e86335 100755
--- a/external/liblhdcv5dec/CHANGES
+++ b/external/liblhdcv5dec/CHANGES
@@ -1,4 +1,7 @@
 Release Note.
 =========================================================
-Monday, Feb 21, 2022, by jimmy.chen@savitech.co
-  Summary for 5.0.1 liblhdcv5dec release - b5900e
+Jun 21, 2022, by jimmy.chen@savitech.co
+  *Update version to 5.0.5
+
+Feb, 21, 2022, by jimmy.chen@savitech.co
+  *Add LHDCV5 Decoder v5.0.1
diff --git a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
index 29701bd60..0785b9fe2 100755
--- a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
+++ b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
@@ -4,7 +4,7 @@
 extern "C" {
 #endif
 
-#include "lhdcv5Util.h"
+#include "lhdcv5_util_dec.h"
 
 #define LHDCV5BT_SAMPLE_RATE_44K    (44100)
 #define LHDCV5BT_SAMPLE_RATE_48K    (48000)
@@ -15,31 +15,53 @@ extern "C" {
 #define LHDCV5BT_BIT_DEPTH_24    (24)
 #define LHDCV5BT_BIT_DEPTH_32    (32)
 
+#define LHDCV5BT_BIT_RATE_64K    (64000)
+#define LHDCV5BT_BIT_RATE_128K   (128000)
+#define LHDCV5BT_BIT_RATE_192K   (192000)
+#define LHDCV5BT_BIT_RATE_256K   (256000)
+#define LHDCV5BT_BIT_RATE_320K   (320000)
+#define LHDCV5BT_BIT_RATE_400K   (400000)
+#define LHDCV5BT_BIT_RATE_600K   (600000)
+#define LHDCV5BT_BIT_RATE_900K   (900000)
+#define LHDCV5BT_BIT_RATE_1000K  (1000000)
 
-typedef struct  
+
+
+typedef struct
 {
   lhdc_ver_t version;
-  uint32_t   sample_rate;
-  uint8_t    bits_depth;
+  uint32_t sample_rate;
+  uint32_t bits_depth;
+  uint32_t bit_rate;
 } tLHDCV5_DEC_CONFIG;
 
 
-
-int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config);
-int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
-int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
-int lhdcBT_dec_deinit_decoder(void);
-
+// lib APIs
+int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config);
+int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle);
 
 #define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
 #define LHDCBT_DEC_UPD_SEQ_NO				1
 
+typedef enum __LHDCV5BT_DEC_API_RET__
+{
+  LHDCV5BT_DEC_API_SUCCEED            =  0,
+  LHDCV5BT_DEC_API_FAIL               = -1,
+  LHDCV5BT_DEC_API_INVALID_INPUT      = -2,
+  LHDCV5BT_DEC_API_INVALID_OUTPUT     = -3,
+  LHDCV5BT_DEC_API_INVALID_SEQ_NO     = -4,
+  LHDCV5BT_DEC_API_INIT_DECODER_FAIL  = -5,
+  LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL = -6,
+  LHDCV5BT_DEC_API_FRAME_INFO_FAIL    = -7,
+  LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH   = -8,
+  LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH  = -9,
+  LHDCV5BT_DEC_API_DECODE_FAIL        = -10,
+  LHDCV5BT_DEC_API_ALLOC_MEM_FAIL  = -11,
+
+} LHDCV5BT_DEC_API_RET_T;
 
-#define LHDCBT_DEC_FUNC_SUCCEED             0
-#define LHDCBT_DEC_FUNC_FAIL                -1
-#define LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH    -2
-#define LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH   -3
-#define LHDCBT_DEC_FUNC_INVALID_SEQ_NO		-4
 
 #ifdef __cplusplus
 }
diff --git a/external/liblhdcv5dec/include/lhdcv5Util.h b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
old mode 100755
new mode 100644
similarity index 55%
rename from external/liblhdcv5dec/include/lhdcv5Util.h
rename to external/liblhdcv5dec/include/lhdcv5_util_dec.h
index 733bd5670..576d8c5c2
--- a/external/liblhdcv5dec/include/lhdcv5Util.h
+++ b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
@@ -1,12 +1,10 @@
 /*
- * lhdcv5Util.h
+ * lhdcv5_util_dec.h
  *
- *  Created on: 2022/03/18
- *      Author: jimmy chen
  */
 
-#ifndef LHDC_UTIL_H
-#define LHDC_UTIL_H
+#ifndef LHDCV5_UTIL_DEC_H
+#define LHDCV5_UTIL_DEC_H
 
 #include <stdbool.h>
 #include <stdint.h>
@@ -15,6 +13,8 @@
 extern "C" {
 #endif
 
+typedef void * HANDLE_LHDCV5_BT;
+
 // Copy definition from external
 #define BTIF_BD_ADDR_SIZE    6
 
@@ -25,10 +25,6 @@ typedef enum {
 }LHDC_STRM_TYPE;
 
 typedef enum {
-  VERSION_2 = 200,
-  VERSION_3 = 300,
-  VERSION_4 = 400,
-  VERSION_LLAC = 500,
   VERSION_5 = 550
 }lhdc_ver_t;
 
@@ -76,23 +72,29 @@ typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
 #define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
 
 
-int32_t lhdcv5_util_init_decoder(uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
-uint32_t lhdcv5_util_dec_put_data(uint8_t * pInpBuf, uint32_t NumBytes);
-uint32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t len);
-bool lhdcv5_util_set_license(uint8_t * licTable, LHDC_GET_BT_INFO pFunc);
-int32_t lhdcv5_util_set_license_check_period (uint8_t period);
+int32_t lhdcv5_util_init_decoder(uint32_t *ptr, uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+
+int32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t InLen, uint32_t *OutLen);
 char *lhdcv5_util_dec_get_version();
 
 int32_t lhdcv5_util_dec_destroy();
 
-void lhdc_register_log_cb(print_log_fp cb);
+void lhdcv5_util_dec_register_log_cb(print_log_fp cb);
+
+int32_t lhdcv5_util_dec_get_sample_size (uint32_t *frame_samples);
+int32_t lhdcv5_util_dec_fetch_frame_info(uint8_t *frameData, uint32_t frameDataLen, lhdc_frame_Info_t *frameInfo);
 
-uint32_t lhdcv5_util_dec_get_sample_size (void);
-bool lhdcv5_util_dec_fetch_frame_info(uint8_t * frameData, lhdc_frame_Info_t * frameInfo);
+int32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
+int32_t lhdcv5_util_dec_get_mem_req(lhdc_ver_t version, uint32_t *mem_req_bytes);
 
-uint32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
+//Return
+#define LHDCV5_UTIL_DEC_SUCCESS 0
+#define LHDCV5_UTIL_DEC_ERROR_NO_INIT -1
+#define LHDCV5_UTIL_DEC_ERROR_PARAM -2
+#define LHDCV5_UTIL_DEC_ERROR -3
+#define LHDCV5_UTIL_DEC_ERROR_WRONG_DEC -10
 
 #ifdef __cplusplus
 }
 #endif
-#endif /* End of LHDC_UTIL_H */
+#endif /* End of LHDCV5_UTIL_DEC_H */
diff --git a/external/liblhdcv5dec/src/lhdcv5BT_dec.c b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
index 43b2d872a..92f1534d7 100755
--- a/external/liblhdcv5dec/src/lhdcv5BT_dec.c
+++ b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
@@ -21,7 +21,7 @@ static void print_log_cb(char *msg)
     return;
   }
 
-  ALOGD("[LHDCV5] %s", msg);
+  ALOGD("[V5Dec_lib] %s", msg);
 }
 
 
@@ -32,26 +32,28 @@ static void print_log_cb(char *msg)
 //   input_len: length (bytes) of input buffer pointed by input
 //   pLout: pointer to pointer to output buffer
 //   pLlen: length (bytes) of encoded stream in output buffer
+//   upd_seq_no: sequence number type
 // return:
 //   > 0: number of frames in current packet
 //   == 0: No frames in current packet
 //   < 0: error
-static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len,
+static int32_t assemble_lhdcv5_packet(uint32_t *frame_num, uint8_t *input, uint32_t input_len,
     uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
 {
   uint8_t hdr = 0, seqno = 0xff;
-  int ret = LHDCBT_DEC_FUNC_FAIL;
   uint32_t status = 0;
   uint32_t lhdc_total_frame_nb = 0;
 
   if ((input == NULL) ||
       (pLout == NULL) ||
       (pLlen == NULL)) {
-    return LHDCBT_DEC_FUNC_FAIL;
+    ALOGD("%s: null ptr", __func__);
+    return -1;
   }
 
   if (input_len < 2) {
-    return LHDCBT_DEC_FUNC_FAIL;
+    ALOGD("%s: input len too small", __func__);
+    return -1;
   }
 
   hdr = (*input);
@@ -67,16 +69,17 @@ static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len,
   status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
 
   if (status <= 0) {
-    ALOGD("%s: No any frame in packet.", __func__);
+    ALOGD("%s: no any frame in packet.", __func__);
+    *frame_num = 0;
     return 0;
   }
 
   lhdc_total_frame_nb = status;
 
   if (seqno != serial_no) {
-    ALOGD("%s: Packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
+    ALOGD("%s: packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
     //serial_no = seqno;
-    //return LHDCBT_DEC_FUNC_INVALID_SEQ_NO;
+    //return -1;
   }
 
   if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO) {
@@ -86,34 +89,42 @@ static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len,
   *pLlen = input_len;
   *pLout = input;
 
-  ret = (int) lhdc_total_frame_nb;
+  *frame_num = (int) lhdc_total_frame_nb;
 
-  ALOGD("%s: ret total frame number (%d)", __func__, ret);
-  return ret;
+  ALOGD("%s: total frame number (%d)", __func__, *frame_num);
+  return 0;
 }
 
 
 // description
-//   init. LHDC v4 decoder 
+//   init. LHDC V5 decoder
 // Parameter
-//   config: configuration data for LHDC v4 decoder
+//   handle: codec handle(ptr for heap) from bt stack
+//   config: configuration for LHDC V5 decoder
 // return:
 //   == 0: succeed
-//   < 0: error
-int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config)
+//   != 0: error code
+int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config)
 {
-  if (config == NULL) {
-    return LHDCBT_DEC_FUNC_FAIL;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+  uint32_t mem_req_bytes = 0;
+  HANDLE_LHDCV5_BT hLhdcBT = NULL;
+
+  ALOGD("%s: decoder lib version = %s", __func__, lhdcv5_util_dec_get_version());
+
+  if (handle == NULL || config == NULL) {
+    ALOGD("%s: null ptr handle %p config %p", __func__, handle, config);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
   }
 
-  ALOGD("%s: bits_depth:%d sample_rate=%d version=%d", __func__,
-      config->bits_depth, config->sample_rate, config->version);
+  ALOGD("%s: bits_depth:%u sample_rate=%u bit_rate=%u version=%d", __func__,
+      config->bits_depth, config->sample_rate, config->bit_rate, config->version);
 
   if ((config->bits_depth != LHDCV5BT_BIT_DEPTH_16) &&
       (config->bits_depth != LHDCV5BT_BIT_DEPTH_24) &&
       (config->bits_depth != LHDCV5BT_BIT_DEPTH_32)) {
     ALOGD("%s: bits_depth %d not supported", __func__, config->bits_depth);
-    return LHDCBT_DEC_FUNC_FAIL;
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
   }
 
   if ((config->sample_rate != LHDCV5BT_SAMPLE_RATE_44K) &&
@@ -121,23 +132,59 @@ int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config)
       (config->sample_rate != LHDCV5BT_SAMPLE_RATE_96K) &&
       (config->sample_rate != LHDCV5BT_SAMPLE_RATE_192K)) {
     ALOGD("%s: sample_rate %d not supported", __func__, config->sample_rate);
-    return LHDCBT_DEC_FUNC_FAIL;
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((0 > config->bit_rate) || (config->bit_rate > LHDCV5BT_BIT_RATE_1000K)) {
+    ALOGD("%s: bit_rate %d not supported", __func__, config->bit_rate);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
   }
 
   if ((config->version != VERSION_5)) {
     ALOGD("%s: version %d not supported", __func__, config->version);
-    return LHDCBT_DEC_FUNC_FAIL;
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  lhdcv5_util_dec_register_log_cb(&print_log_cb);
+
+  func_ret = lhdcv5_util_dec_get_mem_req(config->version, &mem_req_bytes);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS || mem_req_bytes <= 0) {
+    ALOGW("%s: Fail to get required memory size (%d)!", __func__, func_ret);
+    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
+  }
+
+  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
+  if (hLhdcBT == NULL) {
+    ALOGW ("%s: Fail to allocate memory!", __func__);
+    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
   }
 
-  lhdc_register_log_cb(&print_log_cb);
+  ALOGD("%s: init lhdcv5 decoder...", __func__);
+  //TODO: send mem_req_bytes for size check
+  func_ret = lhdcv5_util_init_decoder(hLhdcBT, config->bits_depth,
+      config->sample_rate, config->bit_rate, config->version);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGW ("%s: failed to init decoder (%d)!", __func__, func_ret);
+    free(hLhdcBT);
+    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
+  }
 
-  ALOGD("%s: init lhdcv5 decoder", __func__);
-  lhdcv5_util_init_decoder(config->bits_depth, config->sample_rate, 400000, config->version);
-  lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
+  *handle = hLhdcBT;
+  if ((*handle) == NULL) {
+    ALOGW ("%s: handle return NULL!", __func__);
+    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
+  }
+
+  func_ret = lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGW ("%s: failed to configure channel (%d)!", __func__, func_ret);
+    return LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL;
+  }
 
   serial_no = 0xff;
 
-  return LHDCBT_DEC_FUNC_SUCCEED;
+  ALOGD("%s: init lhdcv5 decoder success", __func__);
+  return LHDCV5BT_DEC_API_SUCCEED;
 }
 
 
@@ -146,10 +193,11 @@ int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config)
 // Parameter
 //   frameData: pointer to input buffer
 //   frameBytes: length (bytes) of input buffer pointed by frameData
+//   packetBytes: return the final number of queued data in decoder lib (for validation)
 // return:
 //   == 0: succeed
 //   < 0: error
-int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData,
+int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData,
     uint32_t frameBytes, uint32_t *packetBytes)
 {
   uint8_t *frameDataStart = (uint8_t *)frameData;
@@ -158,47 +206,45 @@ int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData,
   uint32_t frame_num = 0;
   lhdc_frame_Info_t lhdc_frame_Info;
   uint32_t ptr_offset = 0;
-  bool fn_ret;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
 
   if ((frameData == NULL) || (packetBytes == NULL)) {
-    return LHDCBT_DEC_FUNC_FAIL;
+    return LHDCV5_UTIL_DEC_ERROR_PARAM;
   }
 
-  ALOGD("%s: enter, frameBytes (%d)", __func__, (int)frameBytes);
-
   *packetBytes = 0;
 
-  frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len,
+  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
       LHDCBT_DEC_NOT_UPD_SEQ_NO);
+  if (func_ret < 0 || in_buf == NULL) {
+    ALOGE("%s: failed setup input buffer", __func__);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
 
   if (frame_num == 0) {
-    ALOGD("%s: assemble_lhdc_packet (%d)", __func__, (int)frame_num);
-    return LHDCBT_DEC_FUNC_SUCCEED;
+    return LHDCV5BT_DEC_API_SUCCEED;
   }
 
-  ALOGD("%s: in_buf (%p), frameData (%p), in_len (%d), frame_num (%d)", __func__,
-      in_buf, frameData, (int)in_len, (int) frame_num);
+  ALOGD("%s: incoming frame size(%d), decoding size(%d), total frame num(%d)", __func__,
+      frameBytes, in_len, frame_num);
 
   ptr_offset = 0;
 
   while ((frame_num > 0) && (ptr_offset < in_len))
   {
-    fn_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, &lhdc_frame_Info);
-    if (fn_ret == false) {
-      ALOGD("%s: fetch frame info fail (%d)", __func__, (int)frame_num);
-      return LHDCBT_DEC_FUNC_FAIL;
+    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
     }
 
-    ALOGD("%s: lhdcFetchFrameInfo  frame_num (%d), ptr_offset (%d), "
-        "lhdc_frame_Info.frame_len (%d), in_len (%d)", __func__,
-        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
+    ALOGV("%s: frame_num[%d]: ptr_offset (%d), frame_len (%d)", __func__,
+        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
 
     if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
-      ALOGD(" %s: Not Enough... frame_num(%d), ptr_offset(%d), "
-          "frame_len(%d), in_len (%d)", __func__,
-          (int)frame_num, (int)ptr_offset,
-          (int)lhdc_frame_Info.frame_len, (int)in_len);
-      return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
+      ALOGD(" %s: frame_num[%d]: Not Enough... ptr_offset(%d), frame_len(%d)",
+          __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
+      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
     }
 
     ptr_offset += lhdc_frame_Info.frame_len;
@@ -208,42 +254,43 @@ int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData,
 
   *packetBytes = ptr_offset;
 
-  return LHDCBT_DEC_FUNC_SUCCEED;
+  return LHDCV5BT_DEC_API_SUCCEED;
 }
 
 
 // description
 //   decode all frames in one packet
 // Parameter
-//   frameData: pointer to input buffer
+//   frameData: pointer to input buffer from bt stack
 //   frameBytes: length (bytes) of input buffer pointed by frameData
-//   pcmData: pointer to output buffer
+//   pcmData: pointer to output buffer to bt stack
 //   pcmBytes: length (bytes) of pcm samples in output buffer
+//   bits_depth: bit per sample
 // return:
 //   == 0: succeed
 //   < 0: error
-int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
-    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth)
+int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t *pcmData, uint32_t *pcmBytes, uint32_t bits_depth)
 {
   uint8_t *frameDataStart = (uint8_t *)frameData;
   uint32_t dec_sum = 0;
   uint32_t lhdc_out_len = 0;
-  uint8_t *in_buf = NULL;
+  uint8_t *in_buf = NULL;   //buffer position to input to decode process
   uint32_t in_len = 0;
   uint32_t frame_num = 0;
   lhdc_frame_Info_t lhdc_frame_Info;
   uint32_t ptr_offset = 0;
-  bool fn_ret;
   uint32_t frame_samples;
   uint32_t frame_bytes;
   uint32_t pcmSpaceBytes;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
 
-  ALOGD("%s: enter frameBytes %d", __func__, (int)frameBytes);
+  ALOGV("%s: enter frameBytes %d", __func__, (int)frameBytes);
 
   if ((frameData == NULL) ||
       (pcmData == NULL) ||
       (pcmBytes == NULL)) {
-    return LHDCBT_DEC_FUNC_FAIL;
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
   }
 
   pcmSpaceBytes = *pcmBytes;
@@ -261,45 +308,62 @@ int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
   }
    */
 
-  frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len,
+  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
       LHDCBT_DEC_UPD_SEQ_NO);
+  if (func_ret < 0 || in_buf == NULL) {
+    ALOGE("%s: failed setup input buffer", __func__);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
 
   if (frame_num == 0) {
-    return LHDCBT_DEC_FUNC_SUCCEED;
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  func_ret = lhdcv5_util_dec_get_sample_size(&frame_samples);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGD("%s: fetch frame samples failed (%d)", __func__, func_ret);
+    return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
   }
+  ALOGV("%s: output frame samples %d", __func__, (int)frame_samples);
 
-  frame_samples = lhdcv5_util_dec_get_sample_size();
-  if (bits_depth == 16) {
+  if (bits_depth == LHDCV5BT_BIT_DEPTH_16) {
     frame_bytes = frame_samples * 2 * 2;
   } else {
+    // 24 or 32
     frame_bytes = frame_samples * 4 * 2;
   }
-  ALOGD("%s: frame_samples=%d", __func__, (int)frame_samples);
 
   ptr_offset = 0;
   dec_sum = 0;
 
   while ((frame_num > 0) && (ptr_offset < in_len))
   {
-    fn_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, &lhdc_frame_Info);
-    if (fn_ret == false) {
-      ALOGD("%s: fetch frame info fail (%d)", __func__, (int)frame_num);
-      return LHDCBT_DEC_FUNC_FAIL;
+    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
     }
 
     if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
-      return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
+      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
     }
 
     if ((dec_sum + frame_bytes) > pcmSpaceBytes) {
-      return LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH;
+      return LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH;
     }
 
     //ALOGD("%s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
-    lhdc_out_len = lhdcv5_util_dec_process(((uint8_t *)pcmData) + dec_sum,
-        in_buf + ptr_offset, lhdc_frame_Info.frame_len);
+    func_ret = lhdcv5_util_dec_process(
+        ((uint8_t *)pcmData) + dec_sum,
+        in_buf + ptr_offset,
+        lhdc_frame_Info.frame_len,
+        &lhdc_out_len);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: decode fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_DECODE_FAIL;
+    }
 
-    ALOGD("%s: frm=%d, frame_len=%d out_len=%d..", __func__,
+    ALOGD("%s: frame_num[%d]: input_frame_len %d output_len %d", __func__,
         (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
 
     ptr_offset += lhdc_frame_Info.frame_len;
@@ -310,7 +374,7 @@ int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
 
   *pcmBytes = (uint32_t) dec_sum;
 
-  return LHDCBT_DEC_FUNC_SUCCEED;
+  return LHDCV5BT_DEC_API_SUCCEED;
 }
 
 
@@ -320,13 +384,26 @@ int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
 //   none
 // return:
 //   == 0: success
-int lhdcBT_dec_deinit_decoder(void)
+int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle)
 {
-  int32_t ret = 0;
+  int32_t func_ret = 0;
+
+  if(handle == NULL) {
+    ALOGD("%s: empty handle", __func__);
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
 
-  ret = lhdcv5_util_dec_destroy();
-  ALOGD("%s: ret %d", __func__, ret);
+  func_ret = lhdcv5_util_dec_destroy();
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGD("%s: deinit decoder error (%d)", __func__, func_ret);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if(handle) {
+    ALOGD ("%s: free handle %p!", __func__, handle);
+    free(handle);
+  }
 
-  return LHDCBT_DEC_FUNC_SUCCEED;
+  return LHDCV5BT_DEC_API_SUCCEED;
 }
 
diff --git a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
index 027a3c8f2..9f4d953fe 100755
--- a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
+++ b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
@@ -48,7 +48,6 @@ public final class BluetoothCodecConfig implements Parcelable {
             SOURCE_CODEC_TYPE_LDAC,
             SOURCE_CODEC_TYPE_LHDCV3,
             SOURCE_CODEC_TYPE_LHDCV2,
-            SOURCE_CODEC_TYPE_LHDCV1,
             SOURCE_CODEC_TYPE_LHDCV5,
             SOURCE_CODEC_TYPE_MAX,
             SOURCE_CODEC_TYPE_INVALID
@@ -79,14 +78,11 @@ public final class BluetoothCodecConfig implements Parcelable {
     public static final int SOURCE_CODEC_TYPE_LHDCV2 = 6;
 
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_LHDCV1 = 7;
-
-    @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 8;
+    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 7;
     // Savitech LHDC -- END
 
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_MAX = 9;
+    public static final int SOURCE_CODEC_TYPE_MAX = 8;
 
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
@@ -422,8 +418,6 @@ public final class BluetoothCodecConfig implements Parcelable {
             case SOURCE_CODEC_TYPE_LDAC:
                 return "LDAC";
             // Savitech LHDC -- START
-            case SOURCE_CODEC_TYPE_LHDCV1:
-                return "LHDC V1";
             case SOURCE_CODEC_TYPE_LHDCV2:
                 return "LHDC V2";
             case SOURCE_CODEC_TYPE_LHDCV3:
@@ -684,12 +678,11 @@ public final class BluetoothCodecConfig implements Parcelable {
                 }
                 return true;
             // LHDC: Playback Quality at CodecSpecific1, Low Latency at CodecSpecific2; other feature flags at CodecSpecific3.
-            case SOURCE_CODEC_TYPE_LHDCV1:
             case SOURCE_CODEC_TYPE_LHDCV2:
             case SOURCE_CODEC_TYPE_LHDCV3:
             case SOURCE_CODEC_TYPE_LHDCV5:
                 if (mCodecSpecific1 != other.mCodecSpecific1 ||
-                    mCodecSpecific2 != other.mCodecSpecific2 || 
+                    mCodecSpecific2 != other.mCodecSpecific2 ||
                     mCodecSpecific3 != other.mCodecSpecific3) {
                     return false;
                 }
diff --git a/frameworks_base/core/java/android/provider/Settings.java b/frameworks_base/core/java/android/provider/Settings.java
index 93983fdf8..289780712 100755
--- a/frameworks_base/core/java/android/provider/Settings.java
+++ b/frameworks_base/core/java/android/provider/Settings.java
@@ -10758,7 +10758,7 @@ public final class Settings {
 
         /**
          * Savitech Add - A2DP_Source_Sink_Switch
-         * Whether bluetooth A2DP is initialized as Source or Sink 
+         * Whether bluetooth A2DP is initialized as Source or Sink
          * @hide
          */
         @Readable
diff --git a/frameworks_base/media/java/android/media/AudioManager.java b/frameworks_base/media/java/android/media/AudioManager.java
index 38f9607c9..e985855dd 100755
--- a/frameworks_base/media/java/android/media/AudioManager.java
+++ b/frameworks_base/media/java/android/media/AudioManager.java
@@ -6844,6 +6844,15 @@ public class AudioManager {
             int btSourceCodec = AudioSystem.audioFormatToBluetoothSourceCodec(format);
             if (btSourceCodec
                     != BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID) {
+                // Savitech Patch - START  Offload
+                // Add all LHDC series codecs to offload path
+                /*
+                if (btSourceCodec == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2));
+                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3));
+                }
+                */
+                // Savitech Patch - END
                 codecConfigList.add(new BluetoothCodecConfig(btSourceCodec));
             }
         }
diff --git a/frameworks_base/media/java/android/media/AudioSystem.java b/frameworks_base/media/java/android/media/AudioSystem.java
index 6ff551a68..dd8ca8181 100755
--- a/frameworks_base/media/java/android/media/AudioSystem.java
+++ b/frameworks_base/media/java/android/media/AudioSystem.java
@@ -230,6 +230,12 @@ public class AudioSystem
     public static final int AUDIO_FORMAT_APTX_HD        = 0x21000000;
     /** @hide */
     public static final int AUDIO_FORMAT_LDAC           = 0x23000000;
+    // Savitech Patch - START  Offload
+    /** @hide */
+    //public static final int AUDIO_FORMAT_LHDC           = 0x28000000;
+    /** @hide */
+    //public static final int AUDIO_FORMAT_LHDC_LL        = 0x29000000;
+    // Savitech Patch - END
 
     /** @hide */
     @IntDef(flag = false, prefix = "AUDIO_FORMAT_", value = {
@@ -239,7 +245,10 @@ public class AudioSystem
             AUDIO_FORMAT_SBC,
             AUDIO_FORMAT_APTX,
             AUDIO_FORMAT_APTX_HD,
-            AUDIO_FORMAT_LDAC }
+            AUDIO_FORMAT_LDAC,
+            //AUDIO_FORMAT_LHDC,    // Savitech Patch - START  Offload
+            //AUDIO_FORMAT_LHDC_LL,
+            }
     )
     @Retention(RetentionPolicy.SOURCE)
     public @interface AudioFormatNativeEnumForBtCodec {}
@@ -256,6 +265,14 @@ public class AudioSystem
             case AUDIO_FORMAT_APTX: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX;
             case AUDIO_FORMAT_APTX_HD: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD;
             case AUDIO_FORMAT_LDAC: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
+            // Savitech Patch - START  Offload
+            /*
+            case AUDIO_FORMAT_LHDC:
+                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+            case AUDIO_FORMAT_LHDC_LL:
+                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+            */
+            // Savitech Patch - END
             default:
                 Log.e(TAG, "Unknown audio format 0x" + Integer.toHexString(audioFormat)
                         + " for conversion to BT codec");
@@ -281,6 +298,16 @@ public class AudioSystem
                 return AudioSystem.AUDIO_FORMAT_APTX_HD;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                 return AudioSystem.AUDIO_FORMAT_LDAC;
+            // Savitech Patch - START  Offload
+            /*
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
+                return AudioSystem.AUDIO_FORMAT_LHDC;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
+                return AudioSystem.AUDIO_FORMAT_LHDC;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
+                return AudioSystem.AUDIO_FORMAT_LHDC;
+            */
+            // Savitech Patch - END
             default:
                 Log.e(TAG, "Unknown BT codec 0x" + Integer.toHexString(btCodec)
                         + " for conversion to audio format");
diff --git a/frameworks_base/packages/SettingsLib/res/values/arrays.xml b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
index 2fabb4ec7..cd7f9d29f 100755
--- a/frameworks_base/packages/SettingsLib/res/values/arrays.xml
+++ b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
@@ -154,10 +154,11 @@
         <item><xliff:g id="qualcomm">Qualcomm®</xliff:g> <xliff:g id="aptx">aptX™</xliff:g> audio</item>
         <item><xliff:g id="qualcomm">Qualcomm®</xliff:g> <xliff:g id="aptx_hd">aptX™ HD</xliff:g> audio</item>
         <item>LDAC</item>
-        <item>Savitech LHDC V1</item>
-        <item>Savitech LHDC V2</item>
-        <item>Savitech LHDC V3</item>
-        <item>Savitech LHDC V5</item>
+        <!-- Savitech Patch - START -->
+        <item>Savitech® LHDC V2™</item>
+        <item>Savitech® LHDC V3/V4™</item>
+        <item>Savitech® LHDC-V™</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Values for Bluetooth Audio Codec selection preference. -->
@@ -168,10 +169,11 @@
         <item>2</item>
         <item>3</item>
         <item>4</item>
+        <!-- Savitech Patch - START -->
         <item>5</item>
         <item>6</item>
         <item>7</item>
-        <item>8</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Summaries for Bluetooth Audio Codec selection preference. [CHAR LIMIT=50]-->
@@ -182,10 +184,11 @@
         <item><xliff:g id="qualcomm">Qualcomm®</xliff:g> <xliff:g id="aptx">aptX™</xliff:g> audio</item>
         <item><xliff:g id="qualcomm">Qualcomm®</xliff:g> <xliff:g id="aptx_hd">aptX™ HD</xliff:g> audio</item>
         <item>LDAC</item>
-        <item>Savitech LHDC V1</item>
-        <item>Savitech LHDC V2</item>
-        <item>Savitech LHDC V3</item>
-        <item>Savitech LHDC V5</item>
+        <!-- Savitech Patch - START -->
+        <item>Savitech® LHDC V2™</item>
+        <item>Savitech® LHDC V3/V4™</item>
+        <item>Savitech® LHDC-V™</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Titles for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50] -->
@@ -195,8 +198,10 @@
         <item>48.0 kHz</item>
         <item>88.2 kHz</item>
         <item>96.0 kHz</item>
+        <!-- Savitech Patch - START -->
         <item>176.4 kHz</item>
         <item>192.0 kHz</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Values for Bluetooth Audio Codec Sample Rate selection preference. -->
@@ -206,8 +211,10 @@
         <item>2</item>
         <item>4</item>
         <item>8</item>
+        <!-- Savitech Patch - START -->
         <item>16</item>
         <item>32</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Summaries for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50]-->
@@ -217,8 +224,10 @@
         <item>48.0 kHz</item>
         <item>88.2 kHz</item>
         <item>96.0 kHz</item>
+        <!-- Savitech Patch - START -->
         <item>176.4 kHz</item>
         <item>192.0 kHz</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Titles for Bluetooth Audio Codec Bits Per Sample selection preference. [CHAR LIMIT=50] -->
@@ -289,14 +298,14 @@
         <item>Optimized for Connection Quality</item>
         <item>Best Effort (Adaptive Bit Rate)</item>
     </string-array>
-    
+
     <!-- Titles for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70] -->
     <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_titles" translatable="false" >
-        <item>Low bit rate 00 Quality (64kbps)</item>
-        <item>Low bit rate 01 Quality (128kbps)</item>
-        <item>Low bit rate 02 Quality (192kbps)</item>
-        <item>Low bit rate 03 Quality (256kbps)</item>
-        <item>Low bit rate 04 Quality (320kbps)</item>
+        <item>Optimized for Connection Quality (64kbps)</item>
+        <item>Optimized for Connection Quality (128kbps)</item>
+        <item>Optimized for Connection Quality (192kbps)</item>
+        <item>Optimized for Connection Quality (256kbps)</item>
+        <item>Optimized for Connection Quality (320kbps)</item>
         <item>Optimized for Connection Quality (400kbps)</item>
         <item>Balanced Audio And Connection Quality (500kbps)</item>
         <item>High Audio Quality (900kbps)</item>
@@ -317,33 +326,33 @@
         <item>32776</item>
         <item>32777</item>
     </string-array>
-    
+
     <!-- Summaries for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70]-->
     <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_summaries" translatable="false" >
-        <item>Low bit rate 00 Quality</item>
-        <item>Low bit rate 01 Quality</item>
-        <item>Low bit rate 02 Quality</item>
-        <item>Low bit rate 03 Quality</item>
-        <item>Low bit rate 04 Quality</item>
-        <item>Optimized for Connection Quality</item>
+        <item>Optimized for Connection Quality (64kbps)</item>
+        <item>Optimized for Connection Quality (128kbps)</item>
+        <item>Optimized for Connection Quality (192kbps)</item>
+        <item>Optimized for Connection Quality (256kbps)</item>
+        <item>Optimized for Connection Quality (320kbps)</item>
+        <item>Optimized for Connection Quality (400kbps)</item>
         <item>Balanced Audio And Connection Quality</item>
         <item>High Audio Quality</item>
         <item>Extremely High Audio Quality</item>
         <item>Best Effort (Auto Bit Rate)</item>
     </string-array>
-    
+
     <!-- Titles for Bluetooth Audio Codec LHDC Low Latency selection preference. [CHAR LIMIT=70] -->
     <string-array name="bluetooth_a2dp_codec_lhdc_latency_titles" translatable="false" >
         <item>Low Latency Mode Disable</item>
         <item>Low Latency Mode Enable</item>
     </string-array>
-    
+
     <!-- Values for Bluetooth Audio Codec LHDC Latency selection preference. -->
     <string-array name="bluetooth_a2dp_codec_lhdc_latency_values" translatable="false" >
         <item>49152</item>
         <item>49153</item>
     </string-array>
-    
+
     <!-- Summaries for Bluetooth Audio Codec LHDC Latency selection preference. [CHAR LIMIT=70]-->
     <string-array name="bluetooth_a2dp_codec_lhdc_latency_summaries" translatable="false" >
         <item>Low Latency OFF</item>
@@ -355,19 +364,38 @@
         <item>OFF</item>
         <item>ON</item>
     </string-array>
-    
+
     <!-- Values for Bluetooth Audio Codec LHDC AR Effect selection preference -->
     <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" translatable="false" >
         <item>0</item>
         <item>2</item>
     </string-array>
-    
+
     <!-- Summaries for Bluetooth Audio Codec LHDC AR Effect selection preference [CHAR LIMIT=70]-->
     <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries" translatable="false" >
         <item>LHDC 3DAR Effect OFF</item>
         <item>LHDC 3DAR Effect ON</item>
     </string-array>
 
+    <!-- Titles for Bluetooth Audio Codec LHDC Lossless selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_titles" translatable="false" >
+        <item>OFF</item>
+        <item>ON</item>
+    </string-array>
+
+    <!-- Values for Bluetooth Audio Codec LHDC Lossless selection preference -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_values" translatable="false" >
+        <item>0</item>
+        <item>2</item>
+    </string-array>
+
+    <!-- Summaries for Bluetooth Audio Codec LHDC Lossless selection preference [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_summaries" translatable="false" >
+        <item>LHDC Lossless OFF</item>
+        <item>LHDC Lossless ON</item>
+    </string-array>
+    <!-- Savitech Patch - END -->
+
     <!-- Summaries for Android Auto Bluetooth Audio Active Device status. [CHAR LIMIT=50]-->
     <string-array name="bluetooth_audio_active_device_summaries" >
         <!-- Status message when the device is not Active. -->
diff --git a/frameworks_base/packages/SettingsLib/res/values/strings.xml b/frameworks_base/packages/SettingsLib/res/values/strings.xml
index dbdbf49bb..954dcb725 100755
--- a/frameworks_base/packages/SettingsLib/res/values/strings.xml
+++ b/frameworks_base/packages/SettingsLib/res/values/strings.xml
@@ -704,6 +704,7 @@
     <!-- UI debug setting: Select Bluetooth Audio LDAC Codec: LDAC Playback Quality -->
     <string name="bluetooth_select_a2dp_codec_ldac_playback_quality_dialog_title">Trigger Bluetooth Audio LDAC\u000ACodec Selection: Playback Quality</string>
 
+    <!-- Savitech LHDC - START -->
     <!-- UI debug setting: Select Bluetooth Audio LHDC Playback Quality -->
     <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality">Bluetooth Audio LHDC Codec: Playback Quality</string>
     <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
@@ -711,9 +712,9 @@
 
     <!-- UI debug setting: Select Bluetooth Audio LHDC Low Latency -->
     <string name="bluetooth_select_a2dp_codec_lhdc_latency">Bluetooth Audio LHDC Codec: Low Latency</string>
-        <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency -->
     <string name="bluetooth_select_a2dp_codec_lhdc_latency_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALatency</string>
-    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality Summary -->
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency Summary -->
     <string name="bluetooth_select_a2dp_codec_lhdc_latency_summary">LHDC Codec:\u000ALow Latency</string>
 
     <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect -->
@@ -721,6 +722,12 @@
     <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect: LHDC AR Audio -->
     <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title">Select Bluetooth Audio LHDC Codec:\u000AAR Audio</string>
 
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless">Enable LHDC Lossless</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless: LHDC Lossless Audio -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALossless Audio</string>
+    <!-- Savitech LHDC - END -->
+
     <!-- [CHAR LIMIT=NONE] Label for displaying Bluetooth Audio Codec Parameters while streaming -->
     <string name="bluetooth_select_a2dp_codec_streaming_label">Streaming: <xliff:g id="streaming_parameter">%1$s</xliff:g></string>
 
diff --git a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index c87ba3303..391d5574b 100755
--- a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -2466,7 +2466,7 @@ class DatabaseHelper extends SQLiteOpenHelper {
 
             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
                     R.bool.def_bluetooth_on);
-            
+
             // Savitech Add -- A2DP_Source_Sink_Switch
             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_A2DP_SINK,
                     R.bool.def_bluetooth_a2dp_sink);
diff --git a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
index a1513b304..b18640f9f 100755
--- a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
+++ b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
@@ -30,6 +30,10 @@ using ::android::hardware::bluetooth::audio::V2_0::AacVariableBitRate;
 using ::android::hardware::bluetooth::audio::V2_0::AptxParameters;
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using ::android::hardware::bluetooth::audio::V2_0::CodecType;
 using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
@@ -52,7 +56,12 @@ static const PcmParameters kDefaultSoftwarePcmCapabilities = {
         static_cast<ChannelMode>(ChannelMode::MONO | ChannelMode::STEREO),
     .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |
                                                 BitsPerSample::BITS_24 |
-                                                BitsPerSample::BITS_32)};
+                                                BitsPerSample::BITS_32),
+    // Savitech Patch - Start
+    //   LHDC_Low_Latency(non-offload)
+    //.isLowLatencyEnabled = static_cast<LhdcLowLatencyEn>(LhdcLowLatencyEn::Disabled | LhdcLowLatencyEn::Disabled),
+    // Savitech Patch - End
+};
 
 // Default Supported Codecs
 // SBC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(MONO|STEREO)
diff --git a/packages_apps_Bluetooth/res/values/config.xml b/packages_apps_Bluetooth/res/values/config.xml
index ff04a191d..88152d5d0 100755
--- a/packages_apps_Bluetooth/res/values/config.xml
+++ b/packages_apps_Bluetooth/res/values/config.xml
@@ -101,10 +101,9 @@
     <integer name="a2dp_source_codec_priority_aptx">3001</integer>
     <integer name="a2dp_source_codec_priority_aptx_hd">4001</integer>
     <integer name="a2dp_source_codec_priority_ldac">5001</integer>
-    <integer name="a2dp_source_codec_priority_lhdcv1">6001</integer>
-    <integer name="a2dp_source_codec_priority_lhdcv2">6002</integer>
-    <integer name="a2dp_source_codec_priority_lhdcv3">6003</integer>
-    <integer name="a2dp_source_codec_priority_lhdcv5">6004</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv2">6001</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv3">6002</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv5">6003</integer>
 
     <!-- For enabling the AVRCP Target Cover Artowrk feature-->
     <bool name="avrcp_target_enable_cover_art">true</bool>
diff --git a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
index 0d29e2a0d..e6f7c040f 100755
--- a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+++ b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
@@ -51,8 +51,6 @@ class A2dpCodecConfig {
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private @CodecPriority int mA2dpSourceCodecPriorityLdac =
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
-    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV1 =
-            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private @CodecPriority int mA2dpSourceCodecPriorityLhdcV2 =
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private @CodecPriority int mA2dpSourceCodecPriorityLhdcV3 =
@@ -240,16 +238,6 @@ class A2dpCodecConfig {
         }
 
         // Savitech LHDC -- START
-        try {
-            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv1);
-        } catch (NotFoundException e) {
-            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
-        }
-        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
-                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
-            mA2dpSourceCodecPriorityLhdcV1 = value;
-        }
-
         try {
             value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv2);
         } catch (NotFoundException e) {
@@ -316,30 +304,24 @@ class A2dpCodecConfig {
         codecConfigArray[4] = codecConfig;
 
         // Savitech LHDC -- START
-        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1,
-                mA2dpSourceCodecPriorityLhdcV1, BluetoothCodecConfig.SAMPLE_RATE_NONE,
-                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
-                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
-                0 /* codecSpecific4 */);
-        codecConfigArray[5] = codecConfig;
         codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
                 mA2dpSourceCodecPriorityLhdcV2, BluetoothCodecConfig.SAMPLE_RATE_NONE,
                 BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
                 0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
                 0 /* codecSpecific4 */);
-        codecConfigArray[6] = codecConfig;
+        codecConfigArray[5] = codecConfig;
         codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
                 mA2dpSourceCodecPriorityLhdcV3, BluetoothCodecConfig.SAMPLE_RATE_NONE,
                 BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
                 0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
                 0 /* codecSpecific4 */);
-        codecConfigArray[7] = codecConfig;
+        codecConfigArray[6] = codecConfig;
         codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
                 mA2dpSourceCodecPriorityLhdcV5, BluetoothCodecConfig.SAMPLE_RATE_NONE,
                 BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
                 0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
                 0 /* codecSpecific4 */);
-        codecConfigArray[8] = codecConfig;
+        codecConfigArray[7] = codecConfig;
         // Savitech LHDC -- END
 
         return codecConfigArray;
@@ -352,32 +334,32 @@ class A2dpCodecConfig {
                                 byte[] exApiVer) {
         return mA2dpNativeInterface.getLhdcCodecExtendApiVer(device, exApiVer);
     }
-        
+
     int setLhdcCodecExtendApiConfigAr(BluetoothDevice device,
                                 byte[] codecConfig) {
         return mA2dpNativeInterface.setLhdcCodecExtendApiConfigAr(device, codecConfig);
     }
-    
+
     int getLhdcCodecExtendApiConfigAr(BluetoothDevice device,
                                 byte[] codecConfig) {
         return mA2dpNativeInterface.getLhdcCodecExtendApiConfigAr(device, codecConfig);
-    }    
-    
+    }
+
     int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
                                 byte[] codecConfig) {
         return mA2dpNativeInterface.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
     }
-    
+
     int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
                                 byte[] codecConfig) {
         return mA2dpNativeInterface.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
-    }    
-    
+    }
+
     int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device,
                                 byte[] codecConfig) {
         return mA2dpNativeInterface.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
-    }    
-    
+    }
+
     void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device,
                                 byte[] codecData) {
         mA2dpNativeInterface.setLhdcCodecExtendApiDataGyro2D(device, codecData);
diff --git a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
index 272c5cb7d..2137780f2 100755
--- a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -1487,9 +1487,9 @@ public class A2dpService extends ProfileService {
 
         /************************************************
          * Savitech Patch - LHDC Extended API Start
-         ***********************************************/        
+         ***********************************************/
         @Override
-        public int getLhdcCodecExtendApiVer(BluetoothDevice device, 
+        public int getLhdcCodecExtendApiVer(BluetoothDevice device,
                 byte[] exApiVer) {
             A2dpService service = getServiceLhdc();
             if (service == null) {
@@ -1516,7 +1516,7 @@ public class A2dpService extends ProfileService {
                 return -1;
             }
             return service.getLhdcCodecExtendApiConfigAr(device, codecConfig);
-        }        
+        }
 
         @Override
         public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
diff --git a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
index 033591b30..fba3d580f 100755
--- a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
+++ b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
@@ -55,10 +55,6 @@
                 android:id="@+id/bluetooth_audio_codec_ldac"
                 layout="@layout/preference_widget_dialog_radiobutton"/>
 
-            <include
-                android:id="@+id/bluetooth_audio_codec_lhdcv1"
-                layout="@layout/preference_widget_dialog_radiobutton"/>
-
             <include
                 android:id="@+id/bluetooth_audio_codec_lhdcv2"
                 layout="@layout/preference_widget_dialog_radiobutton"/>
diff --git a/packages_apps_Settings/res/xml/development_settings.xml b/packages_apps_Settings/res/xml/development_settings.xml
index 7dd77f0fe..79d488363 100755
--- a/packages_apps_Settings/res/xml/development_settings.xml
+++ b/packages_apps_Settings/res/xml/development_settings.xml
@@ -396,6 +396,13 @@
             android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title"
             android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles"
             android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" />
+            
+        <ListPreference
+            android:key="bluetooth_enable_a2dp_codec_lhdc_lossless"
+            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_lossless"
+            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title"
+            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_titles"
+            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_values" />
 
         <ListPreference
             android:key="bluetooth_max_connected_audio_devices"
diff --git a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
index 62fead091..1af1465e4 100755
--- a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+++ b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
@@ -577,6 +577,8 @@ public class DevelopmentSettingsDashboardFragment extends RestrictedDashboardFra
                 bluetoothA2dpConfigStore));
         controllers.add(new BluetoothLHDCAudioArEffectPreferenceController(context, lifecycle,
                 bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioLosslessPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
         // Savitech LHDC -- END
         controllers.add(new BluetoothChannelModeDialogPreferenceController(context, lifecycle,
                 bluetoothA2dpConfigStore));
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
index 4571ffa2d..2b305debb 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
@@ -42,7 +42,6 @@ public abstract class AbstractBluetoothDialogPreferenceController extends
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
-            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX,
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
index 5cd8af28a..93b4f62bb 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
@@ -61,8 +61,13 @@ public class BluetoothBitPerSampleDialogPreferenceController extends
             case 0:
                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
                 if (currentConfig != null) {
-                    bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
-                            currentConfig.getCodecType()));
+                /* Savitech patch: pick default by native decision, not always get the Highest one */
+                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                            bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
+                                currentConfig.getCodecType()));
+                    }
                 }
                 break;
             case 1:
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
index d156abde6..8603f6b5e 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
@@ -61,8 +61,13 @@ public class BluetoothChannelModeDialogPreferenceController extends
             case 0:
                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
                 if (currentConfig != null) {
-                    channelModeValue = getHighestChannelMode(getSelectableByCodecType(
-                            currentConfig.getCodecType()));
+                    /* Savitech patch: pick default by native decision, not always get the Highest one */
+                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                            channelModeValue = getHighestChannelMode(getSelectableByCodecType(
+                                currentConfig.getCodecType()));
+                    }
                 }
                 break;
             case 1:
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
index 327c1ed9a..d9a2d8f83 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
@@ -61,7 +61,6 @@ public class BluetoothCodecDialogPreference extends BaseBluetoothDialogPreferenc
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx_hd);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_ldac);
-        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv1);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv2);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv3);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv5);
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
index 2d481981c..a73a0e315 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
@@ -118,18 +118,14 @@ public class BluetoothCodecDialogPreferenceController extends
                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
                 break;
             case 6:
-                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1;
-                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
-                break;
-            case 7:
                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2;
                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
                 break;
-            case 8:
+            case 7:
                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3;
                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
                 break;
-            case 9:
+            case 8:
                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
                 break;
@@ -144,9 +140,19 @@ public class BluetoothCodecDialogPreferenceController extends
         if (config == null) {
             Log.d(TAG, "Selectable config is null. Unable to reset");
         }
-        mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
-        mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
-        mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
+
+        /* Savitech LHDC patch: use default when codec switching */
+        if (codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
+            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+            mBluetoothA2dpConfigStore.setSampleRate(BluetoothCodecConfig.SAMPLE_RATE_NONE);
+            mBluetoothA2dpConfigStore.setBitsPerSample(BluetoothCodecConfig.BITS_PER_SAMPLE_NONE);
+            mBluetoothA2dpConfigStore.setChannelMode(BluetoothCodecConfig.CHANNEL_MODE_NONE);
+        } else {
+            mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
+            mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
+            mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
+        }
     }
 
     @Override
@@ -190,17 +196,14 @@ public class BluetoothCodecDialogPreferenceController extends
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                 index = 5;
                 break;
-            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1:
-                index = 6;
-                break;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
-                index = 7;
+                index = 6;
                 break;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
-                index = 8;
+                index = 7;
                 break;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
-                index = 9;
+                index = 8;
                 break;
             default:
                 Log.e(TAG, "Unsupported config:" + config);
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
new file mode 100644
index 000000000..4c7d0b3a0
--- /dev/null
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import android.util.Log;
+
+/**
+ * Switch preference controller for LHDC Lossless ON/OFF
+ */
+public class BluetoothLHDCAudioLosslessPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 0;
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY =
+            "bluetooth_enable_a2dp_codec_lhdc_lossless";
+
+    private static final int LHDC_FEATURE_MASK = 0xFF000000;
+    private static final int LHDC_FEATURE_TAG = 0x4C000000;
+    private static final int LHDC_LOSSLESS_FEATURE = 0x80;
+
+    public BluetoothLHDCAudioLosslessPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        int codecSpecific3Value = 0; // default
+        codecSpecific3Value |= LHDC_FEATURE_TAG;
+        if (index != 0) {
+            codecSpecific3Value |= LHDC_LOSSLESS_FEATURE;
+        }else{
+            codecSpecific3Value &= ~LHDC_LOSSLESS_FEATURE;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int ret = 0;
+        int index = (int)config.getCodecSpecific3();
+        int tmp = index & LHDC_FEATURE_MASK;
+        if (tmp == LHDC_FEATURE_TAG) {
+            if ((index & LHDC_LOSSLESS_FEATURE) != 0) {
+                ret = 1;
+            } else {
+                ret = 0;
+            }
+        } else {
+            ret = 0;
+        }
+        return ret;
+    }
+}
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
index 721c349dc..772ae1eb4 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
@@ -36,12 +36,17 @@ import java.util.List;
 public class BluetoothLHDCQualityDialogPreferenceController extends
         AbstractBluetoothDialogPreferenceController {
 
+    // In standard case, low0 is available
+    private static final int index_adjust_offset = 0;
+    // In case of low0 is removed, shift the rest indices
+    //private static final int index_adjust_offset = 1;
+
     private static final String KEY = "bluetooth_select_a2dp_lhdc_playback_quality";
     private static final String TAG = "BtLhdcAudioQualityCtr";
     private static final int DEFAULT_TAG = 0xC000;
     private static final int DEFAULT_MAGIC = 0x8000;
-    private static final int DEFAULT_INDEX = 5;
-    private static final int DEFAULT_MAX_INDEX = 9; //0~9
+    private static final int DEFAULT_INDEX = (5 - index_adjust_offset);
+    private static final int DEFAULT_MAX_INDEX = (9 - index_adjust_offset); //0~9
 
     public BluetoothLHDCQualityDialogPreferenceController(Context context, Lifecycle lifecycle,
                                                       BluetoothA2dpConfigStore store) {
@@ -63,7 +68,7 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
     protected void writeConfigurationValues(final int index) {
         long codecSpecific1Value = 0;
         if (index <= DEFAULT_MAX_INDEX) {
-            codecSpecific1Value = DEFAULT_MAGIC | index;
+            codecSpecific1Value = DEFAULT_MAGIC | (index + index_adjust_offset);
         }else{
             codecSpecific1Value = DEFAULT_MAGIC | DEFAULT_INDEX;
         }
@@ -81,15 +86,13 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
     @Override
     public List<Integer> getSelectableIndex() {
         List<Integer> selectableIndex = new ArrayList<>();
-        /*
         final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
         if (currentConfig != null) {
-            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1 ||
-                currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
                 currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3) {
-                // except 8(ie., 1000K)
+                // excluding 1000Kbps
                 for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
-                    if(i != 8) {
+                    if(i != (8 - index_adjust_offset)) {
                         selectableIndex.add(i);
                     }
                 }
@@ -101,7 +104,6 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
                 }
             }
         }
-        */
 
         // All items are available to set from UI but be filtered at native layer.
         for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
@@ -113,11 +115,10 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
     @Override
     public void updateState(Preference preference) {
         super.updateState(preference);
-        // Enable preference when current codec type is LHDCV1/V2/V3/V5. For other cases, disable it.
+        // Enable preference when current codec type is LHDC V2/V3/V5. For other cases, disable it.
         final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
         if (currentConfig != null
-                && (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1 || 
-                    currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+                && (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
                     currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
                     currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5)
                 ) {
@@ -142,6 +143,6 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
         } else {
             index &= 0xff;
         }
-        return index;
+        return (index - index_adjust_offset);
     }
 }
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
index 1af84788a..6228a6c64 100755
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
@@ -61,8 +61,13 @@ public class BluetoothSampleRateDialogPreferenceController extends
             case 0:
                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
                 if (currentConfig != null) {
-                    sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
-                            currentConfig.getCodecType()));
+                    /* Savitech LHDC patch: use default by LHDC native when selecting system default */
+                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                            sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
+                                currentConfig.getCodecType()));
+                    }
                 }
                 break;
             case 1:
diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.cc b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
index afa87426b..19a5c8b4f 100755
--- a/system_bt/audio_bluetooth_hw/device_port_proxy.cc
+++ b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
@@ -37,6 +37,10 @@ using ::android::bluetooth::audio::BluetoothAudioSessionControl_2_1;
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::PcmParameters;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using SampleRate = ::android::hardware::bluetooth::audio::V2_0::SampleRate;
 using SampleRate_2_1 = ::android::hardware::bluetooth::audio::V2_1::SampleRate;
 using BluetoothAudioStatus =
@@ -108,6 +112,22 @@ audio_format_t BitsPerSampleToAudioFormat(BitsPerSample bits_per_sample) {
   }
 }
 
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+/*
+bool isLhdcLowLatencyToAudioFormat(LhdcLowLatencyEn low_latency_enabled) {
+  switch (low_latency_enabled) {
+    case LhdcLowLatencyEn::Enabled:
+      return true;
+    case LhdcLowLatencyEn::Disabled:
+      return false;
+    default:
+      return kBluetoothDefaultAudioFormatLhdcLowLatency;
+  }
+}
+*/
+// Savitech Patch - End
+
 // The maximum time to wait in std::condition_variable::wait_for()
 constexpr unsigned int kMaxWaitingTimeMs = 4500;
 
@@ -320,6 +340,10 @@ bool BluetoothAudioPortOut::LoadAudioConfig(audio_config_t* audio_cfg) const {
            ? AUDIO_CHANNEL_OUT_STEREO
            : OutputChannelModeToAudioFormat(pcm_cfg.channelMode));
   audio_cfg->format = BitsPerSampleToAudioFormat(pcm_cfg.bitsPerSample);
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  //_lowLatencyEnabled = isLhdcLowLatencyToAudioFormat(pcm_cfg.isLowLatencyEnabled);
+  // Savitech Patch - End
   return true;
 }
 
diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.h b/system_bt/audio_bluetooth_hw/device_port_proxy.h
index 9e113926f..c8b18893a 100755
--- a/system_bt/audio_bluetooth_hw/device_port_proxy.h
+++ b/system_bt/audio_bluetooth_hw/device_port_proxy.h
@@ -54,6 +54,15 @@ class BluetoothAudioPort {
   // Bluetooth stack
   virtual bool LoadAudioConfig(audio_config_t* audio_cfg) const = 0;
 
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  /*
+  bool isLowLatencyEnabled() const {
+    return _lowLatencyEnabled;
+  }
+  */
+  // Savitech Patch - End
+
   // WAR to support Mono mode / 16 bits per sample
   void ForcePcmStereoToMono(bool force) {
     is_stereo_to_mono_ = force;
@@ -89,6 +98,11 @@ class BluetoothAudioPort {
            session_type_ == SessionType_2_1::A2DP_HARDWARE_OFFLOAD_DATAPATH;
   }
 
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  //mutable bool _lowLatencyEnabled = false;
+  // Savitech Patch - End
+
  protected:
   uint16_t cookie_;
   BluetoothStreamState state_;
diff --git a/system_bt/audio_bluetooth_hw/stream_apis.cc b/system_bt/audio_bluetooth_hw/stream_apis.cc
index aafe547f7..28e1648fc 100755
--- a/system_bt/audio_bluetooth_hw/stream_apis.cc
+++ b/system_bt/audio_bluetooth_hw/stream_apis.cc
@@ -86,8 +86,18 @@ void out_calculate_feeding_delay_ms(const BluetoothStreamOut* out,
     //   frames_count = buffer_size / frame_size
     //   latency (sec.) = frames_count / samples_per_second (sample_rate)
     // Sync from audio_a2dp_hw to add extra delay kExtraAudioSyncMs(+200ms)
+#if 0
+    bool lowLatencySt = false;
+    // Savitech Patch - Start
+    //   LHDC_Low_Latency(non-offload)
+    lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
+    delay_report_ms =
+        out->frames_count_ * 1000 / out->sample_rate_ + (lowLatencySt == true ? 0 : kExtraAudioSyncMs);
+    // Savitech Patch - End
+#else
     delay_report_ms =
         out->frames_count_ * 1000 / out->sample_rate_ + kExtraAudioSyncMs;
+#endif
     if (timestamp != nullptr) {
       clock_gettime(CLOCK_MONOTONIC, &absorbed_timestamp);
     }
@@ -220,6 +230,13 @@ static size_t out_get_buffer_size(const struct audio_stream* stream) {
   const auto* out = reinterpret_cast<const BluetoothStreamOut*>(stream);
   size_t buffer_size =
       out->frames_count_ * audio_stream_out_frame_size(&out->stream_out_);
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  /*
+  bool lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
+  if (lowLatencySt) buffer_size = buffer_size/2;
+  */
+  // Savitech Patch - End
   LOG(VERBOSE) << __func__ << ": state=" << out->bluetooth_output_.GetState()
                << ", buffer_size=" << buffer_size;
   return buffer_size;
diff --git a/system_bt/audio_bluetooth_hw/stream_apis.h b/system_bt/audio_bluetooth_hw/stream_apis.h
index 55512d7fb..a1d5daeb3 100755
--- a/system_bt/audio_bluetooth_hw/stream_apis.h
+++ b/system_bt/audio_bluetooth_hw/stream_apis.h
@@ -26,6 +26,11 @@ constexpr unsigned int kBluetoothDefaultSampleRate = 44100;
 constexpr audio_format_t kBluetoothDefaultAudioFormatBitsPerSample =
     AUDIO_FORMAT_PCM_16_BIT;
 
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//constexpr bool kBluetoothDefaultAudioFormatLhdcLowLatency = 0;
+// Savitech Patch - End
+
 constexpr unsigned int kBluetoothDefaultInputBufferMs = 20;
 constexpr unsigned int kBluetoothDefaultInputStateTimeoutMs = 20;
 
diff --git a/system_bt/audio_hal_interface/a2dp_encoding.cc b/system_bt/audio_hal_interface/a2dp_encoding.cc
index f88237be5..761791b8f 100755
--- a/system_bt/audio_hal_interface/a2dp_encoding.cc
+++ b/system_bt/audio_hal_interface/a2dp_encoding.cc
@@ -44,7 +44,14 @@ using ::bluetooth::audio::codec::A2dpAptxToHalConfig;
 using ::bluetooth::audio::codec::A2dpCodecToHalBitsPerSample;
 using ::bluetooth::audio::codec::A2dpCodecToHalChannelMode;
 using ::bluetooth::audio::codec::A2dpCodecToHalSampleRate;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::bluetooth::audio::codec::A2dpCodecToHalLhdcLowLatencyMode;
+// Savitech Patch - End
 using ::bluetooth::audio::codec::A2dpLdacToHalConfig;
+// Savitech Patch - Offload
+//using ::bluetooth::audio::codec::A2dpLhdcv5ToHalConfig;
+// Savitech Patch - End
 using ::bluetooth::audio::codec::A2dpSbcToHalConfig;
 using ::bluetooth::audio::codec::CodecConfiguration;
 
@@ -264,15 +271,25 @@ bool a2dp_get_selected_hal_codec_config(CodecConfiguration* codec_config) {
       }
       break;
     }
-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5: {
-        return true;
+#if 0
+      // Savitech Patch Offload
+      if (!A2dpLhdcv5ToHalConfig(codec_config, a2dp_config)) {
+        LOG(ERROR) << __func__
+                   << ": Fail to call A2dpLhdcv5ToHalConfig(), codec_type=" << current_codec.codec_type;
+        return false;
       }
       break;
+#else
+      // for non-offload only
+      return true;
+#endif
+      // Savitech Patch - End
+    }
     case BTAV_A2DP_CODEC_INDEX_MAX:
       [[fallthrough]];
     default:
@@ -316,6 +333,18 @@ bool a2dp_get_selected_hal_pcm_config(PcmParameters* pcm_config) {
   pcm_config->sampleRate = A2dpCodecToHalSampleRate(current_codec);
   pcm_config->bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
   pcm_config->channelMode = A2dpCodecToHalChannelMode(current_codec);
+
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  /*
+  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3 ||
+      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2 ||
+      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
+    pcm_config->isLowLatencyEnabled = A2dpCodecToHalLhdcLowLatencyMode(current_codec);
+  }
+  */
+  // Savitech Patch - End
+
   return (pcm_config->sampleRate != SampleRate::RATE_UNKNOWN &&
           pcm_config->bitsPerSample != BitsPerSample::BITS_UNKNOWN &&
           pcm_config->channelMode != ChannelMode::UNKNOWN);
diff --git a/system_bt/audio_hal_interface/client_interface.h b/system_bt/audio_hal_interface/client_interface.h
index b9f18b9ed..4cd4de3f8 100755
--- a/system_bt/audio_hal_interface/client_interface.h
+++ b/system_bt/audio_hal_interface/client_interface.h
@@ -43,6 +43,10 @@ using AudioConfiguration_2_1 =
     ::android::hardware::bluetooth::audio::V2_1::AudioConfiguration;
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using IBluetoothAudioProvider =
     ::android::hardware::bluetooth::audio::V2_0::IBluetoothAudioProvider;
 using IBluetoothAudioProvider_2_1 =
@@ -221,7 +225,12 @@ class BluetoothAudioClientInterface {
   static constexpr PcmParameters kInvalidPcmConfiguration = {
       .sampleRate = SampleRate::RATE_UNKNOWN,
       .channelMode = ChannelMode::UNKNOWN,
-      .bitsPerSample = BitsPerSample::BITS_UNKNOWN};
+      .bitsPerSample = BitsPerSample::BITS_UNKNOWN,
+      // Savitech Patch - Start
+      //   LHDC_Low_Latency(non-offload)
+      //.isLowLatencyEnabled = LhdcLowLatencyEn::Disabled,
+      // Savitech Patch - End
+  };
 
  protected:
   mutable std::mutex internal_mutex_;
diff --git a/system_bt/audio_hal_interface/client_interface_unittest.cc b/system_bt/audio_hal_interface/client_interface_unittest.cc
index 33954c720..996060db5 100755
--- a/system_bt/audio_hal_interface/client_interface_unittest.cc
+++ b/system_bt/audio_hal_interface/client_interface_unittest.cc
@@ -32,6 +32,8 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
 using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
 using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
+// Savitech Patch  Offload
+//using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
 using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
 using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
 using ::android::hardware::bluetooth::audio::V2_0::SbcChannelMode;
@@ -121,11 +123,15 @@ constexpr ChannelModePair kChannelModePairs[3] = {
     {.hal_channel_mode_ = ChannelMode::STEREO,
      .btav_channel_mode_ = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO}};
 
+// Savitech Patch  Offload
 constexpr btav_a2dp_codec_index_t codec_indexes[] = {
     BTAV_A2DP_CODEC_INDEX_SOURCE_SBC,  BTAV_A2DP_CODEC_INDEX_SOURCE_AAC,
     BTAV_A2DP_CODEC_INDEX_SOURCE_APTX, BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
-    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SINK_SBC,
-    BTAV_A2DP_CODEC_INDEX_SINK_AAC,    BTAV_A2DP_CODEC_INDEX_SINK_LDAC};
+    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+    BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+    BTAV_A2DP_CODEC_INDEX_SINK_SBC,
+    BTAV_A2DP_CODEC_INDEX_SINK_AAC, BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
+    BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3, BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5};
 constexpr uint16_t kPeerMtus[5] = {660, 663, 883, 1005, 1500};
 
 class TestSinkTransport
@@ -307,6 +313,24 @@ class BluetoothAudioClientInterfaceTest : public Test {
              ldac_config.bitsPerSample & ldac_capability.bitsPerSample);
         return is_codec_config_supported;
       }
+      // Savitech Patch - START  Offload
+      /*
+      case CodecType::LHDCV3:
+        [[fallthrough]];
+      case CodecType::LHDCV2:
+        [[fallthrough]];
+      case CodecType::LHDCV5: {
+        Lhdcv5Parameters lhdcv5_config = codec_config.config.lhdcv5Config();
+        Lhdcv5Parameters lhdcv5_capability =
+            codec_capability.capabilities.lhdcv5Capabilities();
+        is_codec_config_supported =
+            (lhdcv5_config.sampleRate & lhdcv5_capability.sampleRate &&
+             lhdcv5_config.channelMode & lhdcv5_capability.channelMode &&
+             lhdcv5_config.bitsPerSample & lhdcv5_capability.bitsPerSample);
+        return is_codec_config_supported;
+      }
+      */
+      // Savitech Patch - END
       case CodecType::APTX:
         [[fallthrough]];
       case CodecType::APTX_HD: {
@@ -649,6 +673,81 @@ TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLdacSession) {
   }
 }
 
+// Savitech Patch - START  Offload
+/*
+std::vector<CodecConfiguration> Lhdcv5CodecConfigurationsGenerator() {
+  std::vector<CodecConfiguration> lhdcv5_codec_configs;
+  CodecConfiguration codec_config = {};
+  Lhdcv5QualityIndex quality_indexes[10] = {
+      Lhdcv5QualityIndex::QUALITY_LOW4, Lhdcv5QualityIndex::QUALITY_LOW3,
+      Lhdcv5QualityIndex::QUALITY_LOW2, Lhdcv5QualityIndex::QUALITY_LOW1,
+    Lhdcv5QualityIndex::QUALITY_LOW0, Lhdcv5QualityIndex::QUALITY_LOW,
+    Lhdcv5QualityIndex::QUALITY_MID, Lhdcv5QualityIndex::QUALITY_HIGH,
+    Lhdcv5QualityIndex::QUALITY_HIGH1, Lhdcv5QualityIndex::QUALITY_ABR};
+  for (auto sample_rate_pair : kSampleRatePairs) {
+    for (auto bits_per_sample_pair : kBitsPerSamplePairs) {
+      for (auto channel_mode_pair : kChannelModePairs) {
+        for (auto peer_mtu : kPeerMtus) {
+          for (auto quality_index : quality_indexes) {
+            codec_config.codecType = CodecType::LHDCV5;
+            codec_config.peerMtu = peer_mtu;
+            codec_config.isScmstEnabled = false;
+            codec_config.encodedAudioBitrate = 400000;
+            Lhdcv5Parameters lhdc = {
+                .sampleRate = sample_rate_pair.hal_sample_rate_,
+                .channelMode = ChannelMode::STEREO,
+                .qualityIndex = quality_index,
+                .bitsPerSample = bits_per_sample_pair.hal_bits_per_sample_};
+            codec_config.config.lhdcv5Config(lhdc);
+            lhdcv5_codec_configs.push_back(codec_config);
+          }  // LdacQualityIndex
+        }    // peerMtu
+      }      // ChannelMode
+    }        // BitsPerSampple
+  }          // SampleRate
+  return lhdcv5_codec_configs;
+}
+
+TEST_F(BluetoothAudioClientInterfaceTest, A2dpLhdcv5CodecOffloadingState) {
+  test_sink_transport_ =
+      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
+  clientif_sink_ =
+      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
+  auto lhdcv5_codec_configs = Lhdcv5CodecConfigurationsGenerator();
+  for (auto codec_offloading_preference :
+       CodecOffloadingPreferenceGenerator(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
+    UpdateOffloadingCapabilities(codec_offloading_preference.preference_);
+    for (CodecConfiguration codec_config : lhdcv5_codec_configs) {
+      if (IsCodecOffloadingSupported(codec_config) &&
+          codec_offloading_preference.is_target_codec_included_) {
+        ASSERT_TRUE(IsCodecOffloadingEnabled(codec_config));
+      } else {
+        ASSERT_FALSE(IsCodecOffloadingEnabled(codec_config));
+      }
+    }
+  }
+}
+
+TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLhdcv5Session) {
+  test_sink_transport_ =
+      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
+  clientif_sink_ =
+      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
+  AudioConfiguration audio_config = {};
+  for (CodecConfiguration codec_config : Lhdcv5CodecConfigurationsGenerator()) {
+    audio_config.codecConfig(codec_config);
+    clientif_sink_->UpdateAudioConfig(audio_config);
+    if (IsCodecOffloadingSupported(codec_config)) {
+      ASSERT_EQ(clientif_sink_->StartSession(), kClientIfReturnSuccess);
+    } else {
+      ASSERT_NE(clientif_sink_->StartSession(), kClientIfReturnSuccess);
+    }
+    ASSERT_EQ(clientif_sink_->EndSession(), kClientIfReturnSuccess);
+  }
+}
+*/
+// Savitech Patch - END
+
 std::vector<CodecConfiguration> AptxCodecConfigurationsGenerator(
     CodecType codec_type) {
   std::vector<CodecConfiguration> aptx_codec_configs;
diff --git a/system_bt/audio_hal_interface/codec_status.cc b/system_bt/audio_hal_interface/codec_status.cc
index cd9d88e05..8ebcdb745 100755
--- a/system_bt/audio_hal_interface/codec_status.cc
+++ b/system_bt/audio_hal_interface/codec_status.cc
@@ -24,6 +24,7 @@
 #include "a2dp_vendor_aptx_constants.h"
 #include "a2dp_vendor_aptx_hd_constants.h"
 #include "a2dp_vendor_ldac_constants.h"
+#include "a2dp_vendor_lhdc_constants.h"
 #include "bta/av/bta_av_int.h"
 
 namespace {
@@ -39,6 +40,16 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
 using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
 using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
+// Savitech Patch - START Offload
+/*
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5QualityIndex;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5FrameDuration;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5DataInterval;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Version;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Specific;
+*/
+// Savitech Patch - END
 using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
 using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
 using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
@@ -148,6 +159,30 @@ bool ldac_offloading_capability_match(const LdacParameters& ldac_capability,
           << " capability=" << toString(ldac_capability);
   return true;
 }
+
+// Savitech Patch - START  Offload
+/*
+bool lhdcv5_offloading_capability_match(const Lhdcv5Parameters& lhdcv5_capability,
+                                        const Lhdcv5Parameters& lhdcv5_config) {
+  if ((static_cast<SampleRate>(lhdcv5_capability.sampleRate &
+                               lhdcv5_config.sampleRate) ==
+       SampleRate::RATE_UNKNOWN) ||
+      (static_cast<ChannelMode>(lhdcv5_capability.channelMode &
+                                    lhdcv5_config.channelMode) ==
+       ChannelMode::UNKNOWN) ||
+      (static_cast<BitsPerSample>(lhdcv5_capability.bitsPerSample &
+                                  lhdcv5_config.bitsPerSample) ==
+       BitsPerSample::BITS_UNKNOWN)) {
+    LOG(WARNING) << __func__ << ": software codec=" << toString(lhdcv5_config)
+                 << " capability=" << toString(lhdcv5_capability);
+    return false;
+  }
+  VLOG(1) << __func__ << ": offloading codec=" << toString(lhdcv5_config)
+          << " capability=" << toString(lhdcv5_capability);
+  return true;
+}
+*/
+// Savitech Patch - END
 }  // namespace
 
 namespace bluetooth {
@@ -211,6 +246,26 @@ ChannelMode A2dpCodecToHalChannelMode(
   }
 }
 
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+/*
+LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
+    const btav_a2dp_codec_config_t& a2dp_codec_config) {
+  switch ((int)(a2dp_codec_config.codec_specific_2 & 0x1)) {
+    case 0:
+      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
+      return LhdcLowLatencyEn::Disabled;
+    case 1:
+      LOG(INFO) << __func__ << ": LHDC low latency Enabled";
+      return LhdcLowLatencyEn::Enabled;
+    default:
+      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
+      return LhdcLowLatencyEn::Disabled;
+  }
+}
+*/
+// Savitech Patch - End
+
 bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
                         A2dpCodecConfig* a2dp_config) {
   btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
@@ -470,6 +525,88 @@ bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
   return true;
 }
 
+// Savitech Patch - START  Offload
+#if 0
+//require definition supported in hardware/interfaces/bluetooth/audio/types.hal
+bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config) {
+  btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
+  if ((current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) &&
+      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) &&
+      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
+    codec_config = {};
+    return false;
+  }
+  LOG(INFO) << __func__ << ": enter: codec_type = " << current_codec.codec_type;
+
+  tBT_A2DP_OFFLOAD a2dp_offload;
+  if (false == a2dp_config->getCodecSpecificConfig(&a2dp_offload) ) {
+    LOG(ERROR) << __func__ << ": getCodecSpecificConfig fail";
+    return false;
+  }
+
+  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) {
+    codec_config->codecType = CodecType::LHDCV3;
+  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) {
+    codec_config->codecType = CodecType::LHDCV2;
+  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
+    codec_config->codecType = CodecType::LHDCV5;
+  }
+  codec_config->config.lhdcv5Config({});
+  auto lhdcv5Config = codec_config->config.lhdcv5Config();
+
+  lhdcv5Config.sampleRate = A2dpCodecToHalSampleRate(current_codec);
+  if (lhdcv5Config.sampleRate == SampleRate::RATE_UNKNOWN) {
+    LOG(ERROR) << __func__
+               << ": Unknown LHDC Vn sample_rate=" << current_codec.sample_rate;
+    return false;
+  }
+
+  lhdcv5Config.channelMode = A2dpCodecToHalChannelMode(current_codec);
+  if (lhdcv5Config.channelMode == ChannelMode::UNKNOWN) {
+    LOG(ERROR) << __func__
+               << ": Unknown LHDC Vn channel_mode=" << current_codec.channel_mode;
+    return false;
+  }
+
+  lhdcv5Config.bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
+  if (lhdcv5Config.bitsPerSample == BitsPerSample::BITS_UNKNOWN) {
+    LOG(ERROR) << __func__ << ": Unknown LHDC Vn bits_per_sample="
+               << current_codec.bits_per_sample;
+    return false;
+  }
+
+  lhdcv5Config.codecVersion            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Version) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_VER];
+  lhdcv5Config.qualityIndex            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
+                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L]));
+  lhdcv5Config.maxQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
+                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L]));
+  lhdcv5Config.minQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
+                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]));
+  lhdcv5Config.frameDuration           = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5FrameDuration) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR];
+  lhdcv5Config.dataInterval            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5DataInterval)  a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL];
+  lhdcv5Config.codecSpecific_1         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1];
+  lhdcv5Config.codecSpecific_2         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2];
+  lhdcv5Config.metaData[0]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META];
+  lhdcv5Config.metaData[1]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 1];
+  lhdcv5Config.metaData[2]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 2];
+  lhdcv5Config.metaData[3]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 3];
+  lhdcv5Config.metaData[4]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 4];
+  lhdcv5Config.metaData[5]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 5];
+  lhdcv5Config.metaData[6]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 6];
+  lhdcv5Config.metaData[7]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 7];
+
+  codec_config->config.lhdcv5Config(lhdcv5Config);
+
+  LOG(INFO) << __func__ << ": debug: sampleRate = " << current_codec.sample_rate;
+  LOG(INFO) << __func__ << ": debug: bitsPerSample = " << current_codec.bits_per_sample;
+  LOG(INFO) << __func__ << ": debug: channelMode = " << current_codec.channel_mode;
+
+  return true;
+}
+#endif
+// Savitech Patch - END
+
 bool UpdateOffloadingCapabilities(
     const std::vector<btav_a2dp_codec_config_t>& framework_preference) {
   audio_hal_capabilities = BluetoothAudioClientInterface::GetAudioCapabilities(
@@ -492,10 +629,38 @@ bool UpdateOffloadingCapabilities(
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         codec_type_masks |= CodecType::LDAC;
         break;
+      // Savitech Patch - START  Offload
+#if 0
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        codec_type_masks |= CodecType::LHDCV3;
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+        codec_type_masks |= CodecType::LHDCV2;
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        codec_type_masks |= CodecType::LHDCV5;
+        break;
+#else
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        [[fallthrough]];
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+        [[fallthrough]];
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        LOG(WARNING) << __func__
+                     << ": Ignore source codec_type=" << preference.codec_type;
+        break;
+#endif
+      // Savitech Patch - END
       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
         [[fallthrough]];
       case BTAV_A2DP_CODEC_INDEX_SINK_AAC:
         [[fallthrough]];
+      // Savitech Patch - START  Offload
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+          [[fallthrough]];
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+        [[fallthrough]];
+      // Savitech Patch - END
       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
         LOG(WARNING) << __func__
                      << ": Ignore sink codec_type=" << preference.codec_type;
@@ -554,6 +719,21 @@ bool IsCodecOffloadingEnabled(const CodecConfiguration& codec_config) {
         auto ldac_config = codec_config.config.ldacConfig();
         return ldac_offloading_capability_match(ldac_capability, ldac_config);
       }
+      // Savitech Patch - START  Offload
+      /*
+      case CodecType::LHDCV3:
+        [[fallthrough]];
+      case CodecType::LHDCV2:
+        [[fallthrough]];
+      case CodecType::LHDCV5: {
+        LOG(INFO) << __func__ << ": LHDC aDSP codecType="
+                   << toString(codec_capability.codecType);
+        auto lhdcv5_capability = codec_capability.capabilities.lhdcv5Capabilities();
+        auto lhdcv5_config = codec_config.config.lhdcv5Config();
+        return lhdcv5_offloading_capability_match(lhdcv5_capability, lhdcv5_config);
+      }
+      */
+      // Savitech Patch - END
       case CodecType::UNKNOWN:
         [[fallthrough]];
       default:
diff --git a/system_bt/audio_hal_interface/codec_status.h b/system_bt/audio_hal_interface/codec_status.h
index e0e074438..6a476f086 100755
--- a/system_bt/audio_hal_interface/codec_status.h
+++ b/system_bt/audio_hal_interface/codec_status.h
@@ -28,6 +28,10 @@ namespace codec {
 
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using ::android::hardware::bluetooth::audio::V2_0::CodecConfiguration;
 using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
 
@@ -39,6 +43,13 @@ BitsPerSample A2dpCodecToHalBitsPerSample(
     const btav_a2dp_codec_config_t& a2dp_codec_config);
 ChannelMode A2dpCodecToHalChannelMode(
     const btav_a2dp_codec_config_t& a2dp_codec_config);
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+/*
+LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
+    const btav_a2dp_codec_config_t& a2dp_codec_config);
+    */
+// Savitech Patch - End
 
 bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
                         A2dpCodecConfig* a2dp_config);
@@ -48,7 +59,10 @@ bool A2dpAptxToHalConfig(CodecConfiguration* codec_config,
                          A2dpCodecConfig* a2dp_config);
 bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
                          A2dpCodecConfig* a2dp_config);
-
+// Savitech Patch - START  Offload
+bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config);
+// Savitech Patch - END
 bool UpdateOffloadingCapabilities(
     const std::vector<btav_a2dp_codec_config_t>& framework_preference);
 // Check whether this codec is supported by the audio HAL and is allowed to use
diff --git a/system_bt/bta/av/bta_av_aact.cc b/system_bt/bta/av/bta_av_aact.cc
index 33298d649..50d7433c9 100755
--- a/system_bt/bta/av/bta_av_aact.cc
+++ b/system_bt/bta/av/bta_av_aact.cc
@@ -3198,6 +3198,17 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
       codec_type = BTA_AV_CODEC_TYPE_LDAC;
       break;
+    // Savitech Patch - START  Offload
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      codec_type = BTA_AV_CODEC_TYPE_LHDCV3;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      codec_type = BTA_AV_CODEC_TYPE_LHDCV2;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      codec_type = BTA_AV_CODEC_TYPE_LHDCV5;
+      break;
+    // Savitech Patch - END
     default:
       APPL_TRACE_ERROR("%s: Unknown Codec type ", __func__);
       return;
@@ -3231,6 +3242,14 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
     case 96000:
       p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
       break;
+    // Savitech Patch - START  Offload
+    case 176400:
+      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_176400;
+      break;
+    case 192000:
+      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+      break;
+    // Savitech Patch - END
   }
   if (L2CA_GetRemoteCid(p_scb->l2c_cid, &p_a2dp_offload->l2c_rcid) == false) {
     APPL_TRACE_ERROR("%s: Failed to fetch l2c rcid", __func__);
diff --git a/system_bt/bta/include/bta_av_api.h b/system_bt/bta/include/bta_av_api.h
index 4591bbaef..1aacad72c 100755
--- a/system_bt/bta/include/bta_av_api.h
+++ b/system_bt/bta/include/bta_av_api.h
@@ -151,7 +151,12 @@ typedef enum {
   BTA_AV_CODEC_TYPE_AAC = 0x02,
   BTA_AV_CODEC_TYPE_APTX = 0x04,
   BTA_AV_CODEC_TYPE_APTXHD = 0x08,
-  BTA_AV_CODEC_TYPE_LDAC = 0x10
+  BTA_AV_CODEC_TYPE_LDAC = 0x10,
+  // Savitech Patch - START
+  BTA_AV_CODEC_TYPE_LHDCV3 = 0x20,
+  BTA_AV_CODEC_TYPE_LHDCV2 = 0x40,
+  BTA_AV_CODEC_TYPE_LHDCV5 = 0x80,
+  // Savitech Patch - END
 } tBTA_AV_CODEC_TYPE;
 
 /* Event associated with BTA_AV_ENABLE_EVT */
diff --git a/system_bt/btif/src/btif_a2dp_audio_interface.cc b/system_bt/btif/src/btif_a2dp_audio_interface.cc
index 7d7a083a3..2b60cc72f 100755
--- a/system_bt/btif/src/btif_a2dp_audio_interface.cc
+++ b/system_bt/btif/src/btif_a2dp_audio_interface.cc
@@ -232,6 +232,23 @@ static void btif_a2dp_get_codec_configuration(
       p_codec_info->codecSpecific.ldacData.bitrateIndex =
           a2dp_offload.codec_info[6];
       break;
+    // Savitech Patch - START  Offload
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      p_codec_info->codecType =
+          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
+          BTA_AV_CODEC_TYPE_LHDCV3;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      p_codec_info->codecType =
+          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
+          BTA_AV_CODEC_TYPE_LHDCV2;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      p_codec_info->codecType =
+          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
+          BTA_AV_CODEC_TYPE_LHDCV5;
+      break;
+    // Savitech Patch - END
     default:
       APPL_TRACE_ERROR("%s: Unknown Codec type :%d ", __func__,
                        codec_config.codec_type);
diff --git a/system_bt/btif/src/btif_a2dp_source.cc b/system_bt/btif/src/btif_a2dp_source.cc
index 6359d3029..94c5bfd78 100755
--- a/system_bt/btif/src/btif_a2dp_source.cc
+++ b/system_bt/btif/src/btif_a2dp_source.cc
@@ -930,7 +930,7 @@ static uint32_t btif_a2dp_source_read_callback(uint8_t* p_buf, uint32_t len) {
     if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
       bytes_read = bluetooth::audio::a2dp::read(p_buf + bytes_offset, len_read);
     } else if (a2dp_uipc != nullptr) {
-      bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len);
+      bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len_read);
     }
 
     // Savitech LHDC -- Low Latency Mode
diff --git a/system_bt/common/metrics.cc b/system_bt/common/metrics.cc
index 9214dcbde..ada5d0692 100755
--- a/system_bt/common/metrics.cc
+++ b/system_bt/common/metrics.cc
@@ -249,6 +249,14 @@ static A2dpSourceCodec get_a2dp_source_codec(int64_t codec_index) {
       return A2dpSourceCodec::A2DP_SOURCE_CODEC_APTX_HD;
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
       return A2dpSourceCodec::A2DP_SOURCE_CODEC_LDAC;
+    // Savitech Patch - START  Offload
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV3;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV2;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV5;
+    // Savitech Patch - END
     default:
       return A2dpSourceCodec::A2DP_SOURCE_CODEC_UNKNOWN;
   }
diff --git a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
index 676798782..31d606fab 100755
--- a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
+++ b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
@@ -138,6 +138,11 @@ enum A2dpSourceCodec {
   A2DP_SOURCE_CODEC_APTX = 3;
   A2DP_SOURCE_CODEC_APTX_HD = 4;
   A2DP_SOURCE_CODEC_LDAC = 5;
+  // Savitech Patch - START  Offload
+  A2DP_SOURCE_CODEC_LHDCV3 = 6;
+  A2DP_SOURCE_CODEC_LHDCV2 = 7;
+  A2DP_SOURCE_CODEC_LHDCV5 = 8;
+  // Savitech Patch - END
 }
 
 // Session information that gets logged for A2DP session.
diff --git a/system_bt/include/hardware/bt_av.h b/system_bt/include/hardware/bt_av.h
index e89da167e..432644ae3 100755
--- a/system_bt/include/hardware/bt_av.h
+++ b/system_bt/include/hardware/bt_av.h
@@ -56,7 +56,6 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
   BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
   BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
-  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1,
   BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
 
   BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
@@ -160,9 +159,6 @@ typedef struct {
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         codec_name_str = "LDAC";
         break;
-      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
-        codec_name_str = "LHDC V1";
-        break;
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
         codec_name_str = "LHDC V2";
         break;
diff --git a/system_bt/stack/Android.bp b/system_bt/stack/Android.bp
index f7803768c..10101e7ab 100755
--- a/system_bt/stack/Android.bp
+++ b/system_bt/stack/Android.bp
@@ -96,8 +96,6 @@ cc_library_static {
         "a2dp/a2dp_vendor_ldac_abr.cc",
         "a2dp/a2dp_vendor_ldac_decoder.cc",
         "a2dp/a2dp_vendor_ldac_encoder.cc",
-        "a2dp/a2dp_vendor_lhdcv1.cc",
-        "a2dp/a2dp_vendor_lhdcv1_encoder.cc",
         "a2dp/a2dp_vendor_lhdcv2.cc",
         "a2dp/a2dp_vendor_lhdcv2_encoder.cc",
         "a2dp/a2dp_vendor_lhdcv3.cc",
diff --git a/system_bt/stack/a2dp/a2dp_codec_config.cc b/system_bt/stack/a2dp/a2dp_codec_config.cc
index 6409bd1f2..0869fad5e 100755
--- a/system_bt/stack/a2dp/a2dp_codec_config.cc
+++ b/system_bt/stack/a2dp/a2dp_codec_config.cc
@@ -33,7 +33,6 @@
 #include "a2dp_vendor_aptx.h"
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
-#include "a2dp_vendor_lhdcv1.h"
 #include "a2dp_vendor_lhdcv2.h"
 #include "a2dp_vendor_lhdcv3.h"
 #include "a2dp_vendor_lhdcv3_dec.h"
@@ -144,9 +143,6 @@ A2dpCodecConfig* A2dpCodecConfig::createCodec(
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       codec_config = new A2dpCodecConfigLdacSink(codec_priority);
       break;
-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
-      codec_config = new A2dpCodecConfigLhdcV1(codec_priority);
-      break;
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
       codec_config = new A2dpCodecConfigLhdcV2(codec_priority);
       break;
@@ -271,12 +267,430 @@ bool A2dpCodecConfig::getCodecSpecificConfig(tBT_A2DP_OFFLOAD* p_a2dp_offload) {
         LOG_VERBOSE("%s: Ldac specific channelmode =%d", __func__,
                     p_a2dp_offload->codec_info[7]);
       }
+      // Savitech Patch - START  Offload
+      else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+        //
+        // LHDC V3
+        //
+        // Main Version
+        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER3 &&
+            (codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER6) {
+          LOG_ERROR("%s: [LHDC V3] Unsupported version 0x%x", __func__,
+              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
+          goto fail;
+        }
+
+        LOG_DEBUG("%s: [LHDC V3] isLLAC=%d isLHDCV4=%d", __func__,
+            (codec_config[10] & A2DP_LHDC_FEATURE_LLAC),
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4));
+        // LHDC/LLAC handle Version
+        if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) != 0 &&
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
+          // LLAC (isLLAC && !isLHDCV4)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_LLAC-1);
+          LOG_DEBUG("%s: [LHDC V3] init to LLAC (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) != 0) {
+          // LHDC V4 Only (!isLLAC && isLHDCV4)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V4_ONLY-1);
+          LOG_DEBUG("%s: [LHDC V3] init to LHDCV4 only (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
+          // LHDC V3 Only (!isLLAC && !isLHDCV4)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
+          LOG_DEBUG("%s: [LHDC V3] init to LHDCV3 only (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        }else {
+          // LHDC V3 Only - default
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
+          LOG_DEBUG("%s: [LHDC V3] flags check incorrect. So init to LHDCV3 only (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        }
+
+        // bit rate index
+        switch (codec_config_.codec_specific_1 & 0x0F) {
+        case A2DP_LHDC_QUALITY_LOW0:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW2:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW3:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW4:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_MID:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_HIGH:
+        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V3
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_ABR:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        default:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        }
+        LOG_DEBUG("%s: [LHDC V3] Bit Rate = 0x%02X", __func__,
+            (uint8_t)(codec_config_.codec_specific_1 & 0x0F));
+
+        // max bit rate index
+        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V3] Max Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
+
+        // min bit rate index
+        if ((codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR) == A2DP_LHDC_FEATURE_MIN_BR) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+        } else {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V3] Min Bit Rate = 0x%02X", __func__,
+            codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR);
+
+        // frameDuration - not supported
+        // p_a2dp_offload->codec_info[13]
+
+        // data interval
+        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
+          // LL is enabled (10 ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
+          LOG_DEBUG("%s: [LHDC V3] Low Latency mode", __func__);
+        } else {
+          // LL is disabled (20ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
+          LOG_DEBUG("%s: [LHDC V3] Normal Latency mode", __func__);
+        }
+
+        // Codec specific 1
+        if ((codec_config[9] & A2DP_LHDC_FEATURE_AR) != 0) {
+          // AR
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
+          LOG_DEBUG("%s: [LHDC V3] Has feature AR", __func__);
+        }
+        if ((codec_config[9] & A2DP_LHDC_FEATURE_JAS) != 0) {
+          // JAS
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
+          LOG_DEBUG("%s: [LHDC V3] Has feature JAS", __func__);
+        }
+        if ((codec_config[11] & A2DP_LHDC_FEATURE_META) != 0) {
+          // META
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
+          LOG_DEBUG("%s: [LHDC V3] Has feature META", __func__);
+        }
+
+        // Codec specific 2
+        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
+          // split mode disabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
+          LOG_DEBUG("%s: [LHDC V3] No ch split", __func__);
+        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
+          // split mode enabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
+          LOG_DEBUG("%s: [LHDC V3] Has ch split", __func__);
+        } else {
+          LOG_ERROR("%s: [LHDC V3] Unsupported split mode 0x%x", __func__,
+              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
+          goto fail;
+        }
+
+      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+        //
+        // LHDC V2
+        //
+        // Version
+        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) > A2DP_LHDC_VER2) {
+          LOG_ERROR("%s: [LHDC V2] Unsupported version 0x%x", __func__,
+              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
+          goto fail;
+        }
+        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV2_VER_1-1);
+        LOG_DEBUG("%s: [LHDC V2] version (0x%02X)", __func__,
+            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+
+        // bit rate index
+        switch (codec_config_.codec_specific_1 & 0x0F) {
+        case A2DP_LHDC_QUALITY_LOW0:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW2:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW3:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW4:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_MID:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_HIGH:
+        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V2
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_ABR:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        default:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        }
+        LOG_DEBUG("%s: [LHDC V2] Bit Rate = 0x%02X", __func__,
+            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
+
+        // max bit rate index
+        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V2] Max Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
+
+        // min bit rate index - not supported
+        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]
+        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]
+
+        // frameDuration - not supported
+        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR]
+
+        // data interval
+        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
+          // LL is enabled (10 ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
+          LOG_DEBUG("%s: [LHDC V2] Low Latency mode", __func__);
+        } else {
+          // LL is disabled (20ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
+          LOG_DEBUG("%s: [LHDC V2] Normal Latency mode", __func__);
+        }
+
+        // Codec specific 1 - not supported
+        // p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1]
+
+        // Codec specific 2
+        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
+          // split mode disabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
+          LOG_DEBUG("%s: [LHDC V2] No ch split", __func__);
+        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
+          // split mode enabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
+          LOG_DEBUG("%s: [LHDC V2] Has ch split", __func__);
+        } else {
+          LOG_ERROR("%s: [LHDC V2] Unsupported split mode 0x%x", __func__,
+              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
+          goto fail;
+        }
+      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+        //
+        // LHDC V5
+        //
+
+        // Version
+        if ((codec_config[11] & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_1) {
+          LOG_ERROR("%s: [LHDC V5] unsupported version 0x%x", __func__,
+              (codec_config[11] & A2DP_LHDCV5_VERSION_MASK));
+          goto fail;
+        }
+        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV5_VER_1-1);
+        LOG_DEBUG("%s: [LHDC V5] version (0x%02X)", __func__,
+            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+
+        // bit rate index
+        switch (codec_config_.codec_specific_1 & 0xF) {
+        case A2DP_LHDCV5_QUALITY_LOW0:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW2:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW3:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW4:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_MID:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_HIGH:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_HIGH1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_ABR:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        default:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        }
+        LOG_DEBUG("%s: [LHDC V5] Bit Rate = 0x%02X", __func__,
+            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
+
+        // max bit rate index
+        if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+        } else {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V5] Max Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+
+        // min bit rate index
+        if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+        } else {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V5] Min Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+
+        // frame duration
+        if ((codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK) != 0) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR] = A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US;
+          LOG_DEBUG("%s: [LHDC V5] Frame Duration: 5ms ", __func__);
+        } else {
+          LOG_ERROR("%s: [LHDC V5] unsupported frame duration 0x%x", __func__,
+              codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK);
+          goto fail;
+        }
+
+        // data interval
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_LL) != 0) {
+          // LL is disabled (10 ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
+          LOG_DEBUG("%s: [LHDC V5] Low Latency mode", __func__);
+        } else {
+          // LL is enabled (20ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
+          LOG_DEBUG("%s: [LHDC V5] Normal Latency mode", __func__);
+        }
+
+        // Codec specific 1
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_AR) != 0) {
+          // AR
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
+          LOG_DEBUG("%s: [LHDC V5] Has feature AR", __func__);
+        }
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_JAS) != 0) {
+          // JAS
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
+          LOG_DEBUG("%s: [LHDC V5] Has feature JAS", __func__);
+        }
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_META) != 0) {
+          // META
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
+          LOG_DEBUG("%s: [LHDC V5] Has feature META", __func__);
+        }
+
+        // Codec specific 2
+        if ((codec_config[13] & A2DP_LHDCV5_AR_ON) != 0) {
+          // AR_ON
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON;
+          LOG_DEBUG("%s: [LHDC V5] AR_ON is set", __func__);
+        }
+      }
+      // Savitech Patch - END
       break;
 #endif
     default:
       break;
   }
   return true;
+
+fail:
+  return false;
 }
 
 bool A2dpCodecConfig::isValid() const { return true; }
@@ -625,10 +1039,7 @@ bool A2dpCodecs::init() {
       } else if (strcmp(tok, "ldac") == 0) {
         LOG_INFO("%s: LDAC offload supported", __func__);
         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC] = true;
-      } else if (strcmp(tok, "lhdcv1") == 0) {  // Savitech LHDC
-        LOG_INFO("%s: LHDCV1 offload not supported", __func__);
-        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1] = false;
-      } else if (strcmp(tok, "lhdcv2") == 0) {
+      } else if (strcmp(tok, "lhdcv2") == 0) {  // Savitech LHDC
         LOG_INFO("%s: LHDCV2 offload not supported", __func__);
         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2] = false;
       } else if (strcmp(tok, "lhdcv3") == 0) {
@@ -952,7 +1363,6 @@ int A2dpCodecs::getLHDCCodecUserConfig(
       result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(codecConfig, clen);
     }
     break;
-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
   default:
     APPL_TRACE_DEBUG("%s: feature not support!", __func__);
@@ -983,7 +1393,6 @@ int A2dpCodecs::setLHDCCodecUserConfig(
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
     result = A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(codecConfig, clen);
     break;
-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
   default:
     APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
@@ -1011,7 +1420,6 @@ bool A2dpCodecs::setLHDCCodecUserData(
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
     A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(codecData, clen);
     break;
-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
   default:
     APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
@@ -1039,7 +1447,6 @@ int A2dpCodecs::getLHDCCodecUserApiVer(
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
     result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(version, clen);
     break;
-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
   default:
     APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
@@ -1726,11 +2133,14 @@ const tA2DP_DECODER_INTERFACE* A2DP_GetDecoderInterface(
 
   switch (codec_type) {
     case A2DP_MEDIA_CT_SBC:
+      LOG_DEBUG("%s: SBC", __func__);
       return A2DP_GetDecoderInterfaceSbc(p_codec_info);
 #if !defined(EXCLUDE_NONSTANDARD_CODECS)
     case A2DP_MEDIA_CT_AAC:
+      LOG_DEBUG("%s: AAC", __func__);
       return A2DP_GetDecoderInterfaceAac(p_codec_info);
     case A2DP_MEDIA_CT_NON_A2DP:
+      LOG_DEBUG("%s: VENDOR CODEC", __func__);
       return A2DP_VendorGetDecoderInterface(p_codec_info);
 #endif
     default:
diff --git a/system_bt/stack/a2dp/a2dp_vendor.cc b/system_bt/stack/a2dp/a2dp_vendor.cc
index b32580a78..b9936427f 100755
--- a/system_bt/stack/a2dp/a2dp_vendor.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor.cc
@@ -26,7 +26,6 @@
 #include "a2dp_vendor_ldac.h"
 #include "a2dp_vendor_lhdcv3.h"
 #include "a2dp_vendor_lhdcv2.h"
-#include "a2dp_vendor_lhdcv1.h"
 #include "a2dp_vendor_lhdcv3_dec.h"
 #include "a2dp_vendor_lhdcv5.h"
 #include "bt_target.h"
@@ -54,11 +53,6 @@ bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSourceCodecValidLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_IsVendorSourceCodecValidLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info);
@@ -149,11 +143,6 @@ bool A2DP_IsVendorPeerSinkCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorPeerSinkCodecValidLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_IsVendorPeerSinkCodecValidLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_IsVendorPeerSinkCodecValidLhdcV2(p_codec_info);
@@ -267,12 +256,6 @@ bool A2DP_VendorUsesRtpHeader(bool content_protection_enabled,
                                         p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorUsesRtpHeaderLhdcV1(content_protection_enabled,
-                                          p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorUsesRtpHeaderLhdcV2(content_protection_enabled,
@@ -316,11 +299,6 @@ const char* A2DP_VendorCodecName(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecNameLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorCodecNameLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorCodecNameLhdcV2(p_codec_info);
@@ -375,11 +353,6 @@ bool A2DP_VendorCodecTypeEquals(const uint8_t* p_codec_info_a,
     return A2DP_VendorCodecTypeEqualsLdac(p_codec_info_a, p_codec_info_b);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorCodecTypeEqualsLhdcV1(p_codec_info_a, p_codec_info_b);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorCodecTypeEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
@@ -435,11 +408,6 @@ bool A2DP_VendorCodecEquals(const uint8_t* p_codec_info_a,
     return A2DP_VendorCodecEqualsLdac(p_codec_info_a, p_codec_info_b);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorCodecEqualsLhdcV1(p_codec_info_a, p_codec_info_b);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorCodecEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
@@ -482,9 +450,14 @@ int A2DP_VendorGetBitRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetBitRateLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV2(p_codec_info);
+  }
+
   // Check for Savitech LHDCV3
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
-    return A2DP_VendorGetBitRateLhdcV3Sink(p_codec_info);
+    return A2DP_VendorGetBitRateLhdcV3(p_codec_info);
   }
 
   // Check for Savitech LHDCV5
@@ -518,11 +491,6 @@ int A2DP_VendorGetTrackSampleRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackSampleRateLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorGetTrackSampleRateLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
@@ -564,11 +532,6 @@ int A2DP_VendorGetTrackBitsPerSample(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackBitsPerSampleLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorGetTrackBitsPerSampleLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorGetTrackBitsPerSampleLhdcV2(p_codec_info);
@@ -610,11 +573,6 @@ int A2DP_VendorGetTrackChannelCount(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackChannelCountLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorGetTrackChannelCountLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
@@ -684,11 +642,6 @@ bool A2DP_VendorGetPacketTimestamp(const uint8_t* p_codec_info,
     return A2DP_VendorGetPacketTimestampLdac(p_codec_info, p_data, p_timestamp);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorGetPacketTimestampLhdcV1(p_codec_info, p_data, p_timestamp);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorGetPacketTimestampLhdcV2(p_codec_info, p_data, p_timestamp);
@@ -734,12 +687,6 @@ bool A2DP_VendorBuildCodecHeader(const uint8_t* p_codec_info, BT_HDR* p_buf,
                                            frames_per_packet);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorBuildCodecHeaderLhdcV1(p_codec_info, p_buf,
-                                               frames_per_packet);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorBuildCodecHeaderLhdcV2(p_codec_info, p_buf,
@@ -785,11 +732,6 @@ const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterface(
     return A2DP_VendorGetEncoderInterfaceLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorGetEncoderInterfaceLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorGetEncoderInterfaceLhdcV2(p_codec_info);
@@ -857,11 +799,6 @@ bool A2DP_VendorAdjustCodec(uint8_t* p_codec_info) {
     return A2DP_VendorAdjustCodecLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorAdjustCodecLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorAdjustCodecLhdcV2(p_codec_info);
@@ -904,11 +841,6 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(
     return A2DP_VendorSourceCodecIndexLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorSourceCodecIndexLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorSourceCodecIndexLhdcV2(p_codec_info);
@@ -970,8 +902,7 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
       return A2DP_VendorCodecIndexStrLdac();
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       return A2DP_VendorCodecIndexStrLdacSink();
-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
-      return A2DP_VendorCodecIndexStrLhdcV1();
+    // Savitech Patch - START
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
       return A2DP_VendorCodecIndexStrLhdcV2();
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
@@ -982,6 +913,7 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
       return A2DP_VendorCodecIndexStrLhdcV3Sink();
     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
       return A2DP_VendorCodecIndexStrLhdcV5Sink();
+    // Savitech Patch - END
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -1007,8 +939,7 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
       return A2DP_VendorInitCodecConfigLdac(p_cfg);
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       return A2DP_VendorInitCodecConfigLdacSink(p_cfg);
-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
-      return A2DP_VendorInitCodecConfigLhdcV1(p_cfg);
+    // Savitech Patch - START
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
       return A2DP_VendorInitCodecConfigLhdcV2(p_cfg);
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
@@ -1019,6 +950,7 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
       return A2DP_VendorInitCodecConfigLhdcV3Sink(p_cfg);
     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
       return A2DP_VendorInitCodecConfigLhdcV5Sink(p_cfg);
+    // Savitech Patch - END
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -1048,11 +980,6 @@ std::string A2DP_VendorCodecInfoString(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecInfoStringLdac(p_codec_info);
   }
 
-  // Check for Savitech LHDCV1
-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_VendorCodecInfoStringLhdcV1(p_codec_info);
-  }
-
   // Check for Savitech LHDCV2
   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
     return A2DP_VendorCodecInfoStringLhdcV2(p_codec_info);
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv1.cc
deleted file mode 100755
index 2adb760d7..000000000
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1.cc
+++ /dev/null
@@ -1,1220 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/******************************************************************************
- *
- *  Utility functions to help build and parse the LHDC Codec Information
- *  Element and Media Payload.
- *
- ******************************************************************************/
-
-#define LOG_TAG "a2dp_vendor_lhdcv1"
-
-#include "bt_target.h"
-
-#include "a2dp_vendor_lhdcv1.h"
-
-#include <string.h>
-
-#include <base/logging.h>
-#include "a2dp_vendor.h"
-#include "a2dp_vendor_lhdcv1_encoder.h"
-#include "bt_utils.h"
-#include "osi/include/log.h"
-#include "osi/include/osi.h"
-
-// data type for the LHDC Codec Information Element */
-// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
-typedef struct {
-  uint32_t vendorId;
-  uint16_t codecId;    /* Codec ID for LHDC */
-  uint8_t sampleRate;  /* Sampling Frequency */
-  uint8_t channelMode; /* STEREO/DUAL/MONO */
-  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
-  bool isChannelSeparation;
-} tA2DP_LHDC_CIE;
-
-/* LHDC Source codec capabilities */
-static const tA2DP_LHDC_CIE a2dp_lhdcV1_caps = {
-    A2DP_LHDC_VENDOR_ID,  // vendorId
-    A2DP_LHDCV1_CODEC_ID,   // codecId
-    // sampleRate
-    //(A2DP_LHDCV1_SAMPLING_FREQ_48000),
-    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
-    // channelMode
-    (A2DP_LHDC_CHANNEL_MODE_STEREO),
-    // bits_per_sample
-    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
-    //Channel Separation
-    true
-};
-    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
-
-/* Default LHDC codec configuration */
-static const tA2DP_LHDC_CIE a2dp_lhdcV1_default_config = {
-    A2DP_LHDC_VENDOR_ID,                // vendorId
-    A2DP_LHDCV1_CODEC_ID,                 // codecId
-    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
-    A2DP_LHDC_CHANNEL_MODE_STEREO,      // channelMode
-    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
-    false
-};
-
-static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv1 = {
-    a2dp_vendor_lhdcV1_encoder_init,
-    a2dp_vendor_lhdcV1_encoder_cleanup,
-    a2dp_vendor_lhdcV1_feeding_reset,
-    a2dp_vendor_lhdcV1_feeding_flush,
-    a2dp_vendor_lhdcV1_get_encoder_interval_ms,
-    a2dp_vendor_lhdcV1_send_frames,
-    a2dp_vendor_lhdcV1_set_transmit_queue_length};
-
-UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV1(
-    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
-    bool is_peer_codec_info);
-
-// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
-// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
-// |p_ie| is a pointer to the LHDC Codec Information Element information.
-// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
-// otherwise the corresponding A2DP error status code.
-static tA2DP_STATUS A2DP_BuildInfoLhdcV1(uint8_t media_type,
-                                       const tA2DP_LHDC_CIE* p_ie,
-                                       uint8_t* p_result) {
-
-  const uint8_t* tmpInfo = p_result;
-  if (p_ie == NULL || p_result == NULL) {
-    return A2DP_INVALID_PARAMS;
-  }
-
-  *p_result++ = A2DP_LHDCV1_CODEC_LEN;
-  *p_result++ = (media_type << 4);
-  *p_result++ = A2DP_MEDIA_CT_NON_A2DP;
-
-  // Vendor ID and Codec ID
-  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
-  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
-  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
-  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
-  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
-  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
-
-  // Sampling Frequency & Bits per sample
-  uint8_t para = 0;
-
-  // sample rate bit0 ~ bit2
-  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
-
-  if(p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
-      para |= A2DP_LHDC_BIT_FMT_24;
-  if(p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
-      para = para | A2DP_LHDC_BIT_FMT_16;
-
-  if (p_ie->isChannelSeparation == true) {
-      para |= A2DP_LHDCV1_CHANNEL_SEPARATION;   //Force supported Dual channels
-  }else {
-      para &= ~A2DP_LHDCV1_CHANNEL_SEPARATION;
-  }
-
-  *p_result = para;
-  if (*p_result == 0) return A2DP_INVALID_PARAMS;
-
-  LOG_DEBUG( "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x",
-     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9]);
-  return A2DP_SUCCESS;
-}
-
-// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
-// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
-// |p_codec_info|. If |is_capability| is true, the byte sequence is
-// codec capabilities, otherwise is codec configuration.
-// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
-// status code.
-static tA2DP_STATUS A2DP_ParseInfoLhdcV1(tA2DP_LHDC_CIE* p_ie,
-                                       const uint8_t* p_codec_info,
-                                       bool is_capability) {
-  uint8_t losc;
-  uint8_t media_type;
-  tA2DP_CODEC_TYPE codec_type;
-  const uint8_t* tmpInfo = p_codec_info;
-
-  //LOG_DEBUG( "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
-  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
-
-
-  LOG_DEBUG( "%s: Parses codec info for capbility = %s", __func__, (is_capability == 1 ? "true" : "false"));
-  LOG_DEBUG( "%s: Parses codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x",
-   __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9]);
-  // Check the codec capability length
-  losc = *p_codec_info++;
-    //LOG_DEBUG( "%s: losc = %d, A2DP_LHDCV1_CODEC_LEN = %d", __func__, losc, A2DP_LHDCV1_CODEC_LEN);
-  if (losc != A2DP_LHDCV1_CODEC_LEN) return A2DP_WRONG_CODEC;
-
-  media_type = (*p_codec_info++) >> 4;
-  codec_type = *p_codec_info++;
-    //LOG_DEBUG( "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
-  /* Check the Media Type and Media Codec Type */
-  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
-      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
-    return A2DP_WRONG_CODEC;
-  }
-
-  // Check the Vendor ID and Codec ID */
-  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
-                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
-                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
-                   (*(p_codec_info + 3) << 24 & 0xFF000000);
-  p_codec_info += 4;
-  p_ie->codecId =
-      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
-  p_codec_info += 2;
-    //LOG_DEBUG( "%s: p_ie->vendorId = %d, p_ie->codecId = %d", __func__, p_ie->vendorId, p_ie->codecId);
-  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
-      p_ie->codecId != A2DP_LHDCV1_CODEC_ID) {
-    return A2DP_WRONG_CODEC;
-  }
-
-  //LOG_DEBUG( "%s: *p_codec_info = 0x%x", __func__, *p_codec_info);
-
-  if (*p_codec_info & A2DP_LHDCV1_CHANNEL_SEPARATION){
-    p_ie->isChannelSeparation = true;
-  }else{
-    p_ie->isChannelSeparation = false;
-  }
-
-  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
-
-  p_ie->channelMode = A2DP_LHDC_CHANNEL_MODE_STEREO;
-
-  //p_ie->bits_per_sample = *p_codec_info & A2DP_LHDCV1_BIT_FMT_MASK;
-
-  LOG_DEBUG( "%s: *p_codec_info[0x%02x] & A2DP_LHDCV1_BIT_FMT_MASK[0x%02x] = 0x%02x", __func__, *p_codec_info, A2DP_LHDCV1_BIT_FMT_MASK, *p_codec_info & A2DP_LHDCV1_BIT_FMT_MASK);
-  
-  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
-    return A2DP_WRONG_CODEC;
-  }
-
-  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
-  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
-    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
-    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-  }
-
-
-  /*
-  p_ie->sampleRate = *p_codec_info++ & A2DP_LHDC_SAMPLING_FREQ_MASK;
-  p_ie->channelMode = *p_codec_info++ & A2DP_LHDCV1_CHANNEL_MODE_MASK;
-
-*/
-
-//LOG_DEBUG( "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x",
- //__func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6]);
-
-  if (is_capability) return A2DP_SUCCESS;
-
-  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
-    return A2DP_BAD_SAMP_FREQ;
-  if (A2DP_BitsSet(p_ie->channelMode) != A2DP_SET_ONE_BIT)
-    return A2DP_BAD_CH_MODE;
-
-  return A2DP_SUCCESS;
-}
-
-// Build the LHDC Media Payload Header.
-// |p_dst| points to the location where the header should be written to.
-// If |frag| is true, the media payload frame is fragmented.
-// |start| is true for the first packet of a fragmented frame.
-// |last| is true for the last packet of a fragmented frame.
-// If |frag| is false, |num| is the number of number of frames in the packet,
-// otherwise is the number of remaining fragments (including this one).
-/*
-static void A2DP_BuildMediaPayloadHeaderLhdcV1(uint8_t* p, uint16_t num) {
-  if (p == NULL) return;
-  *p = ( uint8_t)( num & 0xff);
-}
-*/
-
-bool A2DP_IsVendorSourceCodecValidLhdcV1(const uint8_t* p_codec_info) {
-  tA2DP_LHDC_CIE cfg_cie;
-
-  /* Use a liberal check when parsing the codec info */
-  return (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
-         (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
-}
-
-bool A2DP_IsVendorPeerSinkCodecValidLhdcV1(const uint8_t* p_codec_info) {
-  tA2DP_LHDC_CIE cfg_cie;
-
-  /* Use a liberal check when parsing the codec info */
-  return (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
-         (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
-}
-
-// Checks whether A2DP LHDC codec configuration matches with a device's codec
-// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
-// the device's codec capabilities.
-// If |is_capability| is true, the byte sequence is codec capabilities,
-// otherwise is codec configuration.
-// |p_codec_info| contains the codec capabilities for a peer device that
-// is acting as an A2DP source.
-// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
-// otherwise the corresponding A2DP error status code.
-static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV1(
-    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
-    bool is_capability) {
-  tA2DP_STATUS status;
-  tA2DP_LHDC_CIE cfg_cie;
-
-  /* parse configuration */
-  status = A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, is_capability);
-  if (status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: parsing failed %d", __func__, status);
-    return status;
-  }
-
-  /* verify that each parameter is in range */
-
-  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
-            cfg_cie.sampleRate, p_cap->sampleRate);
-  LOG_DEBUG( "%s: CH_MODE peer: 0x%x, capability 0x%x", __func__,
-            cfg_cie.channelMode, p_cap->channelMode);
-  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
-            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
-
-  /* sampling frequency */
-  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
-
-  /* channel mode */
-  //if ((cfg_cie.channelMode & p_cap->channelMode) == 0) return A2DP_NS_CH_MODE;
-
-  /* channel mode */
-  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
-
-  return A2DP_SUCCESS;
-}
-
-bool A2DP_VendorUsesRtpHeaderLhdcV1(UNUSED_ATTR bool content_protection_enabled,
-                                  UNUSED_ATTR const uint8_t* p_codec_info) {
-  // TODO: Is this correct? The RTP header is always included?
-  return true;
-}
-
-const char* A2DP_VendorCodecNameLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info) {
-  return "LHDC V1";
-}
-
-bool A2DP_VendorCodecTypeEqualsLhdcV1(const uint8_t* p_codec_info_a,
-                                    const uint8_t* p_codec_info_b) {
-  tA2DP_LHDC_CIE lhdcV1_cie_a;
-  tA2DP_LHDC_CIE lhdcV1_cie_b;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status =
-      A2DP_ParseInfoLhdcV1(&lhdcV1_cie_a, p_codec_info_a, true);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return false;
-  }
-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie_b, p_codec_info_b, true);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return false;
-  }
-
-  return true;
-}
-
-bool A2DP_VendorCodecEqualsLhdcV1(const uint8_t* p_codec_info_a,
-                                const uint8_t* p_codec_info_b) {
-  tA2DP_LHDC_CIE lhdcV1_cie_a;
-  tA2DP_LHDC_CIE lhdcV1_cie_b;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status =
-      A2DP_ParseInfoLhdcV1(&lhdcV1_cie_a, p_codec_info_a, true);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return false;
-  }
-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie_b, p_codec_info_b, true);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return false;
-  }
-
-  return (lhdcV1_cie_a.sampleRate == lhdcV1_cie_b.sampleRate) &&
-         (lhdcV1_cie_a.bits_per_sample == lhdcV1_cie_b.bits_per_sample);
-}
-
-
-int A2DP_VendorGetTrackSampleRateLhdcV1(const uint8_t* p_codec_info) {
-  tA2DP_LHDC_CIE lhdcV1_cie;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return -1;
-  }
-
-  switch (lhdcV1_cie.sampleRate) {
-    case A2DP_LHDC_SAMPLING_FREQ_44100:
-      return 44100;
-    case A2DP_LHDC_SAMPLING_FREQ_48000:
-      return 48000;
-    case A2DP_LHDC_SAMPLING_FREQ_88200:
-      return 88200;
-    case A2DP_LHDC_SAMPLING_FREQ_96000:
-      return 96000;
-  }
-
-  return -1;
-}
-
-int A2DP_VendorGetTrackBitsPerSampleLhdcV1(const uint8_t* p_codec_info) {
-    tA2DP_LHDC_CIE lhdc_cie;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdc_cie, p_codec_info, false);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return -1;
-  }
-
-#if 0
-  return 32;
-#else
-  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
-
-  switch (lhdc_cie.bits_per_sample) {
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
-      return 16;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
-      return 24;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
-      return 32;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
-      return -1;
-  }
-#endif
-}
-
-int A2DP_VendorGetTrackChannelCountLhdcV1(const uint8_t* p_codec_info) {
-  tA2DP_LHDC_CIE lhdcV1_cie;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return -1;
-  }
-
-  switch (lhdcV1_cie.channelMode) {
-    case A2DP_LHDC_CHANNEL_MODE_STEREO:
-      return 2;
-  }
-
-  return -1;
-}
-
-int A2DP_VendorGetChannelModeCodeLhdcV1(const uint8_t* p_codec_info) {
-  tA2DP_LHDC_CIE lhdcV1_cie;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return -1;
-  }
-
-  switch (lhdcV1_cie.channelMode) {
-    case A2DP_LHDC_CHANNEL_MODE_STEREO:
-      return lhdcV1_cie.channelMode;
-    default:
-      break;
-  }
-
-  return -1;
-}
-
-bool A2DP_VendorGetPacketTimestampLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info,
-                                       const uint8_t* p_data,
-                                       uint32_t* p_timestamp) {
-  // TODO: Is this function really codec-specific?
-  *p_timestamp = *(const uint32_t*)p_data;
-  return true;
-}
-
-bool A2DP_VendorGetChannelSeparation(const uint8_t* p_codec_info){
-  tA2DP_LHDC_CIE lhdcV1_cie;
-
-  // Check whether the codec info contains valid data
-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
-              a2dp_status);
-    return false;
-  }
-
-  LOG_ERROR( "%s: isChannelSeparation =%d", __func__, lhdcV1_cie.isChannelSeparation);
-
-  return lhdcV1_cie.isChannelSeparation == 0 ? false : true;
-}
-
-bool A2DP_VendorBuildCodecHeaderLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info,
-                                     BT_HDR* p_buf,
-                                     uint16_t frames_per_packet) {
-  uint8_t* p;
-
-  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
-  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
-  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
-  p[0] = ( uint8_t)( frames_per_packet & 0xff);
-  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
-  //A2DP_BuildMediaPayloadHeaderLhdcV1(p, frames_per_packet);
-  return true;
-}
-
-void A2DP_VendorDumpCodecInfoLhdcV1(const uint8_t* p_codec_info) {
-  tA2DP_STATUS a2dp_status;
-  tA2DP_LHDC_CIE lhdcV1_cie;
-
-  LOG_DEBUG( "%s", __func__);
-
-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, true);
-  if (a2dp_status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV1 fail:%d", __func__, a2dp_status);
-    return;
-  }
-
-  LOG_DEBUG( "\tsamp_freq: 0x%x", lhdcV1_cie.sampleRate);
-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-    LOG_DEBUG( "\tsamp_freq: (44100)");
-  }
-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-    LOG_DEBUG( "\tsamp_freq: (48000)");
-  }
-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
-    LOG_DEBUG( "\tsamp_freq: (88200)");
-  }
-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-    LOG_DEBUG( "\tsamp_freq: (96000)");
-  }
-
-  LOG_DEBUG( "\tch_mode: 0x%x", lhdcV1_cie.channelMode);
-  if (lhdcV1_cie.channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
-    LOG_DEBUG( "\tch_mode: (Stereo)");
-  }
-}
-
-std::string A2DP_VendorCodecInfoStringLhdcV1(const uint8_t* p_codec_info) {
-  std::stringstream res;
-  std::string field;
-  tA2DP_STATUS a2dp_status;
-  tA2DP_LHDC_CIE lhdcV1_cie;
-
-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, true);
-  if (a2dp_status != A2DP_SUCCESS) {
-    res << "A2DP_ParseInfoLhdc fail: " << loghex(a2dp_status);
-    return res.str();
-  }
-
-  res << "\tname: LHDCV1\n";
-
-  // Sample frequency
-  field.clear();
-  AppendField(&field, (lhdcV1_cie.sampleRate == 0), "NONE");
-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
-              "44100");
-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
-              "48000");
-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
-              "88200");
-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
-              "96000");
-  res << "\tsamp_freq: " << field << " (" << loghex(lhdcV1_cie.sampleRate)
-      << ")\n";
-
-  // Channel mode
-  /*
-  field.clear();
-  AppendField(&field, 0, "NONE");
-  AppendField(&field, 0,
-              "Mono");
-  AppendField(&field, 0,
-              "Dual");
-  AppendField(&field, 1,
-              "Stereo");
-  res << "\tch_mode: " << field << " (" << loghex(lhdcV1_cie.channelMode)
-      << ")\n";
-*/
-  return res.str();
-}
-
-const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV1(
-    const uint8_t* p_codec_info) {
-  if (!A2DP_IsVendorSourceCodecValidLhdcV1(p_codec_info)) return NULL;
-
-  return &a2dp_encoder_interface_lhdcv1;
-}
-
-bool A2DP_VendorAdjustCodecLhdcV1(uint8_t* p_codec_info) {
-  tA2DP_LHDC_CIE cfg_cie;
-
-  // Nothing to do: just verify the codec info is valid
-  if (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
-    return false;
-
-  return true;
-}
-
-btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV1(
-    UNUSED_ATTR const uint8_t* p_codec_info) {
-  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1;
-}
-
-const char* A2DP_VendorCodecIndexStrLhdcV1(void) { return "LHDC V1"; }
-
-bool A2DP_VendorInitCodecConfigLhdcV1(AvdtpSepConfig* p_cfg) {
-  if (A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcV1_caps,
-                         p_cfg->codec_info) != A2DP_SUCCESS) {
-    return false;
-  }
-
-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
-  /* Content protection info - support SCMS-T */
-  uint8_t* p = p_cfg->protect_info;
-  *p++ = AVDT_CP_LOSC;
-  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
-  p_cfg->num_protect = 1;
-#endif
-
-  return true;
-}
-
-UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
-                                           btav_a2dp_codec_config_t* result) {
-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-
-  result->bits_per_sample = config_cie.bits_per_sample;
-
-  if (config_cie.channelMode &
-       (A2DP_LHDC_CHANNEL_MODE_STEREO)) {
-    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
-  }
-}
-
-A2dpCodecConfigLhdcV1::A2dpCodecConfigLhdcV1(
-    btav_a2dp_codec_priority_t codec_priority)
-    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1, "LHDC V1",
-                      codec_priority) {
-  // Compute the local capability
-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-  }
-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-  }
-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
-  }
-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-  }
-  codec_local_capability_.bits_per_sample = a2dp_lhdcV1_caps.bits_per_sample;
-  if (a2dp_lhdcV1_caps.channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
-    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
-  }
-}
-
-A2dpCodecConfigLhdcV1::~A2dpCodecConfigLhdcV1() {}
-
-bool A2dpCodecConfigLhdcV1::init() {
-  if (!isValid()) return false;
-
-  // Load the encoder
-  if (!A2DP_VendorLoadEncoderLhdcV1()) {
-    LOG_ERROR( "%s: cannot load the encoder", __func__);
-    return false;
-  }
-
-  return true;
-}
-
-bool A2dpCodecConfigLhdcV1::useRtpHeaderMarkerBit() const { return false; }
-
-//
-// Selects the best sample rate from |sampleRate|.
-// The result is stored in |p_result| and |p_codec_config|.
-// Returns true if a selection was made, otherwise false.
-//
-static bool select_best_sample_rate(uint8_t sampleRate,
-                                    tA2DP_LHDC_CIE* p_result,
-                                    btav_a2dp_codec_config_t* p_codec_config) {
-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-    return true;
-  }
-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
-    return true;
-  }
-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-    return true;
-  }
-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-    return true;
-  }
-  return false;
-}
-
-//
-// Selects the audio sample rate from |p_codec_audio_config|.
-// |sampleRate| contains the capability.
-// The result is stored in |p_result| and |p_codec_config|.
-// Returns true if a selection was made, otherwise false.
-//
-static bool select_audio_sample_rate(
-    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
-    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
-  switch (p_codec_audio_config->sample_rate) {
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-        return true;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-        return true;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
-        return true;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-        return true;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
-      break;
-  }
-  return false;
-}
-
-//
-// Selects the best bits per sample from |bits_per_sample|.
-// |bits_per_sample| contains the capability.
-// The result is stored in |p_result| and |p_codec_config|.
-// Returns true if a selection was made, otherwise false.
-//
-static bool select_best_bits_per_sample(
-    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
-    btav_a2dp_codec_config_t* p_codec_config) {
-  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
-    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-    return true;
-  }
-  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
-    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-    return true;
-  }
-  return false;
-}
-
-//
-// Selects the audio bits per sample from |p_codec_audio_config|.
-// |bits_per_sample| contains the capability.
-// The result is stored in |p_result| and |p_codec_config|.
-// Returns true if a selection was made, otherwise false.
-//
-static bool select_audio_bits_per_sample(
-    const btav_a2dp_codec_config_t* p_codec_audio_config,
-    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
-    btav_a2dp_codec_config_t* p_codec_config) {
-  switch (p_codec_audio_config->bits_per_sample) {
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
-        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-        return true;
-      }
-      break;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
-        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-        return true;
-      }
-      break;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
-      break;
-  }
-  return false;
-}
-
-
-
-bool A2dpCodecConfigLhdcV1::setCodecConfig(const uint8_t* p_peer_codec_info,
-                                         bool is_capability,
-                                         uint8_t* p_result_codec_config) {
-  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
-  tA2DP_LHDC_CIE sink_info_cie;
-  tA2DP_LHDC_CIE result_config_cie;
-  uint8_t channelMode;
-  uint8_t sampleRate;
-  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
-
-  // Save the internal state
-  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
-  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
-  btav_a2dp_codec_config_t saved_codec_selectable_capability =
-      codec_selectable_capability_;
-  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
-  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
-  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
-  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
-  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
-  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
-  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
-         sizeof(ota_codec_peer_capability_));
-  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
-         sizeof(ota_codec_peer_config_));
-
-  tA2DP_STATUS status =
-      A2DP_ParseInfoLhdcV1(&sink_info_cie, p_peer_codec_info, is_capability);
-  if (status != A2DP_SUCCESS) {
-    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
-              __func__, status);
-    goto fail;
-  }
-
-    LOG_ERROR(
-              "%s",
-              __func__);
-
-  //
-  // Build the preferred configuration
-  //
-  memset(&result_config_cie, 0, sizeof(result_config_cie));
-  result_config_cie.vendorId = a2dp_lhdcV1_caps.vendorId;
-  result_config_cie.codecId = a2dp_lhdcV1_caps.codecId;
-
-  //
-  // Select the sample frequency
-  //
-  sampleRate = a2dp_lhdcV1_caps.sampleRate & sink_info_cie.sampleRate;
-  LOG_ERROR( "%s: samplrate = 0x%x", __func__, sampleRate);
-  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
-  switch (codec_user_config_.sample_rate) {
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
-        codec_config_.sample_rate = codec_user_config_.sample_rate;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
-        codec_config_.sample_rate = codec_user_config_.sample_rate;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
-        codec_config_.sample_rate = codec_user_config_.sample_rate;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
-        codec_config_.sample_rate = codec_user_config_.sample_rate;
-      }
-      break;
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
-    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
-      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
-      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
-      break;
-  }
-
-  // Select the sample frequency if there is no user preference
-  do {
-    // Compute the selectable capability
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-      codec_selectable_capability_.sample_rate |=
-          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-    }
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-      codec_selectable_capability_.sample_rate |=
-          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-    }
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
-      codec_selectable_capability_.sample_rate |=
-          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
-    }
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-      codec_selectable_capability_.sample_rate |=
-          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-    }
-
-    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) break;
-
-    // Compute the common capability
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-
-    // No user preference - try the codec audio config
-    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
-                                 &result_config_cie, &codec_config_)) {
-      break;
-    }
-
-    // No user preference - try the default config
-    if (select_best_sample_rate(
-            a2dp_lhdcV1_default_config.sampleRate & sink_info_cie.sampleRate,
-            &result_config_cie, &codec_config_)) {
-      break;
-    }
-
-    // No user preference - use the best match
-    if (select_best_sample_rate(sampleRate, &result_config_cie,
-                                &codec_config_)) {
-      break;
-    }
-  } while (false);
-  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
-    LOG_ERROR(
-              "%s: cannot match sample frequency: source caps = 0x%x "
-              "sink info = 0x%x",
-              __func__, a2dp_lhdcV1_caps.sampleRate, sink_info_cie.sampleRate);
-    goto fail;
-  }
-
-  //
-  // Select the bits per sample
-  //
-  // NOTE: this information is NOT included in the LHDC A2DP codec description
-  // that is sent OTA.
-  bits_per_sample = a2dp_lhdcV1_caps.bits_per_sample & sink_info_cie.bits_per_sample;
-  LOG_ERROR( "%s: a2dp_lhdcV1_caps.bits_per_sample = 0x%02x, sink_info_cie.bits_per_sample = 0x%02x", __func__, a2dp_lhdcV1_caps.bits_per_sample, sink_info_cie.bits_per_sample);
-  LOG_ERROR( "%s: bits_per_sample = 0x%02x", __func__, bits_per_sample);
-  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
-  switch (codec_user_config_.bits_per_sample) {
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
-        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
-        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
-      }
-      break;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
-        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
-        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
-      }
-      break;
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
-      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
-      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
-      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
-      break;
-  }
-
-  // Select the bits per sample if there is no user preference
-  do {
-    // Compute the selectable capability
-      // Compute the selectable capability
-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-
-    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) break;
-
-    // Compute the common capability
-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
-      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
-      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-
-    // No user preference - the the codec audio config
-    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
-                                     &result_config_cie, &codec_config_)) {
-      break;
-    }
-
-    // No user preference - try the default config
-    if (select_best_bits_per_sample(a2dp_lhdcV1_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
-                                    &result_config_cie, &codec_config_)) {
-      break;
-    }
-
-    // No user preference - use the best match
-    if (select_best_bits_per_sample(bits_per_sample,
-                                    &result_config_cie, &codec_config_)) {
-      break;
-    }
-  } while (false);
-/*
-  // Select the bits per sample if there is no user preference
-  do {
-    // Compute the selectable capability
-    codec_selectable_capability_.bits_per_sample =
-        a2dp_lhdcV1_caps.bits_per_sample;
-
-    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE)
-      break;
-
-    // Compute the common capability
-    codec_capability_.bits_per_sample = bits_per_sample;
-
-    // No user preference - the the codec audio config
-    if (select_audio_bits_per_sample(&codec_audio_config_,
-                                     a2dp_lhdcV1_caps.bits_per_sample,
-                                     &result_config_cie, &codec_config_)) {
-      break;
-    }
-
-    // No user preference - try the default config
-    if (select_best_bits_per_sample(a2dp_lhdcV1_default_config.bits_per_sample,
-                                    &result_config_cie, &codec_config_)) {
-      break;
-    }
-
-    // No user preference - use the best match
-    if (select_best_bits_per_sample(a2dp_lhdcV1_caps.bits_per_sample,
-                                    &result_config_cie, &codec_config_)) {
-      break;
-    }
-} while (false);*/
-  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
-    LOG_ERROR(
-              "%s: cannot match bits per sample: default = 0x%x "
-              "user preference = 0x%x",
-              __func__, a2dp_lhdcV1_default_config.bits_per_sample,
-              codec_user_config_.bits_per_sample);
-    goto fail;
-  }
-
-  //
-  // Select the channel mode
-  //
-  channelMode = a2dp_lhdcV1_caps.channelMode & sink_info_cie.channelMode;
-  LOG_ERROR( "%s: channelMode = 0x%x", __func__, channelMode);
-  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
-  switch (codec_user_config_.channel_mode) {
-    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
-      if (channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
-        result_config_cie.channelMode = A2DP_LHDC_CHANNEL_MODE_STEREO;
-        codec_capability_.channel_mode = codec_user_config_.channel_mode;
-        codec_config_.channel_mode = codec_user_config_.channel_mode;
-        break;
-      }
-      break;
-    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
-    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
-      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
-      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
-      break;
-  }
-  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
-  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
-  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
-  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
-    LOG_ERROR(
-              "%s: cannot match channel mode: source caps = 0x%x "
-              "sink info = 0x%x",
-              __func__, a2dp_lhdcV1_caps.channelMode, sink_info_cie.channelMode);
-    goto fail;
-  }
-
-  if (int ret = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
-                         p_result_codec_config) != A2DP_SUCCESS) {
-    LOG_ERROR("%s: A2DP_BuildInfoLhdcV1 fail(0x%x)", __func__, ret);
-    goto fail;
-  }
-
-  //
-  // Copy the codec-specific fields if they are not zero
-  //
-  if (codec_user_config_.codec_specific_1 != 0)
-    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
-  if (codec_user_config_.codec_specific_2 != 0)
-    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
-  if (codec_user_config_.codec_specific_3 != 0)
-    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
-  if (codec_user_config_.codec_specific_4 != 0)
-    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
-
-
-  result_config_cie.isChannelSeparation = sink_info_cie.isChannelSeparation;
-  LOG_ERROR("%s: isChannelSeparation = %d", __func__, result_config_cie.isChannelSeparation);
-
-  // Create a local copy of the peer codec capability, and the
-  // result codec config.
-    LOG_ERROR("%s: is_capability = %d", __func__, is_capability);
-  if (is_capability) {
-    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
-                                ota_codec_peer_capability_);
-  } else {
-    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
-                                ota_codec_peer_config_);
-  }
-  CHECK(status == A2DP_SUCCESS);
-
-  status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
-                              ota_codec_config_);
-  CHECK(status == A2DP_SUCCESS);
-  return true;
-
-fail:
-  // Restore the internal state
-  codec_config_ = saved_codec_config;
-  codec_capability_ = saved_codec_capability;
-  codec_selectable_capability_ = saved_codec_selectable_capability;
-  codec_user_config_ = saved_codec_user_config;
-  codec_audio_config_ = saved_codec_audio_config;
-  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
-  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
-         sizeof(ota_codec_peer_capability_));
-  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
-         sizeof(ota_codec_peer_config_));
-  return false;
-}
-
-bool A2dpCodecConfigLhdcV1::setPeerCodecCapabilities(
-                                                   const uint8_t* p_peer_codec_capabilities) {
-    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
-    tA2DP_LHDC_CIE peer_info_cie;
-    uint8_t sampleRate;
-    uint8_t bits_per_sample;
-
-    // Save the internal state
-    btav_a2dp_codec_config_t saved_codec_selectable_capability =
-    codec_selectable_capability_;
-    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
-    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
-           sizeof(ota_codec_peer_capability_));
-
-    tA2DP_STATUS status =
-    A2DP_ParseInfoLhdcV1(&peer_info_cie, p_peer_codec_capabilities, true);
-    if (status != A2DP_SUCCESS) {
-        LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
-                  __func__, status);
-        goto fail;
-    }
-
-
-    codec_selectable_capability_.codec_specific_3 = 0;
-
-    // Compute the selectable capability - bits per sample
-    //codec_selectable_capability_.bits_per_sample =
-    //a2dp_lhdcV1_caps.bits_per_sample;
-    bits_per_sample = peer_info_cie.bits_per_sample & peer_info_cie.bits_per_sample;
-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
-    }
-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
-    }
-
-
-    // Compute the selectable capability - sample rate
-    sampleRate = a2dp_lhdcV1_caps.sampleRate & peer_info_cie.sampleRate;
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
-        codec_selectable_capability_.sample_rate |=
-        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
-    }
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
-        codec_selectable_capability_.sample_rate |=
-        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
-    }
-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
-        codec_selectable_capability_.sample_rate |=
-        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
-    }
-
-
-    // Compute the selectable capability - channel mode
-    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
-
-    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
-                                ota_codec_peer_capability_);
-    CHECK(status == A2DP_SUCCESS);
-    return true;
-
-fail:
-    // Restore the internal state
-    codec_selectable_capability_ = saved_codec_selectable_capability;
-    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
-           sizeof(ota_codec_peer_capability_));
-    return false;
-}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc
deleted file mode 100755
index 0a8acb20e..000000000
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc
+++ /dev/null
@@ -1,874 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "a2dp_vendor_lhdcv1_encoder"
-#define ATRACE_TAG ATRACE_TAG_AUDIO
-
-#include "a2dp_vendor_lhdcv1_encoder.h"
-
-#ifndef OS_GENERIC
-#include <cutils/trace.h>
-#endif
-#include <dlfcn.h>
-#include <inttypes.h>
-#include <stdio.h>
-#include <string.h>
-#include <base/logging.h>
-
-#include <lhdcBT.h>
-
-#include "a2dp_vendor.h"
-#include "a2dp_vendor_lhdcv1.h"
-#include "bt_common.h"
-#include "common/time_util.h"
-#include "osi/include/log.h"
-#include "osi/include/osi.h"
-
-//
-// Encoder for LHDC Source Codec
-//
-
-//
-// The LHDC encoder shared library, and the functions to use
-//
-static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
-static void* lhdcV1_encoder_lib_handle = NULL;
-
-static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
-typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
-
-static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
-typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
-
-static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
-typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
-static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
-typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
-
-//static const char* LHDC_GET_SAMPLING_FREQ_NAME = "lhdcBT_get_sampling_freq";
-//typedef int (*tLHDC_GET_SAMPLING_FREQ)(HANDLE_LHDC_BT hLhdcParam);
-
-static const char* LHDC_INIT_HANDLE_ENCODE_NAME = "lhdcBT_init_encoder";
-typedef int (*tLHDC_INIT_HANDLE_ENCODE)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
-
-static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
-typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
-
-
-static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
-typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
-
-//static const char* LHDC_GET_ERROR_CODE_NAME = "lhdcBT_get_error_code";
-//typedef int (*tLHDC_GET_ERROR_CODE)(HANDLE_LHDC_BT hLhdcParam);
-
-static tLHDC_GET_HANDLE lhdcV1_get_handle_func;
-static tLHDC_FREE_HANDLE lhdcV1_free_handle_func;
-//static tLHDC_CLOSE_HANDLE lhdcV1_close_handle_func;
-//static tLHDC_GET_VERSION lhdcV1_get_version_func;
-static tLHDC_GET_BITRATE lhdcV1_get_bitrate_func;
-static tLHDC_SET_BITRATE lhdcV1_set_bitrate_func;
-//static tLHDC_GET_SAMPLING_FREQ lhdcV1_get_sampling_freq_func;
-static tLHDC_INIT_HANDLE_ENCODE lhdcV1_init_handle_encode_func;
-static tLHDC_ENCODE lhdcV1_encode_func;
-static tLHDC_AUTO_ADJUST_BITRATE lhdcV1_auto_adjust_bitrate_func;
-//static tLHDC_GET_ERROR_CODE lhdcV1_get_error_code_func;
-//static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdcV1_set_limit_bitrate_enabled;
-
-// A2DP LHDC encoder interval in milliseconds
-#define A2DP_LHDCV1_ENCODER_INTERVAL_MS 20
-#define A2DP_LHDCV1_SAMPLES_PER_FRAME 512
-
-// offset
-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
-#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
-#else
-#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
-#endif
-
-//#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + 0)
-
-typedef struct {
-  uint32_t sample_rate;
-  uint8_t channel_mode;
-  uint8_t bits_per_sample;
-  int quality_mode_index;
-  int latency_mode_index;
-  int pcm_wlength;
-  LHDCBT_SMPL_FMT_T pcm_fmt;
-  bool isChannelSeparation;
-} tA2DP_LHDC_ENCODER_PARAMS;
-
-typedef struct {
-  uint32_t counter;
-  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
-  uint64_t last_frame_us;
-} tA2DP_LHDC_FEEDING_STATE;
-
-typedef struct {
-  uint64_t session_start_us;
-
-  size_t media_read_total_expected_packets;
-  size_t media_read_total_expected_reads_count;
-  size_t media_read_total_expected_read_bytes;
-
-  size_t media_read_total_dropped_packets;
-  size_t media_read_total_actual_reads_count;
-  size_t media_read_total_actual_read_bytes;
-} a2dp_lhdcV1_encoder_stats_t;
-
-typedef struct {
-  a2dp_source_read_callback_t read_callback;
-  a2dp_source_enqueue_callback_t enqueue_callback;
-  uint16_t TxAaMtuSize;
-  size_t TxQueueLength;
-
-  bool use_SCMS_T;
-  bool is_peer_edr;          // True if the peer device supports EDR
-  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
-  uint16_t peer_mtu;         // MTU of the A2DP peer
-  uint32_t timestamp;        // Timestamp for the A2DP frames
-
-  HANDLE_LHDC_BT lhdcV1_handle;
-  bool has_lhdcV1_handle;  // True if lhdcV1_handle is valid
-/*
-  HANDLE_LHDC_ABR lhdcV1_abr_handle;
-  bool has_lhdcV1_abr_handle;
-  int last_lhdcV1_abr_eqmid;
-  size_t lhdcV1_abr_adjustments;
-*/
-  tA2DP_FEEDING_PARAMS feeding_params;
-  tA2DP_LHDC_ENCODER_PARAMS lhdcV1_encoder_params;
-  tA2DP_LHDC_FEEDING_STATE lhdcV1_feeding_state;
-
-  a2dp_lhdcV1_encoder_stats_t stats;
-  uint32_t buf_seq;
-} tA2DP_LHDC_ENCODER_CB;
-
-//static bool lhdcV1_abr_loaded = false;
-
-//FILE  *RecFile = NULL;
-
-static tA2DP_LHDC_ENCODER_CB a2dp_lhdcV1_encoder_cb;
-
-static void a2dp_vendor_lhdcV1_encoder_update(uint16_t peer_mtu,
-                                            A2dpCodecConfig* a2dp_codec_config,
-                                            bool* p_restart_input,
-                                            bool* p_restart_output,
-                                            bool* p_config_updated);
-static void a2dp_lhdcV1_get_num_frame_iteration(uint8_t* num_of_iterations,
-                                              uint8_t* num_of_frames,
-                                              uint64_t timestamp_us);
-static void a2dp_lhdcV1_encode_frames(uint8_t nb_frame);
-static bool a2dp_lhdcV1_read_feeding(uint8_t* read_buffer);
-static std::string quality_mode_index_to_name(int quality_mode_index);
-static std::string latency_mode_index_to_name(int latency_mode_index);
-
-static void* load_func(const char* func_name) {
-  void* func_ptr = dlsym(lhdcV1_encoder_lib_handle, func_name);
-  if (func_ptr == NULL) {
-    LOG_ERROR(
-              "%s: cannot find function '%s' in the encoder library: %s",
-              __func__, func_name, dlerror());
-    A2DP_VendorUnloadEncoderLhdcV1();
-    return NULL;
-  }
-  return func_ptr;
-}
-
-bool A2DP_VendorLoadEncoderLhdcV1(void) {
-  if (lhdcV1_encoder_lib_handle != NULL) return true;  // Already loaded
-
-  // Initialize the control block
-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
-
-  // Open the encoder library
-  lhdcV1_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
-  if (lhdcV1_encoder_lib_handle == NULL) {
-    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
-              LHDC_ENCODER_LIB_NAME, dlerror());
-    return false;
-  }
-
-  // Load all functions
-  lhdcV1_get_handle_func = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
-  if (lhdcV1_get_handle_func == NULL) return false;
-  lhdcV1_free_handle_func = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
-  if (lhdcV1_free_handle_func == NULL) return false;
-  //lhdcV1_close_handle_func = (tLHDC_CLOSE_HANDLE)load_func(LHDC_CLOSE_HANDLE_NAME);
-  //if (lhdcV1_close_handle_func == NULL) return false;
-  //lhdcV1_get_version_func = (tLHDC_GET_VERSION)load_func(LHDC_GET_VERSION_NAME);
-  //if (lhdcV1_get_version_func == NULL) return false;
-  lhdcV1_get_bitrate_func = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
-  if (lhdcV1_get_bitrate_func == NULL) return false;
-  lhdcV1_set_bitrate_func = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
-  if (lhdcV1_set_bitrate_func == NULL) return false;
-  //lhdcV1_get_sampling_freq_func = (tLHDC_GET_SAMPLING_FREQ)load_func(LHDC_GET_SAMPLING_FREQ_NAME);
-  //if (lhdcV1_get_sampling_freq_func == NULL) return false;
-  lhdcV1_init_handle_encode_func =
-      (tLHDC_INIT_HANDLE_ENCODE)load_func(LHDC_INIT_HANDLE_ENCODE_NAME);
-  if (lhdcV1_init_handle_encode_func == NULL) return false;
-  lhdcV1_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
-  if (lhdcV1_encode_func == NULL) return false;
-  lhdcV1_auto_adjust_bitrate_func = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
-  if (lhdcV1_auto_adjust_bitrate_func == NULL) return false;
-  //lhdcV1_alter_eqmid_priority_func = (tLHDC_ALTER_EQMID_PRIORITY)load_func(LHDC_ALTER_EQMID_PRIORITY_NAME);
-  //if (lhdcV1_alter_eqmid_priority_func == NULL) return false;
-  //lhdcV1_get_eqmid_func = (tLHDC_GET_EQMID)load_func(LHDC_GET_EQMID_NAME);
-  //if (lhdcV1_get_eqmid_func == NULL) return false;
-  //lhdcV1_get_error_code_func = (tLHDC_GET_ERROR_CODE)load_func(LHDC_GET_ERROR_CODE_NAME);
-  //if (lhdcV1_get_error_code_func == NULL) return false;
-
-
-  //lhdcV1_set_limit_bitrate_enabled = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
-  //if (lhdcV1_set_limit_bitrate_enabled == NULL) return false;
-
-
-/*
-  if (!A2DP_VendorLoadLhdcAbr()) {
-    LOG_WARN( "%s: cannot load the LHDC ABR library", __func__);
-    lhdcV1_abr_loaded = false;
-  } else {
-    lhdcV1_abr_loaded = true;
-  }
-  */
-  return true;
-}
-
-void A2DP_VendorUnloadEncoderLhdcV1(void) {
-  // Cleanup any LHDC-related state
-
-    LOG_DEBUG( "%s: a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle = %d, lhdcV1_free_handle_func = %p",
-              __func__, a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle, lhdcV1_free_handle_func);
-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle && lhdcV1_free_handle_func != NULL)
-    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
-
-  lhdcV1_get_handle_func = NULL;
-  lhdcV1_free_handle_func = NULL;
-  lhdcV1_get_bitrate_func = NULL;
-  lhdcV1_set_bitrate_func = NULL;
-  //lhdcV1_get_sampling_freq_func = NULL;
-  lhdcV1_init_handle_encode_func = NULL;
-  lhdcV1_encode_func = NULL;
-  lhdcV1_auto_adjust_bitrate_func = NULL;
-  //lhdcV1_get_error_code_func = NULL;
-  //lhdcV1_set_limit_bitrate_enabled = NULL;
-
-  if (lhdcV1_encoder_lib_handle != NULL) {
-    dlclose(lhdcV1_encoder_lib_handle);
-    lhdcV1_encoder_lib_handle = NULL;
-  }
-}
-
-void a2dp_vendor_lhdcV1_encoder_init(
-    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
-    A2dpCodecConfig* a2dp_codec_config,
-    a2dp_source_read_callback_t read_callback,
-    a2dp_source_enqueue_callback_t enqueue_callback) {
-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle)
-    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
-
-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
-
-  a2dp_lhdcV1_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
-
-  a2dp_lhdcV1_encoder_cb.read_callback = read_callback;
-  a2dp_lhdcV1_encoder_cb.enqueue_callback = enqueue_callback;
-  a2dp_lhdcV1_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
-  a2dp_lhdcV1_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
-  a2dp_lhdcV1_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
-  a2dp_lhdcV1_encoder_cb.timestamp = 0;
-
-
-  a2dp_lhdcV1_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
-  a2dp_lhdcV1_encoder_cb.use_SCMS_T = true;
-#endif
-
-  // NOTE: Ignore the restart_input / restart_output flags - this initization
-  // happens when the connection is (re)started.
-  bool restart_input = false;
-  bool restart_output = false;
-  bool config_updated = false;
-  a2dp_vendor_lhdcV1_encoder_update(a2dp_lhdcV1_encoder_cb.peer_mtu,
-                                  a2dp_codec_config, &restart_input,
-                                  &restart_output, &config_updated);
-}
-
-bool A2dpCodecConfigLhdcV1::updateEncoderUserConfig(
-    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
-    bool* p_restart_output, bool* p_config_updated) {
-  a2dp_lhdcV1_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
-  a2dp_lhdcV1_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
-  a2dp_lhdcV1_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
-  a2dp_lhdcV1_encoder_cb.timestamp = 0;
-
-  if (a2dp_lhdcV1_encoder_cb.peer_mtu == 0) {
-    LOG_ERROR(
-              "%s: Cannot update the codec encoder for %s: "
-              "invalid peer MTU",
-              __func__, name().c_str());
-    return false;
-  }
-
-  a2dp_vendor_lhdcV1_encoder_update(a2dp_lhdcV1_encoder_cb.peer_mtu, this,
-                                  p_restart_input, p_restart_output,
-                                  p_config_updated);
-  return true;
-}
-
-// Update the A2DP LHDC encoder.
-// |peer_mtu| is the peer MTU.
-// |a2dp_codec_config| is the A2DP codec to use for the update.
-static void a2dp_vendor_lhdcV1_encoder_update(uint16_t peer_mtu,
-                                            A2dpCodecConfig* a2dp_codec_config,
-                                            bool* p_restart_input,
-                                            bool* p_restart_output,
-                                            bool* p_config_updated) {
-  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
-      &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
-  uint8_t codec_info[AVDT_CODEC_SIZE];
-
-  *p_restart_input = false;
-  *p_restart_output = false;
-  *p_config_updated = false;
-
-  //Example for limit bit rate
-  //lhdcV1_set_limit_bitrate_enabled(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, 0);
-
-
-  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
-    LOG_ERROR(
-              "%s: Cannot update the codec encoder for %s: "
-              "invalid codec config",
-              __func__, a2dp_codec_config->name().c_str());
-    return;
-  }
-
-  if (!a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle) {
-      a2dp_lhdcV1_encoder_cb.lhdcV1_handle = lhdcV1_get_handle_func(0);
-      if (a2dp_lhdcV1_encoder_cb.lhdcV1_handle == NULL) {
-          LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
-          return;  // TODO: Return an error?
-      }
-      a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle = true;
-  }
-  const uint8_t* p_codec_info = codec_info;
-  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
-  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
-
-  // The feeding parameters
-  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdcV1_encoder_cb.feeding_params;
-  p_feeding_params->sample_rate =
-      A2DP_VendorGetTrackSampleRateLhdcV1(p_codec_info);
-  p_feeding_params->bits_per_sample =
-      a2dp_codec_config->getAudioBitsPerSample();
-  p_feeding_params->channel_count =
-      A2DP_VendorGetTrackChannelCountLhdcV1(p_codec_info);
-  LOG_DEBUG( "%s: sample_rate=%u bits_per_sample=%u channel_count=%u",
-            __func__, p_feeding_params->sample_rate,
-            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
-
-  // The codec parameters
-  p_encoder_params->sample_rate =
-      a2dp_lhdcV1_encoder_cb.feeding_params.sample_rate;
-  p_encoder_params->channel_mode =
-      A2DP_VendorGetChannelModeCodeLhdcV1(p_codec_info);
-
-  uint16_t mtu_size =
-      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDCV1_OFFSET - sizeof(BT_HDR);
-  if (mtu_size < peer_mtu) {
-    a2dp_lhdcV1_encoder_cb.TxAaMtuSize = mtu_size;
-  } else {
-    a2dp_lhdcV1_encoder_cb.TxAaMtuSize = peer_mtu;
-  }
-
-  //get separation feature.
-  p_encoder_params->isChannelSeparation = A2DP_VendorGetChannelSeparation(p_codec_info);
-  // Set the quality mode index
-  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
-  LOG_DEBUG( "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
-  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
-      //int newValue = codec_config.codec_specific_1 & 0xff;
-      int newValue = codec_config.codec_specific_1 & 0xff;
-
-      // adjust non-supported quality modes and wrap to internal library used index
-      if (newValue == A2DP_LHDC_QUALITY_ABR) {
-        newValue = LHDCBT_QUALITY_AUTO; //9->8
-      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
-        // High1(1000K) does not supported, downgrade to High(900K)
-        newValue = LHDCBT_QUALITY_HIGH; //8->7
-        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
-        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
-      }
-
-      if (newValue != p_encoder_params->quality_mode_index) {
-
-        p_encoder_params->quality_mode_index = newValue;
-        LOG_DEBUG( "%s: setting internal quality mode to %s(%d)", __func__,
-                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
-                      .c_str(), p_encoder_params->quality_mode_index);
-      }
-  }else {
-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
-      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
-      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
-  }
-  if (p_encoder_params->isChannelSeparation && p_encoder_params->quality_mode_index >= LHDCBT_QUALITY_HIGH) {
-      /* code */
-      LOG_DEBUG( "%s: Channel separation enabled, Max bit rate = LHDCBT_QUALITY_MID", __func__);
-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_MID;
-  }
-
-  //p_encoder_params->latency_mode_index = 1;
-  if ((codec_config.codec_specific_2 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_LATENCY_MAGIC_NUM) {
-      int newValue = codec_config.codec_specific_2 & 0xff;
-      if (newValue != p_encoder_params->latency_mode_index) {
-          /* code */
-          p_encoder_params->latency_mode_index = newValue;
-          LOG_DEBUG( "%s: setting latency value to %s(%d)", __func__,
-                    latency_mode_index_to_name(p_encoder_params->latency_mode_index).c_str(),
-                    p_encoder_params->latency_mode_index);
-      }
-  }else {
-      p_encoder_params->latency_mode_index = A2DP_LHDC_LATENCY_MID;
-  }
-
-  p_encoder_params->pcm_wlength =
-      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample >> 3;
-  // Set the Audio format from pcm_wlength
-  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
-  if (p_encoder_params->pcm_wlength == 2)
-    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
-  else if (p_encoder_params->pcm_wlength == 3)
-    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
-
-  LOG_DEBUG( "%s: MTU=%d, peer_mtu=%d", __func__,
-            a2dp_lhdcV1_encoder_cb.TxAaMtuSize, peer_mtu);
-  LOG_DEBUG(
-            "%s: sample_rate: %d channel_mode: %d "
-            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
-            __func__, p_encoder_params->sample_rate,
-            p_encoder_params->channel_mode,
-            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
-            p_encoder_params->pcm_fmt);
-/*
-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
-#else
-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
-#endif
-*/
-  // Initialize the encoder.
-  // NOTE: MTU in the initialization must include the AVDT media header size.
-  int result = lhdcV1_init_handle_encode_func(
-      a2dp_lhdcV1_encoder_cb.lhdcV1_handle,
-      p_encoder_params->sample_rate,
-      p_encoder_params->pcm_fmt,
-      p_encoder_params->quality_mode_index,
-      p_encoder_params->isChannelSeparation == true ? 1 : 0,
-      0 /* This parameter alaways is 0 in A2DP */,
-      0,
-      a2dp_vendor_lhdcV1_get_encoder_interval_ms()
-  );
-  lhdcV1_set_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, p_encoder_params->quality_mode_index);
-
-#if defined(RecFile)
-  if (RecFile == NULL) {
-      /* code */
-      RecFile = fopen("/sdcard/Download/lhdc.raw","wb");
-  }
-#endif
-  if (result != 0) {
-    LOG_ERROR( "%s: error initializing the LHDC encoder: %d", __func__,
-              result);
-  }
-}
-
-void a2dp_vendor_lhdcV1_encoder_cleanup(void) {
-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle)
-    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
-#if defined(RecFile)
-  if (RecFile != NULL) {
-      fclose(RecFile);
-      RecFile = NULL;
-  }
-#endif
-}
-
-void a2dp_vendor_lhdcV1_feeding_reset(void) {
-  /* By default, just clear the entire state */
-  memset(&a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state, 0,
-         sizeof(a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state));
-
-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick =
-      (a2dp_lhdcV1_encoder_cb.feeding_params.sample_rate *
-       a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8 *
-       a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
-       A2DP_LHDCV1_ENCODER_INTERVAL_MS) /
-      1000;
-  a2dp_lhdcV1_encoder_cb.buf_seq = 0;
-  LOG_DEBUG( "%s: PCM bytes per tick %u", __func__,
-            a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick);
-}
-
-void a2dp_vendor_lhdcV1_feeding_flush(void) {
-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter = 0;
-  LOG_DEBUG( "%s", __func__);
-}
-
-uint64_t a2dp_vendor_lhdcV1_get_encoder_interval_ms(void) {
-  LOG_DEBUG( "%s: A2DP_LHDCV1_ENCODER_INTERVAL_MS %u",
-              __func__, A2DP_LHDCV1_ENCODER_INTERVAL_MS);
-  return A2DP_LHDCV1_ENCODER_INTERVAL_MS;
-}
-
-void a2dp_vendor_lhdcV1_send_frames(uint64_t timestamp_us) {
-  uint8_t nb_frame = 0;
-  uint8_t nb_iterations = 0;
-
-  a2dp_lhdcV1_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
-  LOG_DEBUG( "%s: Sending %d frames per iteration, %d iterations",
-              __func__, nb_frame, nb_iterations);
-  if (nb_frame == 0) return;
-
-  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
-    // Transcode frame and enqueue
-    a2dp_lhdcV1_encode_frames(nb_frame);
-  }
-}
-
-// Obtains the number of frames to send and number of iterations
-// to be used. |num_of_iterations| and |num_of_frames| parameters
-// are used as output param for returning the respective values.
-static void a2dp_lhdcV1_get_num_frame_iteration(uint8_t* num_of_iterations,
-                                              uint8_t* num_of_frames,
-                                              uint64_t timestamp_us) {
-  uint32_t result = 0;
-  uint8_t nof = 0;
-  uint8_t noi = 1;
-
-  uint32_t pcm_bytes_per_frame =
-      A2DP_LHDCV1_SAMPLES_PER_FRAME *
-      a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
-      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
-  LOG_DEBUG( "%s: pcm_bytes_per_frame %u", __func__,
-              pcm_bytes_per_frame);
-
-  uint32_t us_this_tick = A2DP_LHDCV1_ENCODER_INTERVAL_MS * 1000;
-  uint64_t now_us = timestamp_us;
-  if (a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us != 0)
-    us_this_tick =
-        (now_us - a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us);
-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us = now_us;
-
-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter +=
-      a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick * us_this_tick /
-      (A2DP_LHDCV1_ENCODER_INTERVAL_MS * 1000);
-
-  result =
-      a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter / pcm_bytes_per_frame;
-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter -=
-      result * pcm_bytes_per_frame;
-  nof = result;
-
-  LOG_DEBUG( "%s: effective num of frames %u, iterations %u",
-              __func__, nof, noi);
-
-  *num_of_frames = nof;
-  *num_of_iterations = noi;
-}
-
-static BT_HDR *bt_buf_new( void) {
-    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
-    if ( p_buf == NULL) {
-        // LeoKu(C): should not happen
-        LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
-        return  NULL;
-    }
-
-    p_buf->offset = A2DP_LHDCV1_OFFSET;
-    p_buf->len = 0;
-    p_buf->layer_specific = 0;
-    return  p_buf;
-}
-
-#include <vector>
-using namespace std;
-static void a2dp_lhdcV1_encode_frames(uint8_t nb_frame) {
-    BT_HDR * p_buf = NULL;
-    //BT_HDR * p_btBufs[128];
-    vector<BT_HDR * > btBufs;
-    uint8_t nb_frame_org = nb_frame;
-    tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
-        &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
-    uint32_t pcm_bytes_per_frame = LHDCV1_BT_ENC_BLOCK_SIZE *
-                                 a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
-                                 a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
-
-
-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
-#else
-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
-#endif
-    uint8_t * read_buffer = (uint8_t*)malloc(pcm_bytes_per_frame * 2);
-    uint8_t * write_buffer = (uint8_t*)&(read_buffer[pcm_bytes_per_frame]);
-    uint8_t latency = p_encoder_params->latency_mode_index;
-    int out_offset = 0;
-    int out_len = 0;
-    static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
-    static uint32_t allSendbytes = 0;
-
-    //if (!p_encoder_params->isChannelSeparation) {
-        while( nb_frame) {
-            if ( !a2dp_lhdcV1_read_feeding(read_buffer)) {
-            LOG_WARN( "%s: underflow %d", __func__, nb_frame);
-            a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter +=
-                      nb_frame * LHDCV1_BT_ENC_BLOCK_SIZE *
-                      a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
-                      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
-                break;
-            }
-
-            out_offset = 0;
-            out_len = lhdcV1_encode_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, read_buffer, write_buffer);
-    #if defined(RecFile)
-            if (RecFile != NULL && out_len > 0) {
-                fwrite(write_buffer, sizeof(uint8_t), out_len, RecFile);
-            }
-    #endif
-
-            nb_frame--;
-
-            while (out_len > 0) {
-                if (p_buf == NULL) {
-                    if (NULL == (p_buf = bt_buf_new())) {
-                        LOG_ERROR ( "%s: ERROR", __func__);
-                        if (read_buffer) {
-                            free(read_buffer);
-                            read_buffer = NULL;
-                        }
-                        for(BT_HDR*  p : btBufs) {
-                            free(p);
-                        }
-                        btBufs.clear();
-                        return;
-                    }
-                }
-
-                uint8_t *p = ( uint8_t *)( p_buf + 1) + p_buf->offset + p_buf->len;
-                int space = max_mtu_len - p_buf->len;
-                int bytes = ( out_len < space)? out_len : space;
-                memcpy( p, &write_buffer[out_offset], bytes);
-                out_offset += bytes;
-                out_len -= bytes;
-                p_buf->len += bytes;
-                allSendbytes += bytes;
-
-                if ( p_buf->len >= max_mtu_len ) {
-                    btBufs.push_back(p_buf);
-                    // allocate new one
-                    p_buf = NULL;
-                    if (btBufs.size() >= 64) {
-                        LOG_ERROR( "%s: Packet buffer usage to big!(%u)", __func__, (uint32_t)btBufs.size());
-                        break;
-                    }
-                }
-            }
-        }
-        uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
-        if (now_ms - time_prev >= 1000 ) {
-            /* code */
-            LOG_WARN( "%s: Current data rate about %d kbps", __func__, (allSendbytes * 8) / 1000);
-            allSendbytes = 0;
-            time_prev = now_ms;
-        }
-
-        if ( p_buf) {
-            btBufs.push_back(p_buf);
-        }
-
-        LOG_DEBUG( "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
-        if ( btBufs.size() == 1) {
-            p_buf = btBufs[0];
-
-            p_buf->layer_specific = a2dp_lhdcV1_encoder_cb.buf_seq++;
-            p_buf->layer_specific <<= 8;
-            p_buf->layer_specific |= ( latency | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
-
-            *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdcV1_encoder_cb.timestamp;
-
-            a2dp_lhdcV1_encoder_cb.enqueue_callback( p_buf, 1, p_buf->len);
-
-        } else {
-
-            uint8_t i;
-
-            if (btBufs.size() > 16) {
-                LOG_DEBUG( "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
-            }
-
-            for( i = 0; i < btBufs.size(); i++) {
-                p_buf = btBufs[i];
-
-                p_buf->layer_specific = a2dp_lhdcV1_encoder_cb.buf_seq++;
-                p_buf->layer_specific <<= 8;
-                p_buf->layer_specific |= ( A2DP_LHDC_HDR_F_MSK | latency);
-
-                if ( i == 0) {
-                    p_buf->layer_specific |= ( A2DP_LHDC_HDR_S_MSK | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
-                } else if ( i == ( btBufs.size() - 1)) {
-                    p_buf->layer_specific |= A2DP_LHDC_HDR_L_MSK;
-                }
-
-                *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdcV1_encoder_cb.timestamp;
-
-                a2dp_lhdcV1_encoder_cb.enqueue_callback( p_buf, 1, p_buf->len);
-            }
-        }
-
-        a2dp_lhdcV1_encoder_cb.timestamp += ( nb_frame_org * LHDCV1_BT_ENC_BLOCK_SIZE);
-        if (read_buffer) {
-            free(read_buffer);
-            read_buffer = NULL;
-        }
-        btBufs.clear();
-}
-
-static bool a2dp_lhdcV1_read_feeding(uint8_t* read_buffer) {
-  uint32_t read_size = LHDCV1_BT_ENC_BLOCK_SIZE *
-                       a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
-                       a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
-
-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_expected_reads_count++;
-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
-
-  /* Read Data from UIPC channel */
-  uint32_t nb_byte_read =
-      a2dp_lhdcV1_encoder_cb.read_callback(read_buffer, read_size);
-  LOG_DEBUG( "%s: want to read size %u, read byte number %u",
-                    __func__, read_size, nb_byte_read);
-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
-
-  if (nb_byte_read < read_size) {
-    if (nb_byte_read == 0) return false;
-
-    /* Fill the unfilled part of the read buffer with silence (0) */
-    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
-    nb_byte_read = read_size;
-  }
-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_actual_reads_count++;
-
-  return true;
-}
-
-static std::string quality_mode_index_to_name(int quality_mode_index) {
-  switch (quality_mode_index) {
-    case LHDCBT_QUALITY_HIGH:
-      return "HIGH";
-    case LHDCBT_QUALITY_MID:
-      return "MID";
-    case LHDCBT_QUALITY_LOW:
-      return "LOW";
-    case LHDCBT_QUALITY_AUTO:
-      return "ABR";
-    default:
-      return "Unknown";
-  }
-}
-
-static std::string latency_mode_index_to_name(int latency_mode_index){
-    switch (latency_mode_index) {
-        case A2DP_LHDC_LATENCY_HIGH:
-            return "Long Latency";
-        case A2DP_LHDC_LATENCY_MID:
-            return "Middle Latency";
-        case A2DP_LHDC_LATENCY_LOW:
-            return "Short Latency";
-        default:
-            return "Unknown";
-    }
-}
-
-void a2dp_vendor_lhdcV1_set_transmit_queue_length(size_t transmit_queue_length) {
-  a2dp_lhdcV1_encoder_cb.TxQueueLength = transmit_queue_length;
-  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
-  LOG_DEBUG( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
-  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
-      LOG_DEBUG( "%s: Auto Bitrate Enabled!", __func__);
-      if (lhdcV1_auto_adjust_bitrate_func != NULL) {
-          lhdcV1_auto_adjust_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, transmit_queue_length);
-      }
-  }
-}
-
-uint64_t A2dpCodecConfigLhdcV1::encoderIntervalMs() const {
-  return a2dp_vendor_lhdcV1_get_encoder_interval_ms();
-}
-
-int A2dpCodecConfigLhdcV1::getEffectiveMtu() const {
-  return a2dp_lhdcV1_encoder_cb.TxAaMtuSize;
-}
-
-void A2dpCodecConfigLhdcV1::debug_codec_dump(int fd) {
-  a2dp_lhdcV1_encoder_stats_t* stats = &a2dp_lhdcV1_encoder_cb.stats;
-  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
-      &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
-
-  A2dpCodecConfig::debug_codec_dump(fd);
-
-  dprintf(fd,
-          "  Packet counts (expected/dropped)                        : %zu / "
-          "%zu\n",
-          stats->media_read_total_expected_packets,
-          stats->media_read_total_dropped_packets);
-
-  dprintf(fd,
-          "  PCM read counts (expected/actual)                       : %zu / "
-          "%zu\n",
-          stats->media_read_total_expected_reads_count,
-          stats->media_read_total_actual_reads_count);
-
-  dprintf(fd,
-          "  PCM read bytes (expected/actual)                        : %zu / "
-          "%zu\n",
-          stats->media_read_total_expected_read_bytes,
-          stats->media_read_total_actual_read_bytes);
-
-  dprintf(
-      fd, "  LHDC quality mode                                       : %s\n",
-      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
-
-  dprintf(fd,
-          "  LHDC transmission bitrate (Kbps)                        : %d\n",
-          lhdcV1_get_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle));
-
-  dprintf(fd,
-          "  LHDC saved transmit queue length                        : %zu\n",
-          a2dp_lhdcV1_encoder_cb.TxQueueLength);
-/*
-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_abr_handle) {
-    dprintf(fd,
-            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
-            a2dp_lhdcV1_encoder_cb.last_lhdcV1_abr_eqmid);
-    dprintf(fd,
-            "  LHDC adaptive bit rate adjustments                      : %zu\n",
-            a2dp_lhdcV1_encoder_cb.lhdcV1_abr_adjustments);
-  }
-  */
-}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
index 36d9ee39a..6b0cc11b3 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
@@ -33,6 +33,7 @@
 #include "a2dp_vendor.h"
 #include "a2dp_vendor_lhdcv2_encoder.h"
 #include "bt_utils.h"
+#include "btif_av_co.h"
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
 
@@ -55,14 +56,14 @@ static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
     A2DP_LHDCV2_CODEC_ID,   // codecId
     // sampleRate
     //(A2DP_LHDC_SAMPLING_FREQ_48000),
-    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
     // bits_per_sample
     (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
     //Channel Separation
     A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
     //Version number
     A2DP_LHDC_VER2,
-    //Target bit Rate
+    //Max target bit Rate
     A2DP_LHDC_MAX_BIT_RATE_900K,
     //LL supported ?
     false,
@@ -260,6 +261,54 @@ static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
 }
 */
 
+static bool A2DP_MaxBitRatetoQualityLevelLhdcV2(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+  case A2DP_LHDC_MAX_BIT_RATE_900K:
+    *mode = A2DP_LHDC_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDC_MAX_BIT_RATE_500K:
+    *mode = A2DP_LHDC_QUALITY_MID;
+    return true;
+  case A2DP_LHDC_MAX_BIT_RATE_400K:
+    *mode = A2DP_LHDC_QUALITY_LOW;
+    return true;
+  }
+  return false;
+}
+
+static std::string lhdcV2_QualityModeBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
 bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info) {
   tA2DP_LHDC_CIE cfg_cie;
 
@@ -372,6 +421,42 @@ bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
          (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample);
 }
 
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 600000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        [[fallthrough]];
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
 
 int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info) {
   tA2DP_LHDC_CIE lhdc_cie;
@@ -409,11 +494,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
     return -1;
   }
 
-#if 0
-  return 32;
-#else
-  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
-
   switch (lhdc_cie.bits_per_sample) {
     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
       return 16;
@@ -424,7 +504,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
       return -1;
   }
-#endif
 }
 
 int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info) {
@@ -901,6 +980,8 @@ bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
   tA2DP_LHDC_CIE sink_info_cie;
   tA2DP_LHDC_CIE result_config_cie;
   uint8_t sampleRate;
+  uint8_t qualityMode = 0;
+  uint8_t bitRateQmode = 0;
   bool isLLEnabled;
   btav_a2dp_codec_bits_per_sample_t bits_per_sample;
 
@@ -1177,12 +1258,48 @@ bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
 
   result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
 
-  LOG_DEBUG( "%s: Config bitrate result(0x%02x), prev(0x%02x)", __func__, result_config_cie.maxTargetBitrate, sink_info_cie.maxTargetBitrate);
+  LOG_DEBUG( "%s: max target bitrate: 0x%02x", __func__,
+      result_config_cie.maxTargetBitrate);
 
 
   result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
   LOG_ERROR("%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
 
+  // quality mode (BitRate) adjust
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
+    LOG_DEBUG( "%s: tag not match, use default Mode: ABR", __func__);
+  }
+  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+
+  //
+  // quality mode adjust when non-ABR
+  //
+  if (qualityMode != A2DP_LHDC_QUALITY_ABR) {
+    // get corresponding quality mode of the max target bit rate
+    if (!A2DP_MaxBitRatetoQualityLevelLhdcV2(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+      LOG_ERROR( "%s: get quality mode from maxTargetBitrate error", __func__);
+      goto fail;
+    }
+    // downgrade audio quality according to the max target bit rate
+    if (qualityMode > bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LOG_DEBUG( "%s: downgrade quality mode to 0x%02X by max target bitrate", __func__, qualityMode);
+    }
+
+    // High1(1000K) does not supported in V2, downgrade to High(900K)
+    if (qualityMode == A2DP_LHDC_QUALITY_HIGH1) {
+      LOG_DEBUG( "%s: reset non-supported quality mode %s to HIGH (900 Kbps)", __func__,
+          lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+      qualityMode = A2DP_LHDC_QUALITY_HIGH;
+    }
+  }
+
+  LOG_DEBUG( "%s: => final quality mode(0x%02X) = %s", __func__,
+      qualityMode,
+      lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
 
   if (int ret = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
                          p_result_codec_config) != A2DP_SUCCESS) {
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
index 96a10930d..675125a3d 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
@@ -363,8 +363,6 @@ static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
   }
   const uint8_t* p_codec_info = codec_info;
   btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
-  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
-
 
   if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
       a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle_func(A2DP_VendorGetVersionLhdcV2(p_codec_info) <= A2DP_LHDC_VER2 ? 1 : -1);
@@ -411,11 +409,6 @@ static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
       // adjust non-supported quality modes and wrap to internal library used index
       if (newValue == A2DP_LHDC_QUALITY_ABR) {
         newValue = LHDCBT_QUALITY_AUTO; //9->8
-      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
-        // High1(1000K) does not supported, downgrade to High(900K)
-        newValue = LHDCBT_QUALITY_HIGH; //8->7
-        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
-        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
       }
 
       if (newValue != p_encoder_params->quality_mode_index) {
@@ -425,9 +418,8 @@ static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
             .c_str(), p_encoder_params->quality_mode_index);
       }
   }else {
-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
-      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
-      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
   }
 
   //To correcting data to middle.
@@ -537,6 +529,13 @@ void a2dp_vendor_lhdcv2_feeding_reset(void) {
       1000;
   a2dp_lhdc_encoder_cb.buf_seq = 0;
   a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG("%s: has_lhdc_handle %d (%d)", __func__,
+      a2dp_lhdc_encoder_cb.has_lhdc_handle,p_encoder_params->quality_mode_index);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate_func != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle)
+      lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+  }
   LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
             a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
 }
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
index 17c1be04f..2269aad67 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
@@ -33,6 +33,7 @@
 #include "a2dp_vendor.h"
 #include "a2dp_vendor_lhdcv3_encoder.h"
 #include "bt_utils.h"
+#include "btif_av_co.h"
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
 
@@ -134,7 +135,7 @@ static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
     A2DP_LHDCV3_CODEC_ID,   // codecId
     // sampleRate
     //(A2DP_LHDC_SAMPLING_FREQ_48000),
-    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
 	(A2DP_LHDC_SAMPLING_FREQ_48000),
     // bits_per_sample
     (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
@@ -638,6 +639,42 @@ bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
          (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
 }
 
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 600000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        [[fallthrough]];
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
 
 int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info) {
   tA2DP_LHDC_CIE lhdc_cie;
@@ -675,11 +712,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
     return -1;
   }
 
-#if 0
-  return 32;
-#else
-  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
-
   switch (lhdc_cie.bits_per_sample) {
     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
       return 16;
@@ -690,7 +722,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
       return -1;
   }
-#endif
 }
 
 int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info) {
@@ -2370,12 +2401,13 @@ bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
 
   } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
     //LHDC V4 only
+    LOG_DEBUG("%s: [LHDCV4 only]", __func__);
 	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
 		if (result_config_cie.hasFeatureMinBitrate) {
 			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
 				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
 				quality_mode = A2DP_LHDC_QUALITY_LOW;
-				LOG_DEBUG("%s: [LHDC only]: reset Qmode (0x%x)", __func__, quality_mode);
+				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x)", __func__, quality_mode);
 			}
 		}
 	} else {
@@ -2383,13 +2415,14 @@ bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
 			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
 				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
 				quality_mode = A2DP_LHDC_QUALITY_LOW4;
-				LOG_DEBUG("%s: [LHDC only]: reset Qmode (0x%x), ", __func__, quality_mode);
+				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x), ", __func__, quality_mode);
 			}
 		}
 	}
 
   } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
     //LLAC only
+    LOG_DEBUG("%s: [LLAC only]", __func__);
     if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
       result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
       codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
@@ -2414,6 +2447,7 @@ bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
 
   } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
     //LHDC V3 only
+    LOG_DEBUG("%s: [LHDCV3 only]", __func__);
 	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
 		if (result_config_cie.hasFeatureMinBitrate) {
 			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
index 2dcead914..894cabd0a 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
@@ -508,8 +508,6 @@ int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info) {
   return -1;
 }
 
-uint32_t A2DP_VendorGetBitRateLhdcV3Sink(const uint8_t* p_codec_info) { return 400; /*a2dp_sbc_get_bitrate();*/ }
-
 int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info) {
   tA2DP_LHDCV3_SINK_CIE lhdc_cie;
 
@@ -661,7 +659,7 @@ btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(
 const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void) { return "LHDC V3 SINK"; }
 
 bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg) {
-  LOG_DEBUG("[WL50] %s: enter", __func__);
+  LOG_DEBUG("%s: enter", __func__);
   if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_caps,
                         p_cfg->codec_info) != A2DP_SUCCESS) {
     return false;
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
index 03e8fa8c6..4124345eb 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
@@ -20,7 +20,6 @@
 
 #include <dlfcn.h>
 #include <inttypes.h>
-#include <pthread.h>
 #include <stdio.h>
 #include <string.h>
 
@@ -547,5 +546,5 @@ void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info) {
     return;
   }
 
-  LOG_ERROR("JIMM %s: enter", __func__);
+  LOG_ERROR("%s", __func__);
 }
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
index 69cb36200..47877a676 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
@@ -488,7 +488,6 @@ static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
   }
   const uint8_t* p_codec_info = codec_info;
   btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
-  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
 
   uint32_t verCode = A2DP_VendorGetVersionLhdcV3(p_codec_info);  //LHDC V3 should 1!
 
@@ -504,12 +503,6 @@ static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
       // adjust non-supported quality modes and wrap to internal library used index
       if (newValue == A2DP_LHDC_QUALITY_ABR) {
         newValue = LHDCBT_QUALITY_AUTO; //9->8
-      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
-        // should not be here normally (re-adjusted in vendor_lhdcv3.cc), but just make a safe.
-        // High1(1000K) does not supported here, reset to High(900K)
-        newValue = LHDCBT_QUALITY_HIGH; //8->7
-        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
-        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
       }
 
       if (newValue != p_encoder_params->quality_mode_index) {
@@ -519,9 +512,8 @@ static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
                       .c_str(), p_encoder_params->quality_mode_index);
       }
   }else {
-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
-      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
-      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
   }
 
   if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
@@ -681,6 +673,13 @@ void a2dp_vendor_lhdcv3_feeding_reset(void) {
   a2dp_lhdc_encoder_cb.buf_seq = 0;
   a2dp_lhdc_encoder_cb.bytes_read = 0;
   a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      LOG_DEBUG("%s: reset ABR!", __func__);
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+    }
+  }
   LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
             a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
 }
@@ -885,7 +884,7 @@ static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame){
         return;
     } else {
       // NOTE: Unlike the execution path for other codecs, it is normal for
-      // LDAC to NOT write encoded data to the last buffer if there wasn't
+      // LHDC to NOT write encoded data to the last buffer if there wasn't
       // enough data to write to. That data is accumulated internally by
       // the codec and included in the next iteration. Therefore, here we
       // don't increment the "media_read_total_dropped_packets" counter.
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
index 25ad19f35..8b4c1f384 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
@@ -65,7 +65,7 @@ static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_caps = {
     // Sampling Frequency
     (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
     // Bits Per Sample
-    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24 | A2DP_LHDCV5_BIT_FMT_32),
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24),
     // Channel Mode
     A2DP_LHDCV5_CHANNEL_MODE_STEREO,
     // Codec SubVersion Number
@@ -869,14 +869,15 @@ int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info) {
         return 500000;
       case A2DP_LHDCV5_QUALITY_HIGH:
         return 900000;
-      case A2DP_LHDCV5_QUALITY_ABR:
-        return 1000000;
       case A2DP_LHDCV5_QUALITY_HIGH1:
+        return 1000000;
+      case A2DP_LHDCV5_QUALITY_ABR:
+        return 9999999;
       default:
-        return 0;
+        return -1;
     }
   }
-  return 0;
+  return 400000;
 }
 
 int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info) {
@@ -1060,6 +1061,53 @@ bool A2DP_VendorBuildCodecHeaderLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
   return true;
 }
 
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV5 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG( "\tsamp_freq: 0x%02X ", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    LOG_DEBUG( "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    LOG_DEBUG( "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    LOG_DEBUG( "\tsamp_freq: (96000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    LOG_DEBUG( "\tsamp_freq: (19200)");
+  }
+
+  LOG_DEBUG( "\tbitsPerSample: 0x%02X ", lhdc_cie.bitsPerSample);
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    LOG_DEBUG( "\tbit_depth: (16)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    LOG_DEBUG( "\tbit_depth: (24)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    LOG_DEBUG( "\tbit_depth: (32)");
+  }
+
+  LOG_DEBUG( "\tchannelMode: 0x%02X ", lhdc_cie.channelMode);
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    LOG_DEBUG( "\tchannle_mode: (mono)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    LOG_DEBUG( "\tchannle_mode: (dual)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    LOG_DEBUG( "\tchannle_mode: (stereo)");
+  }
+}
+
 std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info) {
   std::stringstream res;
   std::string field;
@@ -2147,7 +2195,8 @@ bool A2dpCodecConfigLhdcV5Base::setCodecConfig(const uint8_t* p_peer_codec_info,
         (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
         false);
     // update
-    hasUserSet = true;  //caps-control enabling, always true
+    //hasUserSet = true;  //caps-control enabling, always true
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS);  //UI-control
     if (hasFeature && hasUserSet) {
       result_config_cie.hasFeatureLLESS = true;
       A2DP_UpdateFeatureToA2dpConfigLhdcV5(
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
index ce44032e9..0202c7773 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2022 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,6 +20,7 @@
 
 #include <dlfcn.h>
 #include <inttypes.h>
+#include <pthread.h>
 #include <stdio.h>
 #include <string.h>
 
@@ -39,14 +40,19 @@
 #define LHDCV5_DEC_MAX_CHANNELS           2
 #define LHDCV5_DEC_MAX_BIT_DEPTH          32
 #define LHDCV5_DEC_FRAME_NUM              16
-#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * LHDCV5_DEC_MAX_CHANNELS * (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * \
+                                           LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * \
+                                           LHDCV5_DEC_MAX_CHANNELS * \
+                                           (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
 #define LHDCV5_DEC_PACKET_NUM             8
-
 #define LHDCV5_DEC_INPUT_BUF_BYTES        1024
-
 #define LHDCV5_DEC_PKT_HDR_BYTES          2
 
 typedef struct {
+  pthread_mutex_t mutex;
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
   uint32_t    sample_rate;
   uint8_t     bits_per_sample;
   lhdc_ver_t  version;
@@ -80,24 +86,28 @@ static FILE *pcmFile = NULL;
 static const char* LHDC_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
 static void* lhdc_decoder_lib_handle = NULL;
 
-static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcBT_dec_init_decoder";
-typedef int (*tLHDCDEC_INIT_DECODER)(tLHDCV5_DEC_CONFIG *config);
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcv5BT_dec_init_decoder";
+typedef int32_t (*tLHDCDEC_INIT_DECODER)(HANDLE_LHDCV5_BT *handle,
+    tLHDCV5_DEC_CONFIG *config);
 
-static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME = "lhdcBT_dec_check_frame_data_enough";
-typedef int (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME =
+    "lhdcv5BT_dec_check_frame_data_enough";
+typedef int32_t (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData,
+    uint32_t frameBytes, uint32_t *packetBytes);
 
-static const char* LHDCDEC_DECODE_NAME = "lhdcBT_dec_decode";
-typedef int (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+static const char* LHDCDEC_DECODE_NAME = "lhdcv5BT_dec_decode";
+typedef int32_t (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
 
-static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcBT_dec_deinit_decoder";
-typedef int (*tLHDCDEC_DEINIT_DECODER)(void);
-
-static tLHDCDEC_INIT_DECODER lhdcdec_init_decoder;
-static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcdec_check_frame_data_enough;
-static tLHDCDEC_DECODE lhdcdec_decode;
-static tLHDCDEC_DEINIT_DECODER lhdcdec_deinit_decoder;
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcv5BT_dec_deinit_decoder";
+typedef int32_t (*tLHDCDEC_DEINIT_DECODER)(HANDLE_LHDCV5_BT handle);
 
+static tLHDCDEC_INIT_DECODER lhdcv5dec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcv5dec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcv5dec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcv5dec_deinit_decoder;
 
+// LHDC V5 Codec Info:
 //  ----------------------------------------------------------------
 //  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
 //  losc | mediaType | codecType | vendorId | codecId | SampRate |
@@ -221,6 +231,11 @@ bool A2DP_VendorLoadDecoderLhdcV5(void) {
     return true;  // Already loaded
   }
 
+  // Initialize the control block
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  pthread_mutex_init(&(a2dp_lhdcv5_decoder_cb.mutex), NULL);
+
   // Open the encoder library
   lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
   if (lhdc_decoder_lib_handle == NULL) {
@@ -229,17 +244,19 @@ bool A2DP_VendorLoadDecoderLhdcV5(void) {
   }
 
   // Load all functions
-  lhdcdec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
-  if (lhdcdec_init_decoder == NULL) return false;
+  lhdcv5dec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcv5dec_init_decoder == NULL) return false;
 
-  lhdcdec_check_frame_data_enough = (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
-  if (lhdcdec_check_frame_data_enough == NULL) return false;
+  lhdcv5dec_check_frame_data_enough =
+      (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcv5dec_check_frame_data_enough == NULL) return false;
 
-  lhdcdec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
-  if (lhdcdec_decode == NULL) return false;
+  lhdcv5dec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcv5dec_decode == NULL) return false;
 
-  lhdcdec_deinit_decoder = (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
-  if (lhdcdec_deinit_decoder == NULL) return false;
+  lhdcv5dec_deinit_decoder =
+      (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcv5dec_deinit_decoder == NULL) return false;
 
   LOG_DEBUG( "%s: LHDCV5 decoder library loaded", __func__);
   return true;
@@ -247,32 +264,82 @@ bool A2DP_VendorLoadDecoderLhdcV5(void) {
 
 
 void A2DP_VendorUnloadDecoderLhdcV5(void) {
+
   a2dp_vendor_lhdcv5_decoder_cleanup();
-  LOG_DEBUG( "%s: LHDCV5 decoder library unloaded", __func__);
+
+  pthread_mutex_destroy(&(a2dp_lhdcv5_decoder_cb.mutex));
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  lhdcv5dec_init_decoder = NULL;
+  lhdcv5dec_check_frame_data_enough = NULL;
+  lhdcv5dec_decode = NULL;
+  lhdcv5dec_deinit_decoder = NULL;
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    dlclose(lhdc_decoder_lib_handle);
+    lhdc_decoder_lib_handle = NULL;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(V5RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5PCM_FILE_NAME);
+  }
+#endif
+  LOG_DEBUG( "%s: unload LHDC V5 decoder", __func__);
 }
 
 
 bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
-  int  fn_ret;
+  int32_t api_ret;
   tLHDCV5_DEC_CONFIG lhdcdec_config;
 
   if ((lhdc_decoder_lib_handle == NULL) ||
-      (lhdcdec_init_decoder == NULL) ||
-      (lhdcdec_deinit_decoder == NULL)) {
+      (lhdcv5dec_init_decoder == NULL) ||
+      (lhdcv5dec_deinit_decoder == NULL)) {
     return false;
   }
 
-  lhdcdec_deinit_decoder();
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  LOG_DEBUG( "%s: has_lhdc_handle(%d) handle_base (%p) handle(%p)", __func__,
+      a2dp_lhdcv5_decoder_cb.has_lhdc_handle,
+      &(a2dp_lhdcv5_decoder_cb.lhdc_handle),
+      a2dp_lhdcv5_decoder_cb.lhdc_handle);
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR( "%s: fail to deinit decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+    a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+    LOG_DEBUG( "%s: handle cleaned", __func__);
+  }
 
   lhdcdec_config.version = a2dp_lhdcv5_decoder_cb.version;
   lhdcdec_config.sample_rate = a2dp_lhdcv5_decoder_cb.sample_rate;
   lhdcdec_config.bits_depth = a2dp_lhdcv5_decoder_cb.bits_per_sample;
-
-  fn_ret = lhdcdec_init_decoder(&lhdcdec_config);
-
-  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
-    LOG_ERROR( "%s: LHDCV5 decoder init fail %d", __func__, fn_ret);
-    return false;
+  lhdcdec_config.bit_rate = 400000;  //TODO
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle == false &&
+      a2dp_lhdcv5_decoder_cb.lhdc_handle == NULL) {
+    LOG_DEBUG( "%s: to init decoder...", __func__);
+    api_ret = lhdcv5dec_init_decoder(&(a2dp_lhdcv5_decoder_cb.lhdc_handle), &lhdcdec_config);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR( "%s: falied to init decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = true;
   }
 
   a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
@@ -282,56 +349,45 @@ bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
 #if defined(_V5DEC_REC_FILE_)
   if (rawFile == NULL) {
     rawFile = fopen(V5RAW_FILE_NAME,"wb");
-    LOG_DEBUG( "%s: Create recode file = %p", __func__, rawFile);
+    LOG_DEBUG( "%s: create recode file = %p", __func__, rawFile);
   }
   if (pcmFile == NULL) {
     pcmFile = fopen(V5PCM_FILE_NAME,"wb");
-    LOG_DEBUG( "%s: Create recode file = %p", __func__, pcmFile);
+    LOG_DEBUG( "%s: create recode file = %p", __func__, pcmFile);
   }
 #endif
+
+  LOG_DEBUG( "%s: init LHDCV5 decoder success", __func__);
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
   return true;
 }
 
 
 void a2dp_vendor_lhdcv5_decoder_cleanup(void) {
-  int  fn_ret;
+  int32_t api_ret;
 
-  if (lhdc_decoder_lib_handle == NULL) {
-    return;
-  }
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
 
-  if (lhdcdec_deinit_decoder != NULL) {
-    fn_ret = lhdcdec_deinit_decoder();
-    if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
-      LOG_ERROR( "%s: LHDCV5 decoder deinit fail %d", __func__, fn_ret);
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR( "%s: fail to deinit LHDCV5 decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
       return;
     }
-  } else {
-    LOG_ERROR( "%s: Cannot deinit LHDCV5 decoder", __func__);
-    return;
   }
 
-  dlclose(lhdc_decoder_lib_handle);
-  lhdc_decoder_lib_handle = NULL;
+  a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+  a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
 
-#if defined(_V5DEC_REC_FILE_)
-  if (rawFile != NULL) {
-    fclose(rawFile);
-    rawFile = NULL;
-    remove(V5RAW_FILE_NAME);
-  }
-  if (pcmFile != NULL) {
-    fclose(pcmFile);
-    pcmFile = NULL;
-    remove(V5PCM_FILE_NAME);
-  }
-#endif
-  LOG_DEBUG( "%s:  LHDCV5 decoder deinited", __func__);
+  LOG_DEBUG( "%s: deinit LHDCV5 decoder success", __func__);
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
 }
 
 
 bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
-  int fn_ret;
+  int32_t api_ret;
   uint8_t *data;
   size_t data_size;
   uint32_t out_used = 0;
@@ -341,27 +397,40 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
   uint32_t packet_bytes;
   uint32_t i;
 
+  LOG_DEBUG( "%s: enter", __func__);
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_decode == NULL)) {
+    LOG_ERROR( "%s: lib not loaded!", __func__);
+    return false;
+  }
+
+  // check handle
+  if (!a2dp_lhdcv5_decoder_cb.has_lhdc_handle || !a2dp_lhdcv5_decoder_cb.lhdc_handle) {
+    LOG_ERROR( "%s: handle not existed!", __func__);
+    return false;
+  }
+
   if (p_buf == NULL) {
     return false;
   }
 
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
   data = p_buf->data + p_buf->offset;
   data_size = p_buf->len;
 
-  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
-  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
-    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
-  }
-
   if (data_size == 0) {
     LOG_ERROR( "%s: Empty packet", __func__);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
     return false;
   }
 
-  if ((lhdc_decoder_lib_handle == NULL) ||
-      (lhdcdec_decode == NULL)) {
-    LOG_ERROR( "%s: Invalid handle!", __func__);
-    return false;
+
+  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
+    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
   }
 
 #if defined(_V5DEC_REC_FILE_)
@@ -371,8 +440,7 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
   }
 #endif
 
-  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES)
-  {
+  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES) {
     // the data queued is useless
     // discard them
     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
@@ -381,26 +449,24 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
     {
       // input data is too big (more than buffer size)!!
       // just ingore it, and do nothing
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
       return true;
     }
   }
 
   memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
-      data,
-      data_size);
+      data, data_size);
   a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
 
   packet_bytes = 0;
-  fn_ret = lhdcdec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+  api_ret = lhdcv5dec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
       a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
       &packet_bytes);
-
-  if (fn_ret == LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH) {
-    return true;
-  } else if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
-    LOG_ERROR( "%s: fail to check frame data!", __func__);
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    LOG_ERROR( "%s: fail to check frame data! %d", __func__, api_ret);
     // clear the data in the input buffer
     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
     return false;
   }
 
@@ -413,15 +479,16 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
         __func__, packet_bytes, a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes);
 
     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
-    memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+    memcpy(&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
         data,
         data_size);
     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
     return true;
   }
 
   out_used = sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]);
-  fn_ret = lhdcdec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+  api_ret = lhdcv5dec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
       a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
       a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
       &out_used,
@@ -431,8 +498,9 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
   // clear the data in the input buffer
   a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
 
-  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
-    LOG_ERROR( "%s: fail to decode lhdc stream!", __func__);
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    LOG_ERROR( "%s: fail to decode lhdc stream! %d", __func__, api_ret);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
     return false;
   }
 
@@ -460,37 +528,41 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
   }
 
 #if defined(_V5DEC_REC_FILE_)
-  if (pcmFile != NULL && out_used > 0 && out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
+  if (pcmFile != NULL && out_used > 0 &&
+      out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
     int write_bytes;
-    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx], sizeof(uint8_t), out_used, pcmFile);
+    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+        sizeof(uint8_t), out_used, pcmFile);
   }
 #endif
 
   a2dp_lhdcv5_decoder_cb.decode_callback(
       reinterpret_cast<uint8_t*>(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]), out_used);
 
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
   return true;
 }
 
 void a2dp_vendor_lhdcv5_decoder_start(void) {
-  LOG_INFO("%s", __func__);
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG("%s", __func__);
   // do nothing
+
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
 }
 
 void a2dp_vendor_lhdcv5_decoder_suspend(void) {
-  LOG_INFO("%s", __func__);
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG("%s", __func__);
   // do nothing
 }
 
 void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info) {
-  //int32_t sample_rate;
-  //int32_t bits_per_sample;
-  //int32_t channel_mode;
-
   if (p_codec_info == NULL) {
-    LOG_ERROR("%s: p_codec_info is NULL", __func__);
+    LOG_DEBUG("%s: p_codec_info is NULL", __func__);
     return;
   }
-
-  LOG_ERROR("JIMM %s: enter", __func__);
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG("%s", __func__);
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
 }
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
index bcb4d8845..c21a825f6 100755
--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
@@ -848,6 +848,14 @@ void a2dp_vendor_lhdcv5_feeding_reset(void) {
   a2dp_lhdc_encoder_cb.bytes_read = 0;
   a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
 
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      LOG_DEBUG("%s: reset ABR!", __func__);
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_QUALITY_RESET_AUTO);
+    }
+  }
+
   LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
       a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
 }
diff --git a/system_bt/stack/include/a2dp_vendor_lhdc_constants.h b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
index e607b2742..69e3c3bad 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
@@ -239,4 +239,55 @@ typedef enum {
   marco_ret;   \
 })
 
+//
+// Savitech - LHDC aDSP configuration
+//
+// Lhdcv5Version: 1 << (below value-1)
+#define A2DP_OFFLOAD_LHDCV2_VER_1                   0x01
+#define A2DP_OFFLOAD_LHDCV3_V3_ONLY                 0x02
+#define A2DP_OFFLOAD_LHDCV3_V4_ONLY                 0x03
+#define A2DP_OFFLOAD_LHDCV3_LLAC                    0x04
+#define A2DP_OFFLOAD_LHDCV5_VER_1                   0x01
+
+// Lhdcv5QualityIndex
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW0            0x01
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW1            0x02
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW2            0x04
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW3            0x08
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW4            0x10
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW             0x20
+#define A2DP_OFFLOAD_LHDC_QUALITY_MID             0x40
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH            0x80
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH1           0x100
+#define A2DP_OFFLOAD_LHDC_QUALITY_ABR             0x8000
+
+// Lhdcv5FrameDuration
+#define A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US   0x01
+
+// Lhdcv5DataInterval
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS      0x01
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS      0x02
+
+// Lhdcv5Specific
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR     0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS    0x02
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META   0x04
+
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON   0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT  0x80
+
+// Lhdcv5Parameters
+#define A2DP_OFFLOAD_LHDC_CFG_VER                   6
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_L             7
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_H             8
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L          9
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H          10
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L          11
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H          12
+#define A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR              13
+#define A2DP_OFFLOAD_LHDC_CFG_INTERVAL              14
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC1                 15
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC2                 16
+#define A2DP_OFFLOAD_LHDC_CFG_META                  17
+
 #endif  // A2DP_VENDOR_LHDC_CONSTANTS_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv1.h b/system_bt/stack/include/a2dp_vendor_lhdcv1.h
deleted file mode 100755
index 68dc6eb23..000000000
--- a/system_bt/stack/include/a2dp_vendor_lhdcv1.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//
-// A2DP Codec API for LHDC
-//
-
-#ifndef A2DP_VENDOR_LHDCV1_H
-#define A2DP_VENDOR_LHDCV1_H
-
-#include "a2dp_codec_api.h"
-#include "a2dp_vendor_lhdc_constants.h"
-#include "a2dp_vendor_lhdcv1_constants.h"
-#include "avdt_api.h"
-
-class A2dpCodecConfigLhdcV1 : public A2dpCodecConfig {
- public:
-  A2dpCodecConfigLhdcV1(btav_a2dp_codec_priority_t codec_priority);
-  virtual ~A2dpCodecConfigLhdcV1();
-
-  bool init() override;
-  uint64_t encoderIntervalMs() const override;
-  int getEffectiveMtu() const override;
-  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
-                      uint8_t* p_result_codec_config) override;
-  bool setPeerCodecCapabilities(
-      const uint8_t* p_peer_codec_capabilities) override;
-
- private:
-  bool useRtpHeaderMarkerBit() const override;
-  bool updateEncoderUserConfig(
-      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
-      bool* p_restart_input, bool* p_restart_output,
-      bool* p_config_updated) override;
-  void debug_codec_dump(int fd) override;
-};
-
-// Checks whether the codec capabilities contain a valid A2DP LHDC Source
-// codec.
-// NOTE: only codecs that are implemented are considered valid.
-// Returns true if |p_codec_info| contains information about a valid LHDC
-// codec, otherwise false.
-bool A2DP_IsVendorSourceCodecValidLhdcV1(const uint8_t* p_codec_info);
-
-// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
-// codec.
-// NOTE: only codecs that are implemented are considered valid.
-// Returns true if |p_codec_info| contains information about a valid LHDC
-// codec, otherwise false.
-bool A2DP_IsVendorPeerSinkCodecValidLhdcV1(const uint8_t* p_codec_info);
-
-// Checks whether the A2DP data packets should contain RTP header.
-// |content_protection_enabled| is true if Content Protection is
-// enabled. |p_codec_info| contains information about the codec capabilities.
-// Returns true if the A2DP data packets should contain RTP header, otherwise
-// false.
-bool A2DP_VendorUsesRtpHeaderLhdcV1(bool content_protection_enabled,
-                                  const uint8_t* p_codec_info);
-
-// Gets the A2DP LHDC codec name for a given |p_codec_info|.
-const char* A2DP_VendorCodecNameLhdcV1(const uint8_t* p_codec_info);
-
-// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
-// have the same type.
-// Returns true if the two codecs have the same type, otherwise false.
-bool A2DP_VendorCodecTypeEqualsLhdcV1(const uint8_t* p_codec_info_a,
-                                    const uint8_t* p_codec_info_b);
-
-// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
-// are exactly the same.
-// Returns true if the two codecs are exactly the same, otherwise false.
-// If the codec type is not LHDC, the return value is false.
-bool A2DP_VendorCodecEqualsLhdcV1(const uint8_t* p_codec_info_a,
-                                const uint8_t* p_codec_info_b);
-
-// Gets the track sample rate value for the A2DP LHDC codec.
-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
-// Returns the track sample rate on success, or -1 if |p_codec_info|
-// contains invalid codec information.
-int A2DP_VendorGetTrackSampleRateLhdcV1(const uint8_t* p_codec_info);
-
-// Gets the bits per audio sample for the A2DP LHDC codec.
-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
-// Returns the bits per audio sample on success, or -1 if |p_codec_info|
-// contains invalid codec information.
-int A2DP_VendorGetTrackBitsPerSampleLhdcV1(const uint8_t* p_codec_info);
-
-// Gets the channel count for the A2DP LHDC codec.
-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
-// Returns the channel count on success, or -1 if |p_codec_info|
-// contains invalid codec information.
-int A2DP_VendorGetTrackChannelCountLhdcV1(const uint8_t* p_codec_info);
-
-// Gets the channel mode code for the A2DP LHDC codec.
-// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
-// Returns the channel mode code on success, or -1 if |p_codec_info|
-// contains invalid codec information.
-int A2DP_VendorGetChannelModeCodeLhdcV1(const uint8_t* p_codec_info);
-
-// Gets the A2DP LHDC audio data timestamp from an audio packet.
-// |p_codec_info| contains the codec information.
-// |p_data| contains the audio data.
-// The timestamp is stored in |p_timestamp|.
-// Returns true on success, otherwise false.
-bool A2DP_VendorGetPacketTimestampLhdcV1(const uint8_t* p_codec_info,
-                                       const uint8_t* p_data,
-                                       uint32_t* p_timestamp);
-
-// Builds A2DP LHDC codec header for audio data.
-// |p_codec_info| contains the codec information.
-// |p_buf| contains the audio data.
-// |frames_per_packet| is the number of frames in this packet.
-// Returns true on success, otherwise false.
-bool A2DP_VendorBuildCodecHeaderLhdcV1(const uint8_t* p_codec_info, BT_HDR* p_buf,
-                                     uint16_t frames_per_packet);
-
-
-// Decodes A2DP LHDC codec info into a human readable string.
-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
-// Returns a string describing the codec information.
-std::string A2DP_VendorCodecInfoStringLhdcV1(const uint8_t* p_codec_info);
-
-// New feature to check codec info is supported Channel Separation.
-bool A2DP_VendorGetChannelSeparation(const uint8_t* p_codec_info);
-
-// Decodes and displays LHDC codec info (for debugging).
-// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
-void A2DP_VendorDumpCodecInfoLhdcV1(const uint8_t* p_codec_info);
-
-// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
-// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
-// |p_codec_info| contains the codec information.
-// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
-// supported, otherwise NULL.
-const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV1(
-    const uint8_t* p_codec_info);
-
-// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
-// specification.
-// |p_codec_info| contains the codec information to adjust.
-// Returns true if |p_codec_info| is valid and supported, otherwise false.
-bool A2DP_VendorAdjustCodecLhdcV1(uint8_t* p_codec_info);
-
-// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
-// Returns the corresponding |btav_a2dp_codec_index_t| on success,
-// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
-btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV1(
-    const uint8_t* p_codec_info);
-
-// Gets the A2DP LHDC Source codec name.
-const char* A2DP_VendorCodecIndexStrLhdcV1(void);
-
-// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
-// configuration entry pointed by |p_cfg|.
-bool A2DP_VendorInitCodecConfigLhdcV1(AvdtpSepConfig* p_cfg);
-
-#endif  // A2DP_VENDOR_LHDCV1_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv1_constants.h b/system_bt/stack/include/a2dp_vendor_lhdcv1_constants.h
deleted file mode 100755
index d9c98493a..000000000
--- a/system_bt/stack/include/a2dp_vendor_lhdcv1_constants.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//
-// A2DP constants for LHDC codec
-//
-
-#ifndef A2DP_VENDOR_LHDCV1_CONSTANTS_H
-#define A2DP_VENDOR_LHDCV1_CONSTANTS_H
-
-#define A2DP_LHDCV1_VENDOR_CMD_MASK    0xC000
-
-// LHDC Quality Mode Index
-//LHDC not supported auto bit rate now.
-//#define A2DP_LHDCV1_QUALITY_MAGIC_NUM 0x8000
-//#define A2DP_LHDCV1_QUALITY_ABR    8   // ABR mode, range: 990,660,492,396,330(kbps)
-//#define A2DP_LHDCV1_QUALITY_HIGH   7   // Equal to LHDCBT_EQMID_HQ 900kbps
-//#define A2DP_LHDCV1_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
-//#define A2DP_LHDCV1_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
-//#define A2DP_LHDCV1_QUALITY_LOW4   4   //
-//#define A2DP_LHDCV1_QUALITY_LOW3   3
-//#define A2DP_LHDCV1_QUALITY_LOW2   2
-//#define A2DP_LHDCV1_QUALITY_LOW1   1
-//#define A2DP_LHDCV1_QUALITY_LOW0   0
-
-#define A2DP_LHDCV1_LATENCY_MAGIC_NUM 0xC000
-//#define A2DP_LHDCV1_LATENCY_LOW	0	// 50-100 ms
-//#define A2DP_LHDCV1_LATENCY_MID	1	// default value, 150-200 ms
-//#define A2DP_LHDCV1_LATENCY_HIGH	2	// 300-500 ms
-
-// Length of the LHDC Media Payload header
-//#define A2DP_LHDCV1_MPL_HDR_LEN 2
-
-// LHDC Media Payload Header
-//#define A2DP_LHDCV1_HDR_F_MSK 0x80
-//#define A2DP_LHDCV1_HDR_S_MSK 0x40
-//#define A2DP_LHDCV1_HDR_L_MSK 0x20
-//#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
-//#define A2DP_LHDCV1_HDR_NUM_SHIFT 2
-//#define A2DP_LHDCV1_HDR_NUM_MAX 7
-
-//#define A2DP_LHDCV1_HDR_LATENCY_LOW   0x00
-//#define A2DP_LHDCV1_HDR_LATENCY_MID   0x01
-//#define A2DP_LHDCV1_HDR_LATENCY_HIGH  0x02
-//#define A2DP_LHDCV1_HDR_LATENCY_MSK   0x03
-
-// LHDC codec specific settings
-//#define A2DP_LHDCV1_CODEC_LEN 9
-// [Octet 0-3] Vendor ID
-//#define A2DP_LHDCV1_VENDOR_ID 0x0000053a
-// [Octet 4-5] Vendor Specific Codec ID
-// [Octet 6], [Bits 0-3] Sampling Frequency
-//#define A2DP_LHDCV1_SAMPLING_FREQ_MASK 0x0F
-//#define A2DP_LHDCV1_SAMPLING_FREQ_44100 0x08
-//#define A2DP_LHDCV1_SAMPLING_FREQ_48000 0x04
-//#define A2DP_LHDCV1_SAMPLING_FREQ_88200 0x02
-//#define A2DP_LHDCV1_SAMPLING_FREQ_96000 0x01
-
-// [Octet 6], [Bits 3-4] Bit dipth
-#define A2DP_LHDCV1_BIT_FMT_MASK 	 0x30
-//#define A2DP_LHDCV1_BIT_FMT_24	 0x10
-//#define A2DP_LHDCV1_BIT_FMT_16	 0x20
-
-#define A2DP_LHDCV1_CHANNEL_SEPARATION  0x40
-
-
-
-//#define A2DP_LHDCV1_CHANNEL_MODE_MASK 0x07
-//#define A2DP_LHDCV1_CHANNEL_MODE_MONO 0x04
-//#define A2DP_LHDCV1_CHANNEL_MODE_DUAL 0x02
-//#define A2DP_LHDCV1_CHANNEL_MODE_STEREO 0x01
-
-
-#endif  // A2DP_VENDOR_LHDCV1_CONSTANTS_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv1_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv1_encoder.h
deleted file mode 100755
index 86da05b67..000000000
--- a/system_bt/stack/include/a2dp_vendor_lhdcv1_encoder.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-//
-// Interface to the A2DP LHDC Encoder
-//
-
-#ifndef A2DP_VENDOR_LHDCV1_ENCODER_H
-#define A2DP_VENDOR_LHDCV1_ENCODER_H
-
-#include "a2dp_codec_api.h"
-
-// Loads the A2DP LHDC encoder.
-// Return true on success, otherwise false.
-bool A2DP_VendorLoadEncoderLhdcV1(void);
-
-// Unloads the A2DP LHDC encoder.
-void A2DP_VendorUnloadEncoderLhdcV1(void);
-
-// Initialize the A2DP LHDC encoder.
-// |p_peer_params| contains the A2DP peer information
-// The current A2DP codec config is in |a2dp_codec_config|.
-// |read_callback| is the callback for reading the input audio data.
-// |enqueue_callback| is the callback for enqueueing the encoded audio data.
-void a2dp_vendor_lhdcV1_encoder_init(
-    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
-    A2dpCodecConfig* a2dp_codec_config,
-    a2dp_source_read_callback_t read_callback,
-    a2dp_source_enqueue_callback_t enqueue_callback);
-
-// Cleanup the A2DP LHDC encoder.
-void a2dp_vendor_lhdcV1_encoder_cleanup(void);
-
-// Reset the feeding for the A2DP LHDC encoder.
-void a2dp_vendor_lhdcV1_feeding_reset(void);
-
-// Flush the feeding for the A2DP LHDC encoder.
-void a2dp_vendor_lhdcV1_feeding_flush(void);
-
-// Get the A2DP LHDC encoder interval (in milliseconds).
-uint64_t a2dp_vendor_lhdcV1_get_encoder_interval_ms(void);
-
-// Prepare and send A2DP LHDC encoded frames.
-// |timestamp_us| is the current timestamp (in microseconds).
-void a2dp_vendor_lhdcV1_send_frames(uint64_t timestamp_us);
-
-// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
-void a2dp_vendor_lhdcV1_set_transmit_queue_length(size_t transmit_queue_length);
-
-#endif  // A2DP_VENDOR_LHDCV1_ENCODER_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv2.h b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
index 8ea7af782..5576d12fb 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdcv2.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
@@ -172,6 +172,12 @@ const char* A2DP_VendorCodecIndexStrLhdcV2(void);
 
 // Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
 // configuration entry pointed by |p_cfg|.
+
 bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg);
+// Gets the track bitrate value for the A2DP LHDCV2 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info);
 
 #endif  // A2DP_VENDOR_LHDCV2_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3.h b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
index ce464fbc9..dd8afaf17 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdcv3.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
@@ -319,4 +319,10 @@ bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg);
 
 bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t* capVector);
 
+// Gets the track bitrate value for the A2DP LHDCV3 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info);
+
 #endif  // A2DP_VENDOR_LHDCV3_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
index 79280b26a..697ca3b69 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
@@ -184,8 +184,4 @@ const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void);
 // configuration entry pointed by |p_cfg|.
 bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg);
 
-// Get SBC bitrate
-// Returns |uint32_t| bitrate value in bits per second
-uint32_t A2DP_VendorGetBitRateLhdcV3Sink(const uint8_t* p_codec_info);
-
 #endif  // A2DP_VENDOR_LHDCV3_DEC_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5.h b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
index 75aff4b4b..f579b28cd 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdcv5.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
@@ -284,8 +284,8 @@ const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void);
 bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg);
 
 // Gets the track bitrate value for the A2DP LHDCV5 codec.
-// |p_codec_info| is a pointer to the LDAC codec_info to decode.
-// Returns the track sample rate on success, or -1 if |p_codec_info|
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
 // contains invalid codec information.
 int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info);
 
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
index e7f176c3c..b405d9225 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
@@ -110,7 +110,7 @@
 #define A2DP_LHDCV5_QUALITY_ABR    (0x09)  // Adaptive Bit Rate
 #define A2DP_LHDCV5_QUALITY_HIGH1  (0x08)  // 1000kbps
 #define A2DP_LHDCV5_QUALITY_HIGH   (0x07)  // 900kbps
-#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 600kbps
+#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 500kbps
 #define A2DP_LHDCV5_QUALITY_LOW    (0x05)  // 400kbps
 #define A2DP_LHDCV5_QUALITY_LOW4   (0x04)  // 320kbps
 #define A2DP_LHDCV5_QUALITY_LOW3   (0x03)  // 256kbps
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
index 0f2bf36ce..ba5be9825 100755
--- a/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2016 The Android Open Source Project
+ * Copyright (C) 2022 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,7 @@
  */
 
 //
-// Interface to the A2DP LHDC V3 Decoder
+// Interface to the A2DP LHDC V5 Decoder
 //
 
 #ifndef A2DP_VENDOR_LHDCV5_DECODER_H
@@ -30,30 +30,29 @@
 // Return true on success, otherwise false.
 bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info);
 
-// Loads the A2DP LHDC V3 decoder.
+// Loads the A2DP LHDC V5 decoder.
 // Return true on success, otherwise false.
 bool A2DP_VendorLoadDecoderLhdcV5(void);
 
-// Unloads the A2DP LHDC V3 decoder.
+// Unloads the A2DP LHDC V5 decoder.
 void A2DP_VendorUnloadDecoderLhdcV5(void);
 
-// Initialize the A2DP LHDC V3 decoder.
+// Initialize the A2DP LHDC V5 decoder.
 bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback);
 
-// Cleanup the A2DP LHDC V3 decoder.
+// Cleanup the A2DP LHDC V5 decoder.
 void a2dp_vendor_lhdcv5_decoder_cleanup(void);
 
-// Decodes |p_buf|. Calls |decode_callback| passed into |a2dp_lhdcv3_decoder_init|
-// if decoded frames are available.
+// Decode LHDC V5 packet to PCM
 bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf);
 
-// Start the A2DP LHDCV3 decoder.
+// Start the A2DP LHDC V5 decoder.
 void a2dp_vendor_lhdcv5_decoder_start(void);
 
-// Suspend the A2DP LHDCV3 decoder.
+// Suspend the A2DP LHDC V5 decoder.
 void a2dp_vendor_lhdcv5_decoder_suspend(void);
 
-// A2DP LHDCV3 decoder configuration.
+// A2DP LHDC V5 decoder configuration.
 void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info);
 
 #endif  // A2DP_VENDOR_LHDCV5_DECODER_H
diff --git a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
index 5b3848abd..8f017bad1 100755
--- a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
+++ b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
@@ -28,11 +28,20 @@ static const std::vector<const btav_a2dp_codec_index_t> CODEC_INDEX_ENUM_VALS =
      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
      BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
+     // Savitech Patch - START
+     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
+     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+     // Savitech Patch - END
      BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
      BTAV_A2DP_CODEC_INDEX_SINK_MIN,
      BTAV_A2DP_CODEC_INDEX_SINK_SBC,
      BTAV_A2DP_CODEC_INDEX_SINK_AAC,
      BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
+     // Savitech Patch - START
+     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+     // Savitech Patch - END
      BTAV_A2DP_CODEC_INDEX_SINK_MAX,
      BTAV_A2DP_CODEC_INDEX_MIN,
      BTAV_A2DP_CODEC_INDEX_MAX};
diff --git a/system_bt/stack/test/stack_a2dp_test.cc b/system_bt/stack/test/stack_a2dp_test.cc
index 2c1e38739..2cb351a30 100755
--- a/system_bt/stack/test/stack_a2dp_test.cc
+++ b/system_bt/stack/test/stack_a2dp_test.cc
@@ -209,6 +209,14 @@ static const char* APTX_ENCODER_LIB_NAME = "libaptX_encoder.so";
 static const char* APTX_HD_ENCODER_LIB_NAME = "libaptXHD_encoder.so";
 static const char* LDAC_ENCODER_LIB_NAME = "libldacBT_enc.so";
 static const char* LDAC_DECODER_LIB_NAME = "libldacBT_dec.so";
+// Savitech Patch - START
+static const char* LHDCV2_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static const char* LHDCV3_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static const char* LHDCV5_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
+static const char* LHDCV3_DECODER_LIB_NAME = "liblhdcBT_dec.so";
+static const char* LHDCV5_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
+// Savitech Patch - END
+
 
 static bool has_shared_library(const char* name) {
   void* lib_handle = dlopen(name, RTLD_NOW);
@@ -253,6 +261,23 @@ class StackA2dpTest : public ::testing::Test {
           // shared library installed.
           supported = has_shared_library(LDAC_ENCODER_LIB_NAME);
           break;
+          // Savitech Patch - START  Offload
+        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV3_ENCODER_LIB_NAME);
+          break;
+        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV2_ENCODER_LIB_NAME);
+          break;
+        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV5_ENCODER_LIB_NAME);
+          break;
+          // Savitech Patch - END
         case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
           supported = true;
           break;
@@ -264,6 +289,18 @@ class StackA2dpTest : public ::testing::Test {
           // shared library installed.
           supported = has_shared_library(LDAC_DECODER_LIB_NAME);
           break;
+        // Savitech Patch - START  Offload
+        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV3_DECODER_LIB_NAME);
+          break;
+        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV5_DECODER_LIB_NAME);
+          break;
+        // Savitech Patch - END
         case BTAV_A2DP_CODEC_INDEX_MAX:
           // Needed to avoid using "default:" case so we can capture when
           // a new codec is added, and it can be included here.
