diff --git a/external/liblhdc/Android.bp b/external/liblhdc/Android.bp
new file mode 100644
index 000000000..30d11199d
--- /dev/null
+++ b/external/liblhdc/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdc",
+
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdc.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdc.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcBT_enc",
+   // vendor_available: true,
+   // vndk: {
+   //     enabled: true,
+   // },
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcBT_enc.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdc",
+    ],
+}
diff --git a/external/liblhdc/inc/lhdcBT.h b/external/liblhdc/inc/lhdcBT.h
new file mode 100644
index 000000000..f478e2134
--- /dev/null
+++ b/external/liblhdc/inc/lhdcBT.h
@@ -0,0 +1,392 @@
+
+
+#ifndef _LHDCBT_H_
+#define _LHDCBT_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+#ifndef LHDCBT_API
+#define LHDCBT_API
+#endif /* LHDCBT_API  */
+#include "lhdc_api.h"
+
+typedef enum _lhdcBT_ext_func_field_t{
+  LHDCBT_EXT_FUNC_AR = 0,
+  LHDCBT_EXT_FUNC_LARC,
+  LHDCBT_EXT_FUNC_EXTR,
+  LHDCBT_EXT_FUNC_JAS,
+  //LHDCBT_EXT_FUNC_META,
+  LHDCBT_EXT_FUNC_MAX,
+} lhdcBT_ext_func_field_t;
+
+//
+// Extend API Basic Settings Definition
+//
+#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
+#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
+#define EXTEND_FUNC_CODE_MIN_BUFFER_LEN                 8
+
+/* **********************************************
+ *  API: Version Control
+ * ***********************************************/
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V1               ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2               ((unsigned int) 0x02000000)
+
+#define EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V1       8
+#define EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V2       16
+
+/* **********************************************
+ *  LIB API: Config Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   META                      *
+ * * * * * * * * * * * * * * * */
+//   META :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_META        ((unsigned int) 0x0C000001)
+#define EXTEND_FUNC_CODE_GET_CONFIG_META        ((unsigned int) 0x0C010001)
+//   META :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+//   META :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+
+/* * * * * * * * * * * * * * * *
+ *   AR                        *
+ * * * * * * * * * * * * * * * */
+//   AR :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_AR          ((unsigned int) 0x0C000002)
+#define EXTEND_FUNC_CODE_GET_CONFIG_AR          ((unsigned int) 0x0C010002)
+//   AR :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V3        ((unsigned int) 0x03000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+//   AR :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+
+
+/* **********************************************
+ *  LIB API: Data Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   GYRO2D                    *
+ * * * * * * * * * * * * * * * */
+//   GYRO2D :: API Code
+#define EXTEND_FUNC_CODE_SET_DATA_GYRO2D        ((unsigned int) 0x0D000001)
+//   GYRO2D :: API Version
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V2      ((unsigned int) 0x02000000)
+//   GYRO2D :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_REQ_BUFSIZE_V2      16    //TBD (8 + 2gyro + 6pad)
+
+
+/* **********************************************
+ *  A2DP-Extended API:
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   GetA2DPSpecifis           *
+ * * * * * * * * * * * * * * * */
+//   GetA2DPSpecifis :: API Code
+#define EXTEND_FUNC_CODE_GET_SPECIFIC           ((unsigned int) 0x0A010001)
+//   GetA2DPSpecifis :: API Version
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V1         ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2         ((unsigned int) 0x02000000)
+
+/* ************************************************************************
+ * Version format info of EXTEND_FUNC_CODE_GET_SPECIFIC
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Capabilities Metadata sub fields:  (7*2 bytes)
+     * sub[0~1]:    JAS
+     * sub[2~3]:    AR
+     * sub[4~5]:    META
+     * sub[6~7]:    LLAC
+     * sub[8~9]:    MBR
+     * sub[10~11]:  LARC
+     * sub[12~13]:  LHDCV4
+   * Padded:                        (2 bytes)
+ * ************************************************************************/
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
+#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
+/* Capabilities metadata fields(2 bytes for each tuple) */
+#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
+#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
+
+/* Total size of buffer */
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
+/* Head of each field */
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
+/* Following part in V1 */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
+/* Following part in V2 */
+#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
+#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
+#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
+
+/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
+
+/************************
+ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
+   * Capability Code:                   (1 byte)
+   * Saving Position Info:              (1 byte)
+ ************************/
+/* Capabilities's code: */
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
+
+/* Capabilities's saving position Info:
+ *  1. in which specific                        (represented in leftmost 2-bits)
+ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
+ * */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
+/********************************************************************************/
+
+
+
+
+#define EXTEND_FUNC_RET_OK                      ((int) 0)
+#define EXTEND_FUNC_RET_INVALID_HANDLE          ((int) 0xE01)
+#define EXTEND_FUNC_RET_INVALID_PARAMETER       ((int) 0xE02)
+#define EXTEND_FUNC_RET_FUNC_NOT_SUPPORT        ((int) 0xE03)
+#define EXTEND_FUNC_RET_VERSION_NOT_SUPPORT     ((int) 0xE04)
+#define EXTEND_FUNC_RET_BUF_UNDERRUN            ((int) 0xE05)
+#define EXTEND_FUNC_RET_ERROR                   ((int) 0xE06)
+#define EXTEND_FUNC_RET_NOT_READY               ((int) 0xE07)
+#define EXTEND_FUNC_RET_REQ_BUFSIZE_NOT_MATCH   ((int) 0xE08)
+
+
+//
+// META
+//
+#define META_ST_VER_V1                           ((unsigned int) 0x00010000)
+#define META_ST_VER_V2                           ((unsigned int) 0x00020000)
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_SET_META {
+
+    unsigned char     header[8];
+    unsigned int      meta_ver;
+    unsigned char     meta_mem_size;
+    unsigned char     meta_enable;
+    unsigned char     meta_set;
+    unsigned char     meta_metadata_length;
+//  unsigned char     meta_metadata[64];
+
+} ST_LHDC_SET_META, *PST_LHDC_SET_META;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_GET_META {
+
+    unsigned char     header[8];
+    unsigned int      meta_ver;
+    unsigned char     meta_mem_size;
+    unsigned char     meta_st;     // [0] 1: reserved bit, [1] 1: in meta mode/0: not in meta mode
+    unsigned char     jas_status;
+
+} ST_LHDC_GET_META, *PST_LHDC_GET_META;
+#pragma pack(pop)
+
+//
+// AR
+//
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR
+{
+    unsigned char     header[8];
+    unsigned int      ver;
+    unsigned int      size;
+    unsigned int      app_ar_enabled;
+    int Ch1_Pos;
+    int Ch2_Pos;
+    int Ch3_Pos;
+    int Ch4_Pos;
+    int Ch5_Pos;
+    int Ch6_Pos;
+    float Ch1_L_PreGain;
+    float Ch1_R_PreGain;
+    float Ch2_L_PreGain;
+    float Ch2_R_PreGain;
+    float Ch3_L_PreGain;
+    float Ch3_R_PreGain;
+    float Ch4_L_PreGain;
+    float Ch4_R_PreGain;
+    float Ch5_L_PreGain;
+    float Ch5_R_PreGain;
+    float Ch6_L_PreGain;
+    float Ch6_R_PreGain;
+    float Ch1_PostGain;
+    float Ch2_PostGain;
+    float Ch3_PostGain;
+    float Ch4_PostGain;
+    float Ch5_PostGain;
+    float Ch6_PostGain;
+    float Dry_Val;
+    float Wet_Val;
+    float Dis_1;
+    float Dis_2;
+    float Dis_3;
+    float Dis_4;
+    float Dis_5;
+    float Rev_1;
+    float Rev_2;
+    float Rev_3;
+    float Rev_4;
+    float Rev_5;
+    float Rev_gain;
+    float ThreeD_gain;
+} ST_LHDC_AR, *PST_LHDC_AR;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR_GYRO
+{
+    unsigned char     header[8];
+    int world_coordinate_x;
+    int world_coordinate_y;
+    int world_coordinate_z;
+
+} ST_LHDC_AR_GYRO, *PST_LHDC_AR_GYRO;
+#pragma pack(pop)
+
+#ifdef NEW_API_SET
+//for NEW API used!!!!
+typedef struct {
+  uint32_t sample_rate;
+  LHDCBT_SMPL_FMT_T bits_per_sample;
+  LHDCBT_QUALITY_T audio_quality;
+  bool channel_split_enabled;
+  uint32_t packet_mtu;
+  uint32_t encode_interval;
+
+  bool output_size_cal;
+} lhdc_init_param_t;
+
+int lhdcBT_init(HANDLE_LHDC_BT handle, lhdc_init_param_t * param);
+#else
+HANDLE_LHDC_BT lhdcBT_get_handle(int version);
+
+
+void lhdcBT_free_handle(HANDLE_LHDC_BT handle);
+
+//static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
+//Encoder for V2
+int lhdcBT_encode(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
+//Encoder for V3
+int lhdcBT_encodeV3(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+
+int lhdcBT_get_bitrate(HANDLE_LHDC_BT hLhdcParam);
+
+int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx);
+
+//int lhdcBT_get_sampling_freq(HANDLE_LHDC_BT handle);
+
+//int lhdcBT_init_handle_encode(HANDLE_LHDC_BT handle,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannel, int need_padding, int mtu, int interval);
+
+//int lhdcBT_get_error_code(HANDLE_LHDC_BT handle);
+
+int lhdcBT_adjust_bitrate(HANDLE_LHDC_BT handle, size_t queueLength) ;
+
+//void lhdcBT_setLimitBitRate(HANDLE_LHDC_BT handle, int max_rate_index);
+
+//uint8_t lhdcBT_getSupportedVersion(HANDLE_LHDC_BT handle);
+
+int     lhdcBT_get_block_Size(HANDLE_LHDC_BT handle);
+
+int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
+
+int lhdcBT_get_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool * enabled);
+
+//
+// Extra API
+//
+// 1. API -- Set User Config (Extend)
+int lhdcBT_set_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen);
+// 2. API -- Get User Config (Extend)
+int lhdcBT_get_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen);
+// 3. API -- Set User Data (Extend)
+void lhdcBT_set_user_exdata(HANDLE_LHDC_BT handle, char* userConfig, int clen);
+// 4. API -- Get Version 
+int lhdcBT_get_user_exApiver(HANDLE_LHDC_BT handle, char *version, int clen);
+
+#endif
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_H_ */
diff --git a/external/liblhdc/include/cirbuf.h b/external/liblhdc/include/cirbuf.h
new file mode 100644
index 000000000..9cd263d2b
--- /dev/null
+++ b/external/liblhdc/include/cirbuf.h
@@ -0,0 +1,29 @@
+#ifndef	_CIRBUF_H_
+#define	_CIRBUF_H_
+
+struct cirbuf_s
+{
+	unsigned int	idx;
+	unsigned int	odx;
+	unsigned int	s_len;
+	unsigned int	r_len;
+	unsigned int	max_len;
+	unsigned char	*cbuf;
+};
+typedef  struct cirbuf_s savi_circ_buf;
+
+void cirbuf_init( struct cirbuf_s *pcb, unsigned char *buf, int len);
+
+void cirbuf_reset( struct cirbuf_s *pcb);
+
+int cirbuf_len( struct cirbuf_s *pcb);
+int cirbuf_empty_len( struct cirbuf_s *pcb);
+
+int cirbuf_get( struct cirbuf_s *pcb, unsigned char *buf, int len);
+int cirbuf_put( struct cirbuf_s *pcb, unsigned char *buf, int len);
+
+int cirbuf_get_no_copy( struct cirbuf_s *pcb, unsigned char **buf, int len);
+int cirbuf_put_no_copy( struct cirbuf_s *pcb, unsigned char **buf, int len);
+
+#endif	/* _CIRBUF_H_ */
+
diff --git a/external/liblhdc/include/lhdc_api.h b/external/liblhdc/include/lhdc_api.h
new file mode 100644
index 000000000..079719cb7
--- /dev/null
+++ b/external/liblhdc/include/lhdc_api.h
@@ -0,0 +1,215 @@
+#ifndef __LHDC_API_H__
+#define __LHDC_API_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "lhdc_process.h"
+#include "cirbuf.h"
+
+#define LHDC_ENC_LIB_COPYRIGHT  "LHDC Encode Library @Copyright SAVITECH 2021"
+#define LHDC_VERSION            LHDCVER
+
+typedef enum {
+    LHDCBT_SMPL_FMT_S16 = 16,
+    LHDCBT_SMPL_FMT_S24 = 24,
+} LHDCBT_SMPL_FMT_T;
+
+typedef enum name {
+    LHDCBT_QUALITY_LOW0 = 0,
+    LHDCBT_QUALITY_LOW1,
+    LHDCBT_QUALITY_LOW2,
+    LHDCBT_QUALITY_LOW3,
+    LHDCBT_QUALITY_LOW4,
+    LHDCBT_QUALITY_LOW,
+    LHDCBT_QUALITY_MID,
+    LHDCBT_QUALITY_HIGH,
+    LHDCBT_QUALITY_AUTO,
+    LHDCBT_QUALITY_RESET_AUTO,
+    LHDCBT_QUALITY_MAX
+} LHDCBT_QUALITY_T;
+
+
+#define LHDCV1_BT_ENC_BLOCK_SIZE  512
+
+#define LHDCV2_BT_ENC_BLOCK_SIZE  512
+
+#define LHDCV3_BT_ENC_BLOCK_SIZE  256
+
+
+#define MAX_CHANNEL		    		2
+#define LHDC_AR_PROCESS_CH			6
+#define LHDC_SEPARATE_OUTPUR_CH     4
+#define LHDC_AR_VERSION             "LHDC AR v1.1a.14 2021-7-7  @Copyright SAVITECH 2021"
+
+typedef enum _lhdc_enc_type_t {
+    ENC_TYPE_UNKNOWN = 0,
+    ENC_TYPE_LHDC,
+    ENC_TYPE_LLAC,
+    ENC_TYPE_MAX,
+    ENC_TYPE_ERR = ENC_TYPE_MAX
+} lhdc_enc_type_t;
+
+typedef enum _lhdc_filter_type_t{
+    LHDC_FILTER_PASSTHROUGH = 0,
+    LHDC_FILTER_AR,
+    LHDC_FILTER_ERR = 0xffU
+} lhdc_filter_type_t;
+
+
+typedef struct _llac_para_t {
+    
+    uint8_t* lh4_enc;
+    int32_t  sample_rate;
+    int32_t  bits_per_sample;
+
+    LHDCBT_QUALITY_T qualityStatus;      //0xff == Auto bitrate
+    LHDCBT_QUALITY_T limitBitRateStatus;
+    int32_t  lastBitrate;     //Record lastbitrate for auto bitrate adjust.
+    int32_t  real_bitrate;
+
+    uint16_t avg_cnt;
+    uint32_t avgValue;
+
+    uint16_t changeBRCnt;
+    uint32_t chageBRAvg;
+
+    uint16_t upBitrateCnt;
+    uint32_t upBitrateSum;
+
+    uint16_t dnBitrateCnt;
+    uint32_t dnBitrateSum;
+
+
+    bool updateFramneInfo;
+    uint32_t samples_per_frame; //equal to block size
+    savi_circ_buf input_cbuf;
+    int32_t  out_nbytes;    //output size per frame;
+    uint32_t host_mtu_size;
+    uint32_t frame_per_packet;
+    uint32_t encode_interval;
+
+    //kaiden:20210311:autobirate:malloc maximum nbyte size
+    bool new_packet_flag;
+
+} llac_para_t;
+
+typedef struct _lhdc_para_t {
+
+    FFT_BLOCK * fft_blk;
+    int32_t  sample_rate;
+    int32_t  bits_per_sample;
+
+    LHDCBT_QUALITY_T qualityStatus;      //0xff == Auto bitrate
+    LHDCBT_QUALITY_T limitBitRateStatus;
+    int32_t lastBitrate;     //Record lastbitrate for auto bitrate adjust.
+    int32_t version;
+
+    uint16_t avg_cnt;
+    uint32_t avgValue;
+
+    uint16_t changeBRCnt;
+    uint32_t chageBRAvg;
+
+    uint16_t upBitrateCnt;
+    uint32_t upBitrateSum;
+
+    uint16_t dnBitrateCnt;
+    uint32_t dnBitrateSum;
+
+    bool updateFramneInfo;
+    uint32_t block_size;
+    uint32_t target_mtu_size;
+    uint32_t host_mtu_size;
+    uint32_t frame_per_packet;
+    uint32_t encode_interval;
+    savi_circ_buf input_cbuf;
+    uint32_t queue_frame_cnt;
+
+    bool hasMinBitrateLimit;
+} lhdc_para_t;
+
+//L_20210408 .start
+typedef struct _lhdc_ar_para_t {
+	int sample_rate;
+	int bits_per_sample;
+	int channels;
+	unsigned int samples_per_frame;
+	unsigned int    app_ar_enabled;
+        unsigned long   ulNumBytes;
+        unsigned char*  pucARParams;
+        unsigned int	uiARParamsBytes;//Ask AR how many mem size
+        unsigned char*  pucLhdcArMem;
+        unsigned int	uiLhdcArMemBytes;//Ask AR how many mem size
+} lhdc_ar_para_t;
+//L_20210408 .end
+
+typedef struct _lhdc_filter_t{
+    uint8_t * priv; //save alloc mem point
+    lhdc_filter_type_t type; //don't del..
+} lhdc_filter_t;
+
+
+typedef union _enc_t {
+        lhdc_para_t *lhdc;
+        llac_para_t *llac;
+} enc_t;
+typedef struct _lhdc_control_block_t {
+
+    lhdc_enc_type_t enc_type;       //LLAC or LHDC
+    int err;
+
+    enc_t enc;
+    lhdc_ar_para_t * ar_filter; //AR Param
+
+} lhdc_cb_t;
+
+
+inline static int32_t TARGET_BITRATE_LIMIT(int32_t X, int32_t Y){
+     //((X < Y) ? (Y) : (X))
+
+     if (X < Y)
+        return Y;
+    else
+        return X;
+
+}
+
+typedef void * HANDLE_LHDC_BT;
+
+extern llac_para_t * llac_encoder_new();
+extern void llac_encoder_free(llac_para_t * llac);
+extern int32_t llac_encoder_get_frame_len(llac_para_t  *  handle);
+extern int32_t llac_encoder_get_target_bitrate(llac_para_t  *  handle);
+extern int32_t llac_encoder_init(llac_para_t  *  handle, uint32_t sample_rate, uint32_t bits_per_sample, uint32_t bitrate_inx, uint32_t mtu_size, uint32_t encode_interval);
+
+extern lhdc_para_t * lhdc_encoder_new(int version);
+extern void lhdc_encoder_free(lhdc_para_t * handle);
+extern int32_t lhdc_encoder_get_frame_len(lhdc_para_t * handle);
+extern int32_t lhdc_encoder_get_target_bitrate(lhdc_para_t * handle);
+extern bool lhdc_get_ext_func_state(lhdc_enc_type_t type, void *h, lhdc_ext_func_t ext_type);
+extern int32_t lhdc_encoder_init(lhdc_para_t * handle,int32_t sampling_freq, uint32_t bitPerSample, uint32_t bitrate_inx, uint32_t dualChannel, uint32_t need_padding, uint32_t mtu, uint32_t interval);
+
+
+extern void ar_process_free(lhdc_ar_para_t * handle);
+extern lhdc_ar_para_t * ar_process_new(void);
+extern int ar_process_init(lhdc_ar_para_t * handle, int sample_rate, int bits_per_sample, int channels, unsigned int samples_per_frame);
+extern int ar_set_gyro_pos(lhdc_ar_para_t * handle, int world_coordinate_x, int world_coordinate_y, int world_coordinate_z);
+extern int ar_set_cfg(lhdc_ar_para_t * handle,int *Pos, float *Gain, unsigned int app_ar_enabled);
+extern int ar_get_cfg(lhdc_ar_para_t * handle,int *Pos, float *Gain);
+
+//Common function
+
+
+extern void lhdc_util_reset_up_bitrate(lhdc_enc_type_t type, void * h);
+extern void lhdc_util_reset_down_bitrate(lhdc_enc_type_t type, void * h);
+extern bool lhdc_util_get_ext_func_state(lhdc_enc_type_t type, void *h, lhdc_ext_func_t ext_type);
+extern int32_t lhdc_util_encv4_process(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+extern uint32_t lhdc_util_get_bitrate(uint32_t index);
+extern uint8_t * lhdc_util_get_buffer(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif //End of __LHDC_API_H__
diff --git a/external/liblhdc/include/lhdc_cfg.h b/external/liblhdc/include/lhdc_cfg.h
new file mode 100644
index 000000000..29ce0200f
--- /dev/null
+++ b/external/liblhdc/include/lhdc_cfg.h
@@ -0,0 +1,34 @@
+#ifndef __LHDC_CONFIG_H__
+#define __LHDC_CONFIG_H__
+
+//
+// Config for LHDC Encode
+//
+
+
+//#define ENC_LPF_FIXED_POINT			1
+
+
+// 20190402 .start
+//#define ENC_LPC_V_MAX_ORDER			1
+//#define ENC_LPC_V_USE_32BIT			1
+// 20190402 .end
+
+
+
+//
+// Config for LHDC Decode
+//
+
+//#define DEC_LPF_FIXED_POINT			1
+
+
+
+// 20190402 .start
+//#define DEC_LPC_V_MAX_ORDER			1
+//#define DEC_ADSP_LPC_V_USE_ADSP		1
+//#define DEC_ADSP_LPC_V_MAX_ORDER		1
+// 20190402 .end
+
+
+#endif
diff --git a/external/liblhdc/include/lhdc_enc_config.h b/external/liblhdc/include/lhdc_enc_config.h
new file mode 100644
index 000000000..7e64b88ee
--- /dev/null
+++ b/external/liblhdc/include/lhdc_enc_config.h
@@ -0,0 +1,7 @@
+#ifndef	_LHDC_ENC_CONFIG_H_
+#define	_LHDC_ENC_CONFIG_H_
+
+
+#define LHDC_ENC_SINK_BUF_LEN       ( 10 * 1024)
+
+#endif	/* _LHDC_ENC_CONFIG_H_ */
diff --git a/external/liblhdc/include/lhdc_process.h b/external/liblhdc/include/lhdc_process.h
new file mode 100644
index 000000000..4a1bf4211
--- /dev/null
+++ b/external/liblhdc/include/lhdc_process.h
@@ -0,0 +1,106 @@
+#ifndef _PROCESS_BLOCK_H_
+#define _PROCESS_BLOCK_H_
+#include <stdbool.h>
+
+
+struct FFT_block_s;
+typedef struct FFT_block_s FFT_BLOCK;
+
+typedef enum {
+	EXT_FUNC_AR,
+	EXT_FUNC_LARC,
+	EXT_FUNC_EXT_FLG,
+	EXT_FUNC_JAS,
+	EXT_FUNC_META
+} lhdc_ext_func_t;
+
+
+typedef enum _lhdc_error {
+    LHDC_ST_OK,
+    LHDC_ST_ERR,
+    LHDC_ST_MAX
+} LHDC_STATE;
+
+
+int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
+
+/**
+ * Allocate new LHDC control block.
+ */
+//Adjust by John
+//FFT_BLOCK *LossyEncoderNew(void);
+FFT_BLOCK *LossyEncoderNew(int32_t version);
+
+/**
+ * Destroy LHDC control block.
+ */
+int LossyEncoderDelete(FFT_BLOCK *fb);
+
+/**
+ * Initial LHDC encoder.
+ * Input :
+ *  fb: LHDC control block.
+ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
+ *  channels    : Fixed to 2 channel.
+ *  block_size  : Fixed to 512.
+ *  sink_buf_len: Fixed to 10 * 1024.
+ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ *  fast_mode   : Always fixed to 0.
+ *  split       : Fixed to 0.
+ *  need_padding: Fixed to 0.
+ *  process_size: Fixed to 256.
+ *
+ * Return value :
+ *  LHDC_ST_ERR : Parameters of init have error.
+ *  LHDC_ST_OK : LHDC encoder initial OK.
+ */
+//void LossyEncoderInit(FFT_BLOCK *fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt);
+void LossyEncoderInit(FFT_BLOCK *fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt, int min_bits_reserved, int lhdc_ver);
+
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  wav : The PCM data. please input non-planer and compact PCM data.
+ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
+ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessWav(FFT_BLOCK *fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  pcm0 : The left channel PCM data.
+ *  pcm1 : The right channel PCM data.
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessPCM(FFT_BLOCK *fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * To change target byte rate at runtime.
+ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ */
+void LossyEncoderSetTargetByteRate(FFT_BLOCK *fb, int target_byte_rate);
+void LossyEncoderResetAlignmentBuf(FFT_BLOCK *fb);
+void LossyEncoderUpdateFrameSize(FFT_BLOCK *fb, int target_mtu_byte, int target_byte_rate);//For auto bit rate
+
+void LhdcExtFuncArEnable(FFT_BLOCK *fb, int enable_ar);
+void LhdcExtFuncJasEnable(FFT_BLOCK *fb, int enable_Jas);
+void LhdcExtFuncMetaEnable(FFT_BLOCK *fb, int enable_meta, unsigned char *pmeta_data, int meta_data_len, int conti_frame_cnt);
+bool LhdcGetExtFuncState(FFT_BLOCK *fb, lhdc_ext_func_t ext_func);
+#endif // _PROCESS_BLOCK_H_
diff --git a/external/liblhdc/include/lhdcv2_process.h b/external/liblhdc/include/lhdcv2_process.h
new file mode 100644
index 000000000..8d13c3ef2
--- /dev/null
+++ b/external/liblhdc/include/lhdcv2_process.h
@@ -0,0 +1,91 @@
+#ifndef _PROCESSV2_BLOCK_H_
+#define _PROCESSV2_BLOCK_H_
+
+
+#ifndef __FFT_BLOCK__
+#define __FFT_BLOCK__
+typedef void *FFT_BLOCK;
+#endif //End of __FFT_BLOCK__
+
+
+#ifndef __LHDC_STATUS__
+#define __LHDC_STATUS__
+typedef enum _lhdc_error {
+    LHDC_ST_OK,
+    LHDC_ST_ERR,
+    LHDC_ST_MAX
+} LHDC_STATE;
+#endif //End of __LHDC_STATUS__
+
+
+//int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
+
+/**
+ * Allocate new LHDC control block.
+ */
+FFT_BLOCK LossyEncoderNewV2(void);
+
+/**
+ * Destroy LHDC control block.
+ */
+int LossyEncoderDeleteV2(FFT_BLOCK fb);
+
+/**
+ * Initial LHDC encoder.
+ * Input :
+ *  fb: LHDC control block.
+ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
+ *  channels    : Fixed to 2 channel.
+ *  block_size  : Fixed to 512.
+ *  sink_buf_len: Fixed to 10 * 1024.
+ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ *  fast_mode   : Always fixed to 0.
+ *  split       : Fixed to 0.
+ *  need_padding: Fixed to 0.
+ *  process_size: Fixed to 256.
+ *
+ * Return value :
+ *  LHDC_ST_ERR : Parameters of init have error.
+ *  LHDC_ST_OK : LHDC encoder initial OK.
+ */
+LHDC_STATE LossyEncoderInitV2(FFT_BLOCK fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  wav : The PCM data. please input non-planer and compact PCM data.
+ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
+ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessWavV2(FFT_BLOCK fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  pcm0 : The left channel PCM data.
+ *  pcm1 : The right channel PCM data.
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessPCMV2(FFT_BLOCK fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * To change target byte rate at runtime.
+ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ */
+void LossyEncoderSetTargetByteRateV2(FFT_BLOCK fb, int target_byte_rate);
+#endif // _PROCESSV2_BLOCK_H_
diff --git a/external/liblhdc/include/lhdcv3_process.h b/external/liblhdc/include/lhdcv3_process.h
new file mode 100644
index 000000000..f1c9d3e7b
--- /dev/null
+++ b/external/liblhdc/include/lhdcv3_process.h
@@ -0,0 +1,92 @@
+#ifndef _PROCESSV3_BLOCK_H_
+#define _PROCESSV3_BLOCK_H_
+
+
+#ifndef __FFT_BLOCK__
+#define __FFT_BLOCK__
+typedef void *FFT_BLOCK;
+#endif //End of __FFT_BLOCK__
+
+
+#ifndef __LHDC_STATUS__
+#define __LHDC_STATUS__
+typedef enum _lhdc_error {
+    LHDC_ST_OK,
+    LHDC_ST_ERR,
+    LHDC_ST_MAX
+} LHDC_STATE;
+#endif //End of __LHDC_STATUS__
+
+
+//int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
+
+/**
+ * Allocate new LHDC control block.
+ */
+FFT_BLOCK LossyEncoderNewV3(void);
+
+/**
+ * Destroy LHDC control block.
+ */
+int LossyEncoderDeleteV3(FFT_BLOCK fb);
+
+/**
+ * Initial LHDC encoder.
+ * Input :
+ *  fb: LHDC control block.
+ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
+ *  channels    : Fixed to 2 channel.
+ *  block_size  : Fixed to 256.
+ *  sink_buf_len: Fixed to 10 * 1024.
+ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ *  fast_mode   : Always fixed to 0.
+ *  split       : Fixed to 0.
+ *  need_padding: Fixed to 0.
+ *  process_size: Fixed to 256.
+ *
+ * Return value :
+ *  LHDC_ST_ERR : Parameters of init have error.
+ *  LHDC_ST_OK : LHDC encoder initial OK.
+ */
+void LossyEncoderInitV3(FFT_BLOCK fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt);
+
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  wav : The PCM data. please input non-planer and compact PCM data.
+ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
+ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessWavV3(FFT_BLOCK fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * LHDC encode function
+ *  fb: LHDC control block.
+ *  pcm0 : The left channel PCM data.
+ *  pcm1 : The right channel PCM data.
+ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
+ *  final   : Fixed to 0.
+ *  out : Output buffer pointer.
+ *  out_len : The output buffer size to protect overwrite.
+ *
+ *  Return value :
+ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
+ *
+ */
+int LossyEncoderProcessPCMV3(FFT_BLOCK fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
+
+/**
+ * To change target byte rate at runtime.
+ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
+ */
+void LossyEncoderSetTargetByteRateV3(FFT_BLOCK fb, int target_byte_rate);
+#endif // _PROCESSV3_BLOCK_H_
diff --git a/external/liblhdc/include/llac_enc_api.h b/external/liblhdc/include/llac_enc_api.h
new file mode 100644
index 000000000..3004bc019
--- /dev/null
+++ b/external/liblhdc/include/llac_enc_api.h
@@ -0,0 +1,128 @@
+/***********************************************************************
+*                               LLAC encoder                           *
+*                                                                      *
+*                                                                      *
+************************************************************************/
+
+#ifndef LLAC_ENC_API_H
+#define LLAC_ENC_API_H
+
+/*
+ * LLAC: 
+ * API Usage
+ *
+ * STEP1.   call llac_enc_mem_alloc() once to allocate the memory
+ * STEP2_0. call llac_enc_set_extra_func() before llac_enc_initial()
+            to enable or disable extra function if needed (for AR, LARC and EXTH ,default is disable)
+ * STEP2.   call llac_enc_initial() once to initialize encoder
+ * STEP3_0. call llac_enc_set_bitrate() before llac_enc_process() 
+ *          to set new bitrate if needed (for autobitrate usage)
+ * STEP3.   call llac_enc_process() in a while loop to encode each frame
+ * STEP4.   call llac_enc_mem_free() once to release the allocated memory 
+ *        when the encode process are done 
+ */
+
+
+
+/*
+ * LLAC: 
+ *      LLAC_MAX_CHANNELS:   Max number of channels
+ *      LLAC_MAX_SAMPLES:    Max number of samples per channel
+ *      LLAC_MAX_BYTES:      Max size of encoded output data in bytess
+ */
+#define LLAC_MAX_CHANNELS 2
+#define LLAC_MAX_SAMPLES 480
+#define LLAC_MAX_BYTES 600
+
+
+/**
+ * LLAC:
+ * llac_enc_mem_alloc - allocate all the memory needed for LLAC encoder
+ * Return: the address of the allocated memory
+ */
+unsigned char* llac_enc_mem_alloc(void);
+
+
+/**
+ * LLAC:
+ * llac_enc_set_extra_func - set extra function enable/disable (for AR, LARC and EXTH)
+ * @func_index: can only be EXTRA_FUNC_AR, EXTRA_FUNC_LARC or EXTRA_FUNC_EXTH
+ * @func_enable: can only be EXTRA_FUNC_DISABLE or EXTRA_FUNC_ENABLE
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+#define EXTRA_FUNC_AR 0
+#define EXTRA_FUNC_LARC 1
+#define EXTRA_FUNC_EXTH 2
+
+#define EXTRA_FUNC_DISABLE 0
+#define EXTRA_FUNC_ENABLE 1
+
+void llac_enc_set_extra_func(unsigned char func_index,
+    unsigned char func_enable,
+    unsigned char* llac_enc_mem_addr);
+
+
+bool llac_enc_get_extra_func(unsigned char func_index,
+                             unsigned char* llac_enc_mem_addr);
+
+/**
+ * LLAC:
+ * llac_enc_initial - do encoder initialization
+ * @sampleRate: sample rate of input file
+ * @nChannels: channel number of input file
+ * @bps_in: bit per sample of input file 
+ * @bps_out: bit per sample of output file
+ * @frame_ms: frame duration in millisecond
+ * @target_bitrate: targeted bitrate
+ * @nBytes: size of encoded output data in bytes
+ * @nSamples: number of sample per channel
+ * @real_bitrate: the actual bitrate that the encoder is gonna use
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+void llac_enc_initial(unsigned int sampleRate,
+                          short nChannels,
+                          short bps_in,
+                          short bps_out,
+                          float frame_ms,
+                          int target_bitrate,
+                          int* nBytes,
+                          unsigned int* nSamples,
+                          int* real_bitrate,
+                          unsigned char* llac_enc_mem_addr);
+
+
+/**
+ * LLAC:
+ * llac_enc_set_bitrate - set new bitrate (for autobitrate usage)
+ * @target_bitrate: targeted bitrate
+ * @nBytes: size of encoded output data in bytes
+ * @real_bitrate: the actual bitrate that the encoder is gonna use
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+void llac_enc_set_bitrate(int target_bitrate,
+    int* nBytes,
+    int* real_bitrate,
+    unsigned char* llac_enc_mem_addr);
+
+
+/**
+ * LLAC:
+ * llac_enc_process - do encode process for one frame
+ * @input: input buffer
+ * @output: output buffer
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ * Return:  size of encoded output data in bytes
+ */
+int llac_enc_process(int* input,
+                         unsigned char* output,
+                         unsigned char* llac_enc_mem_addr);
+
+
+/**
+ * LLAC:
+ * llac_enc_mem_free - release all the memory needed for LLAC encoder
+ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
+ */
+void llac_enc_mem_free(unsigned char* llac_enc_mem_addr);
+
+#endif /* LLAC_ENC_API_H */
\ No newline at end of file
diff --git a/external/liblhdc/libs/arm64-v8a/.gitkeep b/external/liblhdc/libs/arm64-v8a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdc/libs/armeabi-v7a/.gitkeep b/external/liblhdc/libs/armeabi-v7a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdc/release_note b/external/liblhdc/release_note
new file mode 100644
index 000000000..e8bde81d9
--- /dev/null
+++ b/external/liblhdc/release_note
@@ -0,0 +1,53 @@
+Release Note.
+=========================================================
+2022/07/20
+1. Upgrade LHDCV4 encoder version to V4.0.6
+
+2022/04/18
+1. Upgrade LHDCV4 encoder version to V4.0.4
+
+2021/11/15
+1. Add to print LHDC version and build time.
+2. Fix wrong AR effect.
+3. Fix when running LLAC, BT may crash after toggling AR UI on/off.
+
+2021/7/21
+Modify the calculation method to correct the number of frames per packet.
+
+2021/7/16
+Add AR version log on create.
+
+2021/7/6
+Add AR v1.1a.14 function.
+
+2021/7/5
+Add AR v1.1a.13 function.
+Support LHDCV4 AR on/off from app
+
+2021/7/1
+Add AR switch form app.
+
+2021/6/29
+Add AR v1.1a function.
+
+2021/3/12
+Update LHDC algorithm.
+
+2021/2/26
+Remove GPL license module.
+
+2020/7/10
+Fixed issue: The size of the encoded frame exceeded expectations.
+
+2020/5/28
+Updating the core of encoder to improve performance.
+
+2020/4/30
+1. Modify the frame size calculation method and refer to the encoding interval time so that the output size of 48KHz/24bits & LL enabled is lower than the packet size of 2DH3.
+
+2020/4/14
+1. Add new function to evaluate frame size and number of frames in a packet.
+2. Fix frame size evaluate not exactly.
+
+2020/3/9
+LHDC encoder library for android 10 r2 on MTK platform.
diff --git a/external/liblhdc/src/lhdcBT_enc.c b/external/liblhdc/src/lhdcBT_enc.c
new file mode 100644
index 000000000..5c4e15a31
--- /dev/null
+++ b/external/liblhdc/src/lhdcBT_enc.c
@@ -0,0 +1,1552 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcBT.h"
+#include "lhdc_process.h"
+#include "lhdc_cfg.h"
+#include "cirbuf.h"
+#include "llac_enc_api.h"
+
+
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "lhdcBT_enc"
+#include <cutils/log.h>
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+#define UP_RATE_TIME_CNT         3000  //Time about UP_RATE_TIME_CNT * 20ms
+#define DOWN_RATE_TIME_CNT       4  //Time about .... ex. DOWN_RATE_TIME_CNT * 20ms
+#define QUEUE_LENGTH_THRESHOLD   4
+
+#define LHDC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_lhdc)/sizeof(int))
+#define LLAC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_llac)/sizeof(int))
+#define LHDC_ABR_DEFAULT_BITRATE     (400)
+#define LLAC_ABR_DEFAULT_BITRATE     (400)
+
+#define AR_ALWAYS_ONx  1
+
+
+static const char * rate_to_string(LHDCBT_QUALITY_T q){
+    switch (q) {
+        case LHDCBT_QUALITY_LOW0:
+        return "LHDCBT_QUALITY_LOW0";
+        case LHDCBT_QUALITY_LOW1:
+        return "LHDCBT_QUALITY_LOW1";
+        case LHDCBT_QUALITY_LOW2:
+        return "LHDCBT_QUALITY_LOW2";
+        case LHDCBT_QUALITY_LOW3:
+        return "LHDCBT_QUALITY_LOW3";
+        case LHDCBT_QUALITY_LOW4:
+        return "LHDCBT_QUALITY_LOW4";
+        case LHDCBT_QUALITY_LOW:
+        return "LHDCBT_QUALITY_LOW";
+        case LHDCBT_QUALITY_MID:
+        return "LHDCBT_QUALITY_MID";
+        case LHDCBT_QUALITY_HIGH:
+        return "LHDCBT_QUALITY_HIGH";
+        case LHDCBT_QUALITY_AUTO:
+        return "LHDCBT_QUALITY_AUTO";
+        default:
+            ALOGE("%s: Incorrect quality(%d)",  __func__, q);
+        return "UNKNOW_QUALITY";
+    }
+}
+
+
+static int auto_bitrate_adjust_table_lhdc[] = {320, 350, 380, 440, 580, 600};
+static int auto_bitrate_adjust_table_llac[] = {136, 160, 192, 240, 320, 320};//7, 6, 5, 4, 3, 2
+
+static int bitrateFromIndex(lhdc_enc_type_t type, void * h, int index){
+
+    int limit = 0;
+    int result = 0;
+
+    if (type == ENC_TYPE_LHDC) {
+        lhdc_para_t * lhdc = (lhdc_para_t * )h;
+        limit = lhdc_util_get_bitrate((uint32_t)lhdc->limitBitRateStatus);
+        result = auto_bitrate_adjust_table_lhdc[index];
+    }else if (type == ENC_TYPE_LLAC) {
+        llac_para_t * llac = (llac_para_t * )h;
+        limit = lhdc_util_get_bitrate((uint32_t)llac->limitBitRateStatus);
+        result = auto_bitrate_adjust_table_llac[index];
+    }
+
+    return result >= limit ? limit : result;
+
+}
+
+static int bitrateIndexFrom(lhdc_enc_type_t type, size_t queueLength) {
+
+    uint32_t element_size = (type == ENC_TYPE_LHDC) ? LHDC_BITRATE_ELEMENTS_SIZE : LLAC_BITRATE_ELEMENTS_SIZE;
+
+    int newBitrateInx = 0;
+    if (queueLength < QUEUE_LENGTH_THRESHOLD) {
+        float queuePercenty = (1 - ((float)queueLength / QUEUE_LENGTH_THRESHOLD)) * (element_size - 1);
+        newBitrateInx = (int)queuePercenty;
+    }
+    return newBitrateInx;
+}
+
+//lhdcBT encHandle = NULL;
+static int indexOfBitrate(lhdc_enc_type_t type, void * h, int bitrate){
+    uint32_t element_size = type == ENC_TYPE_LHDC ? LHDC_BITRATE_ELEMENTS_SIZE : LLAC_BITRATE_ELEMENTS_SIZE;
+    for (size_t i = 0; i < element_size; i++) {
+        if (bitrateFromIndex(type, h, i) >= bitrate) {
+            return i;
+        }
+    }
+    return 0;
+}
+/*
+******************************************************************
+ LHDC functions group
+******************************************************************
+*/
+
+static void lhdc_encoder_set_max_bitrate(lhdc_para_t * handle, int max_rate_index) {
+    if (handle == NULL || max_rate_index == LHDCBT_QUALITY_AUTO){
+        ALOGE("%s: Error LHDC instance(%p), max rate(%d)",  __func__, handle, max_rate_index);
+        return;
+    }
+    if (max_rate_index != (int)handle->limitBitRateStatus){
+
+        handle->limitBitRateStatus = (LHDCBT_QUALITY_T)max_rate_index;
+
+        if ((uint32_t)handle->limitBitRateStatus != (uint32_t)handle->qualityStatus ){
+            if (handle->qualityStatus != LHDCBT_QUALITY_AUTO) {
+                handle->qualityStatus = handle->limitBitRateStatus;
+            }
+
+            int newRate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(handle->limitBitRateStatus), handle->hasMinBitrateLimit ? 320 : 128);
+
+            if (handle->lastBitrate >= newRate) {
+                handle->lastBitrate = newRate;
+
+                if (handle->version >= 2) {
+                    handle->updateFramneInfo = true;
+                }
+                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+                ALOGD("%s: Update Max target bitrate(%s)",  __func__, rate_to_string(handle->limitBitRateStatus));
+            }
+        }
+    }
+}
+
+
+static int lhdc_encoder_encode(lhdc_para_t * handle, void* p_pcm, unsigned char* p_stream){
+    if (handle) {
+        if (p_pcm == NULL || p_stream == NULL) {
+            ALOGE("%s: Buffer error! source(%p), output(%p)",  __func__, p_pcm, p_stream);
+            return 0;
+        }
+        int bytesSizePerBlock = 0;
+        int encodedSize = -1;
+        uint32_t block_size = handle->block_size;
+        bytesSizePerBlock = (block_size * (handle->bits_per_sample >> 3)) << 1;
+        encodedSize = LossyEncoderProcessWav(handle->fft_blk, (unsigned char *)p_pcm, block_size, 0, p_stream, bytesSizePerBlock);
+        return encodedSize;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return 0;
+}
+
+
+
+
+static int lhdc_encoder_set_bitrate(lhdc_para_t * handle, int bitrate_inx){
+    if (handle) {
+
+        if (bitrate_inx != (int)handle->qualityStatus) {
+
+            if (bitrate_inx != LHDCBT_QUALITY_AUTO) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(bitrate_inx), handle->hasMinBitrateLimit ? 320 : 128);
+            }else{
+                handle->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
+                lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
+                lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
+            }
+
+            handle->qualityStatus = bitrate_inx;
+
+            if ((uint32_t)handle->qualityStatus > (uint32_t)handle->limitBitRateStatus &&
+                handle->qualityStatus != LHDCBT_QUALITY_AUTO) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(handle->limitBitRateStatus), handle->hasMinBitrateLimit ? 320 : 128);
+                handle->qualityStatus = handle->limitBitRateStatus;
+            }
+        }
+        if (handle->version >= 2) {
+          handle->updateFramneInfo = true;
+        }
+        LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+        ALOGD("%s: Update target bitrate(%s)",  __func__, rate_to_string(handle->qualityStatus));
+        return 0;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return -1;
+}
+
+
+
+static int lhdc_encoder_adjust_bitrate(lhdc_para_t * handle, size_t queueLen) {
+    if (handle != NULL && handle->qualityStatus == LHDCBT_QUALITY_AUTO) {
+        if (handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT) {
+            /* code */
+            size_t queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
+
+            handle->dnBitrateSum = 0;
+            handle->dnBitrateCnt = 0;
+            int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
+
+            if (TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128) < handle->lastBitrate) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128);
+                if (handle->version >= 2) {
+                  handle->updateFramneInfo = true;
+                }
+                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+                ALOGD("%s:[Down BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
+            }else{
+              ALOGW("%s: Down bitrate condition fails, new rate:%d, current rate:%d",  __func__,
+                                    TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128),
+                                    handle->lastBitrate);
+            }
+        }
+
+        if (handle->upBitrateCnt >= UP_RATE_TIME_CNT) {
+            //clear down bitrate parameters...
+            size_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
+            uint32_t queuSumTmp = handle->upBitrateSum;
+
+            handle->upBitrateSum = 0;
+            handle->upBitrateCnt = 0;
+            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
+            uint32_t newBitrateInx = indexOfBitrate(ENC_TYPE_LHDC, handle, handle->lastBitrate);
+            if (newBitrateInx < (LHDC_BITRATE_ELEMENTS_SIZE - 1)) {
+                newBitrateInx++;
+            }
+
+            if (TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128) > handle->lastBitrate && queuSumTmp == 0) {
+                handle->lastBitrate = TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128);
+
+                if (handle->version >= 2) {
+                  handle->updateFramneInfo = true;
+                }
+                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
+                ALOGD("%s:[Up BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
+            }else{
+              ALOGW("%s: Up bitrate condition fails, new rate:%d, current rate:%d, sum of queue len:%d",  __func__,
+                                    TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128),
+                                    handle->lastBitrate,
+                                    queuSumTmp);
+            }
+        }
+
+
+        handle->upBitrateSum += queueLen;
+        handle->dnBitrateSum += queueLen;
+
+        handle->upBitrateCnt++;
+        handle->dnBitrateCnt++;
+
+        return 0;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return -1;
+}
+
+
+/*
+******************************************************************
+ LLAC functions group
+******************************************************************
+*/
+
+
+
+//kaiden:20210311:autobirate:llac_encoder_adjust_bitrate fucntion
+static int llac_encoder_adjust_bitrate(llac_para_t * handle, size_t queueLen) {
+
+    if (handle != NULL && handle->qualityStatus == LHDCBT_QUALITY_AUTO) {
+        if (handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT) {
+            /* code */
+            size_t queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
+
+            handle->dnBitrateSum = 0;
+            handle->dnBitrateCnt = 0;
+            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LLAC, queueLength);
+            if (queueLength)
+            {
+
+                int newBitrateInx = 0;
+                if (bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx) < handle->lastBitrate) {
+                    handle->lastBitrate = bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx);
+    
+                        llac_enc_set_bitrate(handle->lastBitrate * 1000, &handle->out_nbytes, &handle->real_bitrate, handle->lh4_enc);
+                        //handle->frame_per_packet = handle->host_mtu_size / handle->out_nbytes;
+                        handle->updateFramneInfo = true;
+    
+                        ALOGD("%s:[Down BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                        lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, handle);
+                    }else{
+                      ALOGW("%s: Down bitrate condition fails, new rate:%d, current rate:%d",  __func__,
+                                            bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx),
+                                            handle->lastBitrate);
+                }
+            }
+
+        }
+
+        if (handle->upBitrateCnt >= UP_RATE_TIME_CNT) {
+            //clear down bitrate parameters...
+            size_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
+            uint32_t queuSumTmp = handle->upBitrateSum;
+
+            handle->upBitrateSum = 0;
+            handle->upBitrateCnt = 0;
+            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
+            uint32_t newBitrateInx = indexOfBitrate(ENC_TYPE_LLAC, handle, handle->lastBitrate);
+            if (newBitrateInx < (LLAC_BITRATE_ELEMENTS_SIZE - 1)) {
+                newBitrateInx++;
+            }
+
+            if (bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx) > handle->lastBitrate && queuSumTmp == 0) {
+                handle->lastBitrate = bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx);
+
+                llac_enc_set_bitrate(handle->lastBitrate * 1000, &handle->out_nbytes, &handle->real_bitrate, handle->lh4_enc);
+                //handle->frame_per_packet = handle->host_mtu_size / handle->out_nbytes;
+                handle->updateFramneInfo = true;
+
+                ALOGD("%s:[Up BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
+                lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, handle);
+            }else{
+              ALOGW("%s: Up bitrate condition fails, new rate:%d, current rate:%d, sum of queue len:%d",  __func__,
+                                    bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx),
+                                    handle->lastBitrate,
+                                    queuSumTmp);
+            }
+        }
+
+
+        handle->upBitrateSum += queueLen;
+        handle->dnBitrateSum += queueLen;
+
+        handle->upBitrateCnt++;
+        handle->dnBitrateCnt++;
+
+        return 0;
+    }
+    ALOGE("%s: Handle error!(%p)",  __func__, handle);
+    return -1;
+}
+
+/*
+******************************************************************
+ LHDC library public functions group
+******************************************************************
+*/
+
+void lhdcBT_free_handle(HANDLE_LHDC_BT handle) {
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return;
+    }
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+        lhdc_encoder_free(lhdcBT->enc.lhdc);
+        break;
+        case ENC_TYPE_LLAC:
+        llac_encoder_free(lhdcBT->enc.llac);
+        break;
+        default:
+        break;
+    }
+
+    ar_process_free(lhdcBT->ar_filter);
+
+    free(lhdcBT);
+}
+
+
+HANDLE_LHDC_BT lhdcBT_get_handle(int version){
+    ALOGD("%s: Version number %d", __func__, version);
+
+    if(version <= 0)
+    {
+      return NULL;
+    }
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)malloc(sizeof(lhdc_cb_t));
+    memset(lhdcBT, 0 , sizeof(lhdc_cb_t));
+
+#ifdef AR_ALWAYS_ON
+    lhdcBT->ar_filter = ar_process_new();
+#else
+    if(version >= 3)
+    {
+        lhdcBT->ar_filter = ar_process_new();
+    }
+#endif
+
+    if (version <= 3)
+    {
+        lhdcBT->enc.lhdc = lhdc_encoder_new(version);
+        lhdcBT->enc_type = ENC_TYPE_LHDC;
+    }else if (version == 4){
+        lhdcBT->enc.llac = llac_encoder_new();
+        lhdcBT->enc_type = ENC_TYPE_LLAC;
+    }else{
+        lhdcBT->enc_type = ENC_TYPE_UNKNOWN;
+        free(lhdcBT);
+        lhdcBT = NULL;
+    }
+
+    return lhdcBT;
+}
+int lhdcBT_init_encoder(HANDLE_LHDC_BT handle,int sampling_freq, int bitPerSample, int bitrate_inx,
+    int dualChannel, int need_padding, int mtu, int interval) {
+
+    int result = 0;
+    unsigned int samples_per_frame = 0;
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+
+    if (sampling_freq != 44100 && sampling_freq != 48000 && sampling_freq != 96000)
+    {
+      ALOGE("%s: Invalid Sample Rate (%d)!!!", __func__, sampling_freq);
+      return -1;
+    }
+
+    if (bitPerSample != LHDCBT_SMPL_FMT_S16 && bitPerSample != LHDCBT_SMPL_FMT_S24)
+    {
+      ALOGE("%s: Invalid Bit Per Sample (%d)!!!", __func__, bitPerSample);
+      return -1;
+    }
+
+    if (bitrate_inx < LHDCBT_QUALITY_LOW0 || bitrate_inx >= LHDCBT_QUALITY_MAX)
+    {
+      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, bitrate_inx);
+      return -1;
+    }
+
+    if (dualChannel != 0 && dualChannel != 1)
+    {
+      ALOGE("%s: invalid Channel mode (%d)!!!", __func__, dualChannel);
+      return -1;
+    }
+
+    if (need_padding != 0)
+    {
+      ALOGE("%s: invalid need padding (%d)!!!", __func__, need_padding);
+      return -1;
+    }
+
+    if (mtu <= 0 || mtu >= 4096 )
+    {
+      ALOGE("%s: invalid mtu (%d)!!!", __func__, mtu);
+      return -1;
+    }
+
+    if (interval <= 0 || interval > 20) //default: 10ms or 20ms
+    {
+      ALOGE("%s: invalid interval (%d)!!!", __func__, interval);
+      return -1;
+    }
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+           result = lhdc_encoder_init(enc->lhdc, sampling_freq, bitPerSample, bitrate_inx, dualChannel, need_padding, mtu, interval);
+           samples_per_frame = lhdc_encoder_get_frame_len(enc->lhdc);
+           break;
+        case ENC_TYPE_LLAC:
+            result = llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            samples_per_frame = llac_encoder_get_frame_len(enc->llac);  
+           break;
+        default:
+        break;
+    }
+
+    if (result >= 0 && samples_per_frame > 0 && lhdcBT->ar_filter != NULL){
+        // number of channels is fixed to "2"
+        result = ar_process_init(lhdcBT->ar_filter, sampling_freq, bitPerSample, 2, samples_per_frame);
+    }
+
+    return result;
+}
+
+void lhdcBT_set_max_bitrate(HANDLE_LHDC_BT handle, int max_rate_index) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return;
+    }
+    if (max_rate_index < LHDCBT_QUALITY_LOW0 || max_rate_index >= LHDCBT_QUALITY_MAX)
+    {
+      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, max_rate_index);
+      return;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_set_max_bitrate(enc->lhdc, max_rate_index);
+        case ENC_TYPE_LLAC: {
+
+            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            ALOGD("%s: LLAC not supported", __func__);
+        }
+        default:
+        break;
+    }
+}
+
+
+int lhdcBT_encode(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* p_stream){
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (!p_pcm)
+    {
+        ALOGE("%s: p_pcm is NULL!!!", __func__);
+        return -1;
+    }
+    if (!p_stream)
+    {
+        ALOGE("%s: p_stream is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_encode(enc->lhdc, p_pcm, p_stream);
+
+        case ENC_TYPE_LLAC: {
+
+            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            ALOGD("%s: LLAC not supported", __func__);
+            break;
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+
+int lhdcBT_encodeV3(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_frames){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (p_pcm == NULL)
+    {
+        ALOGE("%s: input pcm buffer ptr is NULL!!!", __func__);
+        return -1;
+    }
+    if (out_put == NULL)
+    {
+        ALOGE("%s: output pcm buffer ptr is NULL!!!", __func__);
+        return -1;
+    }
+    if (written == NULL)
+    {
+        ALOGE("%s: written address is NULL!!!", __func__);
+        return -1;
+    }
+    if (out_frames == NULL)
+    {
+        ALOGE("%s: out_frames address is NULL!!!", __func__);
+        return -1;
+    }
+
+    return lhdc_util_encv4_process( handle, p_pcm, out_put, written, out_frames);
+}
+
+
+
+int lhdcBT_get_block_Size(HANDLE_LHDC_BT handle){
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_get_frame_len(enc->lhdc);
+
+        case ENC_TYPE_LLAC: {
+            return llac_encoder_get_frame_len(enc->llac);   //llac_encoder_encode(enc->llac, p_pcm, out_put, written, out_fraems);
+        }
+        default:
+        break;
+    }
+    return 0;
+}
+
+
+int lhdcBT_get_bitrate(HANDLE_LHDC_BT handle) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_get_target_bitrate(enc->lhdc);
+
+        case ENC_TYPE_LLAC: {
+            return llac_encoder_get_target_bitrate(enc->llac);  //llac_encoder_encode(enc->llac, p_pcm, out_put, written, out_fraems);
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+
+
+int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx){
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+
+    if(bitrate_inx < LHDCBT_QUALITY_LOW0 || bitrate_inx >= LHDCBT_QUALITY_MAX)
+    {
+      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, bitrate_inx);
+      return -1;
+    }
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC: {
+          lhdc_para_t *lhdc = enc->lhdc;
+          if(lhdc == NULL) {
+            ALOGD("%s: LHDC [Reset BiTrAtE] null ptr!",  __func__);
+            return -1;
+          }
+
+          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
+            if(lhdc->qualityStatus != LHDCBT_QUALITY_AUTO) {
+              ALOGD("%s: LHDC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, lhdc->qualityStatus);
+              return -1;
+            }
+            // change bitrate only, do not update qualityStatus
+            lhdc->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
+            lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, lhdc);
+            lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, lhdc);
+            if (lhdc->version >= 2) {
+              lhdc->updateFramneInfo = true;
+            }
+            LossyEncoderSetTargetByteRate(lhdc->fft_blk, (lhdc->lastBitrate * 1000) / 8);
+            ALOGD("%s: LHDC [Reset BiTrAtE] Reset bitrate to (%d)",  __func__, lhdc->lastBitrate);
+            return 0;
+          } else {
+            // normal case, will update qualityStatus
+            ALOGD("%s: LHDC set bitrate_inx %d", __func__, bitrate_inx);
+            return lhdc_encoder_set_bitrate(lhdc, bitrate_inx);
+          }
+        }
+
+        case ENC_TYPE_LLAC: {
+          llac_para_t * llac = enc->llac;
+          if(llac == NULL) {
+            ALOGD("%s: LLAC [Reset BiTrAtE] null ptr!",  __func__);
+            return -1;
+          }
+
+          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
+            if(llac->qualityStatus != LHDCBT_QUALITY_AUTO) {
+              ALOGD("%s: LLAC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, llac->qualityStatus);
+              return -1;
+            }
+            // change bitrate only, do not update qualityStatus
+            llac->lastBitrate = LLAC_ABR_DEFAULT_BITRATE;
+            ALOGD("%s: LLAC [Reset BiTrAtE] Reset bitrate to (%d)", __func__, llac->lastBitrate);
+            llac_enc_set_bitrate(llac->lastBitrate * 1000, &llac->out_nbytes, &llac->real_bitrate, llac->lh4_enc);
+            llac->updateFramneInfo = true;
+            lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, llac);
+            lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, llac);
+            return 0;
+          } else {
+            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+            ALOGD("%s: LLAC not supported", __func__);
+            return -1;
+          }
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+
+
+int lhdcBT_adjust_bitrate(HANDLE_LHDC_BT handle, size_t queueLen) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+
+    if (queueLen < 0)
+    {
+        ALOGE("%s: Invalid queue Len (%zu)!!!", __func__, queueLen);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            return lhdc_encoder_adjust_bitrate(enc->lhdc, queueLen);
+
+        case ENC_TYPE_LLAC: {
+            return llac_encoder_adjust_bitrate(enc->llac, queueLen);
+        }
+        default:
+        break;
+    }
+    return -1;
+}
+
+int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled,
+    void * priv /*nullable*/, int priv_data_len){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (field < LHDCBT_EXT_FUNC_AR || field >= LHDCBT_EXT_FUNC_MAX)
+    {
+        ALOGE("%s: invalid field (%d) !!!", __func__, field);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+//void LhdcExtFuncArEnable(FFT_BLOCK *fb, int enable_ar);
+//void LhdcExtFuncJasEnable(FFT_BLOCK *fb, int enable_Jas);
+//void LhdcExtFuncMetaEnable(FFT_BLOCK *fb, int enable_meta, unsigned char *pmeta_data, int meta_data_len, int conti_frame_cnt);
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+        {
+            switch((lhdc_ext_func_t)field){
+                case EXT_FUNC_AR:
+                LhdcExtFuncArEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
+                ALOGD("%s: lhdc AR func = %d", __func__, enabled);
+                return 0;
+                break;
+
+                case EXT_FUNC_JAS:
+                LhdcExtFuncJasEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
+                ALOGD("%s: lhdc JAS func = %d", __func__, enabled);
+                return 0;
+                break;
+
+                case EXT_FUNC_META:
+                if (!priv || !priv_data_len) {
+                    return -1;
+                }
+                LhdcExtFuncMetaEnable(enc->lhdc->fft_blk, enabled ? 1 : 0, priv, priv_data_len, 8);
+                ALOGD("%s: lhdc Meta func = %d", __func__, enabled);
+                return 0;
+                break;
+
+                default:
+                break;
+            }
+        }
+        break;
+
+        case ENC_TYPE_LLAC:
+        {
+            int8_t f_inx =  -1;
+            uint8_t f_enbaled = enabled ? 1 : 0;
+            switch((lhdc_ext_func_t)field){
+                case EXT_FUNC_AR:
+                f_inx = EXTRA_FUNC_AR;
+                break;
+
+                case EXT_FUNC_LARC:
+                f_inx = EXTRA_FUNC_LARC;
+                break;
+
+                default:
+                break;
+            }
+            if (f_inx >= 0)
+            {
+                ALOGD("%s: f_inx:%d, f_enbaled:%d, enc->llac->lh4_enc(%p)", __func__, f_inx, f_enbaled, enc->llac->lh4_enc);
+                llac_enc_set_extra_func(f_inx,
+                                        f_enbaled,
+                                        enc->llac->lh4_enc);
+                return 0;
+            }
+        }
+        break;
+
+        default:
+        break;
+    }
+
+    return -1;
+}
+
+int lhdcBT_get_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool * enabled){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    if (!enabled)
+    {
+        ALOGE("%s: enabled is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+    *enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, (lhdc_ext_func_t)field);
+
+
+    return 0;
+}
+
+int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled ){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGE("%s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+            ALOGD("%s:set value (%d)",  __func__, enabled);
+            enc->lhdc->hasMinBitrateLimit = enabled;
+            break;
+
+        case ENC_TYPE_LLAC: {
+            ALOGD("%s: ENC_TYPE_LLAC unsupported!!!", __func__);
+            break;
+        }
+        default:
+        break;
+    }
+
+    return 0;
+}
+
+/*
+******************************************************************
+ Extend API functions group
+******************************************************************
+*/
+
+//
+// META
+//
+static int lhdcBT_set_cfg_meta_v1(HANDLE_LHDC_BT handle, const char* userConfig, const int configLen) 
+{
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    PST_LHDC_SET_META pset_meta = (PST_LHDC_SET_META)userConfig;
+
+    unsigned char  *pmeta_metadata = NULL;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+	
+    if (configLen < (int) sizeof (ST_LHDC_SET_META))
+    {
+        // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small(req:%d)",  __func__, (int)sizeof(ST_LHDC_SET_META));
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+
+
+
+    if (pset_meta->meta_ver != META_ST_VER_V2)
+    {
+    	ALOGE("(LHDC-exAPI) %s: ver not match",  __func__);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+	
+    if (pset_meta->meta_mem_size != (int) sizeof (ST_LHDC_SET_META))
+    {
+    	ALOGE("(LHDC-exAPI) %s: mata size not match", __func__);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+
+    if (configLen < ((int) pset_meta->meta_metadata_length) + ((int) sizeof (ST_LHDC_SET_META)))
+    {
+    	ALOGE("(LHDC-exAPI) %s: cfg size too small", __func__);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type)
+    {
+    case ENC_TYPE_LHDC:
+        ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LHDC", __func__);
+        pmeta_metadata = (unsigned char*) (pset_meta + 1);
+
+        LhdcExtFuncMetaEnable(enc->lhdc->fft_blk, 
+                              pset_meta->meta_enable, 
+                              pmeta_metadata, 
+                              pset_meta->meta_metadata_length, 
+                              pset_meta->meta_set);
+        break;
+
+    case ENC_TYPE_LLAC:
+    	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LLAC", __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+
+    default:
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+    }
+
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+
+static int lhdcBT_get_cfg_meta_v1(HANDLE_LHDC_BT handle, char* userConfig, const int configLen) 
+{
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    PST_LHDC_GET_META pget_meta = (PST_LHDC_GET_META)userConfig;
+    bool jas_enabled = false;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (configLen < (int) sizeof (ST_LHDC_GET_META))
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small(req:%d)",  __func__, (int)sizeof(ST_LHDC_GET_META));
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type)
+    {
+    case ENC_TYPE_LHDC:
+        {
+        	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LHDC",  __func__);
+			pget_meta->meta_ver = META_ST_VER_V2;
+			pget_meta->meta_mem_size = (int) sizeof (ST_LHDC_GET_META);
+			pget_meta->meta_st = (LhdcGetExtFuncState(enc->lhdc->fft_blk, EXT_FUNC_META) << 1) | 0x01;  // Get current frame include metadata or not
+
+			//2021/06/10: Append JAS status her ,let UI can get JAS status from LHDC,
+			jas_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_JAS);
+			if(jas_enabled)
+			{
+				pget_meta->jas_status = 1;
+			}
+			else
+			{
+				pget_meta->jas_status = 0;
+			}
+        }
+        break;
+
+    case ENC_TYPE_LLAC:
+    	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LLAC",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+
+    default:
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        break;
+    }
+
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+
+//
+// AR
+//
+static int Ar_set_ext_func_state(HANDLE_LHDC_BT handle, bool enabled){
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+    if (!lhdcBT)
+    {
+        ALOGD("(LHDC-exAPI) %s: Handle is NULL!!!", __func__);
+        return -1;
+    }
+    enc_t * enc = &lhdcBT->enc;
+
+    switch(lhdcBT->enc_type){
+        case ENC_TYPE_LHDC:
+        {
+            LhdcExtFuncArEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
+            ALOGD("(LHDC-exAPI) %s: lhdc AR func = %d", __func__, enabled);
+        }
+        break;
+        case ENC_TYPE_LLAC:
+        {
+            int8_t f_inx = EXTRA_FUNC_AR;
+            uint8_t f_enbaled = enabled ? 1 : 0;
+            ALOGD("(LHDC-exAPI) %s: f_enbaled:%d, enc->llac->lh4_enc(%p)", __func__, f_enbaled, enc->llac->lh4_enc);
+            llac_enc_set_extra_func(f_inx, f_enbaled, enc->llac->lh4_enc);
+        }
+        break;
+        default:
+        break;
+    }
+    return 0;
+}
+
+static int lhdcBT_set_data_gyro_2d_v1(HANDLE_LHDC_BT handle, const char *userData, const int dataLen) {
+
+    PST_LHDC_AR_GYRO pargyro = (PST_LHDC_AR_GYRO) userData;
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+
+    enc_t * enc = &lhdcBT->enc;
+
+    bool ar_enabled = false;
+
+    int res;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userData == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Data error!(%p)",  __func__, userData);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (dataLen < (int) sizeof (ST_LHDC_AR_GYRO))
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+	ALOGD("(LHDC-exAPI) %s: gyro[%d %d %d]",  __func__,
+			pargyro->world_coordinate_x, pargyro->world_coordinate_y, pargyro->world_coordinate_z);
+
+    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
+
+#ifdef AR_ALWAYS_ON
+    ar_enabled = true;
+#endif
+
+    if (ar_enabled)
+    {
+        res = ar_set_gyro_pos(lhdcBT->ar_filter, pargyro->world_coordinate_x, pargyro->world_coordinate_y, pargyro->world_coordinate_z);
+    }
+    else
+    {
+        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+
+    if(res != 0)
+    {
+    	ALOGD("(LHDC-exAPI) %s: set_gyro_pos error(%d)",  __func__, res);
+        return EXTEND_FUNC_RET_ERROR;
+    }
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+
+static int lhdcBT_set_cfg_ar_v3(HANDLE_LHDC_BT handle, const char *userConfig, const int configLen) {
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+
+    enc_t * enc = &lhdcBT->enc;
+
+    PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR)userConfig;
+
+    bool ar_enabled = false;
+
+    int res;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (configLen < (int) sizeof (ST_LHDC_AR))
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+    ALOGD("(LHDC-exAPI) %s: config AR %d",  __func__, pset_ar_cfg->app_ar_enabled);
+
+    ar_enabled = pset_ar_cfg->app_ar_enabled ? 1 : 0;
+
+    Ar_set_ext_func_state(handle, ar_enabled);
+    //LhdcExtFuncArEnable(enc->lhdc->fft_blk, pset_ar_cfg->app_ar_enabled ? 1 : 0);
+
+    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
+
+    ALOGD("(LHDC-exAPI) %s: AR enabled %d",  __func__, ar_enabled);
+
+#ifdef AR_ALWAYS_ON
+    ar_enabled = true;
+#endif
+
+    if (ar_enabled)
+    {
+        res = ar_set_cfg(lhdcBT->ar_filter, &pset_ar_cfg->Ch1_Pos, &pset_ar_cfg->Ch1_L_PreGain, pset_ar_cfg->app_ar_enabled);
+    }
+    else
+    {
+        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+
+    if(res != 0)
+    {
+        return EXTEND_FUNC_RET_ERROR;
+    }
+
+    return EXTEND_FUNC_RET_OK;
+}
+
+	
+static int lhdcBT_get_cfg_ar_v1(HANDLE_LHDC_BT handle, char *userConfig, const int configLen) {
+
+    //PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR)userConfig;
+
+    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
+
+    enc_t * enc = &lhdcBT->enc;
+
+    bool ar_enabled = false;
+
+
+    int res = 0;
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (configLen <= (int) 0)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
+
+#ifdef AR_ALWAYS_ON
+    ar_enabled = true;
+#endif
+
+    if (ar_enabled)
+    {
+    	ALOGD("(LHDC-exAPI) %s: AR enabled",  __func__);
+    	//2021/11/09: ar_get_cfg not supported yet
+        //res = ar_get_cfg(lhdcBT->ar_filter, &pset_ar_cfg->Ch1_Pos, &pset_ar_cfg->Ch1_L_PreGain);
+    	return EXTEND_FUNC_RET_ERROR;
+    }
+    else
+    {
+        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+
+    if(res != 0)
+    {
+        return EXTEND_FUNC_RET_ERROR;
+    }
+
+    ALOGD("(LHDC-exAPI) %s: End OK",  __func__);
+    return EXTEND_FUNC_RET_OK;	
+}
+
+
+
+/*
+******************************************************************
+ Extend API library public functions group
+******************************************************************
+*/
+
+// 1. API -- Set User Config (Extend)
+int lhdcBT_set_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen) {
+
+    unsigned char *pucConfig = (unsigned char *) userConfig;
+    unsigned int exFuncVer;
+    unsigned int exFuncCode;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+               ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+               ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+               ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+    exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    case EXTEND_FUNC_CODE_SET_CONFIG_META:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_SET_CONFIG_META_V1:
+        	ALOGD("(LHDC-exAPI) %s: SET_CONFIG_META\n",  __func__);
+            result = lhdcBT_set_cfg_meta_v1 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+		
+    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_SET_CONFIG_AR_V3:
+        	ALOGD("(LHDC-exAPI) %s: SET_CONFIG_AR\n",  __func__);
+            result = lhdcBT_set_cfg_ar_v3 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    return result;
+}
+
+
+// 2. API -- Get User Config (Extend)
+int lhdcBT_get_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen) {
+
+
+    unsigned char *pucConfig = (unsigned char *) userConfig;
+    unsigned int exFuncVer;
+    unsigned int exFuncCode;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("%s:(LHDC-exAPI) enter\n",  __func__);
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userConfig == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+               ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+               ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+               ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+    exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    case EXTEND_FUNC_CODE_GET_CONFIG_META:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_GET_CONFIG_META_V1:
+        	ALOGD("(LHDC-exAPI) %s: GET_CONFIG_META\n",  __func__);
+            result = lhdcBT_get_cfg_meta_v1 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_GET_CONFIG_AR_V1:
+        	ALOGD("(LHDC-exAPI) %s: GET_CONFIG_AR\n",  __func__);
+            result = lhdcBT_get_cfg_ar_v1 (handle, userConfig, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+        }
+        break;
+
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    return result;
+
+}
+
+// 3. API -- Set User Data (Extend)
+void lhdcBT_set_user_exdata(HANDLE_LHDC_BT handle, char* userData, int clen) {
+
+    unsigned char *pucData = (unsigned char *) userData;
+    unsigned int exFuncVer;
+    unsigned int exFuncCode;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return; // EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (userData == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: User Data error!(%p)",  __func__, userData);
+        return; // EXTEND_FUNC_RET_INVALID_PARAMETER;		
+    }
+
+    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return;
+    }
+
+    exFuncVer = (((unsigned int) pucData[3]) & ((unsigned int)0xff)) |
+               ((((unsigned int) pucData[2]) & ((unsigned int)0xff)) << 8)  |
+               ((((unsigned int) pucData[1]) & ((unsigned int)0xff)) << 16) |
+               ((((unsigned int) pucData[0]) & ((unsigned int)0xff)) << 24);
+    exFuncCode = (((unsigned int) pucData[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucData[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucData[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucData[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+	
+        switch (exFuncVer) {
+        case EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1:
+        	ALOGD("(LHDC-exAPI) %s: SET_DATA_GYRO\n",  __func__);
+            result = lhdcBT_set_data_gyro_2d_v1 (handle, userData, clen);
+            break;
+
+        default:
+            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+            return; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+        }
+        break;
+		
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    //return result;
+}
+
+
+// 4. API -- Get Version
+int lhdcBT_get_user_exApiver(HANDLE_LHDC_BT handle, char *version, int clen) {
+
+    unsigned char *pucApiVer = (unsigned char *) version;
+    unsigned int exFuncVer = 0;
+    unsigned int exFuncCode = 0;
+    unsigned int exFuncMinBufSize = 0;
+    int result = EXTEND_FUNC_RET_OK;
+
+    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
+
+    if (version == NULL)
+    {
+        ALOGE("(LHDC-exAPI) %s: API verion buffer error!(%p)",  __func__, version);
+        return EXTEND_FUNC_RET_INVALID_PARAMETER;
+    }
+
+    if (handle == NULL) {
+        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
+        return EXTEND_FUNC_RET_INVALID_HANDLE;
+    }
+
+    if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V1)
+    {
+         // Buffer is to small
+    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
+        return EXTEND_FUNC_RET_BUF_UNDERRUN;
+    }
+
+    /*
+    ALOGD("%s: clen=%d, APICode[4:7] = [0x%02X, 0x%02X, 0x%02X, 0x%02X]",  __func__,
+        clen, pucApiVer[4], pucApiVer[5], pucApiVer[6], pucApiVer[7]);
+        */
+
+    exFuncCode = (((unsigned int) pucApiVer[7]) & ((unsigned int)0xff)) |
+                ((((unsigned int) pucApiVer[6]) & ((unsigned int)0xff)) << 8)  |
+                ((((unsigned int) pucApiVer[5]) & ((unsigned int)0xff)) << 16) |
+                ((((unsigned int) pucApiVer[4]) & ((unsigned int)0xff)) << 24);
+
+    switch (exFuncCode) {
+    // Config API
+    case EXTEND_FUNC_CODE_SET_CONFIG_META:
+        exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_META_V1;
+        break;
+
+    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+        exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_AR_V3;
+        break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_META:
+        exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_META_V1;
+        break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+        exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_AR_V1;
+        break;
+
+    // Data API
+    case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+        exFuncVer = EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1;
+        break;
+
+    // A2DP codec Specific API
+    case EXTEND_FUNC_CODE_GET_SPECIFIC:
+        exFuncVer = EXTEND_FUNC_VER_GET_SPECIFIC_V2;
+        exFuncMinBufSize = LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2;
+        break;
+
+    default:
+        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    } // switch (exFuncCode)
+
+    /* fill in current version of target API */
+    pucApiVer[3] = (unsigned char) (exFuncVer & ((unsigned int)0xff));
+    pucApiVer[2] = (unsigned char) ((exFuncVer >> 8) & ((unsigned int)0xff));
+    pucApiVer[1] = (unsigned char) ((exFuncVer >> 16) & ((unsigned int)0xff));
+    pucApiVer[0] = (unsigned char) ((exFuncVer >> 24) & ((unsigned int)0xff));
+
+    /**** Version Control Field: *****/
+    if(exFuncVer >= EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2 &&
+        clen >= EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V2)
+    {
+      /* After API V2.0.0.0, append "minimum required buffer size" into API response */
+      pucApiVer[11] = (unsigned char) (exFuncMinBufSize & ((unsigned int)0xff));
+      pucApiVer[10] = (unsigned char) ((exFuncMinBufSize >> 8) & ((unsigned int)0xff));
+      pucApiVer[9] = (unsigned char) ((exFuncMinBufSize >> 16) & ((unsigned int)0xff));
+      pucApiVer[8] = (unsigned char) ((exFuncMinBufSize >> 24) & ((unsigned int)0xff));
+    }
+
+    ALOGD("(LHDC-exAPI) %s: return Ver=0x[%02X %02X %02X %02X]",  __func__,
+        pucApiVer[4], pucApiVer[5], pucApiVer[6], pucApiVer[7]);
+
+    return result;
+}
+
diff --git a/external/liblhdcdec/Android.bp b/external/liblhdcdec/Android.bp
new file mode 100644
index 000000000..eb12d27c0
--- /dev/null
+++ b/external/liblhdcdec/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdcdec",
+
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdcdec.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdcdec.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcBT_dec",
+   // vendor_available: true,
+   // vndk: {
+   //     enabled: true,
+   // },
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcBT_dec.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdcdec",
+    ],
+}
diff --git a/external/liblhdcdec/inc/lhdcBT_dec.h b/external/liblhdcdec/inc/lhdcBT_dec.h
new file mode 100644
index 000000000..97beb5ed1
--- /dev/null
+++ b/external/liblhdcdec/inc/lhdcBT_dec.h
@@ -0,0 +1,41 @@
+
+
+#ifndef _LHDCBT_DEC_H_
+#define _LHDCBT_DEC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lhdcUtil.h"
+
+
+
+typedef struct  
+{
+  lhdc_ver_t version;
+  uint32_t   sample_rate;
+  uint8_t    bits_depth;
+} tLHDCV3_DEC_CONFIG;
+
+
+
+int lhdcBT_dec_init_decoder(tLHDCV3_DEC_CONFIG *config);
+int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+int lhdcBT_dec_deinit_decoder(void);
+
+
+#define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
+#define LHDCBT_DEC_UPD_SEQ_NO				1
+
+
+#define LHDCBT_DEC_FUNC_SUCCEED             0
+#define LHDCBT_DEC_FUNC_FAIL                -1
+#define LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH    -2
+#define LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH   -3
+#define LHDCBT_DEC_FUNC_INVALID_SEQ_NO		-4
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_DEC_H_ */
diff --git a/external/liblhdcdec/include/lhdcUtil.h b/external/liblhdcdec/include/lhdcUtil.h
new file mode 100644
index 000000000..6a08e540b
--- /dev/null
+++ b/external/liblhdcdec/include/lhdcUtil.h
@@ -0,0 +1,101 @@
+/*
+ * lhdcUtil.h
+ *
+ *  Created on: 2001/1/3
+ *      Author: eric.lee
+ */
+
+#ifndef LHDC_UTIL_H
+#define LHDC_UTIL_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+
+
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+// Copy definition from external
+#define BTIF_BD_ADDR_SIZE    6
+
+
+// Define for LHDC stream type.
+typedef enum {
+    LHDC_STRM_TYPE_COMBINE,
+    LHDC_STRM_TYPE_SPLIT
+}LHDC_STRM_TYPE;
+
+typedef enum {
+  VERSION_2 = 200,
+  VERSION_3 = 300,
+  VERSION_4 = 400,
+  VERSION_LLAC = 500
+}lhdc_ver_t;
+
+typedef enum {
+  LHDCV2_BLOCK_SIZE = 512,
+  LHDCV3_BLOCK_SIZE = 256,
+}lhdc_block_size_t;
+
+typedef struct savi_bt_local_info_t{
+    uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
+    const char *bt_name;
+    uint8_t bt_len;
+    uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
+    const char *ble_name;
+    uint8_t ble_len;
+}savi_bt_local_info;
+
+typedef struct _lhdc_frame_Info
+{
+    uint32_t frame_len; //  frame  frame 
+    uint32_t isSplit;   // 
+    uint32_t isLeft;    //  == true  == false
+
+} lhdc_frame_Info_t;
+
+
+typedef enum {
+    LHDC_OUTPUT_STEREO = 0,
+    LHDC_OUTPUT_LEFT_CAHNNEL,
+    LHDC_OUTPUT_RIGHT_CAHNNEL,
+} lhdc_channel_t;
+
+typedef int LHDCSample;
+
+typedef void (*print_log_fp)(char*  msg);
+typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
+
+
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
+
+#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
+
+
+void lhdcInit(uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+
+uint32_t lhdcDecodeProcess(uint8_t * pOutBuf, uint8_t * pInput, uint32_t len);
+bool lhdcSetLicenseKeyTable(uint8_t * licTable, LHDC_GET_BT_INFO pFunc);
+void lhdcSetLicenseKeyChkPeriod (uint8_t period);
+char * getVersionCode();
+
+void lhdcDestroy();
+
+void lhdc_register_log_cb(print_log_fp cb);
+
+uint32_t lhdcGetSampleSize( void);
+bool lhdcFetchFrameInfo(uint8_t * frameData, lhdc_frame_Info_t * frameInfo);
+
+uint32_t lhdcChannelSelsect(lhdc_channel_t channel_type);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* End of LHDC_UTIL_H */
diff --git a/external/liblhdcdec/libs/arm64-v8a/.gitkeep b/external/liblhdcdec/libs/arm64-v8a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdcdec/libs/armeabi-v7a/.gitkeep b/external/liblhdcdec/libs/armeabi-v7a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdcdec/release_note b/external/liblhdcdec/release_note
new file mode 100644
index 000000000..5a42cb9e0
--- /dev/null
+++ b/external/liblhdcdec/release_note
@@ -0,0 +1,8 @@
+Release Note.
+=========================================================
+2022/05/11
+1. Upgrade LHDCV4 decoder version to V4.0.2
+
+2021/11/22
+Add LHDC v3/v4 Decoder
+
diff --git a/external/liblhdcdec/src/lhdcBT_dec.c b/external/liblhdcdec/src/lhdcBT_dec.c
new file mode 100644
index 000000000..fa20c66b8
--- /dev/null
+++ b/external/liblhdcdec/src/lhdcBT_dec.c
@@ -0,0 +1,405 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcBT_dec.h"
+
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "lhdcBT_dec"
+#include <cutils/log.h>
+
+static uint8_t serial_no = 0xff;
+
+static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len, uint8_t **pLout, uint32_t *pLlen, int upd_seq_no);
+
+// description
+//   a function to log information in LHDC decoder library
+// Parameter
+//   config: configuration data for LHDC v4 decoder
+// return:
+//   == 0: succeed
+//   < 0: error
+static void print_log_cb(char*  msg)
+{
+	if (msg == NULL)
+	{
+		return;
+	}
+
+    ALOGD("[WL50-ex] %s: %s", __func__, msg);
+}
+
+// description
+//   init. LHDC v4 decoder 
+// Parameter
+//   config: configuration data for LHDC v4 decoder
+// return:
+//   == 0: succeed
+//   < 0: error
+int lhdcBT_dec_init_decoder(tLHDCV3_DEC_CONFIG *config)
+{
+	//ALOGD("[WL50] %s: enter", __func__);
+    if (config == NULL)
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    //ALOGD("[WL50] %s: bits_depth:%d sample_rate=%d version=%d", __func__,	config->bits_depth, config->sample_rate, config->version);
+
+    if ((config->bits_depth != 16) && (config->bits_depth != 24))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    if ((config->sample_rate != 44100) && (config->sample_rate != 48000) &&
+	    (config->sample_rate != 96000))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    if ((config->version != VERSION_3) && (config->version != VERSION_4) &&
+	    (config->version != VERSION_LLAC))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+	lhdc_register_log_cb(&print_log_cb);
+
+    //ALOGD("[WL50] %s: start lhdcInit..", __func__);
+    lhdcInit(config->bits_depth, config->sample_rate, 400000, config->version);
+
+    lhdcChannelSelsect(LHDC_OUTPUT_STEREO);
+
+    serial_no = 0xff;
+    //ALOGD("[WL50] %s: end", __func__);
+	return LHDCBT_DEC_FUNC_SUCCEED;
+}
+
+
+
+// description
+//   check whether all frames of one packet are in buffer?
+// Parameter
+//   frameData: pointer to input buffer
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+// return:
+//   == 0: succeed
+//   < 0: error
+int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes)
+{
+	uint8_t *frameDataStart = (uint8_t *)frameData;
+    uint8_t *in_buf = NULL;
+    uint32_t in_len = 0;
+	uint32_t frame_num = 0;
+	lhdc_frame_Info_t lhdc_frame_Info;
+	uint32_t ptr_offset = 0;
+	bool fn_ret;
+
+
+    ALOGD("[WL50] %s: enter, frameBytes (%d)", __func__, (int)frameBytes);
+
+	if ((frameData == NULL) || (packetBytes == NULL))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+	
+	*packetBytes = 0;
+
+    frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len, LHDCBT_DEC_NOT_UPD_SEQ_NO);
+    if (frame_num == 0)
+	{
+        ALOGD("%s: assemble_lhdc_packet (%d)", __func__, (int)frame_num);
+		return LHDCBT_DEC_FUNC_SUCCEED;
+	}
+	//else if (frame_num < 0)
+	//{
+	//	// Fail to check packet header (including invalid packet number)!
+	//	return frame_num;
+	//}
+	
+	ALOGD("[WL50] %s: in_buf (%p), frameData (%p), in_len (%d), frame_num (%d)", __func__, in_buf, frameData, (int)in_len, (int) frame_num);
+	
+	ptr_offset = 0;
+
+	while ((frame_num > 0) && (ptr_offset < in_len))
+	{
+		fn_ret = lhdcFetchFrameInfo (in_buf + ptr_offset, &lhdc_frame_Info);
+		if (fn_ret == false)
+		{
+			ALOGD("[WL50] %s: lhdcFetchFrameInfo(%d) fail..", __func__, (int)frame_num);
+			return LHDCBT_DEC_FUNC_FAIL;
+		}
+		
+		ALOGD("[WL50] %s: lhdcFetchFrameInfo  frame_num (%d), ptr_offset (%d), lhdc_frame_Info.frame_len (%d), in_len (%d)", __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
+		
+		if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len)
+		{
+			ALOGD("[WL50] %s: Not Enough... frame_num(%d), ptr_offset(%d), frame_len(%d), in_len (%d)", __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
+			return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
+		}
+
+        ptr_offset += lhdc_frame_Info.frame_len;
+
+        frame_num--;
+	}
+
+
+	*packetBytes = ptr_offset;
+
+    ALOGD("[WL50] %s: end ", __func__);
+    return LHDCBT_DEC_FUNC_SUCCEED;
+
+}
+
+
+/*
+	uint8_t llac_test_ptn[0x100] = {
+		0x90, 0x01, 0x04, 0xF7, 0x7C, 0x65, 0xEA, 0x83, 
+		0xBB, 0x66, 0x4B, 0xA0, 0xF6, 0x51, 0xB8, 0x48, 
+		0x0C, 0xE7, 0x9D, 0xB9, 0x3B, 0x28, 0x0E, 0x82, 
+		0x73, 0xC6, 0xD7, 0xF9, 0xFC, 0x60, 0x34, 0xA9, 
+		0xEA, 0x46, 0x03, 0xD4, 0xA9, 0x63, 0x41, 0x30, 
+		0x37, 0x54, 0xBF, 0x47, 0x61, 0xAD, 0x7A, 0xB7, 
+		0xF0, 0x6E, 0x49, 0x00, 0xC7, 0xF9, 0xC6, 0x23, 
+		0x99, 0x01, 0xA1, 0x08, 0x79, 0xF4, 0x53, 0xC2, 
+		0xDF, 0xD8, 0x6F, 0x81, 0xB9, 0x8D, 0x65, 0x71, 
+		0xA2, 0x77, 0xF7, 0x0C, 0x65, 0x2D, 0x78, 0x80, 
+		0xA8, 0xBA, 0xC0, 0xA0, 0xD4, 0x98, 0xB4, 0xF5, 
+		0xB3, 0x6C, 0x61, 0x14, 0xD4, 0x93, 0xA5, 0x2D, 
+		0x07, 0x4D, 0x49, 0x1B, 0x78, 0x9F, 0x4E, 0xC7, 
+		0x28, 0x15, 0x35, 0x2E, 0x00, 0x44, 0xD5, 0x62, 
+		0xA3, 0x95, 0x86, 0xE4, 0xDC, 0x9E, 0xD7, 0xAC, 
+		0xC0, 0x90, 0x6D, 0x62, 0xED, 0xBA, 0x4A, 0x89, 
+		0xAE, 0x7F, 0x50, 0xC6, 0xAD, 0x57, 0xBA, 0x47, 
+		0xBA, 0x45, 0xEC, 0x0F, 0x99, 0xA6, 0xA0, 0x3F, 
+		0xBD, 0x14, 0xAA, 0xBD, 0x74, 0x5B, 0x49, 0x7E, 
+		0xF9, 0xD1, 0xB7, 0x6A, 0x4F, 0xF3, 0x31, 0xD9, 
+		0x3D, 0x79, 0xBF, 0x79, 0x1C, 0x99, 0x74, 0xD7, 
+		0x1B, 0x3B, 0x04, 0xF9, 0x61, 0xB4, 0xC3, 0x7B, 
+		0x86, 0x6B, 0x5A, 0x6F, 0xAD, 0x95, 0xB2, 0xD7, 
+		0x6D, 0xCC, 0xC8, 0x33, 0x0D, 0x87, 0xC6, 0x06, 
+		0xFC, 0xD1, 0x17, 0x8C, 0xD0, 0x33, 0x37, 0x55, 
+		0xA1, 0x07, 0x6F, 0x70, 0xD1, 0x97, 0x2A, 0x97, 
+		0x44, 0xE8, 0x8A, 0xBA, 0xC1, 0x28, 0xA9, 0x23, 
+		0x54, 0xD8, 0x89, 0x63, 0x56, 0x8B, 0x32, 0xA6, 
+		0x38, 0xA1, 0xFA, 0x83, 0x87, 0x2A, 0x2B, 0x6F, 
+		0xD7, 0x8E, 0x18, 0x79, 0xEC, 0x53, 0xAE, 0x10, 
+		0xC8, 0xF6, 0x49, 0xD7, 0xA2, 0xC5, 0x00, 0xED, 
+		0x62, 0xFD, 0xBA, 0x48, 0x00, 0x00, 0x00, 0x00};
+	uint8_t llac_ptn[0x100];
+*/
+
+// description
+//   decode all frames in one packet
+// Parameter
+//   frameData: pointer to input buffer
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+//   pcmData: pointer to output buffer
+//   pcmBytes: length (bytes) of pcm samples in output buffer
+// return:
+//   == 0: succeed
+//   < 0: error
+int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth)
+{
+	uint8_t *frameDataStart = (uint8_t *)frameData;
+    uint32_t dec_sum = 0;
+	uint32_t lhdc_out_len = 0;
+    uint8_t *in_buf = NULL;
+    uint32_t in_len = 0;
+	uint32_t frame_num = 0;
+	lhdc_frame_Info_t lhdc_frame_Info;
+	uint32_t ptr_offset = 0;
+	bool fn_ret;
+    uint32_t frame_samples;
+	uint32_t frame_bytes;
+	uint32_t pcmSpaceBytes;
+
+    //ALOGD("[WL50] %s: enter, assemble_lhdc_packet(frameBytes %d)", __func__, (int)frameBytes);
+
+    if ((frameData == NULL) || 
+	    (pcmData == NULL) ||
+		(pcmBytes == NULL))
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    pcmSpaceBytes = *pcmBytes;
+	*pcmBytes = 0;
+
+/*
+    if(frameBytes >= 16)
+    {
+		for(int i=0; i<16; i++)
+		{
+			ALOGD("[WL50] %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+		}
+    }
+    else
+    {
+		for(int i=0; i<(int)frameBytes; i++)
+		{
+			ALOGD("[WL50] %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+		}
+    }
+*/
+
+    frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len, LHDCBT_DEC_UPD_SEQ_NO);
+    if (frame_num == 0)
+	{
+		return LHDCBT_DEC_FUNC_SUCCEED;
+	}
+	//ALOGD("[WL50] %s: frameData=0x%p, in_buf=0x%p, in_len=%d", __func__, frameData, in_buf, in_len);
+    //ALOGD("[WL50] %s: get frame_num=%d", __func__, (int)frame_num);
+
+    frame_samples = lhdcGetSampleSize ();
+	if (bits_depth == 16)
+	{
+		frame_bytes = frame_samples * 2 * 2;
+	}
+	else
+	{
+		frame_bytes = frame_samples * 4 * 2;
+	}
+    ALOGD("[WL50] %s: frame_samples=%d", __func__, (int)frame_samples);
+
+    ptr_offset = 0;
+    dec_sum = 0;
+
+	while ((frame_num > 0) && (ptr_offset < in_len))
+	{
+		fn_ret = lhdcFetchFrameInfo (in_buf + ptr_offset, &lhdc_frame_Info);
+		if (fn_ret == false)
+		{
+			//ALOGD("[WL50] %s: lhdcFetchFrameInfo(%d) fail..", __func__, (int)frame_num);
+			return LHDCBT_DEC_FUNC_FAIL;
+		}
+
+		if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len)
+		{
+			return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
+		}
+
+		if ((dec_sum + frame_bytes) > pcmSpaceBytes)
+		{
+			return LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH;
+		}
+
+ 		//ALOGD("[WL50] %s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
+        lhdc_out_len = lhdcDecodeProcess(((uint8_t *)pcmData) + dec_sum, in_buf + ptr_offset, lhdc_frame_Info.frame_len);
+        //ALOGD("[WL50] %s: lhdcDecodeProcess(frm=%d, frame_len=%d out_len=%d)..", __func__, (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
+
+        //if (lhdc_out_len % frame_samples)
+        //{
+        //    TRACE_A2DP_DECODER_I("[CP][LHDC]error!!! dec_sum: %d decode_temp: %d", dec_sum, lhdc_decode_temp);
+        //    return LHDCBT_DEC_FUNC_FAIL;
+        //}
+
+        ptr_offset += lhdc_frame_Info.frame_len;
+        dec_sum += lhdc_out_len;
+
+        frame_num--;
+	}
+
+    *pcmBytes = (uint32_t) dec_sum;
+
+    //ALOGD("[WL50] %s: end (dec_sum=%d pcmBytes=%d)", __func__, (int)dec_sum, (int)*pcmBytes);
+    return LHDCBT_DEC_FUNC_SUCCEED;
+}
+
+
+// description
+//   de-initialize (free) all resources allocated by LHDC v4 decoder
+// Parameter
+//   none
+// return:
+//   == 0: succceed
+int lhdcBT_dec_deinit_decoder(void)
+{
+	ALOGD("[WL50] %s: enter", __func__);
+    lhdcDestroy();
+
+    return LHDCBT_DEC_FUNC_SUCCEED;
+}
+
+// description
+//   check number of frames in one packet and return pointer to first byte of 1st frame in current packet
+// Parameter
+//   input: pointer to input buffer
+//   input_len: length (bytes) of input buffer pointed by input
+//   pLout: pointer to pointer to output buffer
+//   pLlen: length (bytes) of encoded stream in output buffer
+// return:
+//   > 0: number of frames in current packet
+//   == 0: No frames in current packet
+//   < 0: error
+static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len, uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
+{
+    uint8_t hdr = 0, seqno = 0xff;
+    int ret = LHDCBT_DEC_FUNC_FAIL;
+    uint32_t status = 0;
+	uint32_t lhdc_total_frame_nb = 0;
+
+
+    if ((input == NULL) || 
+		(pLout == NULL) || 
+		(pLlen == NULL)) 
+	{
+
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+	
+	if (input_len < 2)
+	{
+		return LHDCBT_DEC_FUNC_FAIL;
+	}
+
+    hdr = (*input);
+    input++;
+    seqno = (*input);
+    input++;
+    input_len -= 2;
+
+    //Check latency and update value when changed.
+    status = hdr & A2DP_LHDC_HDR_LATENCY_MASK;
+
+    //Get number of frame in packet.
+    status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
+
+    ALOGD("[WL50] %s: enter", __func__);
+
+    if (status <= 0)
+    {
+        ALOGD("%s: No any frame in packet.", __func__);
+        return 0;
+    }
+
+
+    lhdc_total_frame_nb = status;
+
+    if (seqno != serial_no)
+    {
+        ALOGD("%s: Packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
+        //serial_no = seqno;
+		//return LHDCBT_DEC_FUNC_INVALID_SEQ_NO;
+    }
+	
+	if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO)
+	{
+        serial_no = seqno + 1;
+	}
+
+    // log average bit rate
+    //sav_lhdc_log_bytes_len(input_len);
+
+    *pLlen = input_len;
+    *pLout = input;
+
+    ret = (int) lhdc_total_frame_nb;
+
+    ALOGD("[WL50] %s: end frame number (%d)", __func__, ret);
+    return ret;
+}
+
diff --git a/external/liblhdcv5/Android.bp b/external/liblhdcv5/Android.bp
new file mode 100644
index 000000000..b8fe3fa60
--- /dev/null
+++ b/external/liblhdcv5/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdcv5",
+
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdcv5.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdcv5.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcv5BT_enc",
+   // vendor_available: true,
+   // vndk: {
+   //     enabled: true,
+   // },
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcv5BT_enc.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdcv5",
+    ],
+}
diff --git a/external/liblhdcv5/CHANGES b/external/liblhdcv5/CHANGES
new file mode 100644
index 000000000..10de496d1
--- /dev/null
+++ b/external/liblhdcv5/CHANGES
@@ -0,0 +1,7 @@
+Release Note.
+=========================================================
+Jul 20, 2022, by jimmy.chen@savitech.co
+  Summary for 5.0.5 liblhdcv5 release  
+  
+Feb 21, 2022, by jimmy.chen@savitech.co
+  Summary for 5.0.1 liblhdcv5 release
\ No newline at end of file
diff --git a/external/liblhdcv5/inc/lhdcv5BT.h b/external/liblhdcv5/inc/lhdcv5BT.h
new file mode 100644
index 000000000..c955b3bcc
--- /dev/null
+++ b/external/liblhdcv5/inc/lhdcv5BT.h
@@ -0,0 +1,127 @@
+#ifndef _LHDCV5BT_H_
+#define _LHDCV5BT_H_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lhdcv5_api.h"
+
+int32_t lhdcv5BT_free_handle 
+(
+    HANDLE_LHDCV5_BT	handle
+);
+
+int32_t lhdcv5BT_get_handle 
+(
+    uint32_t			version,
+    HANDLE_LHDCV5_BT	*handle
+);
+
+int32_t lhdcv5BT_get_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* bitrate
+);
+
+int32_t lhdcv5BT_set_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			bitrate_inx
+);
+
+int32_t lhdcv5BT_set_max_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			max_bitrate_inx
+);
+
+int32_t lhdcv5BT_set_min_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			min_bitrate_inx
+);
+
+int32_t lhdcv5BT_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			queueLen
+);
+
+int32_t lhdcv5BT_set_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T	field,
+    bool 				enabled,
+    void 				* priv,
+    uint32_t 			priv_data_len
+);
+
+int32_t lhdcv5BT_init_encoder
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			sampling_freq,
+    uint32_t 			bits_per_sample,
+    uint32_t 			bitrate_inx,
+    uint32_t 			mtu,
+    uint32_t 			interval
+) ;
+
+int32_t lhdcv5BT_get_block_Size
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* samples_per_frame
+);
+
+int32_t lhdcv5BT_encode
+(
+    HANDLE_LHDCV5_BT 	handle,
+    void				* p_in_pcm,
+    uint32_t			pcm_bytes,
+    uint8_t				* p_out_buf,
+    uint32_t			out_buf_bytes,
+    uint32_t 			* p_out_bytes,
+    uint32_t 			* p_out_frames
+);
+
+//
+// LHDCV5 Extended APIs
+//
+// Extended API -- Get Version
+int lhdcv5BT_get_user_exApiver
+(
+    HANDLE_LHDCV5_BT handle,
+    char *userConfig,
+    int clen
+);
+
+// Extended API -- Get User Config
+int lhdcv5BT_get_user_exconfig
+(
+    HANDLE_LHDCV5_BT handle,
+    char* userConfig,
+    int clen
+);
+
+// Extended API -- Set User Config
+int lhdcv5BT_set_user_exconfig
+(
+    HANDLE_LHDCV5_BT handle,
+    const char* userConfig,
+    const int clen
+);
+
+// Extended API -- Set User Data
+void lhdcv5BT_set_user_exdata
+(
+    HANDLE_LHDCV5_BT handle,
+    const char* userConfig,
+    const int clen
+);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _LHDCV5BT_H_ */
diff --git a/external/liblhdcv5/include/lhdcv5BT_ext_func.h b/external/liblhdcv5/include/lhdcv5BT_ext_func.h
new file mode 100644
index 000000000..f8612162a
--- /dev/null
+++ b/external/liblhdcv5/include/lhdcv5BT_ext_func.h
@@ -0,0 +1,188 @@
+
+
+#ifndef _LHDCBT_EXT_FUNC_H_
+#define _LHDCBT_EXT_FUNC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#define EXTEND_FUNC_RET_OK                      ((int) 0)
+#define EXTEND_FUNC_RET_INVALID_HANDLE          ((int) 0xE01)
+#define EXTEND_FUNC_RET_INVALID_PARAMETER       ((int) 0xE02)
+#define EXTEND_FUNC_RET_FUNC_NOT_SUPPORT        ((int) 0xE03)
+#define EXTEND_FUNC_RET_VERSION_NOT_SUPPORT     ((int) 0xE04)
+#define EXTEND_FUNC_RET_BUF_UNDERRUN            ((int) 0xE05)
+#define EXTEND_FUNC_RET_ERROR                   ((int) 0xE06)
+#define EXTEND_FUNC_RET_NOT_READY               ((int) 0xE07)
+#define EXTEND_FUNC_RET_REQ_BUFSIZE_NOT_MATCH   ((int) 0xE08)
+
+
+/* **********************************************
+ *  API: Version Control
+ * ***********************************************/
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V1               ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2               ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_MIN_BUFFER_LEN                          (8)
+
+/* **********************************************
+ *  LIB API: Config Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   META                      *
+ * * * * * * * * * * * * * * * */
+//   META :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_META        ((unsigned int) 0x0C000001)
+#define EXTEND_FUNC_CODE_GET_CONFIG_META        ((unsigned int) 0x0C010001)
+//   META :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_META_V2      ((unsigned int) 0x02000000)
+//   META :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
+
+/* * * * * * * * * * * * * * * *
+ *   AR                        *
+ * * * * * * * * * * * * * * * */
+//   AR :: API Code
+#define EXTEND_FUNC_CODE_SET_CONFIG_AR          ((unsigned int) 0x0C000002)
+#define EXTEND_FUNC_CODE_GET_CONFIG_AR          ((unsigned int) 0x0C010002)
+//   AR :: API Version
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_V3        ((unsigned int) 0x03000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
+//   AR :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+#define EXTEND_FUNC_VER_GET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
+
+
+/* **********************************************
+ *  LIB API: Data Type
+ * ***********************************************/
+/* * * * * * * * * * * * * * * *
+ *   GYRO2D                    *
+ * * * * * * * * * * * * * * * */
+//   GYRO2D :: API Code
+#define EXTEND_FUNC_CODE_SET_DATA_GYRO2D        ((unsigned int) 0x0D000001)
+//   GYRO2D :: API Version
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1      ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V2      ((unsigned int) 0x02000000)
+//   GYRO2D :: API Min Required Buffer Size
+#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_REQ_BUFSIZE_V2      16    //TBD (8 + 2gyro + 6pad)
+
+
+/* * * * * * * * * * * * * * * *
+ *   GetA2DPSpecifis           *
+ * * * * * * * * * * * * * * * */
+//   GetA2DPSpecifis :: API Code
+#define EXTEND_FUNC_CODE_GET_SPECIFIC           ((unsigned int) 0x0A010001)
+//   GetA2DPSpecifis :: API Version
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2         ((unsigned int) 0x02000000)
+
+//
+// META
+//
+#define META_ST_VER_V1                           ((unsigned int) 0x00010000)
+#define META_ST_VER_V2                           ((unsigned int) 0x00020000)
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_SET_META {
+
+  unsigned char     header[8];
+  unsigned int      meta_ver;
+  unsigned char     meta_mem_size;
+  unsigned char     meta_enable;
+  unsigned char     meta_set;
+  unsigned char     meta_metadata_length;
+  //  unsigned char     meta_metadata[64];
+
+} ST_LHDC_SET_META, *PST_LHDC_SET_META;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_GET_META {
+
+  unsigned char     header[8];
+  unsigned int      meta_ver;
+  unsigned char     meta_mem_size;
+  unsigned char     meta_st;     // [0] 1: reserved bit, [1] 1: in meta mode/0: not in meta mode
+  unsigned char     jas_status;
+
+} ST_LHDC_GET_META, *PST_LHDC_GET_META;
+#pragma pack(pop)
+
+//
+// AR
+//
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR
+{
+  unsigned char     header[8];
+  unsigned int      ver;
+  unsigned int      size;
+  unsigned int      app_ar_enabled;
+  int Ch1_Pos;
+  int Ch2_Pos;
+  int Ch3_Pos;
+  int Ch4_Pos;
+  int Ch5_Pos;
+  int Ch6_Pos;
+  float Ch1_L_PreGain;
+  float Ch1_R_PreGain;
+  float Ch2_L_PreGain;
+  float Ch2_R_PreGain;
+  float Ch3_L_PreGain;
+  float Ch3_R_PreGain;
+  float Ch4_L_PreGain;
+  float Ch4_R_PreGain;
+  float Ch5_L_PreGain;
+  float Ch5_R_PreGain;
+  float Ch6_L_PreGain;
+  float Ch6_R_PreGain;
+  float Ch1_PostGain;
+  float Ch2_PostGain;
+  float Ch3_PostGain;
+  float Ch4_PostGain;
+  float Ch5_PostGain;
+  float Ch6_PostGain;
+  float Dry_Val;
+  float Wet_Val;
+  float Dis_1;
+  float Dis_2;
+  float Dis_3;
+  float Dis_4;
+  float Dis_5;
+  float Rev_1;
+  float Rev_2;
+  float Rev_3;
+  float Rev_4;
+  float Rev_5;
+  float Rev_gain;
+  float ThreeD_gain;
+} ST_LHDC_AR, *PST_LHDC_AR;
+#pragma pack(pop)
+
+#pragma pack (push)
+#pragma pack (1)
+typedef struct __ST_LHDC_AR_GYRO
+{
+  unsigned char     header[8];
+  int world_coordinate_x;
+  int world_coordinate_y;
+  int world_coordinate_z;
+
+} ST_LHDC_AR_GYRO, *PST_LHDC_AR_GYRO;
+#pragma pack(pop)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_EXT_FUNC_H_ */
diff --git a/external/liblhdcv5/include/lhdcv5_api.h b/external/liblhdcv5/include/lhdcv5_api.h
new file mode 100644
index 000000000..860e4e04b
--- /dev/null
+++ b/external/liblhdcv5/include/lhdcv5_api.h
@@ -0,0 +1,322 @@
+#ifndef __LHDCV5_API_H__
+#define __LHDCV5_API_H__
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+typedef enum __LHDCV5_SAMPLE_FREQ__
+{
+  LHDCV5_SR_44100HZ  =  44100,
+  LHDCV5_SR_48000HZ  =  48000,
+  LHDCV5_SR_96000HZ  =  96000,
+  LHDCV5_SR_192000HZ = 192000,
+} LHDCV5BT_SAMPLE_FREQ_T;
+
+
+typedef enum __LHDCV5BT_SMPL_FMT__
+{
+  LHDCV5BT_SMPL_FMT_S16 = 16,
+  LHDCV5BT_SMPL_FMT_S24 = 24,
+  LHDCV5BT_SMPL_FMT_S32 = 32,
+} LHDCV5BT_SMPL_FMT_T;
+
+
+typedef enum __LHDCV5_SAMPLE_FRAME__
+{
+  LHDCV5_SAMPLE_FRAME_5MS_44100KHZ  = 240,
+  LHDCV5_SAMPLE_FRAME_5MS_48000KHZ  = 240,
+  LHDCV5_SAMPLE_FRAME_5MS_96000KHZ  = 480,
+  LHDCV5_SAMPLE_FRAME_5MS_192000KHZ = 960,
+  LHDCV5_MAX_SAMPLE_FRAME = 960,
+} LHDCV5_SAMPLE_FRAME_T;
+
+
+typedef enum __LHDCV5_FRAME_DURATION__
+{
+  LHDCV5_FRAME_5MS   = 50,
+  LHDCV5_FRAME_7P5MS = 75,
+  LHDCV5_FRAME_10MS  = 100,
+  LHDCV5_FRAME_1S    = 10000,
+} LHDCV5_FRAME_DURATION_T;
+
+
+typedef enum __LHDCV5_ENC_INTERVAL__
+{
+  LHDCV5_ENC_INTERVAL_10MS = 10,
+  LHDCV5_ENC_INTERVAL_20MS = 20,
+} LHDCV5_ENC_INTERVAL_T;
+
+
+typedef enum __LHDCV5_QUALITY__
+{
+  LHDCV5_QUALITY_LOW0 = 0,
+  LHDCV5_QUALITY_LOW1,
+  LHDCV5_QUALITY_LOW2,
+  LHDCV5_QUALITY_LOW3,
+  LHDCV5_QUALITY_LOW4,
+  LHDCV5_QUALITY_LOW,
+  LHDCV5_QUALITY_MID,
+  LHDCV5_QUALITY_HIGH,
+  LHDCV5_QUALITY_HIGH1,
+  LHDCV5_QUALITY_AUTO,
+  LHDCV5_QUALITY_RESET_AUTO,
+  LHDCV5_QUALITY_INVALID
+} LHDCV5_QUALITY_T;
+
+
+typedef enum __LHDCV5_MTU_SIZE__
+{
+  LHDCV5_MTU_MIN   = 300,
+  LHDCV5_MTU_2MBPS = 660,
+  LHDCV5_MTU_MAX   = 1023,
+} LHDCV5_MTU_SIZE_T;
+
+
+typedef enum __LHDCV5_VERSION__
+{
+  LHDCV5_VERSION_1 = 1,
+  LHDCV5_VERSION_INVALID
+} LHDCV5_VERSION_T;
+
+
+typedef enum __LHDCV5_ENC_TYPE__ 
+{
+  LHDCV5_ENC_TYPE_UNKNOWN = 0,
+  LHDCV5_ENC_TYPE_LHDCV5,
+  LHDCV5_ENC_TYPE_INVALID
+} LHDCV5_ENC_TYPE_T;
+
+
+typedef enum __LHDCV5_EXT_FUNC__
+{
+  LHDCV5_EXT_FUNC_AR = 0,
+  LHDCV5_EXT_FUNC_LARC,
+  LHDCV5_EXT_FUNC_JAS,
+  LHDCV5_EXT_FUNC_META,
+  LHDCV5_EXT_FUNC_INVALID
+} LHDCV5_EXT_FUNC_T;
+
+
+typedef enum __LHDCV5_META_PARAM__
+{
+  LHDCV5_META_LOOP_CNT_MAX = 100,
+  LHDCV5_META_LOOP_CNT_STD = 20,
+  LHDCV5_META_LEN_FIXED = 8,
+  LHDCV5_META_LEN_MAX = 128
+} LHDCV5_META_PARAM_T;
+
+
+typedef enum __LHDCV5_ABR_TYPE__ 
+{
+  LHDCV5_ABR_44K_RES = 0,
+  LHDCV5_ABR_48K_RES,
+  LHDCV5_ABR_96K_RES,
+  LHDCV5_ABR_192K_RES,
+  LHDCV5_ABR_INVALID
+} LHDCV5_ABR_TYPE_T;
+
+
+typedef struct _lhdcv5_abr_para_t 
+{
+  uint32_t	version;			// version of LHDC 5.0 CODEC
+  uint32_t	sample_rate;		// sample rate (Hz)
+  uint32_t 	bits_per_sample;	// bits per sample (bit)
+  uint32_t 	bits_per_sample_ui;	// bits per sample (bit) (from UI)
+
+  uint32_t 	upBitrateCnt;		// (ABR) up bitrate check parameter
+  uint32_t 	upBitrateSum;		// (ABR) up bitrate check parameter
+
+  uint32_t 	dnBitrateCnt;		// (ABR) down bitrate check parameter
+  uint32_t 	dnBitrateSum;		// (ABR) down bitrate check parameter
+
+  uint32_t 	lastBitrate;     	// Last bit rate (kbps) set for LHDC 5.0 encoder
+  uint32_t 	qualityStatus;      // current bit rate (index) (LOW0 ~ AUTO) is same as UI setting
+
+  //----------------------------------// Above is shared ABR parameters
+
+} lhdcv5_abr_para_t;
+
+
+
+typedef void * HANDLE_LHDCV5_BT;
+
+
+
+/*
+ ******************************************************************
+ LHDC v5 common utilities functions group
+ ******************************************************************
+ */
+
+extern int32_t lhdcv5_util_free_handle 
+(
+    HANDLE_LHDCV5_BT	handle
+);
+
+extern int32_t lhdcv5_util_get_mem_req 
+(
+    uint32_t			version,
+    uint32_t			* mem_req_bytes
+);
+
+extern int32_t lhdcv5_util_get_handle 
+(
+    uint32_t			version,
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t            mem_size
+);
+
+extern int32_t lhdcv5_util_get_target_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* bitrate
+);
+
+extern int32_t lhdcv5_util_set_target_bitrate_inx
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			bitrate_inx,
+    uint32_t			* bitrate_inx_set,
+    bool				upd_qual_status
+);
+
+extern int32_t lhdcv5_util_set_max_bitrate_inx
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			max_bitrate_inx,
+    uint32_t			* max_bitrate_inx_set
+);
+
+extern int32_t lhdcv5_util_set_min_bitrate_inx
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			min_bitrate_inx,
+    uint32_t			* min_bitrate_inx_set
+);
+
+extern int32_t lhdcv5_util_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_ENC_TYPE_T	* enc_type_ptr,
+    lhdcv5_abr_para_t	** abr_para_ptr
+);
+
+extern int32_t lhdcv5_util_reset_up_bitrate
+(
+    lhdcv5_abr_para_t	* handle
+);
+
+extern int32_t lhdcv5_util_reset_down_bitrate
+(
+    lhdcv5_abr_para_t 	* handle
+);
+
+extern int32_t lhdcv5_util_get_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T 	ext_type,
+    bool				* enable_ptr
+);
+
+extern int32_t lhdcv5_util_set_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T 	ext_type,
+    bool 				func_enable,
+    uint8_t				* data_ptr,
+    uint32_t			data_len,
+    uint32_t			loop_cnt
+);
+
+extern int32_t lhdcv5_util_init_encoder
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			sampling_freq,
+    uint32_t 			bits_per_sample,
+    uint32_t 			bitrate_inx,
+    uint32_t 			frame_duration,
+    uint32_t 			mtu,
+    uint32_t 			interval
+);
+
+extern int32_t lhdcv5_util_get_block_Size
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			* block_size
+);
+
+extern int32_t lhdcv5_util_enc_process
+(
+    HANDLE_LHDCV5_BT 	handle,
+    void				* p_pcm,
+    uint32_t			pcm_bytes,
+    uint8_t				* out_put,
+    uint32_t			out_buf_bytes,
+    uint32_t 			* written,
+    uint32_t 			* out_frames
+);
+
+extern int32_t lhdcv5_util_get_bitrate
+(
+    uint32_t	bitrate_inx,
+    uint32_t	* bitrate
+);
+
+extern int32_t lhdcv5_util_get_bitrate_inx
+(
+    uint32_t	bitrate,
+    uint32_t	* bitrate_inx
+);
+
+extern int32_t lhdcv5_util_ar_set_gyro_pos 
+(
+    HANDLE_LHDCV5_BT 	handle,
+    int32_t 			world_coordinate_x,
+    int32_t 			world_coordinate_y,
+    int32_t				world_coordinate_z
+);
+
+extern int32_t lhdcv5_util_ar_set_cfg
+(
+    HANDLE_LHDCV5_BT 	handle,
+    int32_t 			* pos_ptr,
+    uint32_t			pos_item_num,
+    float 				* gain_ptr,
+    uint32_t			gain_item_num,
+    uint32_t	 		app_ar_enabled
+);
+
+extern int32_t lhdcv5_util_ar_get_cfg 
+(
+    HANDLE_LHDCV5_BT 	handle,
+    int32_t 			* pos_ptr,
+    uint32_t			pos_item_num,
+    float 				* gain_ptr,
+    uint32_t			gain_item_num
+);
+
+
+typedef enum __LHDCV5_FUNC_RET__
+{
+  LHDCV5_FRET_SUCCESS 				=	  0,
+  LHDCV5_FRET_INVALID_INPUT_PARAM		=	 -1,
+  LHDCV5_FRET_INVALID_HANDLE_CB		=	 -2,
+  LHDCV5_FRET_INVALID_HANDLE_PARA		=	 -3,
+  LHDCV5_FRET_INVALID_HANDLE_ENC		=	 -4,
+  LHDCV5_FRET_INVALID_HANDLE_CBUF		=	 -5,
+  LHDCV5_FRET_INVALID_HANDLE_AR		=	 -6,
+  LHDCV5_FRET_INVALID_CODEC			=	 -7,
+  LHDCV5_FRET_CODEC_NOT_READY			=	 -8,
+  LHDCV5_FRET_AR_NOT_READY			=	 -9,
+  LHDCV5_FRET_ERROR					=	-10,
+  LHDCV5_FRET_BUF_NOT_ENOUGH			=	-11,
+} LHDCV5_FUNC_RET_T;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif //End of __LHDCV5_API_H__
diff --git a/external/liblhdcv5/libs/arm64-v8a/.gitkeep b/external/liblhdcv5/libs/arm64-v8a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdcv5/libs/armeabi-v7a/.gitkeep b/external/liblhdcv5/libs/armeabi-v7a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdcv5/src/lhdcv5BT_enc.c b/external/liblhdcv5/src/lhdcv5BT_enc.c
new file mode 100644
index 000000000..7719fbe7c
--- /dev/null
+++ b/external/liblhdcv5/src/lhdcv5BT_enc.c
@@ -0,0 +1,1779 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcv5BT.h"
+#include "lhdcv5BT_ext_func.h"
+
+#define LOG_TAG "lhdcv5BT_enc"
+#include <cutils/log.h>
+
+#define UP_RATE_TIME_CNT         			3000    // ABR bitrate upgrade checking time interval(ms): (UP_RATE_TIME_CNT * 20ms)
+#define DOWN_RATE_TIME_CNT       			4  		  // ABR bitrate downgrade checking time interval(ms): (DOWN_RATE_TIME_CNT * 20ms)
+#define ABR_UP_QUEUE_LENGTH_THRESHOLD     1   // A threshold of ABR bitrate upgrade check
+#define ABR_DOWN_QUEUE_LENGTH_THRESHOLD   0   // A threshold of ABR bitrate downgrade check
+
+// ABR: bit rate adjustment tables
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_std[] = {128, 192, 256, 320, 400, 600};
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_hi[] = {256, 320, 400, 600, 600, 600};
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_std[] = {128, 192, 256, 320, 400, 400};
+//static uint32_t auto_bitrate_adjust_table_lhdcv5_hi[] = {256, 320, 400, 400, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_44k[] = {128, 192, 240, 320, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_48k[] = {128, 192, 256, 320, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_96k[] = {256, 320, 400, 400, 400, 400};
+static uint32_t auto_bitrate_adjust_table_lhdcv5_192k[] = {256, 320, 400, 400, 400, 400};
+
+//#define LHDCV5_STD_BITRATE_ELEMENTS_SIZE	(sizeof(auto_bitrate_adjust_table_lhdcv5_std) / sizeof(uint32_t))
+//#define LHDCV5_HI_BITRATE_ELEMENTS_SIZE		(sizeof(auto_bitrate_adjust_table_lhdcv5_hi) / sizeof(uint32_t))
+#define LHDCV5_44K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_44k) / sizeof(uint32_t))
+#define LHDCV5_48K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_48k) / sizeof(uint32_t))
+#define LHDCV5_96K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_96k) / sizeof(uint32_t))
+#define LHDCV5_192K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_192k) / sizeof(uint32_t))
+
+#define LHDCV5_ABR_DEFAULT_BITRATE     (LHDCV5_QUALITY_LOW)
+
+
+static const char * rate_to_string
+(
+    LHDCV5_QUALITY_T	q
+)
+{
+  switch (q)
+  {
+  case LHDCV5_QUALITY_LOW0:
+    return "LHDCV5_QUALITY_LOW0";
+  case LHDCV5_QUALITY_LOW1:
+    return "LHDCV5_QUALITY_LOW1";
+  case LHDCV5_QUALITY_LOW2:
+    return "LHDCV5_QUALITY_LOW2";
+  case LHDCV5_QUALITY_LOW3:
+    return "LHDCV5_QUALITY_LOW3";
+  case LHDCV5_QUALITY_LOW4:
+    return "LHDCV5_QUALITY_LOW4";
+  case LHDCV5_QUALITY_LOW:
+    return "LHDCV5_QUALITY_LOW";
+  case LHDCV5_QUALITY_MID:
+    return "LHDCV5_QUALITY_MID";
+  case LHDCV5_QUALITY_HIGH:
+    return "LHDCV5_QUALITY_HIGH";
+  case LHDCV5_QUALITY_HIGH1:
+    return "LHDCV5_QUALITY_HIGH1";
+  case LHDCV5_QUALITY_AUTO:
+    return "LHDCV5_QUALITY_AUTO";
+  default:
+    ALOGW ("%s: Incorrect quality(%d)",  __func__, q);
+    return "UNKNOW_QUALITY";
+  }
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5_encoder_inx_of_abr_bitrate ()
+//
+// return the bit rate (index) respond to input bit rate (kbps)
+//	Parameter
+//		abr_type: ABR type
+//		bitrate: bit rate (kbps)
+//		bitrate_inx: ABR bit rate (index) returned
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to return the bit rate (index)
+//		otherwise: fail to return the bit rate (index)
+//----------------------------------------------------------------
+static int lhdcv5_encoder_inx_of_abr_bitrate
+(
+    LHDCV5_ABR_TYPE_T abr_type,
+    uint32_t  bitrate,
+    uint32_t  *bitrate_inx
+)
+{
+  uint32_t element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+  uint32_t *abr_table = NULL;
+
+  if (bitrate_inx == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!!!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if (abr_type == LHDCV5_ABR_44K_RES)
+  {
+    element_size = LHDCV5_44K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_44k[0]);
+  }
+  else if (abr_type == LHDCV5_ABR_48K_RES)
+  {
+    element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
+  }
+  else if (abr_type == LHDCV5_ABR_96K_RES)
+  {
+    element_size = LHDCV5_96K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_96k[0]);
+  }
+  else if (abr_type == LHDCV5_ABR_192K_RES)
+  {
+    element_size = LHDCV5_192K_BITRATE_ELEMENTS_SIZE;
+
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_192k[0]);
+  }
+  else
+  {
+    ALOGW ("%s: Invalid ABR type (%d)!", __func__, abr_type);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if ((bitrate <= 0) || (bitrate > abr_table[element_size - 1]))
+  {
+    ALOGW ("%s: bit rate is out of range (%d)!!!", __func__, bitrate);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+
+  for (uint32_t i = 0; i < element_size; i++)
+  {
+    if (abr_table[i] >= bitrate)
+    {
+      *bitrate_inx = i;
+      return LHDCV5_FRET_SUCCESS;
+    }
+  }
+
+  ALOGW ("%s: Fail to find bit rate (index) (%d)!", __func__, bitrate);
+  return LHDCV5_FRET_ERROR;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5_encoder_adjust_bitrate ()
+//
+// Adjust bit rate automatically according to number of packets in queue for LHDC 5.0 encoding
+//	Parameter
+//		lhdcBT: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		handle: a pointer to ABR parameters
+//		queueLen: number of packets in queue
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to adjust bit rate automatically 
+//		otherwise: fail to adjust bit rate automatically 
+//----------------------------------------------------------------
+static int lhdcv5_encoder_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT  lhdcBT,
+    lhdcv5_abr_para_t *handle,
+    uint32_t  queueLen
+) 
+{
+  uint32_t element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+  uint32_t new_abr_bitrate_inx = 0;
+  uint32_t new_bitrate_inx = 0;
+  uint32_t new_bitrate_inx_set = 0;
+  uint32_t last_bitrate_inx = 0;
+  uint32_t *abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
+  LHDCV5_ABR_TYPE_T	abr_type = LHDCV5_ABR_48K_RES;
+  int32_t func_ret = LHDCV5_FRET_SUCCESS;
+  uint32_t queueLength = 0;
+
+  if (lhdcBT == NULL)
+  {
+    ALOGW ("%s: lhdcBT is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_PARA;
+  }
+
+  if (handle->qualityStatus != LHDCV5_QUALITY_AUTO)
+  {
+    ALOGW ("%s: Not ABR (%d)", __func__, handle->qualityStatus);
+    return LHDCV5_FRET_SUCCESS;
+  }
+
+  if (queueLen < 0)
+  {
+    ALOGW ("%s: Invalid queue length (%u)!", __func__, queueLen);
+    return LHDCV5_FRET_INVALID_HANDLE_PARA;
+  }
+
+  if (handle->sample_rate == LHDCV5_SR_44100HZ)
+  {
+    abr_type = LHDCV5_ABR_44K_RES;
+    element_size = LHDCV5_44K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_44k[0]);
+  }
+  else if (handle->sample_rate == LHDCV5_SR_48000HZ)
+  {
+    abr_type = LHDCV5_ABR_48K_RES;
+    element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
+  }
+  else if (handle->sample_rate == LHDCV5_SR_96000HZ)
+  {
+    abr_type = LHDCV5_ABR_96K_RES;
+    element_size = LHDCV5_96K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_96k[0]);
+  }
+  else if (handle->sample_rate == LHDCV5_SR_192000HZ)
+  {
+    abr_type = LHDCV5_ABR_192K_RES;
+    element_size = LHDCV5_192K_BITRATE_ELEMENTS_SIZE;
+    abr_table = &(auto_bitrate_adjust_table_lhdcv5_192k[0]);
+  }
+  else
+  {
+    ALOGW ("%s: Sample rate is invalid (%u)!", __func__, handle->sample_rate);
+    return LHDCV5_FRET_CODEC_NOT_READY;
+  }
+
+  if (handle->dnBitrateCnt > 0 && handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT)
+  {
+    queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
+
+    //handle->dnBitrateSum = 0;
+    //handle->dnBitrateCnt = 0;
+    func_ret = lhdcv5_util_reset_down_bitrate (handle);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(DN) lhdcv5_util_reset_down_bitrate error %d",  __func__, func_ret);
+      goto fail;
+    }
+
+    if (queueLength > ABR_DOWN_QUEUE_LENGTH_THRESHOLD)
+    {
+      ALOGD ("%s:(DN) dnBitrateSum:%u / dnBitrateCnt:%u = queueLength:%u", __func__,
+          handle->dnBitrateSum, handle->dnBitrateCnt, queueLength);
+
+      new_abr_bitrate_inx = 0;
+      func_ret = lhdcv5_util_get_bitrate_inx (abr_table[new_abr_bitrate_inx], &new_bitrate_inx);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(DN) lhdcv5_util_get_bitrate_inx error %d",  __func__, func_ret);
+        goto fail;
+      }
+
+      func_ret = lhdcv5_util_get_bitrate_inx (handle->lastBitrate, &last_bitrate_inx);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(DN) lhdcv5_util_get_bitrate_inx error %d",  __func__, func_ret);
+        goto fail;
+      }
+
+      if (new_bitrate_inx < last_bitrate_inx)
+      {
+        func_ret = lhdcv5_util_set_target_bitrate_inx (lhdcBT, new_bitrate_inx, &new_bitrate_inx_set, false);
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("%s:(DN) lhdcv5_util_set_target_bitrate_inx error %d", __func__, func_ret);
+          goto fail;
+        }
+
+        ALOGD ("%s:(DN) [AutoBiTrAtE] Down bitrate[%u] to new bitrate(%u)[%u], queueLength(%u)",  __func__,
+            last_bitrate_inx, abr_table[new_abr_bitrate_inx], new_bitrate_inx_set, queueLength);
+
+        func_ret = lhdcv5_util_reset_up_bitrate (handle);
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("%s:(DN) lhdcv5_util_reset_up_bitrate error %d", __func__, func_ret);
+          goto fail;
+        }
+      }
+      else
+      {
+        ALOGD ("%s:(DN) [AutoBiTrAtE] Down bitrate condition fails, new rate:%u, current rate:%u",  __func__,
+            abr_table[new_abr_bitrate_inx],
+            handle->lastBitrate);
+      }
+    }
+  }
+
+  if (handle->upBitrateCnt > 0 && handle->upBitrateCnt >= UP_RATE_TIME_CNT)
+  {
+    uint32_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
+    uint32_t queuSumTmp = handle->upBitrateSum;
+
+    ALOGV ("%s:(UP) Before upBitrateSum:%u / upBitrateCnt:%u = queueLength:%u", __func__,
+        handle->upBitrateSum, handle->upBitrateCnt, queueLength);
+
+    //handle->upBitrateSum = 0;
+    //handle->upBitrateCnt = 0;
+    func_ret = lhdcv5_util_reset_up_bitrate (handle);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_util_reset_up_bitrate error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    func_ret = lhdcv5_encoder_inx_of_abr_bitrate (abr_type,
+        handle->lastBitrate,
+        &new_abr_bitrate_inx);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_encoder_inx_of_abr_bitrate error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    if (new_abr_bitrate_inx < (element_size - 1))
+    {
+      new_abr_bitrate_inx++;
+    }
+
+    func_ret = lhdcv5_util_get_bitrate_inx (abr_table[new_abr_bitrate_inx], &new_bitrate_inx);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_util_get_bitrate_inx error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    func_ret = lhdcv5_util_get_bitrate_inx (handle->lastBitrate, &last_bitrate_inx);
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s:(UP) lhdcv5_util_get_bitrate_inx error %d", __func__, func_ret);
+      goto fail;
+    }
+
+    if ((new_bitrate_inx > last_bitrate_inx) && (queuSumTmp < ABR_UP_QUEUE_LENGTH_THRESHOLD))
+    {
+      func_ret = lhdcv5_util_set_target_bitrate_inx (lhdcBT, new_bitrate_inx, &new_bitrate_inx_set, false);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(UP) lhdcv5_util_set_target_bitrate_inx error %d", __func__, func_ret);
+        goto fail;
+      }
+      ALOGD ("%s:(UP) [AutoBiTrAtE] Up bitrate[%u] to new_bitrate(%u)[%u], queueLength(%u)",
+          __func__, last_bitrate_inx, abr_table[new_abr_bitrate_inx], new_bitrate_inx_set, queueLength);
+
+      func_ret = lhdcv5_util_reset_down_bitrate (handle);
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("%s:(UP) lhdcv5_util_reset_down_bitrate error %d", __func__, func_ret);
+        goto fail;
+      }
+    }
+    else
+    {
+      ALOGD ("%s:(UP) [AutoBiTrAtE] Up bitrate condition fails, new rate:%u, current rate:%u, queue sum:%u",  __func__,
+          abr_table[new_abr_bitrate_inx],
+          handle->lastBitrate,
+          queuSumTmp);
+    }
+  }
+
+  if (queueLen > 0)
+  {
+    handle->upBitrateSum += queueLen;
+    handle->dnBitrateSum += queueLen;
+  }
+
+  handle->upBitrateCnt++;
+  handle->dnBitrateCnt++;
+
+  fail:
+  return func_ret;
+}
+
+
+/*
+ ******************************************************************
+ LHDC library public API group
+ ******************************************************************
+ */
+
+//----------------------------------------------------------------
+// lhdcv5BT_free_handle ()
+//
+// Free all resources allocated
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcv5BT_get_handle ()
+//	Return
+//		LHDCV5_FRET_SUCCESS: Succeed to free all resources
+//		otherwise: Fail to free all resources
+//----------------------------------------------------------------
+int32_t lhdcv5BT_free_handle
+(
+    HANDLE_LHDCV5_BT	handle
+) 
+{
+  int32_t func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  // reset resources
+  func_ret = lhdcv5_util_free_handle (handle);
+
+  // free handle
+  if(handle)
+  {
+    ALOGD ("%s: free handle %p!", __func__, handle);
+    free(handle);
+    handle = NULL;
+  }
+
+  return func_ret;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_get_handle ()
+//
+// Allocate resources required by LHDC 5.0 Encoder 
+// 	Parameter
+//		version: version defined in BT A2DP capability
+//		handle: a pointer to the resource allocated 
+// 	Return
+//		LHDCV5_FRET_SUCCESS: Succeed to allocate resources
+//		otherwise: Fail to allocate resources
+//----------------------------------------------------------------
+int32_t lhdcv5BT_get_handle
+(
+    uint32_t			version,
+    HANDLE_LHDCV5_BT	*handle
+) 
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+  uint32_t mem_req_bytes = 0;
+  HANDLE_LHDCV5_BT hLhdcBT = NULL;
+
+  if (version != LHDCV5_VERSION_1)
+  {
+    ALOGW ("%s: Invalid version (%u)!", __func__, version);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_get_mem_req (version, &mem_req_bytes);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS || mem_req_bytes <= 0)
+  {
+    ALOGW ("%s: Fail to get required memory size (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
+  if (hLhdcBT == NULL)
+  {
+    ALOGW ("%s: Fail to allocate memory for encoder!", __func__);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  func_ret = lhdcv5_util_get_handle (version, hLhdcBT, mem_req_bytes);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Fail to get handle (%d)!", __func__, func_ret);
+    free(hLhdcBT);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  *handle = hLhdcBT;
+
+  if ((*handle) == NULL)
+  {
+    ALOGW ("%s: Get handle NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_get_bitrate ()
+//
+// Get the bit rate used during LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcv5BT_get_handle ()
+//		bitrate: a pointer to bit rate used during LHDC 5.0 encoding,
+//				 range [64000, 1000000]
+//	Return
+//		LHDCV5_FRET_SUCCESS: Succeed to allocate resources
+//		otherwise: Fail to allocate resources
+//----------------------------------------------------------------
+int32_t lhdcv5BT_get_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			*bitrate
+) 
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (bitrate == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_get_target_bitrate (handle, bitrate);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Failed to get bit rate (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  if ((*bitrate < 64000) || (*bitrate > 1000000))
+  {
+    ALOGW ("%s: Invalid bit rate returned (%u)!", __func__, *bitrate);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_bitrate ()
+//
+// Set the bit rate used during LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		bitrate_inx: an index of bit rate to set
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set the bit rate
+//		Other: fail to set the bit rate
+//----------------------------------------------------------------
+int32_t lhdcv5BT_set_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			bitrate_inx
+)
+{
+  uint32_t	bitrate_inx_set = bitrate_inx;
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+      (bitrate_inx >= LHDCV5_QUALITY_INVALID))
+  {
+    ALOGW ("%s: Invalid bit rate index (%u)!", __func__, bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if (bitrate_inx == LHDCV5_QUALITY_RESET_AUTO) {
+    bitrate_inx_set = LHDCV5_ABR_DEFAULT_BITRATE;
+    ALOGD ("%s: [Reset BiTrAtE] reset to bitrate (%s)", __func__, rate_to_string (bitrate_inx_set));
+    bitrate_inx = LHDCV5_ABR_DEFAULT_BITRATE;
+    // change bitrate only, not update quality index
+    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, false);
+  } else {
+    // also update quality index
+    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
+  }
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set bitrate (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  ALOGD ("%s: Update target bitrate(%s)",  __func__,
+      rate_to_string (bitrate_inx_set));
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_max_bitrate ()
+//
+// Set the MAX. bit rate for LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		max_bitrate_inx: MAX. bit rate (index) for LHDC 5.0 encoding
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set the MAX. bit rate
+//		Other: fail to set the MAX. bit rate
+//----------------------------------------------------------------
+int32_t lhdcv5BT_set_max_bitrate
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			max_bitrate_inx
+) 
+{
+  uint32_t max_bitrate_inx_set = max_bitrate_inx;
+  int32_t func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((max_bitrate_inx < LHDCV5_QUALITY_LOW) ||
+      (max_bitrate_inx >= LHDCV5_QUALITY_AUTO))
+  {
+    ALOGW ("%s: Invalid max bit rate index (%u)!", __func__, max_bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_set_max_bitrate_inx (handle, max_bitrate_inx, &max_bitrate_inx_set);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set max. bit rate index (%u), (%d)!", __func__, max_bitrate_inx, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  ALOGD ("%s: Update Max target bitrate(%s)",  __func__, rate_to_string (max_bitrate_inx_set));
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_min_bitrate ()
+//
+// Set the MIN. bit rate for LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		min_bitrate_inx: MIN. bit rate (index) for LHDC 5.0 encoding
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set the MIN. bit rate
+//		Other: fail to set the MIN. bit rate
+//----------------------------------------------------------------
+
+int32_t lhdcv5BT_set_min_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			min_bitrate_inx
+)
+{
+  uint32_t 	min_bitrate_inx_set = (uint32_t) LHDCV5_QUALITY_LOW0;
+  int32_t			func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((min_bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+      (min_bitrate_inx > LHDCV5_QUALITY_LOW))
+  {
+    ALOGW ("%s: Invalid min bit rate index (%u)!", __func__, min_bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_set_min_bitrate_inx (handle, min_bitrate_inx, &min_bitrate_inx_set);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set min. bit rate (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_adjust_bitrate ()
+//
+// Adjust bit rate automatically according to number of packets in queue for LHDC 5.0 encoding
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		queue_len: number of packets in queue
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to adjust bit rate automatically 
+//		Other: fail to adjust bit rate automatically 
+//----------------------------------------------------------------
+
+int32_t lhdcv5BT_adjust_bitrate
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t			queueLen
+) 
+{
+  LHDCV5_ENC_TYPE_T	enc_type = LHDCV5_ENC_TYPE_LHDCV5;
+  lhdcv5_abr_para_t	* abr_para = NULL;
+  int32_t				func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (queueLen < 0)
+  {
+    ALOGW ("%s: Invalid input queue length (%u)!", __func__, queueLen);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_adjust_bitrate (handle, &enc_type, &abr_para);
+
+  if ((func_ret != LHDCV5_FRET_SUCCESS) || (abr_para == NULL))
+  {
+    ALOGW ("%s: Failed to get auto bit rate parameters (%d) (%p)!", __func__, func_ret, abr_para);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  switch (enc_type)
+  {
+  case LHDCV5_ENC_TYPE_LHDCV5:
+
+    func_ret = lhdcv5_encoder_adjust_bitrate (handle, abr_para, queueLen);
+
+    if (func_ret != LHDCV5_FRET_SUCCESS)
+    {
+      ALOGW ("%s: Failed to adjust auto bit rate (%d)!", __func__, func_ret);
+      return LHDCV5_FRET_ERROR;
+    }
+    break;
+
+  default:
+    ALOGW ("%s: Invalid encode type (%d)!", __func__, enc_type);
+    return LHDCV5_FRET_INVALID_CODEC;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_set_ext_func_state ()
+//
+// Set the ext. function state (AR, JAS, Meta, LARC)
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		field: specify the ext. function
+//		enabled: ext. function is set to enabled (true) or disabled (false)
+//		priv: a pointer to the exra data needed for ext. function
+//		priv_data_len: number of bytes of the extra data
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to set specified ext. function to enabled (true) or disabled (false)
+//		Other: fail to set .
+//----------------------------------------------------------------
+
+int32_t lhdcv5BT_set_ext_func_state
+(
+    HANDLE_LHDCV5_BT 	handle,
+    LHDCV5_EXT_FUNC_T	field,
+    bool 				enabled,
+    void 				* priv,
+    uint32_t 			priv_data_len
+)
+{
+  int32_t	func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((field < LHDCV5_EXT_FUNC_AR) ||
+      (field >= LHDCV5_EXT_FUNC_INVALID))
+  {
+    ALOGW ("%s: Invalid ext. func. field (%d)!", __func__, field);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_set_ext_func_state (handle,
+      (LHDCV5_EXT_FUNC_T) field,
+      enabled,
+      priv,
+      priv_data_len,	// data length MUST be 8 for META
+      LHDCV5_META_LOOP_CNT_STD);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: failed to set ext. function state (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_init_encoder ()
+//
+// Initialize LHDC 5.0 encoder
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		sampling_freq: sample frequency
+//		bit_per_sample: bits per sample
+//		bitrate_inx: bit rate index
+//		mtu: BT A2DP MTU 
+//		interval: interval: period of time triggering LHDC 5.0 encoding in ms
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to initialize 
+//		Other: fail to initialize.
+//----------------------------------------------------------------
+int32_t lhdcv5BT_init_encoder
+(
+    HANDLE_LHDCV5_BT 	handle,
+    uint32_t 			sampling_freq,
+    uint32_t 			bits_per_sample,
+    uint32_t 			bitrate_inx,
+    uint32_t 			mtu,
+    uint32_t 			interval
+) 
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((sampling_freq != LHDCV5_SR_44100HZ) &&
+      (sampling_freq != LHDCV5_SR_48000HZ) &&
+      (sampling_freq != LHDCV5_SR_96000HZ) &&
+      (sampling_freq != LHDCV5_SR_192000HZ))
+  {
+    ALOGW ("%s: Invalid sampling frequency (%u)!", __func__, sampling_freq);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if ((bits_per_sample != LHDCV5BT_SMPL_FMT_S16) &&
+      (bits_per_sample != LHDCV5BT_SMPL_FMT_S24) &&
+      (bits_per_sample != LHDCV5BT_SMPL_FMT_S32))
+  {
+    ALOGW ("%s: Invalid bits per sample (%u)!", __func__, bits_per_sample);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+      (bitrate_inx > LHDCV5_QUALITY_AUTO))
+  {
+    ALOGW ("%s: Invalid bit rate (index) (%d)!", __func__, bitrate_inx);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+
+  func_ret = lhdcv5_util_init_encoder (handle,
+      (unsigned int) sampling_freq,
+      (unsigned int) bits_per_sample,
+      (unsigned int) bitrate_inx,
+      (unsigned int) LHDCV5_FRAME_5MS,
+      (unsigned int) mtu,
+      (unsigned int) interval);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Failed to init LHDC 5.0 encoder (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_get_block_Size ()
+//
+// Get number of samples per block for LHDC 5.0 encoder
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned by function lhdcv5Bt_get_handle ()
+//		samples_per_frame: number of samples per block returned
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to get number of samples per block 
+//		Other: fail to get number of samples per block.
+//----------------------------------------------------------------
+int32_t lhdcv5BT_get_block_Size
+(
+    HANDLE_LHDCV5_BT	handle,
+    uint32_t			* samples_per_frame
+)
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if (samples_per_frame == NULL)
+  {
+    ALOGW ("%s: Input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_get_block_Size (handle, samples_per_frame);
+
+  if ((func_ret != LHDCV5_FRET_SUCCESS) || ((*samples_per_frame) <= 0))
+  {
+    ALOGW ("%s: Failed to get block size (%d) (%d)!", __func__, func_ret, *samples_per_frame);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+//----------------------------------------------------------------
+// lhdcv5BT_encode ()
+//
+// Encode pcm samples by LHDC 5.0
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		p_in_pcm: a pointer to a buffer contains PCM samples for encoding
+//		p_out_buf: a pointer to a buffer to put encoded stream
+//		out_buf_bytes: output buffer's size (in byte)
+//		p_out_bytes: a pointer to number of bytes of encoded stream in buffer
+//		p_out_frames: a pointer to number of frames of encoded stream in buffer
+//	Return
+//		LHDCV5_FRET_SUCCESS: succeed to encode pcm samples
+//		Other: fail to encode pcm samples
+//----------------------------------------------------------------
+int32_t lhdcv5BT_encode
+(
+    HANDLE_LHDCV5_BT 	handle,
+    void				* p_in_pcm,
+    uint32_t			pcm_bytes,
+    uint8_t				* p_out_buf,
+    uint32_t			out_buf_bytes,
+    uint32_t 			* p_out_bytes,
+    uint32_t 			* p_out_frames
+)
+{
+  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("%s: Handle is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_HANDLE_CB;
+  }
+
+  if ((p_in_pcm == NULL) || (p_out_buf == NULL) ||
+      (p_out_bytes == NULL) || (p_out_frames == NULL))
+  {
+    ALOGW ("%s: input parameter is NULL!", __func__);
+    return LHDCV5_FRET_INVALID_INPUT_PARAM;
+  }
+
+  func_ret = lhdcv5_util_enc_process (handle,
+      p_in_pcm,
+      pcm_bytes,
+      p_out_buf,
+      out_buf_bytes,
+      p_out_bytes,
+      p_out_frames);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("%s: Failed to encode pcm samples (%d)!", __func__, func_ret);
+    return LHDCV5_FRET_ERROR;
+  }
+
+  return LHDCV5_FRET_SUCCESS;
+}
+
+
+
+/*
+ ******************************************************************
+ Extend API functions group
+ ******************************************************************
+ */
+static bool lhdcBT_code_ver_wrap
+(
+    unsigned char *pucConfig,
+    unsigned int *exFuncCode,
+    unsigned int *exFuncVer
+)
+{
+  *exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+      ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+
+  *exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+      ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+  return true;
+}
+
+//
+// META, JAS
+//
+//----------------------------------------------------------------
+// lhdcBT_set_cfg_meta_v1 ()
+//
+// Set configuration for meta data
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to set configuration  
+//		Other: fail to set configuration.
+//----------------------------------------------------------------
+static int lhdcBT_set_cfg_meta_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char			*userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_SET_META pset_meta = (PST_LHDC_SET_META) userConfig;
+  unsigned char	* pmeta_metadata = NULL;
+  int				func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_SET_META))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  if (pset_meta->meta_ver != META_ST_VER_V2)
+  {
+    ALOGW ("(LHDC-exAPI) %s: version is not match (%d)!",  __func__, pset_meta->meta_ver);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (pset_meta->meta_mem_size != (int) sizeof (ST_LHDC_SET_META))
+  {
+    ALOGW("(LHDC-exAPI) %s: META data size is  not match (%d)!", __func__, pset_meta->meta_mem_size);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < ((int) pset_meta->meta_metadata_length) + ((int) sizeof (ST_LHDC_SET_META)))
+  {
+    ALOGW("(LHDC-exAPI) %s: cfg size too small (%d)!", __func__, configLen);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  pmeta_metadata = (uint8_t*) (pset_meta + 1);
+
+  func_ret = lhdcv5_util_set_ext_func_state (handle,
+      LHDCV5_EXT_FUNC_META,
+      pset_meta->meta_enable,
+      pmeta_metadata,
+      pset_meta->meta_metadata_length,
+      pset_meta->meta_set);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to set META data (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//----------------------------------------------------------------
+// lhdcBT_get_cfg_meta_v1 ()
+//
+// Get configuration for meta data
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to get configuration   
+//		Other: fail to get configuration.
+//----------------------------------------------------------------
+static int lhdcBT_get_cfg_meta_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char				* userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_GET_META pget_meta = (PST_LHDC_GET_META) userConfig;
+  bool 		jas_enabled = false;
+  bool		meta_enabled = false;
+  int			func_ret = LHDCV5_FRET_SUCCESS;
+
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_GET_META))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  func_ret = lhdcv5_util_get_ext_func_state (handle, LHDCV5_EXT_FUNC_META, &meta_enabled);
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to get META flag (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+  ALOGW ("(LHDC-exAPI) %s: LHDCV5_EXT_FUNC_META: meta_enabled=%d",  __func__, meta_enabled);
+
+  func_ret = lhdcv5_util_get_ext_func_state (handle, LHDCV5_EXT_FUNC_JAS, &jas_enabled);
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to get JAS flag (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+  ALOGW ("(LHDC-exAPI) %s: LHDCV5_EXT_FUNC_JAS: jas_enabled=%d",  __func__, jas_enabled);
+
+  pget_meta->meta_ver = META_ST_VER_V2;
+  pget_meta->meta_mem_size = (int) sizeof (ST_LHDC_GET_META);
+  pget_meta->meta_st = meta_enabled ? 0x03 : 0x01;  // Get current frame include metadata or not
+  pget_meta->jas_status = jas_enabled ? 1 : 0;
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//
+// AR Function
+//
+//----------------------------------------------------------------
+// lhdcBT_set_data_gyro_2d_v1 ()
+//
+// Set data for gyro (x, y)
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userData: a pointer to data
+//		dataLen: number of bytes of data
+//	Return
+//		0: succeed to set data  
+//		Other: fail to set data.
+//----------------------------------------------------------------
+static int lhdcBT_set_data_gyro_2d_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char 			* userData,
+    const int 			dataLen
+) 
+{
+  PST_LHDC_AR_GYRO pargyro = (PST_LHDC_AR_GYRO) userData;
+  int 		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userData == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Data is NULL (%p)!",  __func__, userData);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (dataLen < (int) sizeof (ST_LHDC_AR_GYRO))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, dataLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+
+  ALOGV ("(LHDC-exAPI) %s: set coordinate[x:%d y:%d z:%d]",  __func__,
+      pargyro->world_coordinate_x,
+      pargyro->world_coordinate_y,
+      pargyro->world_coordinate_z);
+
+  func_ret = lhdcv5_util_ar_set_gyro_pos (handle,
+      pargyro->world_coordinate_x,
+      pargyro->world_coordinate_y,
+      pargyro->world_coordinate_z);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGD ("(LHDC-exAPI) %s: Fail to set gyro's position[x:%d y:%d z:%d] for AR (%d)!",  __func__,
+        pargyro->world_coordinate_x,
+        pargyro->world_coordinate_y,
+        pargyro->world_coordinate_z,
+        func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//----------------------------------------------------------------
+// lhdcBT_set_cfg_ar_v3 ()
+//
+// Set configuration for AR
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		0: succeed to set configuration  
+//		Other: fail to set configuration.
+//----------------------------------------------------------------
+static int lhdcBT_set_cfg_ar_v3
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char 			* userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR) userConfig;
+  int 		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_AR))
+  {
+    // Buffer is to small
+    ALOGW("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  ALOGD("(LHDC-exAPI) %s: ver(%d) size(%d) app_ar_enabled(%d) Ch_Pos(%d %d %d %d %d %d)"
+      , __func__,
+      pset_ar_cfg->ver,
+      pset_ar_cfg->size,
+      pset_ar_cfg->app_ar_enabled,
+      pset_ar_cfg->Ch1_Pos, pset_ar_cfg->Ch2_Pos, pset_ar_cfg->Ch2_Pos,
+      pset_ar_cfg->Ch4_Pos, pset_ar_cfg->Ch5_Pos, pset_ar_cfg->Ch6_Pos);
+
+  ALOGD("(LHDC-exAPI) %s: PreGain(L:R): ch1[%f:%f] ch2[%f:%f] ch3[%f:%f] ch4[%f:%f] ch5[%f:%f] ch6[%f:%f]"
+      , __func__,
+      pset_ar_cfg->Ch1_L_PreGain, pset_ar_cfg->Ch1_R_PreGain,
+      pset_ar_cfg->Ch2_L_PreGain, pset_ar_cfg->Ch2_R_PreGain,
+      pset_ar_cfg->Ch3_L_PreGain, pset_ar_cfg->Ch3_R_PreGain,
+      pset_ar_cfg->Ch4_L_PreGain, pset_ar_cfg->Ch4_R_PreGain,
+      pset_ar_cfg->Ch5_L_PreGain, pset_ar_cfg->Ch5_R_PreGain,
+      pset_ar_cfg->Ch6_L_PreGain, pset_ar_cfg->Ch6_R_PreGain);
+
+  ALOGD("(LHDC-exAPI) %s: PostGain: ch1[%f] ch2[%f] ch3[%f] ch4[%f] ch5[%f] ch6[%f]"
+      , __func__,
+      pset_ar_cfg->Ch1_PostGain, pset_ar_cfg->Ch2_PostGain,
+      pset_ar_cfg->Ch3_PostGain, pset_ar_cfg->Ch4_PostGain,
+      pset_ar_cfg->Ch5_PostGain, pset_ar_cfg->Ch6_PostGain);
+
+  ALOGD("(LHDC-exAPI) %s: Dry_Val(%f) Wet_Val(%f)" , __func__,
+      pset_ar_cfg->Dry_Val, pset_ar_cfg->Wet_Val);
+
+  ALOGD("(LHDC-exAPI) %s: Dis[%f %f %f %f %f] Rev[%f %f %f %f %f]" , __func__,
+      pset_ar_cfg->Dis_1, pset_ar_cfg->Dis_2, pset_ar_cfg->Dis_3, pset_ar_cfg->Dis_4, pset_ar_cfg->Dis_5,
+      pset_ar_cfg->Rev_1, pset_ar_cfg->Rev_2, pset_ar_cfg->Rev_3, pset_ar_cfg->Rev_4, pset_ar_cfg->Rev_5);
+
+  ALOGD("(LHDC-exAPI) %s: Rev_gain(%f) ThreeD_gain(%f)" , __func__,
+      pset_ar_cfg->Rev_gain, pset_ar_cfg->ThreeD_gain);
+
+  ALOGD ("(LHDC-exAPI) %s: to set AR enable: %d",  __func__, pset_ar_cfg->app_ar_enabled);
+  func_ret = lhdcv5_util_ar_set_cfg (handle,
+      &pset_ar_cfg->Ch1_Pos,
+      6,
+      &pset_ar_cfg->Ch1_L_PreGain,
+      32,
+      pset_ar_cfg->app_ar_enabled);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: func_ret %d",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+//----------------------------------------------------------------
+// lhdcBT_get_cfg_ar_v1 ()
+//
+// Get configuration for AR
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		configLen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to get configuration   
+//		Other: fail to get configuration.
+//----------------------------------------------------------------
+static int lhdcBT_get_cfg_ar_v1
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char 				* userConfig,
+    const int 			configLen
+) 
+{
+  PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR) userConfig;
+  int 		func_ret = LHDCV5_FRET_SUCCESS;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (configLen < (int) sizeof (ST_LHDC_AR))
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  func_ret = lhdcv5_util_ar_get_cfg (handle,
+      &pset_ar_cfg->Ch1_Pos,
+      6,
+      &pset_ar_cfg->Ch1_L_PreGain,
+      32);
+
+  if (func_ret != LHDCV5_FRET_SUCCESS)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Fail to get AR config (%d)!",  __func__, func_ret);
+    return EXTEND_FUNC_RET_ERROR;
+  }
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+// 1. API -- Set User Config (Extend)
+//----------------------------------------------------------------
+// lhdcv5BT_set_user_exconfig ()
+//
+// Set configuration
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		clen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to set configuration   
+//		Other: fail to set configuration.
+//----------------------------------------------------------------
+int lhdcv5BT_set_user_exconfig
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char			* userConfig,
+    const int 			clen
+) 
+{
+  unsigned char 	* pucConfig = (unsigned char *) userConfig;
+  unsigned int 	exFuncVer;
+  unsigned int 	exFuncCode;
+  int 			func_ret = EXTEND_FUNC_RET_OK;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int) EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  lhdcBT_code_ver_wrap(pucConfig, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  case EXTEND_FUNC_CODE_SET_CONFIG_META:
+
+    switch (exFuncVer)
+    {
+    case EXTEND_FUNC_VER_SET_CONFIG_META_V1:
+      ALOGD ("(LHDC-exAPI) %s: SET_CONFIG_META",  __func__);
+      func_ret = lhdcBT_set_cfg_meta_v1 (handle, userConfig, clen);
+
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("(LHDC-exAPI) %s: Fail to set META data (%d)!",  __func__, func_ret);
+        return EXTEND_FUNC_RET_ERROR;
+      }
+      break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+      return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+    }
+    break;
+
+    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+      switch (exFuncVer)
+      {
+      case EXTEND_FUNC_VER_SET_CONFIG_AR_V3:
+        ALOGD ("(LHDC-exAPI) %s: SET_CONFIG_AR",  __func__);
+        func_ret = lhdcBT_set_cfg_ar_v3 (handle, userConfig, clen);
+
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("(LHDC-exAPI) %s: Fail to set AR config (%d)!",  __func__, func_ret);
+          return EXTEND_FUNC_RET_ERROR;
+        }
+        break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+        return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+      }
+      break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+  } // switch (exFuncCode)
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+// 2. API -- Get User Config (Extend)
+//----------------------------------------------------------------
+// lhdcv5BT_get_user_exconfig ()
+//
+// Get configuration
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userConfig: a pointer to configuration
+//		clen: number of bytes of configuration
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to get configuration   
+//		Other: fail to get configuration.
+//----------------------------------------------------------------
+
+int lhdcv5BT_get_user_exconfig
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char				* userConfig,
+    int 				clen
+) 
+{
+  unsigned char 	* pucConfig = (unsigned char *) userConfig;
+  unsigned int 	exFuncVer;
+  unsigned int 	exFuncCode;
+  int 			func_ret = EXTEND_FUNC_RET_OK;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userConfig == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  lhdcBT_code_ver_wrap(pucConfig, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  case EXTEND_FUNC_CODE_GET_CONFIG_META:
+
+    switch (exFuncVer)
+    {
+    case EXTEND_FUNC_VER_GET_CONFIG_META_V1:
+      ALOGD ("(LHDC-exAPI) %s: GET_CONFIG_META",  __func__);
+      func_ret = lhdcBT_get_cfg_meta_v1 (handle, userConfig, clen);
+
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("(LHDC-exAPI) %s: Fail to get META data (%d)!",  __func__, func_ret);
+        return EXTEND_FUNC_RET_ERROR;
+      }
+      break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+      return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+    }
+    break;
+
+    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+
+      switch (exFuncVer)
+      {
+      case EXTEND_FUNC_VER_GET_CONFIG_AR_V1:
+        ALOGD ("(LHDC-exAPI) %s: GET_CONFIG_AR",  __func__);
+        func_ret = lhdcBT_get_cfg_ar_v1 (handle, userConfig, clen);
+
+        if (func_ret != LHDCV5_FRET_SUCCESS)
+        {
+          ALOGW ("(LHDC-exAPI) %s: Fail to get AR config (%d)!",  __func__, func_ret);
+          return EXTEND_FUNC_RET_ERROR;
+        }
+        break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+        return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
+      }
+      break;
+
+      default:
+        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+  } // switch (exFuncCode)
+
+
+  return EXTEND_FUNC_RET_OK;
+}
+
+
+// 3. API -- Set User Data (Extend)
+//----------------------------------------------------------------
+// lhdcv5BT_set_user_exdata ()
+//
+// Set data
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		userData: a pointer to data
+//		clen: number of bytes of data
+//	Return
+//		EXTEND_FUNC_RET_OK: succeed to set data   
+//		Other: fail to set data.
+//----------------------------------------------------------------
+void lhdcv5BT_set_user_exdata
+(
+    HANDLE_LHDCV5_BT 	handle,
+    const char			* userData,
+    const int 			clen
+) 
+{
+  unsigned char 	* pucData = (unsigned char *) userData;
+  unsigned int 	exFuncVer;
+  unsigned int 	exFuncCode;
+  int 			func_ret = EXTEND_FUNC_RET_OK;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return; // EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (userData == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: User Data is NULL (%p)!",  __func__, userData);
+    return; // EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int) EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer is too small (%d)!",  __func__, clen);
+    return;
+  }
+
+  lhdcBT_code_ver_wrap(pucData, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+
+    switch (exFuncVer)
+    {
+    case EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1:
+      ALOGD ("(LHDC-exAPI) %s: SET_DATA_GYRO",  __func__);
+      func_ret = lhdcBT_set_data_gyro_2d_v1 (handle, userData, clen);
+
+      if (func_ret != LHDCV5_FRET_SUCCESS)
+      {
+        ALOGW ("(LHDC-exAPI) %s: Fail to get gyro's data (%d)!",  __func__, func_ret);
+        return;
+      }
+      break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
+      break; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+    }
+    break;
+
+    default:
+      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+      break;
+  } // switch (exFuncCode)
+
+  return;
+}
+
+
+// 4. API -- Get Version
+//----------------------------------------------------------------
+// lhdcv5BT_get_user_exApiver ()
+//
+// Get version
+//	Parameter
+//		handle: a pointer to the resource allocated and is returned 
+//				by function lhdcBT_get_handle ()
+//		version: a pointer to version
+//		clen: number of bytes of version
+//	Return
+//		0: succeed to set data   
+//		Other: fail to set data.
+//----------------------------------------------------------------
+int lhdcv5BT_get_user_exApiver
+(
+    HANDLE_LHDCV5_BT 	handle,
+    char 				* version,
+    int 				clen
+) 
+{
+  unsigned char 	* pucApiVer = (unsigned char *) version;
+  unsigned int 	exFuncVer = 0;
+  unsigned int 	exFuncCode = 0;
+
+  if (handle == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
+    return EXTEND_FUNC_RET_INVALID_HANDLE;
+  }
+
+  if (version == NULL)
+  {
+    ALOGW ("(LHDC-exAPI) %s: API verion pointer is NULL (%p)!",  __func__, version);
+    return EXTEND_FUNC_RET_INVALID_PARAMETER;
+  }
+
+  if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN)
+  {
+    // Buffer is to small
+    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
+    return EXTEND_FUNC_RET_BUF_UNDERRUN;
+  }
+
+  lhdcBT_code_ver_wrap(pucApiVer, &exFuncCode , &exFuncVer);
+
+  switch (exFuncCode)
+  {
+  // Config APIs:
+  case EXTEND_FUNC_CODE_SET_CONFIG_META:
+    exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_META_V1;
+    break;
+
+  case EXTEND_FUNC_CODE_SET_CONFIG_AR:
+    exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_AR_V3;
+    break;
+
+  case EXTEND_FUNC_CODE_GET_CONFIG_META:
+    exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_META_V1;
+    break;
+
+  case EXTEND_FUNC_CODE_GET_CONFIG_AR:
+    exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_AR_V1;
+    break;
+
+    // Data APIs:
+  case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
+    exFuncVer = EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1;
+    break;
+
+    // A2DP codec config APIs:
+  case EXTEND_FUNC_CODE_GET_SPECIFIC:
+    exFuncVer = EXTEND_FUNC_VER_GET_SPECIFIC_V2;
+    break;
+
+  default:
+    ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
+    return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
+  } // switch (exFuncCode)
+
+  // fill version of target API
+  pucApiVer[3] = (unsigned char) (exFuncVer & ((unsigned int)0xff));
+  pucApiVer[2] = (unsigned char) ((exFuncVer >> 8) & ((unsigned int)0xff));
+  pucApiVer[1] = (unsigned char) ((exFuncVer >> 16) & ((unsigned int)0xff));
+  pucApiVer[0] = (unsigned char) ((exFuncVer >> 24) & ((unsigned int)0xff));
+
+  ALOGD ("(LHDC-exAPI) %s: APICode:[%02X %02X %02X %02X] Ver:[%02X %02X %02X %02X]",  __func__,
+      pucApiVer[4],
+      pucApiVer[5],
+      pucApiVer[6],
+      pucApiVer[7],
+      pucApiVer[0],
+      pucApiVer[1],
+      pucApiVer[2],
+      pucApiVer[3]);
+
+  return EXTEND_FUNC_RET_OK;
+}
+
diff --git a/external/liblhdcv5dec/Android.bp b/external/liblhdcv5dec/Android.bp
new file mode 100644
index 000000000..942aadb61
--- /dev/null
+++ b/external/liblhdcv5dec/Android.bp
@@ -0,0 +1,50 @@
+
+cc_prebuilt_library_shared {
+    name: "liblhdcv5dec",
+    
+    export_include_dirs: ["include"],
+    arch: {
+        arm: {
+            srcs: ["libs/armeabi-v7a/liblhdcv5dec.so",],
+        },
+        arm64: {
+            srcs: ["libs/arm64-v8a/liblhdcv5dec.so",],
+        },
+    },
+
+    strip: {
+        none:true,
+    },
+
+    shared_libs: [
+        "liblog",
+        "libstdc++",
+    ],
+}
+
+cc_library_shared {
+    name: "liblhdcv5BT_dec",
+    //vendor_available: true,
+    //vndk: {
+    //    enabled: true,
+    //},
+    arch: {
+        arm: {
+            instruction_set: "arm",
+        },
+    },
+    export_include_dirs: ["inc"],
+    local_include_dirs: ["inc", "include", ],
+    srcs: [
+        "src/lhdcv5BT_dec.c",
+    ],
+    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
+    // unit such as ARM Cortex-R series or external 32-bit DSPs.
+    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
+
+    shared_libs: [
+        "libcutils",
+        "liblog",
+        "liblhdcv5dec",
+    ],
+}
diff --git a/external/liblhdcv5dec/CHANGES b/external/liblhdcv5dec/CHANGES
new file mode 100644
index 000000000..123e86335
--- /dev/null
+++ b/external/liblhdcv5dec/CHANGES
@@ -0,0 +1,7 @@
+Release Note.
+=========================================================
+Jun 21, 2022, by jimmy.chen@savitech.co
+  *Update version to 5.0.5
+
+Feb, 21, 2022, by jimmy.chen@savitech.co
+  *Add LHDCV5 Decoder v5.0.1
diff --git a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
new file mode 100644
index 000000000..0785b9fe2
--- /dev/null
+++ b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
@@ -0,0 +1,69 @@
+#ifndef _LHDCV5BT_DEC_H_
+#define _LHDCV5BT_DEC_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "lhdcv5_util_dec.h"
+
+#define LHDCV5BT_SAMPLE_RATE_44K    (44100)
+#define LHDCV5BT_SAMPLE_RATE_48K    (48000)
+#define LHDCV5BT_SAMPLE_RATE_96K    (96000)
+#define LHDCV5BT_SAMPLE_RATE_192K   (192000)
+
+#define LHDCV5BT_BIT_DEPTH_16    (16)
+#define LHDCV5BT_BIT_DEPTH_24    (24)
+#define LHDCV5BT_BIT_DEPTH_32    (32)
+
+#define LHDCV5BT_BIT_RATE_64K    (64000)
+#define LHDCV5BT_BIT_RATE_128K   (128000)
+#define LHDCV5BT_BIT_RATE_192K   (192000)
+#define LHDCV5BT_BIT_RATE_256K   (256000)
+#define LHDCV5BT_BIT_RATE_320K   (320000)
+#define LHDCV5BT_BIT_RATE_400K   (400000)
+#define LHDCV5BT_BIT_RATE_600K   (600000)
+#define LHDCV5BT_BIT_RATE_900K   (900000)
+#define LHDCV5BT_BIT_RATE_1000K  (1000000)
+
+
+
+typedef struct
+{
+  lhdc_ver_t version;
+  uint32_t sample_rate;
+  uint32_t bits_depth;
+  uint32_t bit_rate;
+} tLHDCV5_DEC_CONFIG;
+
+
+// lib APIs
+int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config);
+int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle);
+
+#define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
+#define LHDCBT_DEC_UPD_SEQ_NO				1
+
+typedef enum __LHDCV5BT_DEC_API_RET__
+{
+  LHDCV5BT_DEC_API_SUCCEED            =  0,
+  LHDCV5BT_DEC_API_FAIL               = -1,
+  LHDCV5BT_DEC_API_INVALID_INPUT      = -2,
+  LHDCV5BT_DEC_API_INVALID_OUTPUT     = -3,
+  LHDCV5BT_DEC_API_INVALID_SEQ_NO     = -4,
+  LHDCV5BT_DEC_API_INIT_DECODER_FAIL  = -5,
+  LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL = -6,
+  LHDCV5BT_DEC_API_FRAME_INFO_FAIL    = -7,
+  LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH   = -8,
+  LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH  = -9,
+  LHDCV5BT_DEC_API_DECODE_FAIL        = -10,
+  LHDCV5BT_DEC_API_ALLOC_MEM_FAIL  = -11,
+
+} LHDCV5BT_DEC_API_RET_T;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _LHDCBT_DEC_H_ */
diff --git a/external/liblhdcv5dec/include/lhdcv5_util_dec.h b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
new file mode 100644
index 000000000..576d8c5c2
--- /dev/null
+++ b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
@@ -0,0 +1,100 @@
+/*
+ * lhdcv5_util_dec.h
+ *
+ */
+
+#ifndef LHDCV5_UTIL_DEC_H
+#define LHDCV5_UTIL_DEC_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void * HANDLE_LHDCV5_BT;
+
+// Copy definition from external
+#define BTIF_BD_ADDR_SIZE    6
+
+// Define for LHDC stream type.
+typedef enum {
+  LHDC_STRM_TYPE_COMBINE,
+  LHDC_STRM_TYPE_SPLIT
+}LHDC_STRM_TYPE;
+
+typedef enum {
+  VERSION_5 = 550
+}lhdc_ver_t;
+
+typedef enum {
+  LHDCV2_BLOCK_SIZE = 512,
+  LHDCV3_BLOCK_SIZE = 256,
+}lhdc_block_size_t;
+
+typedef struct savi_bt_local_info_t{
+  uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
+  const char *bt_name;
+  uint8_t bt_len;
+  uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
+  const char *ble_name;
+  uint8_t ble_len;
+}savi_bt_local_info;
+
+typedef struct _lhdc_frame_Info
+{
+  uint32_t frame_len;
+  uint32_t isSplit;
+  uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+typedef enum {
+  LHDC_OUTPUT_STEREO = 0,
+  LHDC_OUTPUT_LEFT_CAHNNEL,
+  LHDC_OUTPUT_RIGHT_CAHNNEL,
+} lhdc_channel_t;
+
+typedef int LHDCSample;
+
+typedef void (*print_log_fp)(char*  msg);
+typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
+
+
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
+
+#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
+
+
+int32_t lhdcv5_util_init_decoder(uint32_t *ptr, uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+
+int32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t InLen, uint32_t *OutLen);
+char *lhdcv5_util_dec_get_version();
+
+int32_t lhdcv5_util_dec_destroy();
+
+void lhdcv5_util_dec_register_log_cb(print_log_fp cb);
+
+int32_t lhdcv5_util_dec_get_sample_size (uint32_t *frame_samples);
+int32_t lhdcv5_util_dec_fetch_frame_info(uint8_t *frameData, uint32_t frameDataLen, lhdc_frame_Info_t *frameInfo);
+
+int32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
+int32_t lhdcv5_util_dec_get_mem_req(lhdc_ver_t version, uint32_t *mem_req_bytes);
+
+//Return
+#define LHDCV5_UTIL_DEC_SUCCESS 0
+#define LHDCV5_UTIL_DEC_ERROR_NO_INIT -1
+#define LHDCV5_UTIL_DEC_ERROR_PARAM -2
+#define LHDCV5_UTIL_DEC_ERROR -3
+#define LHDCV5_UTIL_DEC_ERROR_WRONG_DEC -10
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* End of LHDCV5_UTIL_DEC_H */
diff --git a/external/liblhdcv5dec/libs/arm64-v8a/.gitkeep b/external/liblhdcv5dec/libs/arm64-v8a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdcv5dec/libs/armeabi-v7a/.gitkeep b/external/liblhdcv5dec/libs/armeabi-v7a/.gitkeep
new file mode 100644
index 000000000..e69de29bb
diff --git a/external/liblhdcv5dec/src/lhdcv5BT_dec.c b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
new file mode 100644
index 000000000..92f1534d7
--- /dev/null
+++ b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
@@ -0,0 +1,409 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include "lhdcv5BT_dec.h"
+
+#define LOG_NDEBUG 0
+#define LOG_TAG "lhdcv5BT_dec"
+#include <cutils/log.h>
+
+static uint8_t serial_no = 0xff;
+
+// description
+//   a function to log in LHDC decoder library
+// Parameter
+//   msg: char string to print
+static void print_log_cb(char *msg)
+{
+  if (msg == NULL) {
+    return;
+  }
+
+  ALOGD("[V5Dec_lib] %s", msg);
+}
+
+
+// description
+//   check number of frames in one packet and return pointer to first byte of 1st frame in current packet
+// Parameter
+//   input: pointer to input buffer
+//   input_len: length (bytes) of input buffer pointed by input
+//   pLout: pointer to pointer to output buffer
+//   pLlen: length (bytes) of encoded stream in output buffer
+//   upd_seq_no: sequence number type
+// return:
+//   > 0: number of frames in current packet
+//   == 0: No frames in current packet
+//   < 0: error
+static int32_t assemble_lhdcv5_packet(uint32_t *frame_num, uint8_t *input, uint32_t input_len,
+    uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
+{
+  uint8_t hdr = 0, seqno = 0xff;
+  uint32_t status = 0;
+  uint32_t lhdc_total_frame_nb = 0;
+
+  if ((input == NULL) ||
+      (pLout == NULL) ||
+      (pLlen == NULL)) {
+    ALOGD("%s: null ptr", __func__);
+    return -1;
+  }
+
+  if (input_len < 2) {
+    ALOGD("%s: input len too small", __func__);
+    return -1;
+  }
+
+  hdr = (*input);
+  input++;
+  seqno = (*input);
+  input++;
+  input_len -= 2;
+
+  //Check latency and update value when changed.
+  status = hdr & A2DP_LHDC_HDR_LATENCY_MASK;
+
+  //Get number of frame in packet.
+  status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
+
+  if (status <= 0) {
+    ALOGD("%s: no any frame in packet.", __func__);
+    *frame_num = 0;
+    return 0;
+  }
+
+  lhdc_total_frame_nb = status;
+
+  if (seqno != serial_no) {
+    ALOGD("%s: packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
+    //serial_no = seqno;
+    //return -1;
+  }
+
+  if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO) {
+    serial_no = seqno + 1;
+  }
+
+  *pLlen = input_len;
+  *pLout = input;
+
+  *frame_num = (int) lhdc_total_frame_nb;
+
+  ALOGD("%s: total frame number (%d)", __func__, *frame_num);
+  return 0;
+}
+
+
+// description
+//   init. LHDC V5 decoder
+// Parameter
+//   handle: codec handle(ptr for heap) from bt stack
+//   config: configuration for LHDC V5 decoder
+// return:
+//   == 0: succeed
+//   != 0: error code
+int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config)
+{
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+  uint32_t mem_req_bytes = 0;
+  HANDLE_LHDCV5_BT hLhdcBT = NULL;
+
+  ALOGD("%s: decoder lib version = %s", __func__, lhdcv5_util_dec_get_version());
+
+  if (handle == NULL || config == NULL) {
+    ALOGD("%s: null ptr handle %p config %p", __func__, handle, config);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  ALOGD("%s: bits_depth:%u sample_rate=%u bit_rate=%u version=%d", __func__,
+      config->bits_depth, config->sample_rate, config->bit_rate, config->version);
+
+  if ((config->bits_depth != LHDCV5BT_BIT_DEPTH_16) &&
+      (config->bits_depth != LHDCV5BT_BIT_DEPTH_24) &&
+      (config->bits_depth != LHDCV5BT_BIT_DEPTH_32)) {
+    ALOGD("%s: bits_depth %d not supported", __func__, config->bits_depth);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((config->sample_rate != LHDCV5BT_SAMPLE_RATE_44K) &&
+      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_48K) &&
+      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_96K) &&
+      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_192K)) {
+    ALOGD("%s: sample_rate %d not supported", __func__, config->sample_rate);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((0 > config->bit_rate) || (config->bit_rate > LHDCV5BT_BIT_RATE_1000K)) {
+    ALOGD("%s: bit_rate %d not supported", __func__, config->bit_rate);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  if ((config->version != VERSION_5)) {
+    ALOGD("%s: version %d not supported", __func__, config->version);
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  lhdcv5_util_dec_register_log_cb(&print_log_cb);
+
+  func_ret = lhdcv5_util_dec_get_mem_req(config->version, &mem_req_bytes);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS || mem_req_bytes <= 0) {
+    ALOGW("%s: Fail to get required memory size (%d)!", __func__, func_ret);
+    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
+  }
+
+  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
+  if (hLhdcBT == NULL) {
+    ALOGW ("%s: Fail to allocate memory!", __func__);
+    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
+  }
+
+  ALOGD("%s: init lhdcv5 decoder...", __func__);
+  //TODO: send mem_req_bytes for size check
+  func_ret = lhdcv5_util_init_decoder(hLhdcBT, config->bits_depth,
+      config->sample_rate, config->bit_rate, config->version);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGW ("%s: failed to init decoder (%d)!", __func__, func_ret);
+    free(hLhdcBT);
+    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
+  }
+
+  *handle = hLhdcBT;
+  if ((*handle) == NULL) {
+    ALOGW ("%s: handle return NULL!", __func__);
+    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
+  }
+
+  func_ret = lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGW ("%s: failed to configure channel (%d)!", __func__, func_ret);
+    return LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL;
+  }
+
+  serial_no = 0xff;
+
+  ALOGD("%s: init lhdcv5 decoder success", __func__);
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
+
+// description
+//   check whether all frames of one packet are in buffer?
+// Parameter
+//   frameData: pointer to input buffer
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+//   packetBytes: return the final number of queued data in decoder lib (for validation)
+// return:
+//   == 0: succeed
+//   < 0: error
+int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData,
+    uint32_t frameBytes, uint32_t *packetBytes)
+{
+  uint8_t *frameDataStart = (uint8_t *)frameData;
+  uint8_t *in_buf = NULL;
+  uint32_t in_len = 0;
+  uint32_t frame_num = 0;
+  lhdc_frame_Info_t lhdc_frame_Info;
+  uint32_t ptr_offset = 0;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+
+  if ((frameData == NULL) || (packetBytes == NULL)) {
+    return LHDCV5_UTIL_DEC_ERROR_PARAM;
+  }
+
+  *packetBytes = 0;
+
+  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
+      LHDCBT_DEC_NOT_UPD_SEQ_NO);
+  if (func_ret < 0 || in_buf == NULL) {
+    ALOGE("%s: failed setup input buffer", __func__);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if (frame_num == 0) {
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  ALOGD("%s: incoming frame size(%d), decoding size(%d), total frame num(%d)", __func__,
+      frameBytes, in_len, frame_num);
+
+  ptr_offset = 0;
+
+  while ((frame_num > 0) && (ptr_offset < in_len))
+  {
+    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+    }
+
+    ALOGV("%s: frame_num[%d]: ptr_offset (%d), frame_len (%d)", __func__,
+        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
+
+    if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
+      ALOGD(" %s: frame_num[%d]: Not Enough... ptr_offset(%d), frame_len(%d)",
+          __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
+      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
+    }
+
+    ptr_offset += lhdc_frame_Info.frame_len;
+
+    frame_num--;
+  }
+
+  *packetBytes = ptr_offset;
+
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
+
+// description
+//   decode all frames in one packet
+// Parameter
+//   frameData: pointer to input buffer from bt stack
+//   frameBytes: length (bytes) of input buffer pointed by frameData
+//   pcmData: pointer to output buffer to bt stack
+//   pcmBytes: length (bytes) of pcm samples in output buffer
+//   bits_depth: bit per sample
+// return:
+//   == 0: succeed
+//   < 0: error
+int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t *pcmData, uint32_t *pcmBytes, uint32_t bits_depth)
+{
+  uint8_t *frameDataStart = (uint8_t *)frameData;
+  uint32_t dec_sum = 0;
+  uint32_t lhdc_out_len = 0;
+  uint8_t *in_buf = NULL;   //buffer position to input to decode process
+  uint32_t in_len = 0;
+  uint32_t frame_num = 0;
+  lhdc_frame_Info_t lhdc_frame_Info;
+  uint32_t ptr_offset = 0;
+  uint32_t frame_samples;
+  uint32_t frame_bytes;
+  uint32_t pcmSpaceBytes;
+  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+
+  ALOGV("%s: enter frameBytes %d", __func__, (int)frameBytes);
+
+  if ((frameData == NULL) ||
+      (pcmData == NULL) ||
+      (pcmBytes == NULL)) {
+    return LHDCV5BT_DEC_API_INVALID_INPUT;
+  }
+
+  pcmSpaceBytes = *pcmBytes;
+  *pcmBytes = 0;
+
+  /*
+  if(frameBytes >= 16) {
+    for(int i=0; i<16; i++) {
+      ALOGD(" %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+    }
+  } else {
+    for(int i=0; i<(int)frameBytes; i++) {
+      ALOGD(" %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
+    }
+  }
+   */
+
+  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
+      LHDCBT_DEC_UPD_SEQ_NO);
+  if (func_ret < 0 || in_buf == NULL) {
+    ALOGE("%s: failed setup input buffer", __func__);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if (frame_num == 0) {
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  func_ret = lhdcv5_util_dec_get_sample_size(&frame_samples);
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGD("%s: fetch frame samples failed (%d)", __func__, func_ret);
+    return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+  }
+  ALOGV("%s: output frame samples %d", __func__, (int)frame_samples);
+
+  if (bits_depth == LHDCV5BT_BIT_DEPTH_16) {
+    frame_bytes = frame_samples * 2 * 2;
+  } else {
+    // 24 or 32
+    frame_bytes = frame_samples * 4 * 2;
+  }
+
+  ptr_offset = 0;
+  dec_sum = 0;
+
+  while ((frame_num > 0) && (ptr_offset < in_len))
+  {
+    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+    }
+
+    if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
+      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
+    }
+
+    if ((dec_sum + frame_bytes) > pcmSpaceBytes) {
+      return LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH;
+    }
+
+    //ALOGD("%s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
+    func_ret = lhdcv5_util_dec_process(
+        ((uint8_t *)pcmData) + dec_sum,
+        in_buf + ptr_offset,
+        lhdc_frame_Info.frame_len,
+        &lhdc_out_len);
+    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+      ALOGD("%s: decode fail (%d)", __func__, func_ret);
+      return LHDCV5BT_DEC_API_DECODE_FAIL;
+    }
+
+    ALOGD("%s: frame_num[%d]: input_frame_len %d output_len %d", __func__,
+        (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
+
+    ptr_offset += lhdc_frame_Info.frame_len;
+    dec_sum += lhdc_out_len;
+
+    frame_num--;
+  }
+
+  *pcmBytes = (uint32_t) dec_sum;
+
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
+
+// description
+//   de-initialize (free) all resources allocated by LHDC V5 decoder
+// Parameter
+//   none
+// return:
+//   == 0: success
+int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle)
+{
+  int32_t func_ret = 0;
+
+  if(handle == NULL) {
+    ALOGD("%s: empty handle", __func__);
+    return LHDCV5BT_DEC_API_SUCCEED;
+  }
+
+  func_ret = lhdcv5_util_dec_destroy();
+  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
+    ALOGD("%s: deinit decoder error (%d)", __func__, func_ret);
+    return LHDCV5BT_DEC_API_FAIL;
+  }
+
+  if(handle) {
+    ALOGD ("%s: free handle %p!", __func__, handle);
+    free(handle);
+  }
+
+  return LHDCV5BT_DEC_API_SUCCEED;
+}
+
diff --git a/frameworks_base/core/api/current.txt b/frameworks_base/core/api/current.txt
index 1dd401d04..9b9a9a9a2 100644
--- a/frameworks_base/core/api/current.txt
+++ b/frameworks_base/core/api/current.txt
@@ -8628,7 +8628,14 @@ package android.bluetooth {
     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices();
     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public int getConnectionState(android.bluetooth.BluetoothDevice);
     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[]);
+    method @Nullable public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+    method @Nullable public int getLhdcCodecExtendApiConfigAr(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+    method @Nullable public int getLhdcCodecExtendApiConfigMeta(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+    method @Nullable public int getLhdcCodecExtendApiVer(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public boolean isA2dpPlaying(android.bluetooth.BluetoothDevice);
+    method @Nullable public int setLhdcCodecExtendApiConfigAr(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+    method @Nullable public int setLhdcCodecExtendApiConfigMeta(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+    method @Nullable public void setLhdcCodecExtendApiDataGyro2D(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
     field @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public static final String ACTION_CONNECTION_STATE_CHANGED = "android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED";
     field @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public static final String ACTION_PLAYING_STATE_CHANGED = "android.bluetooth.a2dp.profile.action.PLAYING_STATE_CHANGED";
     field public static final int STATE_NOT_PLAYING = 11; // 0xb
@@ -35392,6 +35399,7 @@ package android.provider {
     field @Deprecated public static final String ALLOW_MOCK_LOCATION = "mock_location";
     field public static final String ANDROID_ID = "android_id";
     field @Deprecated public static final String BACKGROUND_DATA = "background_data";
+    field @Deprecated public static final String BLUETOOTH_A2DP_SINK = "bluetooth_a2dp_sink";
     field @Deprecated public static final String BLUETOOTH_ON = "bluetooth_on";
     field public static final android.net.Uri CONTENT_URI;
     field @Deprecated public static final String DATA_ROAMING = "data_roaming";
@@ -35486,6 +35494,7 @@ package android.provider {
     field @Deprecated public static final String ANIMATOR_DURATION_SCALE = "animator_duration_scale";
     field @Deprecated public static final String AUTO_TIME = "auto_time";
     field @Deprecated public static final String AUTO_TIME_ZONE = "auto_time_zone";
+    field @Deprecated public static final String BLUETOOTH_A2DP_SINK = "bluetooth_a2dp_sink";
     field public static final String BLUETOOTH_DISCOVERABILITY = "bluetooth_discoverability";
     field public static final String BLUETOOTH_DISCOVERABILITY_TIMEOUT = "bluetooth_discoverability_timeout";
     field @Deprecated public static final String BLUETOOTH_ON = "bluetooth_on";
diff --git a/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java b/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java
index 1dd32fec2..56ef441e1 100644
--- a/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java
+++ b/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java
@@ -792,6 +792,159 @@ public final class BluetoothA2dp implements BluetoothProfile {
         }
     }
 
+    //LHDC Extended Function APIs Start
+    @Nullable
+    public int getLhdcCodecExtendApiVer(@NonNull BluetoothDevice device,
+                                        @NonNull byte[] exApiVer) {
+        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiVer(" + device + ")");
+        verifyDeviceNotNull(device, "setCodecConfigPreference");
+        if (exApiVer == null) {
+            Log.e(TAG, "exApiVer can't be null");
+            throw new IllegalArgumentException("codecConfig cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendApiVer(device, exApiVer);
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+
+    @Nullable
+    public int setLhdcCodecExtendApiConfigAr(@NonNull BluetoothDevice device, 
+                                             @NonNull byte[] codecConfig) {
+        if (DBG) Log.d(TAG, "setLhdcCodecExtendApiConfigAr(" + device + ")");
+        verifyDeviceNotNull(device, "setLhdcCodecExtendApiConfigAr");
+        if (codecConfig == null) {
+            Log.e(TAG, "codecConfig can't be null");
+            throw new IllegalArgumentException("codecConfig cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.setLhdcCodecExtendApiConfigAr(device, codecConfig);
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+
+    @Nullable
+    public int getLhdcCodecExtendApiConfigAr(@NonNull BluetoothDevice device,
+                                             @NonNull byte[] codecConfig) {
+        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiConfigAr(" + device + ")");
+        verifyDeviceNotNull(device, "getLhdcCodecExtendApiConfigAr");
+        if (codecConfig == null) {
+            Log.e(TAG, "codecConfig can't be null");
+            throw new IllegalArgumentException("codecConfig cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+
+    @Nullable
+    public int setLhdcCodecExtendApiConfigMeta(@NonNull BluetoothDevice device,
+                                               @NonNull byte[] codecConfig) {
+        if (DBG) Log.d(TAG, "setLhdcCodecExtendApiConfigMeta(" + device + ")");
+        verifyDeviceNotNull(device, "setLhdcCodecExtendApiConfigMeta");
+        if (codecConfig == null) {
+            Log.e(TAG, "codecConfig can't be null");
+            throw new IllegalArgumentException("codecConfig cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+
+    @Nullable
+    public int getLhdcCodecExtendApiConfigMeta(@NonNull BluetoothDevice device,
+                                               @NonNull byte[] codecConfig) {
+        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiConfigMeta(" + device + ")");
+        verifyDeviceNotNull(device, "getLhdcCodecExtendApiConfigMeta");
+        if (codecConfig == null) {
+            Log.e(TAG, "codecConfig can't be null");
+            throw new IllegalArgumentException("codecConfig cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+
+    @Nullable 
+    public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(@NonNull BluetoothDevice device, 
+                                                            @NonNull byte[] codecConfig) {
+        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiConfigA2dpCodecSpecific(" + device + ")");
+        verifyDeviceNotNull(device, "getLhdcCodecExtendApiConfigA2dpCodecSpecific");
+        if (codecConfig == null) {
+            Log.e(TAG, "codecConfig can't be null");
+            throw new IllegalArgumentException("codecConfig cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                return service.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
+            }
+            if (service == null) Log.w(TAG, "Proxy not attached to service");
+            return -1;
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+            return -1;
+        }
+    }
+
+    @Nullable
+    public void setLhdcCodecExtendApiDataGyro2D(@NonNull BluetoothDevice device,
+                                                @NonNull byte[] codecData) {
+        if (DBG) Log.d(TAG, "setLhdcCodecExtendApiDataGyro2D(" + device + ")");
+        verifyDeviceNotNull(device, "setLhdcCodecExtendApiDataGyro2D");
+        if (codecData == null) {
+            Log.e(TAG, "codecData can't be null");
+            throw new IllegalArgumentException("codecData cannot be null");
+        }
+        try {
+            final IBluetoothA2dp service = getService();
+            if (service != null && isEnabled()) {
+                service.setLhdcCodecExtendApiDataGyro2D(device, codecData);
+            }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Error talking to BT service", e);
+        }
+    }
+    //LHDC Extended Function APIs End
+
     /**
      * Enables the optional codecs.
      *
diff --git a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
index 1d0bf97c3..9f4d953fe 100644
--- a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
+++ b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
@@ -46,6 +46,9 @@ public final class BluetoothCodecConfig implements Parcelable {
             SOURCE_CODEC_TYPE_APTX,
             SOURCE_CODEC_TYPE_APTX_HD,
             SOURCE_CODEC_TYPE_LDAC,
+            SOURCE_CODEC_TYPE_LHDCV3,
+            SOURCE_CODEC_TYPE_LHDCV2,
+            SOURCE_CODEC_TYPE_LHDCV5,
             SOURCE_CODEC_TYPE_MAX,
             SOURCE_CODEC_TYPE_INVALID
     })
@@ -67,8 +70,19 @@ public final class BluetoothCodecConfig implements Parcelable {
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_LDAC = 4;
 
+    // Savitech LHDC -- START
     @UnsupportedAppUsage
-    public static final int SOURCE_CODEC_TYPE_MAX = 5;
+    public static final int SOURCE_CODEC_TYPE_LHDCV3 = 5;
+
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_LHDCV2 = 6;
+
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 7;
+    // Savitech LHDC -- END
+
+    @UnsupportedAppUsage
+    public static final int SOURCE_CODEC_TYPE_MAX = 8;
 
     @UnsupportedAppUsage
     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
@@ -403,6 +417,13 @@ public final class BluetoothCodecConfig implements Parcelable {
                 return "aptX HD";
             case SOURCE_CODEC_TYPE_LDAC:
                 return "LDAC";
+            // Savitech LHDC -- START
+            case SOURCE_CODEC_TYPE_LHDCV2:
+                return "LHDC V2";
+            case SOURCE_CODEC_TYPE_LHDCV3:
+                return "LHDC V3";
+            case SOURCE_CODEC_TYPE_LHDCV5:
+                return "LHDC V5";
             case SOURCE_CODEC_TYPE_INVALID:
                 return "INVALID CODEC";
             default:
@@ -598,7 +619,10 @@ public final class BluetoothCodecConfig implements Parcelable {
     public boolean sameAudioFeedingParameters(BluetoothCodecConfig other) {
         return (other != null && other.mSampleRate == mSampleRate
                 && other.mBitsPerSample == mBitsPerSample
-                && other.mChannelMode == mChannelMode);
+                && other.mChannelMode == mChannelMode
+                && other.mCodecSpecific1 == mCodecSpecific1
+                && other.mCodecSpecific2 == mCodecSpecific2
+                && other.mCodecSpecific3 == mCodecSpecific3);
     }
 
     /**
@@ -652,6 +676,16 @@ public final class BluetoothCodecConfig implements Parcelable {
                 if (mCodecSpecific1 != other.mCodecSpecific1) {
                     return false;
                 }
+                return true;
+            // LHDC: Playback Quality at CodecSpecific1, Low Latency at CodecSpecific2; other feature flags at CodecSpecific3.
+            case SOURCE_CODEC_TYPE_LHDCV2:
+            case SOURCE_CODEC_TYPE_LHDCV3:
+            case SOURCE_CODEC_TYPE_LHDCV5:
+                if (mCodecSpecific1 != other.mCodecSpecific1 ||
+                    mCodecSpecific2 != other.mCodecSpecific2 ||
+                    mCodecSpecific3 != other.mCodecSpecific3) {
+                    return false;
+                }
                 // fall through
             default:
                 return true;
diff --git a/frameworks_base/core/java/android/provider/Settings.java b/frameworks_base/core/java/android/provider/Settings.java
index 54952fc2d..289780712 100644
--- a/frameworks_base/core/java/android/provider/Settings.java
+++ b/frameworks_base/core/java/android/provider/Settings.java
@@ -5415,6 +5415,13 @@ public final class Settings {
         @Deprecated
         public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
 
+        /**
+         * Savitech Add - A2DP_Source_Sink_Switch
+         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_A2DP_SINK} instead
+         */
+        @Deprecated
+        public static final String BLUETOOTH_A2DP_SINK = Global.BLUETOOTH_A2DP_SINK;
+
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
          */
@@ -5696,6 +5703,7 @@ public final class Settings {
             MOVED_TO_GLOBAL.add(Settings.Global.ADB_ENABLED);
             MOVED_TO_GLOBAL.add(Settings.Global.ASSISTED_GPS_ENABLED);
             MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_ON);
+            MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_A2DP_SINK);	// Savitech Add -- A2DP_Source_Sink_Switch
             MOVED_TO_GLOBAL.add(Settings.Global.BUGREPORT_IN_POWER_MENU);
             MOVED_TO_GLOBAL.add(Settings.Global.CDMA_CELL_BROADCAST_SMS);
             MOVED_TO_GLOBAL.add(Settings.Global.CDMA_ROAMING_MODE);
@@ -6438,6 +6446,13 @@ public final class Settings {
          */
         @Deprecated
         public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
+        
+        /**
+         * Savitech Add - A2DP_Source_Sink_Switch
+         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_A2DP_SINK} instead
+         */
+        @Deprecated
+        public static final String BLUETOOTH_A2DP_SINK = Global.BLUETOOTH_A2DP_SINK;
 
         /**
          * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
@@ -10741,6 +10756,14 @@ public final class Settings {
         @Readable
         public static final String BLUETOOTH_ON = "bluetooth_on";
 
+        /**
+         * Savitech Add - A2DP_Source_Sink_Switch
+         * Whether bluetooth A2DP is initialized as Source or Sink
+         * @hide
+         */
+        @Readable
+        public static final String BLUETOOTH_A2DP_SINK = "bluetooth_a2dp_sink";
+
         /**
          * CDMA Cell Broadcast SMS
          *                            0 = CDMA Cell Broadcast SMS disabled
diff --git a/frameworks_base/media/java/android/media/AudioManager.java b/frameworks_base/media/java/android/media/AudioManager.java
index 38f9607c9..e985855dd 100644
--- a/frameworks_base/media/java/android/media/AudioManager.java
+++ b/frameworks_base/media/java/android/media/AudioManager.java
@@ -6844,6 +6844,15 @@ public class AudioManager {
             int btSourceCodec = AudioSystem.audioFormatToBluetoothSourceCodec(format);
             if (btSourceCodec
                     != BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID) {
+                // Savitech Patch - START  Offload
+                // Add all LHDC series codecs to offload path
+                /*
+                if (btSourceCodec == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2));
+                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3));
+                }
+                */
+                // Savitech Patch - END
                 codecConfigList.add(new BluetoothCodecConfig(btSourceCodec));
             }
         }
diff --git a/frameworks_base/media/java/android/media/AudioSystem.java b/frameworks_base/media/java/android/media/AudioSystem.java
index 6ff551a68..dd8ca8181 100644
--- a/frameworks_base/media/java/android/media/AudioSystem.java
+++ b/frameworks_base/media/java/android/media/AudioSystem.java
@@ -230,6 +230,12 @@ public class AudioSystem
     public static final int AUDIO_FORMAT_APTX_HD        = 0x21000000;
     /** @hide */
     public static final int AUDIO_FORMAT_LDAC           = 0x23000000;
+    // Savitech Patch - START  Offload
+    /** @hide */
+    //public static final int AUDIO_FORMAT_LHDC           = 0x28000000;
+    /** @hide */
+    //public static final int AUDIO_FORMAT_LHDC_LL        = 0x29000000;
+    // Savitech Patch - END
 
     /** @hide */
     @IntDef(flag = false, prefix = "AUDIO_FORMAT_", value = {
@@ -239,7 +245,10 @@ public class AudioSystem
             AUDIO_FORMAT_SBC,
             AUDIO_FORMAT_APTX,
             AUDIO_FORMAT_APTX_HD,
-            AUDIO_FORMAT_LDAC }
+            AUDIO_FORMAT_LDAC,
+            //AUDIO_FORMAT_LHDC,    // Savitech Patch - START  Offload
+            //AUDIO_FORMAT_LHDC_LL,
+            }
     )
     @Retention(RetentionPolicy.SOURCE)
     public @interface AudioFormatNativeEnumForBtCodec {}
@@ -256,6 +265,14 @@ public class AudioSystem
             case AUDIO_FORMAT_APTX: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX;
             case AUDIO_FORMAT_APTX_HD: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD;
             case AUDIO_FORMAT_LDAC: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
+            // Savitech Patch - START  Offload
+            /*
+            case AUDIO_FORMAT_LHDC:
+                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+            case AUDIO_FORMAT_LHDC_LL:
+                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+            */
+            // Savitech Patch - END
             default:
                 Log.e(TAG, "Unknown audio format 0x" + Integer.toHexString(audioFormat)
                         + " for conversion to BT codec");
@@ -281,6 +298,16 @@ public class AudioSystem
                 return AudioSystem.AUDIO_FORMAT_APTX_HD;
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                 return AudioSystem.AUDIO_FORMAT_LDAC;
+            // Savitech Patch - START  Offload
+            /*
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
+                return AudioSystem.AUDIO_FORMAT_LHDC;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
+                return AudioSystem.AUDIO_FORMAT_LHDC;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
+                return AudioSystem.AUDIO_FORMAT_LHDC;
+            */
+            // Savitech Patch - END
             default:
                 Log.e(TAG, "Unknown BT codec 0x" + Integer.toHexString(btCodec)
                         + " for conversion to audio format");
diff --git a/frameworks_base/packages/SettingsLib/res/values/arrays.xml b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
index 2b5e9cdc0..cd7f9d29f 100644
--- a/frameworks_base/packages/SettingsLib/res/values/arrays.xml
+++ b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
@@ -154,6 +154,11 @@
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
         <item>LDAC</item>
+        <!-- Savitech Patch - START -->
+        <item>Savitech LHDC V2</item>
+        <item>Savitech LHDC V3/V4</item>
+        <item>Savitech LHDC-V</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Values for Bluetooth Audio Codec selection preference. -->
@@ -164,6 +169,11 @@
         <item>2</item>
         <item>3</item>
         <item>4</item>
+        <!-- Savitech Patch - START -->
+        <item>5</item>
+        <item>6</item>
+        <item>7</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Summaries for Bluetooth Audio Codec selection preference. [CHAR LIMIT=50]-->
@@ -174,6 +184,11 @@
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
         <item>LDAC</item>
+        <!-- Savitech Patch - START -->
+        <item>Savitech LHDC V2</item>
+        <item>Savitech LHDC V3/V4</item>
+        <item>Savitech LHDC-V</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Titles for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50] -->
@@ -183,6 +198,10 @@
         <item>48.0 kHz</item>
         <item>88.2 kHz</item>
         <item>96.0 kHz</item>
+        <!-- Savitech Patch - START -->
+        <item>176.4 kHz</item>
+        <item>192.0 kHz</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Values for Bluetooth Audio Codec Sample Rate selection preference. -->
@@ -192,6 +211,10 @@
         <item>2</item>
         <item>4</item>
         <item>8</item>
+        <!-- Savitech Patch - START -->
+        <item>16</item>
+        <item>32</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Summaries for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50]-->
@@ -201,6 +224,10 @@
         <item>48.0 kHz</item>
         <item>88.2 kHz</item>
         <item>96.0 kHz</item>
+        <!-- Savitech Patch - START -->
+        <item>176.4 kHz</item>
+        <item>192.0 kHz</item>
+        <!-- Savitech Patch - END -->
     </string-array>
 
     <!-- Titles for Bluetooth Audio Codec Bits Per Sample selection preference. [CHAR LIMIT=50] -->
@@ -272,6 +299,103 @@
         <item>Best Effort (Adaptive Bit Rate)</item>
     </string-array>
 
+    <!-- Titles for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_titles" translatable="false" >
+        <item>Optimized for Connection Quality (64kbps)</item>
+        <item>Optimized for Connection Quality (128kbps)</item>
+        <item>Optimized for Connection Quality (192kbps)</item>
+        <item>Optimized for Connection Quality (256kbps)</item>
+        <item>Optimized for Connection Quality (320kbps)</item>
+        <item>Optimized for Connection Quality (400kbps)</item>
+        <item>Balanced Audio And Connection Quality (500kbps)</item>
+        <item>High Audio Quality (900kbps)</item>
+        <item>Extremely High Audio Quality (1000kbps)</item>
+        <item>Best Effort (Auto Bit Rate)</item>
+    </string-array>
+
+    <!-- Values for Bluetooth Audio Codec LHDC Playback Quaility selection preference. -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_values" translatable="false" >
+        <item>32768</item>
+        <item>32769</item>
+        <item>32770</item>
+        <item>32771</item>
+        <item>32772</item>
+        <item>32773</item>
+        <item>32774</item>
+        <item>32775</item>
+        <item>32776</item>
+        <item>32777</item>
+    </string-array>
+
+    <!-- Summaries for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_summaries" translatable="false" >
+        <item>Optimized for Connection Quality (64kbps)</item>
+        <item>Optimized for Connection Quality (128kbps)</item>
+        <item>Optimized for Connection Quality (192kbps)</item>
+        <item>Optimized for Connection Quality (256kbps)</item>
+        <item>Optimized for Connection Quality (320kbps)</item>
+        <item>Optimized for Connection Quality (400kbps)</item>
+        <item>Balanced Audio And Connection Quality</item>
+        <item>High Audio Quality</item>
+        <item>Extremely High Audio Quality</item>
+        <item>Best Effort (Auto Bit Rate)</item>
+    </string-array>
+
+    <!-- Titles for Bluetooth Audio Codec LHDC Low Latency selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_latency_titles" translatable="false" >
+        <item>Low Latency Mode Disable</item>
+        <item>Low Latency Mode Enable</item>
+    </string-array>
+
+    <!-- Values for Bluetooth Audio Codec LHDC Latency selection preference. -->
+    <string-array name="bluetooth_a2dp_codec_lhdc_latency_values" translatable="false" >
+        <item>49152</item>
+        <item>49153</item>
+    </string-array>
+
+    <!-- Summaries for Bluetooth Audio Codec LHDC Latency selection preference. [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_a2dp_codec_lhdc_latency_summaries" translatable="false" >
+        <item>Low Latency OFF</item>
+        <item>Low Latency ON</item>
+    </string-array>
+
+    <!-- Titles for Bluetooth Audio Codec LHDC 3DAR Effect selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles" translatable="false" >
+        <item>OFF</item>
+        <item>ON</item>
+    </string-array>
+
+    <!-- Values for Bluetooth Audio Codec LHDC AR Effect selection preference -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" translatable="false" >
+        <item>0</item>
+        <item>2</item>
+    </string-array>
+
+    <!-- Summaries for Bluetooth Audio Codec LHDC AR Effect selection preference [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries" translatable="false" >
+        <item>LHDC 3DAR Effect OFF</item>
+        <item>LHDC 3DAR Effect ON</item>
+    </string-array>
+
+    <!-- Titles for Bluetooth Audio Codec LHDC Lossless selection preference. [CHAR LIMIT=70] -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_titles" translatable="false" >
+        <item>OFF</item>
+        <item>ON</item>
+    </string-array>
+
+    <!-- Values for Bluetooth Audio Codec LHDC Lossless selection preference -->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_values" translatable="false" >
+        <item>0</item>
+        <item>2</item>
+    </string-array>
+
+    <!-- Summaries for Bluetooth Audio Codec LHDC Lossless selection preference [CHAR LIMIT=70]-->
+    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_summaries" translatable="false" >
+        <item>LHDC Lossless OFF</item>
+        <item>LHDC Lossless ON</item>
+    </string-array>
+    <!-- Savitech Patch - END -->
+
     <!-- Summaries for Android Auto Bluetooth Audio Active Device status. [CHAR LIMIT=50]-->
     <string-array name="bluetooth_audio_active_device_summaries" >
         <!-- Status message when the device is not Active. -->
diff --git a/frameworks_base/packages/SettingsLib/res/values/strings.xml b/frameworks_base/packages/SettingsLib/res/values/strings.xml
index 6b840bd79..954dcb725 100644
--- a/frameworks_base/packages/SettingsLib/res/values/strings.xml
+++ b/frameworks_base/packages/SettingsLib/res/values/strings.xml
@@ -704,6 +704,30 @@
     <!-- UI debug setting: Select Bluetooth Audio LDAC Codec: LDAC Playback Quality -->
     <string name="bluetooth_select_a2dp_codec_ldac_playback_quality_dialog_title">Trigger Bluetooth Audio LDAC\u000ACodec Selection: Playback Quality</string>
 
+    <!-- Savitech LHDC - START -->
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Playback Quality -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality">Bluetooth Audio LHDC Codec: Playback Quality</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality_dialog_title">Select Bluetooth Audio LHDC Codec:\u000APlayback Quality</string>
+
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Low Latency -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_latency">Bluetooth Audio LHDC Codec: Low Latency</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_latency_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALatency</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency Summary -->
+    <string name="bluetooth_select_a2dp_codec_lhdc_latency_summary">LHDC Codec:\u000ALow Latency</string>
+
+    <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect">Enable LHDC 3DAR Effect</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect: LHDC AR Audio -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title">Select Bluetooth Audio LHDC Codec:\u000AAR Audio</string>
+
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless">Enable LHDC Lossless</string>
+    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless: LHDC Lossless Audio -->
+    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALossless Audio</string>
+    <!-- Savitech LHDC - END -->
+
     <!-- [CHAR LIMIT=NONE] Label for displaying Bluetooth Audio Codec Parameters while streaming -->
     <string name="bluetooth_select_a2dp_codec_streaming_label">Streaming: <xliff:g id="streaming_parameter">%1$s</xliff:g></string>
 
diff --git a/frameworks_base/packages/SettingsProvider/res/values/defaults.xml b/frameworks_base/packages/SettingsProvider/res/values/defaults.xml
index 8e6e251ff..d42ba16ca 100644
--- a/frameworks_base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks_base/packages/SettingsProvider/res/values/defaults.xml
@@ -35,8 +35,9 @@
     <fraction name="def_window_animation_scale">100%</fraction>
     <fraction name="def_window_transition_scale">100%</fraction>
     <bool name="def_haptic_feedback">true</bool>
-
     <bool name="def_bluetooth_on">true</bool>
+    <!-- Savitech Add A2DP_Source_Sink_Switch -->
+    <bool name="def_bluetooth_a2dp_sink">false</bool>
     <bool name="def_wifi_display_on">false</bool>
     <bool name="def_install_non_market_apps">false</bool>
     <!-- 0 == off, 3 == on -->
diff --git a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java
index db33c3f2c..0c28a4764 100644
--- a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java
+++ b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java
@@ -63,6 +63,7 @@ public class GlobalSettings {
         Settings.Global.LOW_POWER_MODE_STICKY_AUTO_DISABLE_ENABLED,
         Settings.Global.LOW_POWER_MODE_STICKY_AUTO_DISABLE_LEVEL,
         Settings.Global.BLUETOOTH_ON,
+        Settings.Global.BLUETOOTH_A2DP_SINK, //Savitech Add - A2DP_Source_Sink_Switch
         Settings.Global.PRIVATE_DNS_MODE,
         Settings.Global.PRIVATE_DNS_SPECIFIER,
         Settings.Global.SOFT_AP_TIMEOUT_ENABLED,
diff --git a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java
index d0448ef63..55ddc7e55 100644
--- a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java
+++ b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java
@@ -114,6 +114,10 @@ public class GlobalSettingsValidators {
         VALIDATORS.put(
                 Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, PERCENTAGE_INTEGER_VALIDATOR);
         VALIDATORS.put(Global.BLUETOOTH_ON, BOOLEAN_VALIDATOR);
+
+        //Savitech Add -- A2DP_Source_Sink_Switch
+        VALIDATORS.put(Global.BLUETOOTH_A2DP_SINK, BOOLEAN_VALIDATOR);
+
         VALIDATORS.put(Global.PRIVATE_DNS_MODE, ANY_STRING_VALIDATOR);
         VALIDATORS.put(Global.PRIVATE_DNS_SPECIFIER, ANY_STRING_VALIDATOR);
         VALIDATORS.put(Global.SOFT_AP_TIMEOUT_ENABLED, BOOLEAN_VALIDATOR);
diff --git a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
index 268603fa8..391d5574b 100644
--- a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+++ b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
@@ -2467,6 +2467,10 @@ class DatabaseHelper extends SQLiteOpenHelper {
             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
                     R.bool.def_bluetooth_on);
 
+            // Savitech Add -- A2DP_Source_Sink_Switch
+            loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_A2DP_SINK,
+                    R.bool.def_bluetooth_a2dp_sink);
+
             // Enable or disable Cell Broadcast SMS
             loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS,
                     RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
diff --git a/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java b/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java
index ff24c6f16..7977aa227 100644
--- a/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java
+++ b/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java
@@ -155,6 +155,8 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
 
     // Bluetooth persisted setting is off
     private static final int BLUETOOTH_OFF = 0;
+    // Savitech Add -- A2DP_Source_Sink_Switch
+    private static final int BLUETOOTH_A2DP_SINK_OFF = 0;
     // Bluetooth persisted setting is on
     // and Airplane mode won't affect Bluetooth state at start up
     private static final int BLUETOOTH_ON_BLUETOOTH = 1;
@@ -236,6 +238,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
     // synchronize with broadcast receiver.
     private boolean mQuietEnableExternal;
     private boolean mEnableExternal;
+    private boolean mA2DPSinkEnableExternal; // Savitech Add -- A2DP_Source_Sink_Switch
 
     // Map of apps registered to keep BLE scanning on.
     private Map<IBinder, ClientDeathRecipient> mBleApps =
@@ -484,6 +487,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         mState = BluetoothAdapter.STATE_OFF;
         mQuietEnableExternal = false;
         mEnableExternal = false;
+        mA2DPSinkEnableExternal = false;	// Savitech Add - A2DP_Source_Sink_Switch
         mAddress = null;
         mName = null;
         mErrorRecoveryRetryCounter = 0;
@@ -526,6 +530,14 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             mEnableExternal = true;
         }
 
+        // Savitech Add -- A2DP_Source_Sink_Switch
+        if (isBluetoothPersistedA2DPSinkOn()) {
+            mA2DPSinkEnableExternal = true;
+            Slog.d(TAG, "Startup: A2DP Sink Persisted state is ON.");
+        } else {
+            Slog.d(TAG, "Startup: A2DP Sink Persisted state is OFF.");
+        }
+
         String airplaneModeRadios =
                 Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS);
         if (airplaneModeRadios == null || airplaneModeRadios.contains(
@@ -588,6 +600,19 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         return state == BLUETOOTH_ON_AIRPLANE;
     }
 
+    /**
+     *  Savitech Add -- A2DP_Source_Sink_Switch
+     *  Returns true if the Bluetooth A2DP Sink Mode State is "on"
+     */
+    private boolean isBluetoothPersistedA2DPSinkOn() {
+        if (!supportBluetoothPersistedState()) {
+            return false;
+        }
+        int state = Settings.Global.getInt(mContentResolver, Settings.Global.BLUETOOTH_A2DP_SINK, 0);
+        Slog.d(TAG, "Bluetooth A2DP Sink persisted state: " + state);
+        return state != BLUETOOTH_A2DP_SINK_OFF;
+    }
+
     /**
      *  Returns true if the Bluetooth saved state is BLUETOOTH_ON_BLUETOOTH
      */
@@ -612,6 +637,18 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
         Binder.restoreCallingIdentity(callingIdentity);
     }
 
+    /**
+     *  Savitech Add -- A2DP_Source_Sink_Switch
+     *  Save the Bluetooth A2DP Sink ON/OFF state
+     */
+    private void persistBluetoothA2DPSinkSetting(int value) {
+        Slog.d(TAG, "Persisting Bluetooth A2DP Sink Setting: " + value);
+        // waive WRITE_SECURE_SETTINGS permission check
+        long callingIdentity = Binder.clearCallingIdentity();
+        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.BLUETOOTH_A2DP_SINK, value);
+        Binder.restoreCallingIdentity(callingIdentity);
+    }
+
     /**
      * Returns true if the Bluetooth Adapter's name and address is
      * locally cached
@@ -1200,6 +1237,17 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
             if (!isBluetoothPersistedStateOnAirplane()) {
                 if (persist) {
                     persistBluetoothSetting(BLUETOOTH_OFF);
+
+                    // Savitech Add -- A2DP_Source_Sink_Switch
+                    if(mA2DPSinkEnableExternal == false) {
+                        Slog.d(TAG, "Bluetooth disable(): Modify A2DP Sink state from OFF to ON!");
+                        mA2DPSinkEnableExternal = true;
+                        persistBluetoothA2DPSinkSetting(1);
+                    } else {
+                        Slog.d(TAG, "Bluetooth disable(): Modify A2DP Sink state from ON to OFF!");
+                        mA2DPSinkEnableExternal = false;
+                        persistBluetoothA2DPSinkSetting(0);
+                    }
                 }
                 mEnableExternal = false;
             }
diff --git a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
index c36819746..b18640f9f 100644
--- a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
+++ b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
@@ -30,6 +30,10 @@ using ::android::hardware::bluetooth::audio::V2_0::AacVariableBitRate;
 using ::android::hardware::bluetooth::audio::V2_0::AptxParameters;
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using ::android::hardware::bluetooth::audio::V2_0::CodecType;
 using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
@@ -46,12 +50,18 @@ static const PcmParameters kDefaultSoftwarePcmCapabilities = {
     .sampleRate = static_cast<SampleRate>(
         SampleRate::RATE_44100 | SampleRate::RATE_48000 |
         SampleRate::RATE_88200 | SampleRate::RATE_96000 |
+        SampleRate::RATE_192000 |
         SampleRate::RATE_16000 | SampleRate::RATE_24000),
     .channelMode =
         static_cast<ChannelMode>(ChannelMode::MONO | ChannelMode::STEREO),
     .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |
                                                 BitsPerSample::BITS_24 |
-                                                BitsPerSample::BITS_32)};
+                                                BitsPerSample::BITS_32),
+    // Savitech Patch - Start
+    //   LHDC_Low_Latency(non-offload)
+    //.isLowLatencyEnabled = static_cast<LhdcLowLatencyEn>(LhdcLowLatencyEn::Disabled | LhdcLowLatencyEn::Disabled),
+    // Savitech Patch - End
+};
 
 // Default Supported Codecs
 // SBC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(MONO|STEREO)
@@ -342,6 +352,7 @@ bool IsSoftwarePcmConfigurationValid(const PcmParameters& pcm_config) {
        pcm_config.sampleRate != SampleRate::RATE_48000 &&
        pcm_config.sampleRate != SampleRate::RATE_88200 &&
        pcm_config.sampleRate != SampleRate::RATE_96000 &&
+       pcm_config.sampleRate != SampleRate::RATE_192000 &&
        pcm_config.sampleRate != SampleRate::RATE_16000 &&
        pcm_config.sampleRate != SampleRate::RATE_24000) ||
       (pcm_config.bitsPerSample != BitsPerSample::BITS_16 &&
diff --git a/lhdc_release_diff/LHDC_AOSP12_Orig_to_v507_220812.diff b/lhdc_release_diff/LHDC_AOSP12_Orig_to_v507_220812.diff
new file mode 100644
index 000000000..3018b8b8b
--- /dev/null
+++ b/lhdc_release_diff/LHDC_AOSP12_Orig_to_v507_220812.diff
@@ -0,0 +1,27330 @@
+diff --git a/external/liblhdc/Android.bp b/external/liblhdc/Android.bp
+new file mode 100644
+index 000000000..30d11199d
+--- /dev/null
++++ b/external/liblhdc/Android.bp
+@@ -0,0 +1,50 @@
++
++cc_prebuilt_library_shared {
++    name: "liblhdc",
++
++    export_include_dirs: ["include"],
++    arch: {
++        arm: {
++            srcs: ["libs/armeabi-v7a/liblhdc.so",],
++        },
++        arm64: {
++            srcs: ["libs/arm64-v8a/liblhdc.so",],
++        },
++    },
++
++    strip: {
++        none:true,
++    },
++
++    shared_libs: [
++        "liblog",
++        "libstdc++",
++    ],
++}
++
++cc_library_shared {
++    name: "liblhdcBT_enc",
++   // vendor_available: true,
++   // vndk: {
++   //     enabled: true,
++   // },
++    arch: {
++        arm: {
++            instruction_set: "arm",
++        },
++    },
++    export_include_dirs: ["inc"],
++    local_include_dirs: ["inc", "include", ],
++    srcs: [
++        "src/lhdcBT_enc.c",
++    ],
++    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
++    // unit such as ARM Cortex-R series or external 32-bit DSPs.
++    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
++
++    shared_libs: [
++        "libcutils",
++        "liblog",
++        "liblhdc",
++    ],
++}
+diff --git a/external/liblhdc/LICENSE b/external/liblhdc/LICENSE
+new file mode 100644
+index 000000000..261eeb9e9
+--- /dev/null
++++ b/external/liblhdc/LICENSE
+@@ -0,0 +1,201 @@
++                                 Apache License
++                           Version 2.0, January 2004
++                        http://www.apache.org/licenses/
++
++   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
++
++   1. Definitions.
++
++      "License" shall mean the terms and conditions for use, reproduction,
++      and distribution as defined by Sections 1 through 9 of this document.
++
++      "Licensor" shall mean the copyright owner or entity authorized by
++      the copyright owner that is granting the License.
++
++      "Legal Entity" shall mean the union of the acting entity and all
++      other entities that control, are controlled by, or are under common
++      control with that entity. For the purposes of this definition,
++      "control" means (i) the power, direct or indirect, to cause the
++      direction or management of such entity, whether by contract or
++      otherwise, or (ii) ownership of fifty percent (50%) or more of the
++      outstanding shares, or (iii) beneficial ownership of such entity.
++
++      "You" (or "Your") shall mean an individual or Legal Entity
++      exercising permissions granted by this License.
++
++      "Source" form shall mean the preferred form for making modifications,
++      including but not limited to software source code, documentation
++      source, and configuration files.
++
++      "Object" form shall mean any form resulting from mechanical
++      transformation or translation of a Source form, including but
++      not limited to compiled object code, generated documentation,
++      and conversions to other media types.
++
++      "Work" shall mean the work of authorship, whether in Source or
++      Object form, made available under the License, as indicated by a
++      copyright notice that is included in or attached to the work
++      (an example is provided in the Appendix below).
++
++      "Derivative Works" shall mean any work, whether in Source or Object
++      form, that is based on (or derived from) the Work and for which the
++      editorial revisions, annotations, elaborations, or other modifications
++      represent, as a whole, an original work of authorship. For the purposes
++      of this License, Derivative Works shall not include works that remain
++      separable from, or merely link (or bind by name) to the interfaces of,
++      the Work and Derivative Works thereof.
++
++      "Contribution" shall mean any work of authorship, including
++      the original version of the Work and any modifications or additions
++      to that Work or Derivative Works thereof, that is intentionally
++      submitted to Licensor for inclusion in the Work by the copyright owner
++      or by an individual or Legal Entity authorized to submit on behalf of
++      the copyright owner. For the purposes of this definition, "submitted"
++      means any form of electronic, verbal, or written communication sent
++      to the Licensor or its representatives, including but not limited to
++      communication on electronic mailing lists, source code control systems,
++      and issue tracking systems that are managed by, or on behalf of, the
++      Licensor for the purpose of discussing and improving the Work, but
++      excluding communication that is conspicuously marked or otherwise
++      designated in writing by the copyright owner as "Not a Contribution."
++
++      "Contributor" shall mean Licensor and any individual or Legal Entity
++      on behalf of whom a Contribution has been received by Licensor and
++      subsequently incorporated within the Work.
++
++   2. Grant of Copyright License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      copyright license to reproduce, prepare Derivative Works of,
++      publicly display, publicly perform, sublicense, and distribute the
++      Work and such Derivative Works in Source or Object form.
++
++   3. Grant of Patent License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      (except as stated in this section) patent license to make, have made,
++      use, offer to sell, sell, import, and otherwise transfer the Work,
++      where such license applies only to those patent claims licensable
++      by such Contributor that are necessarily infringed by their
++      Contribution(s) alone or by combination of their Contribution(s)
++      with the Work to which such Contribution(s) was submitted. If You
++      institute patent litigation against any entity (including a
++      cross-claim or counterclaim in a lawsuit) alleging that the Work
++      or a Contribution incorporated within the Work constitutes direct
++      or contributory patent infringement, then any patent licenses
++      granted to You under this License for that Work shall terminate
++      as of the date such litigation is filed.
++
++   4. Redistribution. You may reproduce and distribute copies of the
++      Work or Derivative Works thereof in any medium, with or without
++      modifications, and in Source or Object form, provided that You
++      meet the following conditions:
++
++      (a) You must give any other recipients of the Work or
++          Derivative Works a copy of this License; and
++
++      (b) You must cause any modified files to carry prominent notices
++          stating that You changed the files; and
++
++      (c) You must retain, in the Source form of any Derivative Works
++          that You distribute, all copyright, patent, trademark, and
++          attribution notices from the Source form of the Work,
++          excluding those notices that do not pertain to any part of
++          the Derivative Works; and
++
++      (d) If the Work includes a "NOTICE" text file as part of its
++          distribution, then any Derivative Works that You distribute must
++          include a readable copy of the attribution notices contained
++          within such NOTICE file, excluding those notices that do not
++          pertain to any part of the Derivative Works, in at least one
++          of the following places: within a NOTICE text file distributed
++          as part of the Derivative Works; within the Source form or
++          documentation, if provided along with the Derivative Works; or,
++          within a display generated by the Derivative Works, if and
++          wherever such third-party notices normally appear. The contents
++          of the NOTICE file are for informational purposes only and
++          do not modify the License. You may add Your own attribution
++          notices within Derivative Works that You distribute, alongside
++          or as an addendum to the NOTICE text from the Work, provided
++          that such additional attribution notices cannot be construed
++          as modifying the License.
++
++      You may add Your own copyright statement to Your modifications and
++      may provide additional or different license terms and conditions
++      for use, reproduction, or distribution of Your modifications, or
++      for any such Derivative Works as a whole, provided Your use,
++      reproduction, and distribution of the Work otherwise complies with
++      the conditions stated in this License.
++
++   5. Submission of Contributions. Unless You explicitly state otherwise,
++      any Contribution intentionally submitted for inclusion in the Work
++      by You to the Licensor shall be under the terms and conditions of
++      this License, without any additional terms or conditions.
++      Notwithstanding the above, nothing herein shall supersede or modify
++      the terms of any separate license agreement you may have executed
++      with Licensor regarding such Contributions.
++
++   6. Trademarks. This License does not grant permission to use the trade
++      names, trademarks, service marks, or product names of the Licensor,
++      except as required for reasonable and customary use in describing the
++      origin of the Work and reproducing the content of the NOTICE file.
++
++   7. Disclaimer of Warranty. Unless required by applicable law or
++      agreed to in writing, Licensor provides the Work (and each
++      Contributor provides its Contributions) on an "AS IS" BASIS,
++      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++      implied, including, without limitation, any warranties or conditions
++      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
++      PARTICULAR PURPOSE. You are solely responsible for determining the
++      appropriateness of using or redistributing the Work and assume any
++      risks associated with Your exercise of permissions under this License.
++
++   8. Limitation of Liability. In no event and under no legal theory,
++      whether in tort (including negligence), contract, or otherwise,
++      unless required by applicable law (such as deliberate and grossly
++      negligent acts) or agreed to in writing, shall any Contributor be
++      liable to You for damages, including any direct, indirect, special,
++      incidental, or consequential damages of any character arising as a
++      result of this License or out of the use or inability to use the
++      Work (including but not limited to damages for loss of goodwill,
++      work stoppage, computer failure or malfunction, or any and all
++      other commercial damages or losses), even if such Contributor
++      has been advised of the possibility of such damages.
++
++   9. Accepting Warranty or Additional Liability. While redistributing
++      the Work or Derivative Works thereof, You may choose to offer,
++      and charge a fee for, acceptance of support, warranty, indemnity,
++      or other liability obligations and/or rights consistent with this
++      License. However, in accepting such obligations, You may act only
++      on Your own behalf and on Your sole responsibility, not on behalf
++      of any other Contributor, and only if You agree to indemnify,
++      defend, and hold each Contributor harmless for any liability
++      incurred by, or claims asserted against, such Contributor by reason
++      of your accepting any such warranty or additional liability.
++
++   END OF TERMS AND CONDITIONS
++
++   APPENDIX: How to apply the Apache License to your work.
++
++      To apply the Apache License to your work, attach the following
++      boilerplate notice, with the fields enclosed by brackets "[]"
++      replaced with your own identifying information. (Don't include
++      the brackets!)  The text should be enclosed in the appropriate
++      comment syntax for the file format. We also recommend that a
++      file or class name and description of purpose be included on the
++      same "printed page" as the copyright notice for easier
++      identification within third-party archives.
++
++   Copyright [yyyy] [name of copyright owner]
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
+diff --git a/external/liblhdc/MODULE_LICENSE_APACHE2 b/external/liblhdc/MODULE_LICENSE_APACHE2
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdc/NOTICE b/external/liblhdc/NOTICE
+new file mode 100644
+index 000000000..ea044d3be
+--- /dev/null
++++ b/external/liblhdc/NOTICE
+@@ -0,0 +1,27 @@
++/******************************************************************************
++ *
++ * Copyright (C) 2015 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at:
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ *
++ *****************************************************************************
++ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
++ */
++
++---------------
++ Certification
++---------------
++   Taking the certification process is required to use LHDC in your products.
++   For the detail of certification process, see the following URL:
++      https://www.savitech.co/
++
+diff --git a/external/liblhdc/inc/lhdcBT.h b/external/liblhdc/inc/lhdcBT.h
+new file mode 100644
+index 000000000..f478e2134
+--- /dev/null
++++ b/external/liblhdc/inc/lhdcBT.h
+@@ -0,0 +1,392 @@
++
++
++#ifndef _LHDCBT_H_
++#define _LHDCBT_H_
++#ifdef __cplusplus
++extern "C" {
++#endif
++#ifndef LHDCBT_API
++#define LHDCBT_API
++#endif /* LHDCBT_API  */
++#include "lhdc_api.h"
++
++typedef enum _lhdcBT_ext_func_field_t{
++  LHDCBT_EXT_FUNC_AR = 0,
++  LHDCBT_EXT_FUNC_LARC,
++  LHDCBT_EXT_FUNC_EXTR,
++  LHDCBT_EXT_FUNC_JAS,
++  //LHDCBT_EXT_FUNC_META,
++  LHDCBT_EXT_FUNC_MAX,
++} lhdcBT_ext_func_field_t;
++
++//
++// Extend API Basic Settings Definition
++//
++#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
++#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
++#define EXTEND_FUNC_CODE_MIN_BUFFER_LEN                 8
++
++/* **********************************************
++ *  API: Version Control
++ * ***********************************************/
++#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V1               ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2               ((unsigned int) 0x02000000)
++
++#define EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V1       8
++#define EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V2       16
++
++/* **********************************************
++ *  LIB API: Config Type
++ * ***********************************************/
++/* * * * * * * * * * * * * * * *
++ *   META                      *
++ * * * * * * * * * * * * * * * */
++//   META :: API Code
++#define EXTEND_FUNC_CODE_SET_CONFIG_META        ((unsigned int) 0x0C000001)
++#define EXTEND_FUNC_CODE_GET_CONFIG_META        ((unsigned int) 0x0C010001)
++//   META :: API Version
++#define EXTEND_FUNC_VER_SET_CONFIG_META_V1      ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_SET_CONFIG_META_V2      ((unsigned int) 0x02000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_META_V1      ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_META_V2      ((unsigned int) 0x02000000)
++//   META :: API Min Required Buffer Size
++#define EXTEND_FUNC_VER_SET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
++#define EXTEND_FUNC_VER_GET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
++
++/* * * * * * * * * * * * * * * *
++ *   AR                        *
++ * * * * * * * * * * * * * * * */
++//   AR :: API Code
++#define EXTEND_FUNC_CODE_SET_CONFIG_AR          ((unsigned int) 0x0C000002)
++#define EXTEND_FUNC_CODE_GET_CONFIG_AR          ((unsigned int) 0x0C010002)
++//   AR :: API Version
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_V3        ((unsigned int) 0x03000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
++//   AR :: API Min Required Buffer Size
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
++#define EXTEND_FUNC_VER_GET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
++
++
++/* **********************************************
++ *  LIB API: Data Type
++ * ***********************************************/
++/* * * * * * * * * * * * * * * *
++ *   GYRO2D                    *
++ * * * * * * * * * * * * * * * */
++//   GYRO2D :: API Code
++#define EXTEND_FUNC_CODE_SET_DATA_GYRO2D        ((unsigned int) 0x0D000001)
++//   GYRO2D :: API Version
++#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1      ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V2      ((unsigned int) 0x02000000)
++//   GYRO2D :: API Min Required Buffer Size
++#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_REQ_BUFSIZE_V2      16    //TBD (8 + 2gyro + 6pad)
++
++
++/* **********************************************
++ *  A2DP-Extended API:
++ * ***********************************************/
++/* * * * * * * * * * * * * * * *
++ *   GetA2DPSpecifis           *
++ * * * * * * * * * * * * * * * */
++//   GetA2DPSpecifis :: API Code
++#define EXTEND_FUNC_CODE_GET_SPECIFIC           ((unsigned int) 0x0A010001)
++//   GetA2DPSpecifis :: API Version
++#define EXTEND_FUNC_VER_GET_SPECIFIC_V1         ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_GET_SPECIFIC_V2         ((unsigned int) 0x02000000)
++
++/* ************************************************************************
++ * Version format info of EXTEND_FUNC_CODE_GET_SPECIFIC
++ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
++   * API Version:                   (4 bytes)
++   * API Code:                      (4 bytes)
++   * A2DP Codec Config Code:        (1 bytes)
++   * A2dp Specific1:                (8 bytes)
++   * A2dp Specific2:                (8 bytes)
++   * A2dp Specific3:                (8 bytes)
++   * A2dp Specific4:                (8 bytes)
++ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
++   * API Version:                   (4 bytes)
++   * API Code:                      (4 bytes)
++   * A2DP Codec Config Code:        (1 bytes)
++   * Reserved:                      (7 bytes)
++   * A2dp Specific1:                (8 bytes)
++   * A2dp Specific2:                (8 bytes)
++   * A2dp Specific3:                (8 bytes)
++   * A2dp Specific4:                (8 bytes)
++   * Capabilities Metadata sub fields:  (7*2 bytes)
++     * sub[0~1]:    JAS
++     * sub[2~3]:    AR
++     * sub[4~5]:    META
++     * sub[6~7]:    LLAC
++     * sub[8~9]:    MBR
++     * sub[10~11]:  LARC
++     * sub[12~13]:  LHDCV4
++   * Padded:                        (2 bytes)
++ * ************************************************************************/
++#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
++#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
++#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
++#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
++/* Capabilities metadata fields(2 bytes for each tuple) */
++#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
++#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
++
++/* Total size of buffer */
++#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
++#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
++/* Head of each field */
++#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
++#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
++#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
++/* Following part in V1 */
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
++/* Following part in V2 */
++#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
++#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
++#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
++
++/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
++ * 0x01: codec_config_
++ * 0x02: codec_capability_
++ * 0x03: codec_local_capability_
++ * 0x04: codec_selectable_capability_
++ * 0x05: codec_user_config_
++ * 0x06: codec_audio_config_
++ */
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
++
++/************************
++ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
++   * Capability Code:                   (1 byte)
++   * Saving Position Info:              (1 byte)
++ ************************/
++/* Capabilities's code: */
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
++
++/* Capabilities's saving position Info:
++ *  1. in which specific                        (represented in leftmost 2-bits)
++ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
++ * */
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
++/********************************************************************************/
++
++
++
++
++#define EXTEND_FUNC_RET_OK                      ((int) 0)
++#define EXTEND_FUNC_RET_INVALID_HANDLE          ((int) 0xE01)
++#define EXTEND_FUNC_RET_INVALID_PARAMETER       ((int) 0xE02)
++#define EXTEND_FUNC_RET_FUNC_NOT_SUPPORT        ((int) 0xE03)
++#define EXTEND_FUNC_RET_VERSION_NOT_SUPPORT     ((int) 0xE04)
++#define EXTEND_FUNC_RET_BUF_UNDERRUN            ((int) 0xE05)
++#define EXTEND_FUNC_RET_ERROR                   ((int) 0xE06)
++#define EXTEND_FUNC_RET_NOT_READY               ((int) 0xE07)
++#define EXTEND_FUNC_RET_REQ_BUFSIZE_NOT_MATCH   ((int) 0xE08)
++
++
++//
++// META
++//
++#define META_ST_VER_V1                           ((unsigned int) 0x00010000)
++#define META_ST_VER_V2                           ((unsigned int) 0x00020000)
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_SET_META {
++
++    unsigned char     header[8];
++    unsigned int      meta_ver;
++    unsigned char     meta_mem_size;
++    unsigned char     meta_enable;
++    unsigned char     meta_set;
++    unsigned char     meta_metadata_length;
++//  unsigned char     meta_metadata[64];
++
++} ST_LHDC_SET_META, *PST_LHDC_SET_META;
++#pragma pack(pop)
++
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_GET_META {
++
++    unsigned char     header[8];
++    unsigned int      meta_ver;
++    unsigned char     meta_mem_size;
++    unsigned char     meta_st;     // [0] 1: reserved bit, [1] 1: in meta mode/0: not in meta mode
++    unsigned char     jas_status;
++
++} ST_LHDC_GET_META, *PST_LHDC_GET_META;
++#pragma pack(pop)
++
++//
++// AR
++//
++
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_AR
++{
++    unsigned char     header[8];
++    unsigned int      ver;
++    unsigned int      size;
++    unsigned int      app_ar_enabled;
++    int Ch1_Pos;
++    int Ch2_Pos;
++    int Ch3_Pos;
++    int Ch4_Pos;
++    int Ch5_Pos;
++    int Ch6_Pos;
++    float Ch1_L_PreGain;
++    float Ch1_R_PreGain;
++    float Ch2_L_PreGain;
++    float Ch2_R_PreGain;
++    float Ch3_L_PreGain;
++    float Ch3_R_PreGain;
++    float Ch4_L_PreGain;
++    float Ch4_R_PreGain;
++    float Ch5_L_PreGain;
++    float Ch5_R_PreGain;
++    float Ch6_L_PreGain;
++    float Ch6_R_PreGain;
++    float Ch1_PostGain;
++    float Ch2_PostGain;
++    float Ch3_PostGain;
++    float Ch4_PostGain;
++    float Ch5_PostGain;
++    float Ch6_PostGain;
++    float Dry_Val;
++    float Wet_Val;
++    float Dis_1;
++    float Dis_2;
++    float Dis_3;
++    float Dis_4;
++    float Dis_5;
++    float Rev_1;
++    float Rev_2;
++    float Rev_3;
++    float Rev_4;
++    float Rev_5;
++    float Rev_gain;
++    float ThreeD_gain;
++} ST_LHDC_AR, *PST_LHDC_AR;
++#pragma pack(pop)
++
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_AR_GYRO
++{
++    unsigned char     header[8];
++    int world_coordinate_x;
++    int world_coordinate_y;
++    int world_coordinate_z;
++
++} ST_LHDC_AR_GYRO, *PST_LHDC_AR_GYRO;
++#pragma pack(pop)
++
++#ifdef NEW_API_SET
++//for NEW API used!!!!
++typedef struct {
++  uint32_t sample_rate;
++  LHDCBT_SMPL_FMT_T bits_per_sample;
++  LHDCBT_QUALITY_T audio_quality;
++  bool channel_split_enabled;
++  uint32_t packet_mtu;
++  uint32_t encode_interval;
++
++  bool output_size_cal;
++} lhdc_init_param_t;
++
++int lhdcBT_init(HANDLE_LHDC_BT handle, lhdc_init_param_t * param);
++#else
++HANDLE_LHDC_BT lhdcBT_get_handle(int version);
++
++
++void lhdcBT_free_handle(HANDLE_LHDC_BT handle);
++
++//static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
++//Encoder for V2
++int lhdcBT_encode(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
++//Encoder for V3
++int lhdcBT_encodeV3(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
++
++int lhdcBT_get_bitrate(HANDLE_LHDC_BT hLhdcParam);
++
++int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx);
++
++//int lhdcBT_get_sampling_freq(HANDLE_LHDC_BT handle);
++
++//int lhdcBT_init_handle_encode(HANDLE_LHDC_BT handle,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannel, int need_padding, int mtu, int interval);
++
++//int lhdcBT_get_error_code(HANDLE_LHDC_BT handle);
++
++int lhdcBT_adjust_bitrate(HANDLE_LHDC_BT handle, size_t queueLength) ;
++
++//void lhdcBT_setLimitBitRate(HANDLE_LHDC_BT handle, int max_rate_index);
++
++//uint8_t lhdcBT_getSupportedVersion(HANDLE_LHDC_BT handle);
++
++int     lhdcBT_get_block_Size(HANDLE_LHDC_BT handle);
++
++int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
++
++int lhdcBT_get_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool * enabled);
++
++//
++// Extra API
++//
++// 1. API -- Set User Config (Extend)
++int lhdcBT_set_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen);
++// 2. API -- Get User Config (Extend)
++int lhdcBT_get_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen);
++// 3. API -- Set User Data (Extend)
++void lhdcBT_set_user_exdata(HANDLE_LHDC_BT handle, char* userConfig, int clen);
++// 4. API -- Get Version 
++int lhdcBT_get_user_exApiver(HANDLE_LHDC_BT handle, char *version, int clen);
++
++#endif
++#ifdef __cplusplus
++}
++#endif
++#endif /* _LHDCBT_H_ */
+diff --git a/external/liblhdc/include/cirbuf.h b/external/liblhdc/include/cirbuf.h
+new file mode 100644
+index 000000000..9cd263d2b
+--- /dev/null
++++ b/external/liblhdc/include/cirbuf.h
+@@ -0,0 +1,29 @@
++#ifndef	_CIRBUF_H_
++#define	_CIRBUF_H_
++
++struct cirbuf_s
++{
++	unsigned int	idx;
++	unsigned int	odx;
++	unsigned int	s_len;
++	unsigned int	r_len;
++	unsigned int	max_len;
++	unsigned char	*cbuf;
++};
++typedef  struct cirbuf_s savi_circ_buf;
++
++void cirbuf_init( struct cirbuf_s *pcb, unsigned char *buf, int len);
++
++void cirbuf_reset( struct cirbuf_s *pcb);
++
++int cirbuf_len( struct cirbuf_s *pcb);
++int cirbuf_empty_len( struct cirbuf_s *pcb);
++
++int cirbuf_get( struct cirbuf_s *pcb, unsigned char *buf, int len);
++int cirbuf_put( struct cirbuf_s *pcb, unsigned char *buf, int len);
++
++int cirbuf_get_no_copy( struct cirbuf_s *pcb, unsigned char **buf, int len);
++int cirbuf_put_no_copy( struct cirbuf_s *pcb, unsigned char **buf, int len);
++
++#endif	/* _CIRBUF_H_ */
++
+diff --git a/external/liblhdc/include/lhdc_api.h b/external/liblhdc/include/lhdc_api.h
+new file mode 100644
+index 000000000..079719cb7
+--- /dev/null
++++ b/external/liblhdc/include/lhdc_api.h
+@@ -0,0 +1,215 @@
++#ifndef __LHDC_API_H__
++#define __LHDC_API_H__
++
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++#include "lhdc_process.h"
++#include "cirbuf.h"
++
++#define LHDC_ENC_LIB_COPYRIGHT  "LHDC Encode Library @Copyright SAVITECH 2021"
++#define LHDC_VERSION            LHDCVER
++
++typedef enum {
++    LHDCBT_SMPL_FMT_S16 = 16,
++    LHDCBT_SMPL_FMT_S24 = 24,
++} LHDCBT_SMPL_FMT_T;
++
++typedef enum name {
++    LHDCBT_QUALITY_LOW0 = 0,
++    LHDCBT_QUALITY_LOW1,
++    LHDCBT_QUALITY_LOW2,
++    LHDCBT_QUALITY_LOW3,
++    LHDCBT_QUALITY_LOW4,
++    LHDCBT_QUALITY_LOW,
++    LHDCBT_QUALITY_MID,
++    LHDCBT_QUALITY_HIGH,
++    LHDCBT_QUALITY_AUTO,
++    LHDCBT_QUALITY_RESET_AUTO,
++    LHDCBT_QUALITY_MAX
++} LHDCBT_QUALITY_T;
++
++
++#define LHDCV1_BT_ENC_BLOCK_SIZE  512
++
++#define LHDCV2_BT_ENC_BLOCK_SIZE  512
++
++#define LHDCV3_BT_ENC_BLOCK_SIZE  256
++
++
++#define MAX_CHANNEL		    		2
++#define LHDC_AR_PROCESS_CH			6
++#define LHDC_SEPARATE_OUTPUR_CH     4
++#define LHDC_AR_VERSION             "LHDC AR v1.1a.14 2021-7-7  @Copyright SAVITECH 2021"
++
++typedef enum _lhdc_enc_type_t {
++    ENC_TYPE_UNKNOWN = 0,
++    ENC_TYPE_LHDC,
++    ENC_TYPE_LLAC,
++    ENC_TYPE_MAX,
++    ENC_TYPE_ERR = ENC_TYPE_MAX
++} lhdc_enc_type_t;
++
++typedef enum _lhdc_filter_type_t{
++    LHDC_FILTER_PASSTHROUGH = 0,
++    LHDC_FILTER_AR,
++    LHDC_FILTER_ERR = 0xffU
++} lhdc_filter_type_t;
++
++
++typedef struct _llac_para_t {
++    
++    uint8_t* lh4_enc;
++    int32_t  sample_rate;
++    int32_t  bits_per_sample;
++
++    LHDCBT_QUALITY_T qualityStatus;      //0xff == Auto bitrate
++    LHDCBT_QUALITY_T limitBitRateStatus;
++    int32_t  lastBitrate;     //Record lastbitrate for auto bitrate adjust.
++    int32_t  real_bitrate;
++
++    uint16_t avg_cnt;
++    uint32_t avgValue;
++
++    uint16_t changeBRCnt;
++    uint32_t chageBRAvg;
++
++    uint16_t upBitrateCnt;
++    uint32_t upBitrateSum;
++
++    uint16_t dnBitrateCnt;
++    uint32_t dnBitrateSum;
++
++
++    bool updateFramneInfo;
++    uint32_t samples_per_frame; //equal to block size
++    savi_circ_buf input_cbuf;
++    int32_t  out_nbytes;    //output size per frame;
++    uint32_t host_mtu_size;
++    uint32_t frame_per_packet;
++    uint32_t encode_interval;
++
++    //kaiden:20210311:autobirate:malloc maximum nbyte size
++    bool new_packet_flag;
++
++} llac_para_t;
++
++typedef struct _lhdc_para_t {
++
++    FFT_BLOCK * fft_blk;
++    int32_t  sample_rate;
++    int32_t  bits_per_sample;
++
++    LHDCBT_QUALITY_T qualityStatus;      //0xff == Auto bitrate
++    LHDCBT_QUALITY_T limitBitRateStatus;
++    int32_t lastBitrate;     //Record lastbitrate for auto bitrate adjust.
++    int32_t version;
++
++    uint16_t avg_cnt;
++    uint32_t avgValue;
++
++    uint16_t changeBRCnt;
++    uint32_t chageBRAvg;
++
++    uint16_t upBitrateCnt;
++    uint32_t upBitrateSum;
++
++    uint16_t dnBitrateCnt;
++    uint32_t dnBitrateSum;
++
++    bool updateFramneInfo;
++    uint32_t block_size;
++    uint32_t target_mtu_size;
++    uint32_t host_mtu_size;
++    uint32_t frame_per_packet;
++    uint32_t encode_interval;
++    savi_circ_buf input_cbuf;
++    uint32_t queue_frame_cnt;
++
++    bool hasMinBitrateLimit;
++} lhdc_para_t;
++
++//L_20210408 .start
++typedef struct _lhdc_ar_para_t {
++	int sample_rate;
++	int bits_per_sample;
++	int channels;
++	unsigned int samples_per_frame;
++	unsigned int    app_ar_enabled;
++        unsigned long   ulNumBytes;
++        unsigned char*  pucARParams;
++        unsigned int	uiARParamsBytes;//Ask AR how many mem size
++        unsigned char*  pucLhdcArMem;
++        unsigned int	uiLhdcArMemBytes;//Ask AR how many mem size
++} lhdc_ar_para_t;
++//L_20210408 .end
++
++typedef struct _lhdc_filter_t{
++    uint8_t * priv; //save alloc mem point
++    lhdc_filter_type_t type; //don't del..
++} lhdc_filter_t;
++
++
++typedef union _enc_t {
++        lhdc_para_t *lhdc;
++        llac_para_t *llac;
++} enc_t;
++typedef struct _lhdc_control_block_t {
++
++    lhdc_enc_type_t enc_type;       //LLAC or LHDC
++    int err;
++
++    enc_t enc;
++    lhdc_ar_para_t * ar_filter; //AR Param
++
++} lhdc_cb_t;
++
++
++inline static int32_t TARGET_BITRATE_LIMIT(int32_t X, int32_t Y){
++     //((X < Y) ? (Y) : (X))
++
++     if (X < Y)
++        return Y;
++    else
++        return X;
++
++}
++
++typedef void * HANDLE_LHDC_BT;
++
++extern llac_para_t * llac_encoder_new();
++extern void llac_encoder_free(llac_para_t * llac);
++extern int32_t llac_encoder_get_frame_len(llac_para_t  *  handle);
++extern int32_t llac_encoder_get_target_bitrate(llac_para_t  *  handle);
++extern int32_t llac_encoder_init(llac_para_t  *  handle, uint32_t sample_rate, uint32_t bits_per_sample, uint32_t bitrate_inx, uint32_t mtu_size, uint32_t encode_interval);
++
++extern lhdc_para_t * lhdc_encoder_new(int version);
++extern void lhdc_encoder_free(lhdc_para_t * handle);
++extern int32_t lhdc_encoder_get_frame_len(lhdc_para_t * handle);
++extern int32_t lhdc_encoder_get_target_bitrate(lhdc_para_t * handle);
++extern bool lhdc_get_ext_func_state(lhdc_enc_type_t type, void *h, lhdc_ext_func_t ext_type);
++extern int32_t lhdc_encoder_init(lhdc_para_t * handle,int32_t sampling_freq, uint32_t bitPerSample, uint32_t bitrate_inx, uint32_t dualChannel, uint32_t need_padding, uint32_t mtu, uint32_t interval);
++
++
++extern void ar_process_free(lhdc_ar_para_t * handle);
++extern lhdc_ar_para_t * ar_process_new(void);
++extern int ar_process_init(lhdc_ar_para_t * handle, int sample_rate, int bits_per_sample, int channels, unsigned int samples_per_frame);
++extern int ar_set_gyro_pos(lhdc_ar_para_t * handle, int world_coordinate_x, int world_coordinate_y, int world_coordinate_z);
++extern int ar_set_cfg(lhdc_ar_para_t * handle,int *Pos, float *Gain, unsigned int app_ar_enabled);
++extern int ar_get_cfg(lhdc_ar_para_t * handle,int *Pos, float *Gain);
++
++//Common function
++
++
++extern void lhdc_util_reset_up_bitrate(lhdc_enc_type_t type, void * h);
++extern void lhdc_util_reset_down_bitrate(lhdc_enc_type_t type, void * h);
++extern bool lhdc_util_get_ext_func_state(lhdc_enc_type_t type, void *h, lhdc_ext_func_t ext_type);
++extern int32_t lhdc_util_encv4_process(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
++extern uint32_t lhdc_util_get_bitrate(uint32_t index);
++extern uint8_t * lhdc_util_get_buffer(void);
++
++#ifdef __cplusplus
++}
++#endif
++#endif //End of __LHDC_API_H__
+diff --git a/external/liblhdc/include/lhdc_cfg.h b/external/liblhdc/include/lhdc_cfg.h
+new file mode 100644
+index 000000000..29ce0200f
+--- /dev/null
++++ b/external/liblhdc/include/lhdc_cfg.h
+@@ -0,0 +1,34 @@
++#ifndef __LHDC_CONFIG_H__
++#define __LHDC_CONFIG_H__
++
++//
++// Config for LHDC Encode
++//
++
++
++//#define ENC_LPF_FIXED_POINT			1
++
++
++// 20190402 .start
++//#define ENC_LPC_V_MAX_ORDER			1
++//#define ENC_LPC_V_USE_32BIT			1
++// 20190402 .end
++
++
++
++//
++// Config for LHDC Decode
++//
++
++//#define DEC_LPF_FIXED_POINT			1
++
++
++
++// 20190402 .start
++//#define DEC_LPC_V_MAX_ORDER			1
++//#define DEC_ADSP_LPC_V_USE_ADSP		1
++//#define DEC_ADSP_LPC_V_MAX_ORDER		1
++// 20190402 .end
++
++
++#endif
+diff --git a/external/liblhdc/include/lhdc_enc_config.h b/external/liblhdc/include/lhdc_enc_config.h
+new file mode 100644
+index 000000000..7e64b88ee
+--- /dev/null
++++ b/external/liblhdc/include/lhdc_enc_config.h
+@@ -0,0 +1,7 @@
++#ifndef	_LHDC_ENC_CONFIG_H_
++#define	_LHDC_ENC_CONFIG_H_
++
++
++#define LHDC_ENC_SINK_BUF_LEN       ( 10 * 1024)
++
++#endif	/* _LHDC_ENC_CONFIG_H_ */
+diff --git a/external/liblhdc/include/lhdc_process.h b/external/liblhdc/include/lhdc_process.h
+new file mode 100644
+index 000000000..4a1bf4211
+--- /dev/null
++++ b/external/liblhdc/include/lhdc_process.h
+@@ -0,0 +1,106 @@
++#ifndef _PROCESS_BLOCK_H_
++#define _PROCESS_BLOCK_H_
++#include <stdbool.h>
++
++
++struct FFT_block_s;
++typedef struct FFT_block_s FFT_BLOCK;
++
++typedef enum {
++	EXT_FUNC_AR,
++	EXT_FUNC_LARC,
++	EXT_FUNC_EXT_FLG,
++	EXT_FUNC_JAS,
++	EXT_FUNC_META
++} lhdc_ext_func_t;
++
++
++typedef enum _lhdc_error {
++    LHDC_ST_OK,
++    LHDC_ST_ERR,
++    LHDC_ST_MAX
++} LHDC_STATE;
++
++
++int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
++
++/**
++ * Allocate new LHDC control block.
++ */
++//Adjust by John
++//FFT_BLOCK *LossyEncoderNew(void);
++FFT_BLOCK *LossyEncoderNew(int32_t version);
++
++/**
++ * Destroy LHDC control block.
++ */
++int LossyEncoderDelete(FFT_BLOCK *fb);
++
++/**
++ * Initial LHDC encoder.
++ * Input :
++ *  fb: LHDC control block.
++ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
++ *  channels    : Fixed to 2 channel.
++ *  block_size  : Fixed to 512.
++ *  sink_buf_len: Fixed to 10 * 1024.
++ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
++ *  fast_mode   : Always fixed to 0.
++ *  split       : Fixed to 0.
++ *  need_padding: Fixed to 0.
++ *  process_size: Fixed to 256.
++ *
++ * Return value :
++ *  LHDC_ST_ERR : Parameters of init have error.
++ *  LHDC_ST_OK : LHDC encoder initial OK.
++ */
++//void LossyEncoderInit(FFT_BLOCK *fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt);
++void LossyEncoderInit(FFT_BLOCK *fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt, int min_bits_reserved, int lhdc_ver);
++
++
++/**
++ * LHDC encode function
++ *  fb: LHDC control block.
++ *  wav : The PCM data. please input non-planer and compact PCM data.
++ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
++ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
++ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
++ *  final   : Fixed to 0.
++ *  out : Output buffer pointer.
++ *  out_len : The output buffer size to protect overwrite.
++ *
++ *  Return value :
++ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
++ *
++ */
++int LossyEncoderProcessWav(FFT_BLOCK *fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
++
++/**
++ * LHDC encode function
++ *  fb: LHDC control block.
++ *  pcm0 : The left channel PCM data.
++ *  pcm1 : The right channel PCM data.
++ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
++ *  final   : Fixed to 0.
++ *  out : Output buffer pointer.
++ *  out_len : The output buffer size to protect overwrite.
++ *
++ *  Return value :
++ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
++ *
++ */
++int LossyEncoderProcessPCM(FFT_BLOCK *fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
++
++/**
++ * To change target byte rate at runtime.
++ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
++ */
++void LossyEncoderSetTargetByteRate(FFT_BLOCK *fb, int target_byte_rate);
++void LossyEncoderResetAlignmentBuf(FFT_BLOCK *fb);
++void LossyEncoderUpdateFrameSize(FFT_BLOCK *fb, int target_mtu_byte, int target_byte_rate);//For auto bit rate
++
++void LhdcExtFuncArEnable(FFT_BLOCK *fb, int enable_ar);
++void LhdcExtFuncJasEnable(FFT_BLOCK *fb, int enable_Jas);
++void LhdcExtFuncMetaEnable(FFT_BLOCK *fb, int enable_meta, unsigned char *pmeta_data, int meta_data_len, int conti_frame_cnt);
++bool LhdcGetExtFuncState(FFT_BLOCK *fb, lhdc_ext_func_t ext_func);
++#endif // _PROCESS_BLOCK_H_
+diff --git a/external/liblhdc/include/lhdcv2_process.h b/external/liblhdc/include/lhdcv2_process.h
+new file mode 100644
+index 000000000..8d13c3ef2
+--- /dev/null
++++ b/external/liblhdc/include/lhdcv2_process.h
+@@ -0,0 +1,91 @@
++#ifndef _PROCESSV2_BLOCK_H_
++#define _PROCESSV2_BLOCK_H_
++
++
++#ifndef __FFT_BLOCK__
++#define __FFT_BLOCK__
++typedef void *FFT_BLOCK;
++#endif //End of __FFT_BLOCK__
++
++
++#ifndef __LHDC_STATUS__
++#define __LHDC_STATUS__
++typedef enum _lhdc_error {
++    LHDC_ST_OK,
++    LHDC_ST_ERR,
++    LHDC_ST_MAX
++} LHDC_STATE;
++#endif //End of __LHDC_STATUS__
++
++
++//int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
++
++/**
++ * Allocate new LHDC control block.
++ */
++FFT_BLOCK LossyEncoderNewV2(void);
++
++/**
++ * Destroy LHDC control block.
++ */
++int LossyEncoderDeleteV2(FFT_BLOCK fb);
++
++/**
++ * Initial LHDC encoder.
++ * Input :
++ *  fb: LHDC control block.
++ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
++ *  channels    : Fixed to 2 channel.
++ *  block_size  : Fixed to 512.
++ *  sink_buf_len: Fixed to 10 * 1024.
++ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
++ *  fast_mode   : Always fixed to 0.
++ *  split       : Fixed to 0.
++ *  need_padding: Fixed to 0.
++ *  process_size: Fixed to 256.
++ *
++ * Return value :
++ *  LHDC_ST_ERR : Parameters of init have error.
++ *  LHDC_ST_OK : LHDC encoder initial OK.
++ */
++LHDC_STATE LossyEncoderInitV2(FFT_BLOCK fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size);
++
++/**
++ * LHDC encode function
++ *  fb: LHDC control block.
++ *  wav : The PCM data. please input non-planer and compact PCM data.
++ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
++ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
++ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
++ *  final   : Fixed to 0.
++ *  out : Output buffer pointer.
++ *  out_len : The output buffer size to protect overwrite.
++ *
++ *  Return value :
++ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
++ *
++ */
++int LossyEncoderProcessWavV2(FFT_BLOCK fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
++
++/**
++ * LHDC encode function
++ *  fb: LHDC control block.
++ *  pcm0 : The left channel PCM data.
++ *  pcm1 : The right channel PCM data.
++ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
++ *  final   : Fixed to 0.
++ *  out : Output buffer pointer.
++ *  out_len : The output buffer size to protect overwrite.
++ *
++ *  Return value :
++ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
++ *
++ */
++int LossyEncoderProcessPCMV2(FFT_BLOCK fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
++
++/**
++ * To change target byte rate at runtime.
++ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
++ */
++void LossyEncoderSetTargetByteRateV2(FFT_BLOCK fb, int target_byte_rate);
++#endif // _PROCESSV2_BLOCK_H_
+diff --git a/external/liblhdc/include/lhdcv3_process.h b/external/liblhdc/include/lhdcv3_process.h
+new file mode 100644
+index 000000000..f1c9d3e7b
+--- /dev/null
++++ b/external/liblhdc/include/lhdcv3_process.h
+@@ -0,0 +1,92 @@
++#ifndef _PROCESSV3_BLOCK_H_
++#define _PROCESSV3_BLOCK_H_
++
++
++#ifndef __FFT_BLOCK__
++#define __FFT_BLOCK__
++typedef void *FFT_BLOCK;
++#endif //End of __FFT_BLOCK__
++
++
++#ifndef __LHDC_STATUS__
++#define __LHDC_STATUS__
++typedef enum _lhdc_error {
++    LHDC_ST_OK,
++    LHDC_ST_ERR,
++    LHDC_ST_MAX
++} LHDC_STATE;
++#endif //End of __LHDC_STATUS__
++
++
++//int LossyEncoderLoadQualitySetting(FFT_BLOCK *fb, char *file_name);
++
++/**
++ * Allocate new LHDC control block.
++ */
++FFT_BLOCK LossyEncoderNewV3(void);
++
++/**
++ * Destroy LHDC control block.
++ */
++int LossyEncoderDeleteV3(FFT_BLOCK fb);
++
++/**
++ * Initial LHDC encoder.
++ * Input :
++ *  fb: LHDC control block.
++ *  sample_rate : The sampling rate setting value as you wanted. (Only support 44.1Khz/48Khz/96KHz)
++ *  channels    : Fixed to 2 channel.
++ *  block_size  : Fixed to 256.
++ *  sink_buf_len: Fixed to 10 * 1024.
++ *  target_byte_rate : The target byte rate.(eg. 400k bit per sec = 50k byte per sec, Only support 400kbps, 500kbps, 560kbps, 900kbps)
++ *  fast_mode   : Always fixed to 0.
++ *  split       : Fixed to 0.
++ *  need_padding: Fixed to 0.
++ *  process_size: Fixed to 256.
++ *
++ * Return value :
++ *  LHDC_ST_ERR : Parameters of init have error.
++ *  LHDC_ST_OK : LHDC encoder initial OK.
++ */
++void LossyEncoderInitV3(FFT_BLOCK fb, int sample_rate, int bits_per_sample, int channels, int block_size, int sink_buf_len, int target_byte_rate, int fast_mode, int one_frame_per_channel, int need_min_byte_rate, int process_size, int target_mtu_byte, int no_btr_limit_frame_cnt);
++
++
++/**
++ * LHDC encode function
++ *  fb: LHDC control block.
++ *  wav : The PCM data. please input non-planer and compact PCM data.
++ *        (eg. The input stream format is 96KHz/24bits stereo and the LHDC request 512 samples for each frame.
++ *         So the PCM data length should be 512 * 2 * (24/8) = 3072 bytes. The data order should be L/R, L/R, L/R....).
++ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
++ *  final   : Fixed to 0.
++ *  out : Output buffer pointer.
++ *  out_len : The output buffer size to protect overwrite.
++ *
++ *  Return value :
++ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
++ *
++ */
++int LossyEncoderProcessWavV3(FFT_BLOCK fb, unsigned char *wav, int ns, int final, unsigned char *out, int out_len);
++
++/**
++ * LHDC encode function
++ *  fb: LHDC control block.
++ *  pcm0 : The left channel PCM data.
++ *  pcm1 : The right channel PCM data.
++ *  ns  : The number of samples, not PCM data byte length. The LHDC encoder only supports 512.
++ *  final   : Fixed to 0.
++ *  out : Output buffer pointer.
++ *  out_len : The output buffer size to protect overwrite.
++ *
++ *  Return value :
++ *      The return value should be the encoded size, otherwise an error occurs (less than or equal to 0)
++ *
++ */
++int LossyEncoderProcessPCMV3(FFT_BLOCK fb, int *pcm0, int *pcm1, int ns, int final, unsigned char *out, int out_len);
++
++/**
++ * To change target byte rate at runtime.
++ * (Only support 400kbps, 500kbps, 560kbps, 900kbps)
++ */
++void LossyEncoderSetTargetByteRateV3(FFT_BLOCK fb, int target_byte_rate);
++#endif // _PROCESSV3_BLOCK_H_
+diff --git a/external/liblhdc/include/llac_enc_api.h b/external/liblhdc/include/llac_enc_api.h
+new file mode 100644
+index 000000000..3004bc019
+--- /dev/null
++++ b/external/liblhdc/include/llac_enc_api.h
+@@ -0,0 +1,128 @@
++/***********************************************************************
++*                               LLAC encoder                           *
++*                                                                      *
++*                                                                      *
++************************************************************************/
++
++#ifndef LLAC_ENC_API_H
++#define LLAC_ENC_API_H
++
++/*
++ * LLAC: 
++ * API Usage
++ *
++ * STEP1.   call llac_enc_mem_alloc() once to allocate the memory
++ * STEP2_0. call llac_enc_set_extra_func() before llac_enc_initial()
++            to enable or disable extra function if needed (for AR, LARC and EXTH ,default is disable)
++ * STEP2.   call llac_enc_initial() once to initialize encoder
++ * STEP3_0. call llac_enc_set_bitrate() before llac_enc_process() 
++ *          to set new bitrate if needed (for autobitrate usage)
++ * STEP3.   call llac_enc_process() in a while loop to encode each frame
++ * STEP4.   call llac_enc_mem_free() once to release the allocated memory 
++ *        when the encode process are done 
++ */
++
++
++
++/*
++ * LLAC: 
++ *      LLAC_MAX_CHANNELS:   Max number of channels
++ *      LLAC_MAX_SAMPLES:    Max number of samples per channel
++ *      LLAC_MAX_BYTES:      Max size of encoded output data in bytess
++ */
++#define LLAC_MAX_CHANNELS 2
++#define LLAC_MAX_SAMPLES 480
++#define LLAC_MAX_BYTES 600
++
++
++/**
++ * LLAC:
++ * llac_enc_mem_alloc - allocate all the memory needed for LLAC encoder
++ * Return: the address of the allocated memory
++ */
++unsigned char* llac_enc_mem_alloc(void);
++
++
++/**
++ * LLAC:
++ * llac_enc_set_extra_func - set extra function enable/disable (for AR, LARC and EXTH)
++ * @func_index: can only be EXTRA_FUNC_AR, EXTRA_FUNC_LARC or EXTRA_FUNC_EXTH
++ * @func_enable: can only be EXTRA_FUNC_DISABLE or EXTRA_FUNC_ENABLE
++ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
++ */
++#define EXTRA_FUNC_AR 0
++#define EXTRA_FUNC_LARC 1
++#define EXTRA_FUNC_EXTH 2
++
++#define EXTRA_FUNC_DISABLE 0
++#define EXTRA_FUNC_ENABLE 1
++
++void llac_enc_set_extra_func(unsigned char func_index,
++    unsigned char func_enable,
++    unsigned char* llac_enc_mem_addr);
++
++
++bool llac_enc_get_extra_func(unsigned char func_index,
++                             unsigned char* llac_enc_mem_addr);
++
++/**
++ * LLAC:
++ * llac_enc_initial - do encoder initialization
++ * @sampleRate: sample rate of input file
++ * @nChannels: channel number of input file
++ * @bps_in: bit per sample of input file 
++ * @bps_out: bit per sample of output file
++ * @frame_ms: frame duration in millisecond
++ * @target_bitrate: targeted bitrate
++ * @nBytes: size of encoded output data in bytes
++ * @nSamples: number of sample per channel
++ * @real_bitrate: the actual bitrate that the encoder is gonna use
++ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
++ */
++void llac_enc_initial(unsigned int sampleRate,
++                          short nChannels,
++                          short bps_in,
++                          short bps_out,
++                          float frame_ms,
++                          int target_bitrate,
++                          int* nBytes,
++                          unsigned int* nSamples,
++                          int* real_bitrate,
++                          unsigned char* llac_enc_mem_addr);
++
++
++/**
++ * LLAC:
++ * llac_enc_set_bitrate - set new bitrate (for autobitrate usage)
++ * @target_bitrate: targeted bitrate
++ * @nBytes: size of encoded output data in bytes
++ * @real_bitrate: the actual bitrate that the encoder is gonna use
++ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
++ */
++void llac_enc_set_bitrate(int target_bitrate,
++    int* nBytes,
++    int* real_bitrate,
++    unsigned char* llac_enc_mem_addr);
++
++
++/**
++ * LLAC:
++ * llac_enc_process - do encode process for one frame
++ * @input: input buffer
++ * @output: output buffer
++ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
++ * Return:  size of encoded output data in bytes
++ */
++int llac_enc_process(int* input,
++                         unsigned char* output,
++                         unsigned char* llac_enc_mem_addr);
++
++
++/**
++ * LLAC:
++ * llac_enc_mem_free - release all the memory needed for LLAC encoder
++ * @llac_enc_mem_addr: the address returned by llac_enc_mem_alloc()
++ */
++void llac_enc_mem_free(unsigned char* llac_enc_mem_addr);
++
++#endif /* LLAC_ENC_API_H */
+\ No newline at end of file
+diff --git a/external/liblhdc/libs/arm64-v8a/.gitkeep b/external/liblhdc/libs/arm64-v8a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdc/libs/armeabi-v7a/.gitkeep b/external/liblhdc/libs/armeabi-v7a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdc/release_note b/external/liblhdc/release_note
+new file mode 100644
+index 000000000..e8bde81d9
+--- /dev/null
++++ b/external/liblhdc/release_note
+@@ -0,0 +1,53 @@
++Release Note.
++=========================================================
++2022/07/20
++1. Upgrade LHDCV4 encoder version to V4.0.6
++
++2022/04/18
++1. Upgrade LHDCV4 encoder version to V4.0.4
++
++2021/11/15
++1. Add to print LHDC version and build time.
++2. Fix wrong AR effect.
++3. Fix when running LLAC, BT may crash after toggling AR UI on/off.
++
++2021/7/21
++Modify the calculation method to correct the number of frames per packet.
++
++2021/7/16
++Add AR version log on create.
++
++2021/7/6
++Add AR v1.1a.14 function.
++
++2021/7/5
++Add AR v1.1a.13 function.
++Support LHDCV4 AR on/off from app
++
++2021/7/1
++Add AR switch form app.
++
++2021/6/29
++Add AR v1.1a function.
++
++2021/3/12
++Update LHDC algorithm.
++
++2021/2/26
++Remove GPL license module.
++
++2020/7/10
++Fixed issue: The size of the encoded frame exceeded expectations.
++
++2020/5/28
++Updating the core of encoder to improve performance.
++
++2020/4/30
++1. Modify the frame size calculation method and refer to the encoding interval time so that the output size of 48KHz/24bits & LL enabled is lower than the packet size of 2DH3.
++
++2020/4/14
++1. Add new function to evaluate frame size and number of frames in a packet.
++2. Fix frame size evaluate not exactly.
++
++2020/3/9
++LHDC encoder library for android 10 r2 on MTK platform.
+diff --git a/external/liblhdc/src/lhdcBT_enc.c b/external/liblhdc/src/lhdcBT_enc.c
+new file mode 100644
+index 000000000..5c4e15a31
+--- /dev/null
++++ b/external/liblhdc/src/lhdcBT_enc.c
+@@ -0,0 +1,1552 @@
++
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdint.h>
++#include <stdbool.h>
++#include "lhdcBT.h"
++#include "lhdc_process.h"
++#include "lhdc_cfg.h"
++#include "cirbuf.h"
++#include "llac_enc_api.h"
++
++
++
++#define LOG_NDEBUG 0
++#define LOG_TAG "lhdcBT_enc"
++#include <cutils/log.h>
++#define max(a,b) ((a) > (b) ? (a) : (b))
++
++#define UP_RATE_TIME_CNT         3000  //Time about UP_RATE_TIME_CNT * 20ms
++#define DOWN_RATE_TIME_CNT       4  //Time about .... ex. DOWN_RATE_TIME_CNT * 20ms
++#define QUEUE_LENGTH_THRESHOLD   4
++
++#define LHDC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_lhdc)/sizeof(int))
++#define LLAC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_llac)/sizeof(int))
++#define LHDC_ABR_DEFAULT_BITRATE     (400)
++#define LLAC_ABR_DEFAULT_BITRATE     (400)
++
++#define AR_ALWAYS_ONx  1
++
++
++static const char * rate_to_string(LHDCBT_QUALITY_T q){
++    switch (q) {
++        case LHDCBT_QUALITY_LOW0:
++        return "LHDCBT_QUALITY_LOW0";
++        case LHDCBT_QUALITY_LOW1:
++        return "LHDCBT_QUALITY_LOW1";
++        case LHDCBT_QUALITY_LOW2:
++        return "LHDCBT_QUALITY_LOW2";
++        case LHDCBT_QUALITY_LOW3:
++        return "LHDCBT_QUALITY_LOW3";
++        case LHDCBT_QUALITY_LOW4:
++        return "LHDCBT_QUALITY_LOW4";
++        case LHDCBT_QUALITY_LOW:
++        return "LHDCBT_QUALITY_LOW";
++        case LHDCBT_QUALITY_MID:
++        return "LHDCBT_QUALITY_MID";
++        case LHDCBT_QUALITY_HIGH:
++        return "LHDCBT_QUALITY_HIGH";
++        case LHDCBT_QUALITY_AUTO:
++        return "LHDCBT_QUALITY_AUTO";
++        default:
++            ALOGE("%s: Incorrect quality(%d)",  __func__, q);
++        return "UNKNOW_QUALITY";
++    }
++}
++
++
++static int auto_bitrate_adjust_table_lhdc[] = {320, 350, 380, 440, 580, 600};
++static int auto_bitrate_adjust_table_llac[] = {136, 160, 192, 240, 320, 320};//7, 6, 5, 4, 3, 2
++
++static int bitrateFromIndex(lhdc_enc_type_t type, void * h, int index){
++
++    int limit = 0;
++    int result = 0;
++
++    if (type == ENC_TYPE_LHDC) {
++        lhdc_para_t * lhdc = (lhdc_para_t * )h;
++        limit = lhdc_util_get_bitrate((uint32_t)lhdc->limitBitRateStatus);
++        result = auto_bitrate_adjust_table_lhdc[index];
++    }else if (type == ENC_TYPE_LLAC) {
++        llac_para_t * llac = (llac_para_t * )h;
++        limit = lhdc_util_get_bitrate((uint32_t)llac->limitBitRateStatus);
++        result = auto_bitrate_adjust_table_llac[index];
++    }
++
++    return result >= limit ? limit : result;
++
++}
++
++static int bitrateIndexFrom(lhdc_enc_type_t type, size_t queueLength) {
++
++    uint32_t element_size = (type == ENC_TYPE_LHDC) ? LHDC_BITRATE_ELEMENTS_SIZE : LLAC_BITRATE_ELEMENTS_SIZE;
++
++    int newBitrateInx = 0;
++    if (queueLength < QUEUE_LENGTH_THRESHOLD) {
++        float queuePercenty = (1 - ((float)queueLength / QUEUE_LENGTH_THRESHOLD)) * (element_size - 1);
++        newBitrateInx = (int)queuePercenty;
++    }
++    return newBitrateInx;
++}
++
++//lhdcBT encHandle = NULL;
++static int indexOfBitrate(lhdc_enc_type_t type, void * h, int bitrate){
++    uint32_t element_size = type == ENC_TYPE_LHDC ? LHDC_BITRATE_ELEMENTS_SIZE : LLAC_BITRATE_ELEMENTS_SIZE;
++    for (size_t i = 0; i < element_size; i++) {
++        if (bitrateFromIndex(type, h, i) >= bitrate) {
++            return i;
++        }
++    }
++    return 0;
++}
++/*
++******************************************************************
++ LHDC functions group
++******************************************************************
++*/
++
++static void lhdc_encoder_set_max_bitrate(lhdc_para_t * handle, int max_rate_index) {
++    if (handle == NULL || max_rate_index == LHDCBT_QUALITY_AUTO){
++        ALOGE("%s: Error LHDC instance(%p), max rate(%d)",  __func__, handle, max_rate_index);
++        return;
++    }
++    if (max_rate_index != (int)handle->limitBitRateStatus){
++
++        handle->limitBitRateStatus = (LHDCBT_QUALITY_T)max_rate_index;
++
++        if ((uint32_t)handle->limitBitRateStatus != (uint32_t)handle->qualityStatus ){
++            if (handle->qualityStatus != LHDCBT_QUALITY_AUTO) {
++                handle->qualityStatus = handle->limitBitRateStatus;
++            }
++
++            int newRate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(handle->limitBitRateStatus), handle->hasMinBitrateLimit ? 320 : 128);
++
++            if (handle->lastBitrate >= newRate) {
++                handle->lastBitrate = newRate;
++
++                if (handle->version >= 2) {
++                    handle->updateFramneInfo = true;
++                }
++                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
++                ALOGD("%s: Update Max target bitrate(%s)",  __func__, rate_to_string(handle->limitBitRateStatus));
++            }
++        }
++    }
++}
++
++
++static int lhdc_encoder_encode(lhdc_para_t * handle, void* p_pcm, unsigned char* p_stream){
++    if (handle) {
++        if (p_pcm == NULL || p_stream == NULL) {
++            ALOGE("%s: Buffer error! source(%p), output(%p)",  __func__, p_pcm, p_stream);
++            return 0;
++        }
++        int bytesSizePerBlock = 0;
++        int encodedSize = -1;
++        uint32_t block_size = handle->block_size;
++        bytesSizePerBlock = (block_size * (handle->bits_per_sample >> 3)) << 1;
++        encodedSize = LossyEncoderProcessWav(handle->fft_blk, (unsigned char *)p_pcm, block_size, 0, p_stream, bytesSizePerBlock);
++        return encodedSize;
++    }
++    ALOGE("%s: Handle error!(%p)",  __func__, handle);
++    return 0;
++}
++
++
++
++
++static int lhdc_encoder_set_bitrate(lhdc_para_t * handle, int bitrate_inx){
++    if (handle) {
++
++        if (bitrate_inx != (int)handle->qualityStatus) {
++
++            if (bitrate_inx != LHDCBT_QUALITY_AUTO) {
++                handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(bitrate_inx), handle->hasMinBitrateLimit ? 320 : 128);
++            }else{
++                handle->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
++                lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
++                lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
++            }
++
++            handle->qualityStatus = bitrate_inx;
++
++            if ((uint32_t)handle->qualityStatus > (uint32_t)handle->limitBitRateStatus &&
++                handle->qualityStatus != LHDCBT_QUALITY_AUTO) {
++                handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(handle->limitBitRateStatus), handle->hasMinBitrateLimit ? 320 : 128);
++                handle->qualityStatus = handle->limitBitRateStatus;
++            }
++        }
++        if (handle->version >= 2) {
++          handle->updateFramneInfo = true;
++        }
++        LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
++        ALOGD("%s: Update target bitrate(%s)",  __func__, rate_to_string(handle->qualityStatus));
++        return 0;
++    }
++    ALOGE("%s: Handle error!(%p)",  __func__, handle);
++    return -1;
++}
++
++
++
++static int lhdc_encoder_adjust_bitrate(lhdc_para_t * handle, size_t queueLen) {
++    if (handle != NULL && handle->qualityStatus == LHDCBT_QUALITY_AUTO) {
++        if (handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT) {
++            /* code */
++            size_t queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
++
++            handle->dnBitrateSum = 0;
++            handle->dnBitrateCnt = 0;
++            int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
++
++            if (TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128) < handle->lastBitrate) {
++                handle->lastBitrate = TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128);
++                if (handle->version >= 2) {
++                  handle->updateFramneInfo = true;
++                }
++                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
++                ALOGD("%s:[Down BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
++                lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
++            }else{
++              ALOGW("%s: Down bitrate condition fails, new rate:%d, current rate:%d",  __func__,
++                                    TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128),
++                                    handle->lastBitrate);
++            }
++        }
++
++        if (handle->upBitrateCnt >= UP_RATE_TIME_CNT) {
++            //clear down bitrate parameters...
++            size_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
++            uint32_t queuSumTmp = handle->upBitrateSum;
++
++            handle->upBitrateSum = 0;
++            handle->upBitrateCnt = 0;
++            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
++            uint32_t newBitrateInx = indexOfBitrate(ENC_TYPE_LHDC, handle, handle->lastBitrate);
++            if (newBitrateInx < (LHDC_BITRATE_ELEMENTS_SIZE - 1)) {
++                newBitrateInx++;
++            }
++
++            if (TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128) > handle->lastBitrate && queuSumTmp == 0) {
++                handle->lastBitrate = TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128);
++
++                if (handle->version >= 2) {
++                  handle->updateFramneInfo = true;
++                }
++                LossyEncoderSetTargetByteRate(handle->fft_blk, (handle->lastBitrate * 1000) / 8);
++                ALOGD("%s:[Up BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
++                lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
++            }else{
++              ALOGW("%s: Up bitrate condition fails, new rate:%d, current rate:%d, sum of queue len:%d",  __func__,
++                                    TARGET_BITRATE_LIMIT(bitrateFromIndex(ENC_TYPE_LHDC, handle, newBitrateInx), handle->hasMinBitrateLimit ? 320 : 128),
++                                    handle->lastBitrate,
++                                    queuSumTmp);
++            }
++        }
++
++
++        handle->upBitrateSum += queueLen;
++        handle->dnBitrateSum += queueLen;
++
++        handle->upBitrateCnt++;
++        handle->dnBitrateCnt++;
++
++        return 0;
++    }
++    ALOGE("%s: Handle error!(%p)",  __func__, handle);
++    return -1;
++}
++
++
++/*
++******************************************************************
++ LLAC functions group
++******************************************************************
++*/
++
++
++
++//kaiden:20210311:autobirate:llac_encoder_adjust_bitrate fucntion
++static int llac_encoder_adjust_bitrate(llac_para_t * handle, size_t queueLen) {
++
++    if (handle != NULL && handle->qualityStatus == LHDCBT_QUALITY_AUTO) {
++        if (handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT) {
++            /* code */
++            size_t queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
++
++            handle->dnBitrateSum = 0;
++            handle->dnBitrateCnt = 0;
++            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LLAC, queueLength);
++            if (queueLength)
++            {
++
++                int newBitrateInx = 0;
++                if (bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx) < handle->lastBitrate) {
++                    handle->lastBitrate = bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx);
++    
++                        llac_enc_set_bitrate(handle->lastBitrate * 1000, &handle->out_nbytes, &handle->real_bitrate, handle->lh4_enc);
++                        //handle->frame_per_packet = handle->host_mtu_size / handle->out_nbytes;
++                        handle->updateFramneInfo = true;
++    
++                        ALOGD("%s:[Down BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
++                        lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, handle);
++                    }else{
++                      ALOGW("%s: Down bitrate condition fails, new rate:%d, current rate:%d",  __func__,
++                                            bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx),
++                                            handle->lastBitrate);
++                }
++            }
++
++        }
++
++        if (handle->upBitrateCnt >= UP_RATE_TIME_CNT) {
++            //clear down bitrate parameters...
++            size_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
++            uint32_t queuSumTmp = handle->upBitrateSum;
++
++            handle->upBitrateSum = 0;
++            handle->upBitrateCnt = 0;
++            //int newBitrateInx = bitrateIndexFrom(ENC_TYPE_LHDC, queueLength);
++            uint32_t newBitrateInx = indexOfBitrate(ENC_TYPE_LLAC, handle, handle->lastBitrate);
++            if (newBitrateInx < (LLAC_BITRATE_ELEMENTS_SIZE - 1)) {
++                newBitrateInx++;
++            }
++
++            if (bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx) > handle->lastBitrate && queuSumTmp == 0) {
++                handle->lastBitrate = bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx);
++
++                llac_enc_set_bitrate(handle->lastBitrate * 1000, &handle->out_nbytes, &handle->real_bitrate, handle->lh4_enc);
++                //handle->frame_per_packet = handle->host_mtu_size / handle->out_nbytes;
++                handle->updateFramneInfo = true;
++
++                ALOGD("%s:[Up BiTrAtE] Update bitrate(%d), queue length(%zu)",  __func__, handle->lastBitrate, queueLength);
++                lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, handle);
++            }else{
++              ALOGW("%s: Up bitrate condition fails, new rate:%d, current rate:%d, sum of queue len:%d",  __func__,
++                                    bitrateFromIndex(ENC_TYPE_LLAC, handle, newBitrateInx),
++                                    handle->lastBitrate,
++                                    queuSumTmp);
++            }
++        }
++
++
++        handle->upBitrateSum += queueLen;
++        handle->dnBitrateSum += queueLen;
++
++        handle->upBitrateCnt++;
++        handle->dnBitrateCnt++;
++
++        return 0;
++    }
++    ALOGE("%s: Handle error!(%p)",  __func__, handle);
++    return -1;
++}
++
++/*
++******************************************************************
++ LHDC library public functions group
++******************************************************************
++*/
++
++void lhdcBT_free_handle(HANDLE_LHDC_BT handle) {
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return;
++    }
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++        lhdc_encoder_free(lhdcBT->enc.lhdc);
++        break;
++        case ENC_TYPE_LLAC:
++        llac_encoder_free(lhdcBT->enc.llac);
++        break;
++        default:
++        break;
++    }
++
++    ar_process_free(lhdcBT->ar_filter);
++
++    free(lhdcBT);
++}
++
++
++HANDLE_LHDC_BT lhdcBT_get_handle(int version){
++    ALOGD("%s: Version number %d", __func__, version);
++
++    if(version <= 0)
++    {
++      return NULL;
++    }
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)malloc(sizeof(lhdc_cb_t));
++    memset(lhdcBT, 0 , sizeof(lhdc_cb_t));
++
++#ifdef AR_ALWAYS_ON
++    lhdcBT->ar_filter = ar_process_new();
++#else
++    if(version >= 3)
++    {
++        lhdcBT->ar_filter = ar_process_new();
++    }
++#endif
++
++    if (version <= 3)
++    {
++        lhdcBT->enc.lhdc = lhdc_encoder_new(version);
++        lhdcBT->enc_type = ENC_TYPE_LHDC;
++    }else if (version == 4){
++        lhdcBT->enc.llac = llac_encoder_new();
++        lhdcBT->enc_type = ENC_TYPE_LLAC;
++    }else{
++        lhdcBT->enc_type = ENC_TYPE_UNKNOWN;
++        free(lhdcBT);
++        lhdcBT = NULL;
++    }
++
++    return lhdcBT;
++}
++int lhdcBT_init_encoder(HANDLE_LHDC_BT handle,int sampling_freq, int bitPerSample, int bitrate_inx,
++    int dualChannel, int need_padding, int mtu, int interval) {
++
++    int result = 0;
++    unsigned int samples_per_frame = 0;
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++
++    if (sampling_freq != 44100 && sampling_freq != 48000 && sampling_freq != 96000)
++    {
++      ALOGE("%s: Invalid Sample Rate (%d)!!!", __func__, sampling_freq);
++      return -1;
++    }
++
++    if (bitPerSample != LHDCBT_SMPL_FMT_S16 && bitPerSample != LHDCBT_SMPL_FMT_S24)
++    {
++      ALOGE("%s: Invalid Bit Per Sample (%d)!!!", __func__, bitPerSample);
++      return -1;
++    }
++
++    if (bitrate_inx < LHDCBT_QUALITY_LOW0 || bitrate_inx >= LHDCBT_QUALITY_MAX)
++    {
++      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, bitrate_inx);
++      return -1;
++    }
++
++    if (dualChannel != 0 && dualChannel != 1)
++    {
++      ALOGE("%s: invalid Channel mode (%d)!!!", __func__, dualChannel);
++      return -1;
++    }
++
++    if (need_padding != 0)
++    {
++      ALOGE("%s: invalid need padding (%d)!!!", __func__, need_padding);
++      return -1;
++    }
++
++    if (mtu <= 0 || mtu >= 4096 )
++    {
++      ALOGE("%s: invalid mtu (%d)!!!", __func__, mtu);
++      return -1;
++    }
++
++    if (interval <= 0 || interval > 20) //default: 10ms or 20ms
++    {
++      ALOGE("%s: invalid interval (%d)!!!", __func__, interval);
++      return -1;
++    }
++
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++           result = lhdc_encoder_init(enc->lhdc, sampling_freq, bitPerSample, bitrate_inx, dualChannel, need_padding, mtu, interval);
++           samples_per_frame = lhdc_encoder_get_frame_len(enc->lhdc);
++           break;
++        case ENC_TYPE_LLAC:
++            result = llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
++            samples_per_frame = llac_encoder_get_frame_len(enc->llac);  
++           break;
++        default:
++        break;
++    }
++
++    if (result >= 0 && samples_per_frame > 0 && lhdcBT->ar_filter != NULL){
++        // number of channels is fixed to "2"
++        result = ar_process_init(lhdcBT->ar_filter, sampling_freq, bitPerSample, 2, samples_per_frame);
++    }
++
++    return result;
++}
++
++void lhdcBT_set_max_bitrate(HANDLE_LHDC_BT handle, int max_rate_index) {
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return;
++    }
++    if (max_rate_index < LHDCBT_QUALITY_LOW0 || max_rate_index >= LHDCBT_QUALITY_MAX)
++    {
++      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, max_rate_index);
++      return;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++            return lhdc_encoder_set_max_bitrate(enc->lhdc, max_rate_index);
++        case ENC_TYPE_LLAC: {
++
++            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
++            ALOGD("%s: LLAC not supported", __func__);
++        }
++        default:
++        break;
++    }
++}
++
++
++int lhdcBT_encode(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* p_stream){
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    if (!p_pcm)
++    {
++        ALOGE("%s: p_pcm is NULL!!!", __func__);
++        return -1;
++    }
++    if (!p_stream)
++    {
++        ALOGE("%s: p_stream is NULL!!!", __func__);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++            return lhdc_encoder_encode(enc->lhdc, p_pcm, p_stream);
++
++        case ENC_TYPE_LLAC: {
++
++            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
++            ALOGD("%s: LLAC not supported", __func__);
++            break;
++        }
++        default:
++        break;
++    }
++    return -1;
++}
++
++
++int lhdcBT_encodeV3(HANDLE_LHDC_BT handle, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_frames){
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    if (p_pcm == NULL)
++    {
++        ALOGE("%s: input pcm buffer ptr is NULL!!!", __func__);
++        return -1;
++    }
++    if (out_put == NULL)
++    {
++        ALOGE("%s: output pcm buffer ptr is NULL!!!", __func__);
++        return -1;
++    }
++    if (written == NULL)
++    {
++        ALOGE("%s: written address is NULL!!!", __func__);
++        return -1;
++    }
++    if (out_frames == NULL)
++    {
++        ALOGE("%s: out_frames address is NULL!!!", __func__);
++        return -1;
++    }
++
++    return lhdc_util_encv4_process( handle, p_pcm, out_put, written, out_frames);
++}
++
++
++
++int lhdcBT_get_block_Size(HANDLE_LHDC_BT handle){
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++            return lhdc_encoder_get_frame_len(enc->lhdc);
++
++        case ENC_TYPE_LLAC: {
++            return llac_encoder_get_frame_len(enc->llac);   //llac_encoder_encode(enc->llac, p_pcm, out_put, written, out_fraems);
++        }
++        default:
++        break;
++    }
++    return 0;
++}
++
++
++int lhdcBT_get_bitrate(HANDLE_LHDC_BT handle) {
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++            return lhdc_encoder_get_target_bitrate(enc->lhdc);
++
++        case ENC_TYPE_LLAC: {
++            return llac_encoder_get_target_bitrate(enc->llac);  //llac_encoder_encode(enc->llac, p_pcm, out_put, written, out_fraems);
++        }
++        default:
++        break;
++    }
++    return -1;
++}
++
++
++
++int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx){
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++
++    if(bitrate_inx < LHDCBT_QUALITY_LOW0 || bitrate_inx >= LHDCBT_QUALITY_MAX)
++    {
++      ALOGE("%s: invalid bit rate index (%d)!!!", __func__, bitrate_inx);
++      return -1;
++    }
++
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC: {
++          lhdc_para_t *lhdc = enc->lhdc;
++          if(lhdc == NULL) {
++            ALOGD("%s: LHDC [Reset BiTrAtE] null ptr!",  __func__);
++            return -1;
++          }
++
++          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
++            if(lhdc->qualityStatus != LHDCBT_QUALITY_AUTO) {
++              ALOGD("%s: LHDC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, lhdc->qualityStatus);
++              return -1;
++            }
++            // change bitrate only, do not update qualityStatus
++            lhdc->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
++            lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, lhdc);
++            lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, lhdc);
++            if (lhdc->version >= 2) {
++              lhdc->updateFramneInfo = true;
++            }
++            LossyEncoderSetTargetByteRate(lhdc->fft_blk, (lhdc->lastBitrate * 1000) / 8);
++            ALOGD("%s: LHDC [Reset BiTrAtE] Reset bitrate to (%d)",  __func__, lhdc->lastBitrate);
++            return 0;
++          } else {
++            // normal case, will update qualityStatus
++            ALOGD("%s: LHDC set bitrate_inx %d", __func__, bitrate_inx);
++            return lhdc_encoder_set_bitrate(lhdc, bitrate_inx);
++          }
++        }
++
++        case ENC_TYPE_LLAC: {
++          llac_para_t * llac = enc->llac;
++          if(llac == NULL) {
++            ALOGD("%s: LLAC [Reset BiTrAtE] null ptr!",  __func__);
++            return -1;
++          }
++
++          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
++            if(llac->qualityStatus != LHDCBT_QUALITY_AUTO) {
++              ALOGD("%s: LLAC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, llac->qualityStatus);
++              return -1;
++            }
++            // change bitrate only, do not update qualityStatus
++            llac->lastBitrate = LLAC_ABR_DEFAULT_BITRATE;
++            ALOGD("%s: LLAC [Reset BiTrAtE] Reset bitrate to (%d)", __func__, llac->lastBitrate);
++            llac_enc_set_bitrate(llac->lastBitrate * 1000, &llac->out_nbytes, &llac->real_bitrate, llac->lh4_enc);
++            llac->updateFramneInfo = true;
++            lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, llac);
++            lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, llac);
++            return 0;
++          } else {
++            //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
++            ALOGD("%s: LLAC not supported", __func__);
++            return -1;
++          }
++        }
++        default:
++        break;
++    }
++    return -1;
++}
++
++
++
++int lhdcBT_adjust_bitrate(HANDLE_LHDC_BT handle, size_t queueLen) {
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++
++    if (queueLen < 0)
++    {
++        ALOGE("%s: Invalid queue Len (%zu)!!!", __func__, queueLen);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++            return lhdc_encoder_adjust_bitrate(enc->lhdc, queueLen);
++
++        case ENC_TYPE_LLAC: {
++            return llac_encoder_adjust_bitrate(enc->llac, queueLen);
++        }
++        default:
++        break;
++    }
++    return -1;
++}
++
++int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled,
++    void * priv /*nullable*/, int priv_data_len){
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    if (field < LHDCBT_EXT_FUNC_AR || field >= LHDCBT_EXT_FUNC_MAX)
++    {
++        ALOGE("%s: invalid field (%d) !!!", __func__, field);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++//void LhdcExtFuncArEnable(FFT_BLOCK *fb, int enable_ar);
++//void LhdcExtFuncJasEnable(FFT_BLOCK *fb, int enable_Jas);
++//void LhdcExtFuncMetaEnable(FFT_BLOCK *fb, int enable_meta, unsigned char *pmeta_data, int meta_data_len, int conti_frame_cnt);
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++        {
++            switch((lhdc_ext_func_t)field){
++                case EXT_FUNC_AR:
++                LhdcExtFuncArEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
++                ALOGD("%s: lhdc AR func = %d", __func__, enabled);
++                return 0;
++                break;
++
++                case EXT_FUNC_JAS:
++                LhdcExtFuncJasEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
++                ALOGD("%s: lhdc JAS func = %d", __func__, enabled);
++                return 0;
++                break;
++
++                case EXT_FUNC_META:
++                if (!priv || !priv_data_len) {
++                    return -1;
++                }
++                LhdcExtFuncMetaEnable(enc->lhdc->fft_blk, enabled ? 1 : 0, priv, priv_data_len, 8);
++                ALOGD("%s: lhdc Meta func = %d", __func__, enabled);
++                return 0;
++                break;
++
++                default:
++                break;
++            }
++        }
++        break;
++
++        case ENC_TYPE_LLAC:
++        {
++            int8_t f_inx =  -1;
++            uint8_t f_enbaled = enabled ? 1 : 0;
++            switch((lhdc_ext_func_t)field){
++                case EXT_FUNC_AR:
++                f_inx = EXTRA_FUNC_AR;
++                break;
++
++                case EXT_FUNC_LARC:
++                f_inx = EXTRA_FUNC_LARC;
++                break;
++
++                default:
++                break;
++            }
++            if (f_inx >= 0)
++            {
++                ALOGD("%s: f_inx:%d, f_enbaled:%d, enc->llac->lh4_enc(%p)", __func__, f_inx, f_enbaled, enc->llac->lh4_enc);
++                llac_enc_set_extra_func(f_inx,
++                                        f_enbaled,
++                                        enc->llac->lh4_enc);
++                return 0;
++            }
++        }
++        break;
++
++        default:
++        break;
++    }
++
++    return -1;
++}
++
++int lhdcBT_get_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool * enabled){
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    if (!enabled)
++    {
++        ALOGE("%s: enabled is NULL!!!", __func__);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++    *enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, (lhdc_ext_func_t)field);
++
++
++    return 0;
++}
++
++int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled ){
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGE("%s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++            ALOGD("%s:set value (%d)",  __func__, enabled);
++            enc->lhdc->hasMinBitrateLimit = enabled;
++            break;
++
++        case ENC_TYPE_LLAC: {
++            ALOGD("%s: ENC_TYPE_LLAC unsupported!!!", __func__);
++            break;
++        }
++        default:
++        break;
++    }
++
++    return 0;
++}
++
++/*
++******************************************************************
++ Extend API functions group
++******************************************************************
++*/
++
++//
++// META
++//
++static int lhdcBT_set_cfg_meta_v1(HANDLE_LHDC_BT handle, const char* userConfig, const int configLen) 
++{
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    PST_LHDC_SET_META pset_meta = (PST_LHDC_SET_META)userConfig;
++
++    unsigned char  *pmeta_metadata = NULL;
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userConfig == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++	
++    if (configLen < (int) sizeof (ST_LHDC_SET_META))
++    {
++        // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small(req:%d)",  __func__, (int)sizeof(ST_LHDC_SET_META));
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++
++
++
++    if (pset_meta->meta_ver != META_ST_VER_V2)
++    {
++    	ALOGE("(LHDC-exAPI) %s: ver not match",  __func__);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;
++    }
++	
++    if (pset_meta->meta_mem_size != (int) sizeof (ST_LHDC_SET_META))
++    {
++    	ALOGE("(LHDC-exAPI) %s: mata size not match", __func__);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;
++    }
++
++    if (configLen < ((int) pset_meta->meta_metadata_length) + ((int) sizeof (ST_LHDC_SET_META)))
++    {
++    	ALOGE("(LHDC-exAPI) %s: cfg size too small", __func__);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;
++    }
++
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type)
++    {
++    case ENC_TYPE_LHDC:
++        ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LHDC", __func__);
++        pmeta_metadata = (unsigned char*) (pset_meta + 1);
++
++        LhdcExtFuncMetaEnable(enc->lhdc->fft_blk, 
++                              pset_meta->meta_enable, 
++                              pmeta_metadata, 
++                              pset_meta->meta_metadata_length, 
++                              pset_meta->meta_set);
++        break;
++
++    case ENC_TYPE_LLAC:
++    	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LLAC", __func__);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++        break;
++
++    default:
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++        break;
++    }
++
++
++    return EXTEND_FUNC_RET_OK;
++}
++
++
++static int lhdcBT_get_cfg_meta_v1(HANDLE_LHDC_BT handle, char* userConfig, const int configLen) 
++{
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    PST_LHDC_GET_META pget_meta = (PST_LHDC_GET_META)userConfig;
++    bool jas_enabled = false;
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userConfig == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (configLen < (int) sizeof (ST_LHDC_GET_META))
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small(req:%d)",  __func__, (int)sizeof(ST_LHDC_GET_META));
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type)
++    {
++    case ENC_TYPE_LHDC:
++        {
++        	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LHDC",  __func__);
++			pget_meta->meta_ver = META_ST_VER_V2;
++			pget_meta->meta_mem_size = (int) sizeof (ST_LHDC_GET_META);
++			pget_meta->meta_st = (LhdcGetExtFuncState(enc->lhdc->fft_blk, EXT_FUNC_META) << 1) | 0x01;  // Get current frame include metadata or not
++
++			//2021/06/10: Append JAS status her ,let UI can get JAS status from LHDC,
++			jas_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_JAS);
++			if(jas_enabled)
++			{
++				pget_meta->jas_status = 1;
++			}
++			else
++			{
++				pget_meta->jas_status = 0;
++			}
++        }
++        break;
++
++    case ENC_TYPE_LLAC:
++    	ALOGD("(LHDC-exAPI) %s: ENC_TYPE_LLAC",  __func__);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++        break;
++
++    default:
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++        break;
++    }
++
++
++    return EXTEND_FUNC_RET_OK;
++}
++
++
++//
++// AR
++//
++static int Ar_set_ext_func_state(HANDLE_LHDC_BT handle, bool enabled){
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++    if (!lhdcBT)
++    {
++        ALOGD("(LHDC-exAPI) %s: Handle is NULL!!!", __func__);
++        return -1;
++    }
++    enc_t * enc = &lhdcBT->enc;
++
++    switch(lhdcBT->enc_type){
++        case ENC_TYPE_LHDC:
++        {
++            LhdcExtFuncArEnable(enc->lhdc->fft_blk, enabled ? 1 : 0);
++            ALOGD("(LHDC-exAPI) %s: lhdc AR func = %d", __func__, enabled);
++        }
++        break;
++        case ENC_TYPE_LLAC:
++        {
++            int8_t f_inx = EXTRA_FUNC_AR;
++            uint8_t f_enbaled = enabled ? 1 : 0;
++            ALOGD("(LHDC-exAPI) %s: f_enbaled:%d, enc->llac->lh4_enc(%p)", __func__, f_enbaled, enc->llac->lh4_enc);
++            llac_enc_set_extra_func(f_inx, f_enbaled, enc->llac->lh4_enc);
++        }
++        break;
++        default:
++        break;
++    }
++    return 0;
++}
++
++static int lhdcBT_set_data_gyro_2d_v1(HANDLE_LHDC_BT handle, const char *userData, const int dataLen) {
++
++    PST_LHDC_AR_GYRO pargyro = (PST_LHDC_AR_GYRO) userData;
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++
++    enc_t * enc = &lhdcBT->enc;
++
++    bool ar_enabled = false;
++
++    int res;
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userData == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Data error!(%p)",  __func__, userData);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (dataLen < (int) sizeof (ST_LHDC_AR_GYRO))
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++	ALOGD("(LHDC-exAPI) %s: gyro[%d %d %d]",  __func__,
++			pargyro->world_coordinate_x, pargyro->world_coordinate_y, pargyro->world_coordinate_z);
++
++    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
++
++#ifdef AR_ALWAYS_ON
++    ar_enabled = true;
++#endif
++
++    if (ar_enabled)
++    {
++        res = ar_set_gyro_pos(lhdcBT->ar_filter, pargyro->world_coordinate_x, pargyro->world_coordinate_y, pargyro->world_coordinate_z);
++    }
++    else
++    {
++        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    }
++
++    if(res != 0)
++    {
++    	ALOGD("(LHDC-exAPI) %s: set_gyro_pos error(%d)",  __func__, res);
++        return EXTEND_FUNC_RET_ERROR;
++    }
++
++    return EXTEND_FUNC_RET_OK;
++}
++
++
++static int lhdcBT_set_cfg_ar_v3(HANDLE_LHDC_BT handle, const char *userConfig, const int configLen) {
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++
++    enc_t * enc = &lhdcBT->enc;
++
++    PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR)userConfig;
++
++    bool ar_enabled = false;
++
++    int res;
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userConfig == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (configLen < (int) sizeof (ST_LHDC_AR))
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++    ALOGD("(LHDC-exAPI) %s: config AR %d",  __func__, pset_ar_cfg->app_ar_enabled);
++
++    ar_enabled = pset_ar_cfg->app_ar_enabled ? 1 : 0;
++
++    Ar_set_ext_func_state(handle, ar_enabled);
++    //LhdcExtFuncArEnable(enc->lhdc->fft_blk, pset_ar_cfg->app_ar_enabled ? 1 : 0);
++
++    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
++
++    ALOGD("(LHDC-exAPI) %s: AR enabled %d",  __func__, ar_enabled);
++
++#ifdef AR_ALWAYS_ON
++    ar_enabled = true;
++#endif
++
++    if (ar_enabled)
++    {
++        res = ar_set_cfg(lhdcBT->ar_filter, &pset_ar_cfg->Ch1_Pos, &pset_ar_cfg->Ch1_L_PreGain, pset_ar_cfg->app_ar_enabled);
++    }
++    else
++    {
++        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    }
++
++    if(res != 0)
++    {
++        return EXTEND_FUNC_RET_ERROR;
++    }
++
++    return EXTEND_FUNC_RET_OK;
++}
++
++	
++static int lhdcBT_get_cfg_ar_v1(HANDLE_LHDC_BT handle, char *userConfig, const int configLen) {
++
++    //PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR)userConfig;
++
++    lhdc_cb_t * lhdcBT = (lhdc_cb_t *)handle;
++
++    enc_t * enc = &lhdcBT->enc;
++
++    bool ar_enabled = false;
++
++
++    int res = 0;
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userConfig == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (configLen <= (int) 0)
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++    ar_enabled = lhdc_util_get_ext_func_state(lhdcBT->enc_type, enc, EXT_FUNC_AR);
++
++#ifdef AR_ALWAYS_ON
++    ar_enabled = true;
++#endif
++
++    if (ar_enabled)
++    {
++    	ALOGD("(LHDC-exAPI) %s: AR enabled",  __func__);
++    	//2021/11/09: ar_get_cfg not supported yet
++        //res = ar_get_cfg(lhdcBT->ar_filter, &pset_ar_cfg->Ch1_Pos, &pset_ar_cfg->Ch1_L_PreGain);
++    	return EXTEND_FUNC_RET_ERROR;
++    }
++    else
++    {
++        ALOGD("(LHDC-exAPI) %s: AR not enabled!",  __func__);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    }
++
++    if(res != 0)
++    {
++        return EXTEND_FUNC_RET_ERROR;
++    }
++
++    ALOGD("(LHDC-exAPI) %s: End OK",  __func__);
++    return EXTEND_FUNC_RET_OK;	
++}
++
++
++
++/*
++******************************************************************
++ Extend API library public functions group
++******************************************************************
++*/
++
++// 1. API -- Set User Config (Extend)
++int lhdcBT_set_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen) {
++
++    unsigned char *pucConfig = (unsigned char *) userConfig;
++    unsigned int exFuncVer;
++    unsigned int exFuncCode;
++    int result = EXTEND_FUNC_RET_OK;
++
++    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userConfig == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++    exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
++               ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
++               ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
++               ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
++    exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
++                ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
++                ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
++                ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
++
++    switch (exFuncCode) {
++    case EXTEND_FUNC_CODE_SET_CONFIG_META:
++	
++        switch (exFuncVer) {
++        case EXTEND_FUNC_VER_SET_CONFIG_META_V1:
++        	ALOGD("(LHDC-exAPI) %s: SET_CONFIG_META\n",  __func__);
++            result = lhdcBT_set_cfg_meta_v1 (handle, userConfig, clen);
++            break;
++
++        default:
++            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
++            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++        }
++        break;
++		
++    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
++        switch (exFuncVer) {
++        case EXTEND_FUNC_VER_SET_CONFIG_AR_V3:
++        	ALOGD("(LHDC-exAPI) %s: SET_CONFIG_AR\n",  __func__);
++            result = lhdcBT_set_cfg_ar_v3 (handle, userConfig, clen);
++            break;
++
++        default:
++            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
++            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++        }
++        break;
++
++    default:
++        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    } // switch (exFuncCode)
++
++    return result;
++}
++
++
++// 2. API -- Get User Config (Extend)
++int lhdcBT_get_user_exconfig(HANDLE_LHDC_BT handle, char* userConfig, int clen) {
++
++
++    unsigned char *pucConfig = (unsigned char *) userConfig;
++    unsigned int exFuncVer;
++    unsigned int exFuncCode;
++    int result = EXTEND_FUNC_RET_OK;
++
++    //ALOGD("%s:(LHDC-exAPI) enter\n",  __func__);
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userConfig == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Config error!(%p)",  __func__, userConfig);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++    exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
++               ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
++               ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
++               ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
++    exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
++                ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
++                ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
++                ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
++
++    switch (exFuncCode) {
++    case EXTEND_FUNC_CODE_GET_CONFIG_META:
++	
++        switch (exFuncVer) {
++        case EXTEND_FUNC_VER_GET_CONFIG_META_V1:
++        	ALOGD("(LHDC-exAPI) %s: GET_CONFIG_META\n",  __func__);
++            result = lhdcBT_get_cfg_meta_v1 (handle, userConfig, clen);
++            break;
++
++        default:
++            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
++            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++        }
++        break;
++
++    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
++	
++        switch (exFuncVer) {
++        case EXTEND_FUNC_VER_GET_CONFIG_AR_V1:
++        	ALOGD("(LHDC-exAPI) %s: GET_CONFIG_AR\n",  __func__);
++            result = lhdcBT_get_cfg_ar_v1 (handle, userConfig, clen);
++            break;
++
++        default:
++            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
++            return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++        }
++        break;
++
++    default:
++        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    } // switch (exFuncCode)
++
++    return result;
++
++}
++
++// 3. API -- Set User Data (Extend)
++void lhdcBT_set_user_exdata(HANDLE_LHDC_BT handle, char* userData, int clen) {
++
++    unsigned char *pucData = (unsigned char *) userData;
++    unsigned int exFuncVer;
++    unsigned int exFuncCode;
++    int result = EXTEND_FUNC_RET_OK;
++
++    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return; // EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (userData == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: User Data error!(%p)",  __func__, userData);
++        return; // EXTEND_FUNC_RET_INVALID_PARAMETER;		
++    }
++
++    if (clen < (int)EXTEND_FUNC_CODE_MIN_BUFFER_LEN)
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return;
++    }
++
++    exFuncVer = (((unsigned int) pucData[3]) & ((unsigned int)0xff)) |
++               ((((unsigned int) pucData[2]) & ((unsigned int)0xff)) << 8)  |
++               ((((unsigned int) pucData[1]) & ((unsigned int)0xff)) << 16) |
++               ((((unsigned int) pucData[0]) & ((unsigned int)0xff)) << 24);
++    exFuncCode = (((unsigned int) pucData[7]) & ((unsigned int)0xff)) |
++                ((((unsigned int) pucData[6]) & ((unsigned int)0xff)) << 8)  |
++                ((((unsigned int) pucData[5]) & ((unsigned int)0xff)) << 16) |
++                ((((unsigned int) pucData[4]) & ((unsigned int)0xff)) << 24);
++
++    switch (exFuncCode) {
++    case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
++	
++        switch (exFuncVer) {
++        case EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1:
++        	ALOGD("(LHDC-exAPI) %s: SET_DATA_GYRO\n",  __func__);
++            result = lhdcBT_set_data_gyro_2d_v1 (handle, userData, clen);
++            break;
++
++        default:
++            ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
++            return; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++        }
++        break;
++		
++    default:
++        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
++        return; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    } // switch (exFuncCode)
++
++    //return result;
++}
++
++
++// 4. API -- Get Version
++int lhdcBT_get_user_exApiver(HANDLE_LHDC_BT handle, char *version, int clen) {
++
++    unsigned char *pucApiVer = (unsigned char *) version;
++    unsigned int exFuncVer = 0;
++    unsigned int exFuncCode = 0;
++    unsigned int exFuncMinBufSize = 0;
++    int result = EXTEND_FUNC_RET_OK;
++
++    //ALOGD("(LHDC-exAPI) %s: enter\n",  __func__);
++
++    if (version == NULL)
++    {
++        ALOGE("(LHDC-exAPI) %s: API verion buffer error!(%p)",  __func__, version);
++        return EXTEND_FUNC_RET_INVALID_PARAMETER;
++    }
++
++    if (handle == NULL) {
++        ALOGE("(LHDC-exAPI) %s: Handle error!(%p)",  __func__, handle);
++        return EXTEND_FUNC_RET_INVALID_HANDLE;
++    }
++
++    if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V1)
++    {
++         // Buffer is to small
++    	ALOGE("(LHDC-exAPI) %s: Buffer too small",  __func__);
++        return EXTEND_FUNC_RET_BUF_UNDERRUN;
++    }
++
++    /*
++    ALOGD("%s: clen=%d, APICode[4:7] = [0x%02X, 0x%02X, 0x%02X, 0x%02X]",  __func__,
++        clen, pucApiVer[4], pucApiVer[5], pucApiVer[6], pucApiVer[7]);
++        */
++
++    exFuncCode = (((unsigned int) pucApiVer[7]) & ((unsigned int)0xff)) |
++                ((((unsigned int) pucApiVer[6]) & ((unsigned int)0xff)) << 8)  |
++                ((((unsigned int) pucApiVer[5]) & ((unsigned int)0xff)) << 16) |
++                ((((unsigned int) pucApiVer[4]) & ((unsigned int)0xff)) << 24);
++
++    switch (exFuncCode) {
++    // Config API
++    case EXTEND_FUNC_CODE_SET_CONFIG_META:
++        exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_META_V1;
++        break;
++
++    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
++        exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_AR_V3;
++        break;
++
++    case EXTEND_FUNC_CODE_GET_CONFIG_META:
++        exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_META_V1;
++        break;
++
++    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
++        exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_AR_V1;
++        break;
++
++    // Data API
++    case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
++        exFuncVer = EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1;
++        break;
++
++    // A2DP codec Specific API
++    case EXTEND_FUNC_CODE_GET_SPECIFIC:
++        exFuncVer = EXTEND_FUNC_VER_GET_SPECIFIC_V2;
++        exFuncMinBufSize = LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2;
++        break;
++
++    default:
++        ALOGE("(LHDC-exAPI) %s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    } // switch (exFuncCode)
++
++    /* fill in current version of target API */
++    pucApiVer[3] = (unsigned char) (exFuncVer & ((unsigned int)0xff));
++    pucApiVer[2] = (unsigned char) ((exFuncVer >> 8) & ((unsigned int)0xff));
++    pucApiVer[1] = (unsigned char) ((exFuncVer >> 16) & ((unsigned int)0xff));
++    pucApiVer[0] = (unsigned char) ((exFuncVer >> 24) & ((unsigned int)0xff));
++
++    /**** Version Control Field: *****/
++    if(exFuncVer >= EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2 &&
++        clen >= EXTEND_FUNC_MIN_BUFFER_LEN_GET_API_VERSION_V2)
++    {
++      /* After API V2.0.0.0, append "minimum required buffer size" into API response */
++      pucApiVer[11] = (unsigned char) (exFuncMinBufSize & ((unsigned int)0xff));
++      pucApiVer[10] = (unsigned char) ((exFuncMinBufSize >> 8) & ((unsigned int)0xff));
++      pucApiVer[9] = (unsigned char) ((exFuncMinBufSize >> 16) & ((unsigned int)0xff));
++      pucApiVer[8] = (unsigned char) ((exFuncMinBufSize >> 24) & ((unsigned int)0xff));
++    }
++
++    ALOGD("(LHDC-exAPI) %s: return Ver=0x[%02X %02X %02X %02X]",  __func__,
++        pucApiVer[4], pucApiVer[5], pucApiVer[6], pucApiVer[7]);
++
++    return result;
++}
++
+diff --git a/external/liblhdcdec/Android.bp b/external/liblhdcdec/Android.bp
+new file mode 100644
+index 000000000..eb12d27c0
+--- /dev/null
++++ b/external/liblhdcdec/Android.bp
+@@ -0,0 +1,50 @@
++
++cc_prebuilt_library_shared {
++    name: "liblhdcdec",
++
++    export_include_dirs: ["include"],
++    arch: {
++        arm: {
++            srcs: ["libs/armeabi-v7a/liblhdcdec.so",],
++        },
++        arm64: {
++            srcs: ["libs/arm64-v8a/liblhdcdec.so",],
++        },
++    },
++
++    strip: {
++        none:true,
++    },
++
++    shared_libs: [
++        "liblog",
++        "libstdc++",
++    ],
++}
++
++cc_library_shared {
++    name: "liblhdcBT_dec",
++   // vendor_available: true,
++   // vndk: {
++   //     enabled: true,
++   // },
++    arch: {
++        arm: {
++            instruction_set: "arm",
++        },
++    },
++    export_include_dirs: ["inc"],
++    local_include_dirs: ["inc", "include", ],
++    srcs: [
++        "src/lhdcBT_dec.c",
++    ],
++    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
++    // unit such as ARM Cortex-R series or external 32-bit DSPs.
++    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
++
++    shared_libs: [
++        "libcutils",
++        "liblog",
++        "liblhdcdec",
++    ],
++}
+diff --git a/external/liblhdcdec/LICENSE b/external/liblhdcdec/LICENSE
+new file mode 100644
+index 000000000..261eeb9e9
+--- /dev/null
++++ b/external/liblhdcdec/LICENSE
+@@ -0,0 +1,201 @@
++                                 Apache License
++                           Version 2.0, January 2004
++                        http://www.apache.org/licenses/
++
++   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
++
++   1. Definitions.
++
++      "License" shall mean the terms and conditions for use, reproduction,
++      and distribution as defined by Sections 1 through 9 of this document.
++
++      "Licensor" shall mean the copyright owner or entity authorized by
++      the copyright owner that is granting the License.
++
++      "Legal Entity" shall mean the union of the acting entity and all
++      other entities that control, are controlled by, or are under common
++      control with that entity. For the purposes of this definition,
++      "control" means (i) the power, direct or indirect, to cause the
++      direction or management of such entity, whether by contract or
++      otherwise, or (ii) ownership of fifty percent (50%) or more of the
++      outstanding shares, or (iii) beneficial ownership of such entity.
++
++      "You" (or "Your") shall mean an individual or Legal Entity
++      exercising permissions granted by this License.
++
++      "Source" form shall mean the preferred form for making modifications,
++      including but not limited to software source code, documentation
++      source, and configuration files.
++
++      "Object" form shall mean any form resulting from mechanical
++      transformation or translation of a Source form, including but
++      not limited to compiled object code, generated documentation,
++      and conversions to other media types.
++
++      "Work" shall mean the work of authorship, whether in Source or
++      Object form, made available under the License, as indicated by a
++      copyright notice that is included in or attached to the work
++      (an example is provided in the Appendix below).
++
++      "Derivative Works" shall mean any work, whether in Source or Object
++      form, that is based on (or derived from) the Work and for which the
++      editorial revisions, annotations, elaborations, or other modifications
++      represent, as a whole, an original work of authorship. For the purposes
++      of this License, Derivative Works shall not include works that remain
++      separable from, or merely link (or bind by name) to the interfaces of,
++      the Work and Derivative Works thereof.
++
++      "Contribution" shall mean any work of authorship, including
++      the original version of the Work and any modifications or additions
++      to that Work or Derivative Works thereof, that is intentionally
++      submitted to Licensor for inclusion in the Work by the copyright owner
++      or by an individual or Legal Entity authorized to submit on behalf of
++      the copyright owner. For the purposes of this definition, "submitted"
++      means any form of electronic, verbal, or written communication sent
++      to the Licensor or its representatives, including but not limited to
++      communication on electronic mailing lists, source code control systems,
++      and issue tracking systems that are managed by, or on behalf of, the
++      Licensor for the purpose of discussing and improving the Work, but
++      excluding communication that is conspicuously marked or otherwise
++      designated in writing by the copyright owner as "Not a Contribution."
++
++      "Contributor" shall mean Licensor and any individual or Legal Entity
++      on behalf of whom a Contribution has been received by Licensor and
++      subsequently incorporated within the Work.
++
++   2. Grant of Copyright License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      copyright license to reproduce, prepare Derivative Works of,
++      publicly display, publicly perform, sublicense, and distribute the
++      Work and such Derivative Works in Source or Object form.
++
++   3. Grant of Patent License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      (except as stated in this section) patent license to make, have made,
++      use, offer to sell, sell, import, and otherwise transfer the Work,
++      where such license applies only to those patent claims licensable
++      by such Contributor that are necessarily infringed by their
++      Contribution(s) alone or by combination of their Contribution(s)
++      with the Work to which such Contribution(s) was submitted. If You
++      institute patent litigation against any entity (including a
++      cross-claim or counterclaim in a lawsuit) alleging that the Work
++      or a Contribution incorporated within the Work constitutes direct
++      or contributory patent infringement, then any patent licenses
++      granted to You under this License for that Work shall terminate
++      as of the date such litigation is filed.
++
++   4. Redistribution. You may reproduce and distribute copies of the
++      Work or Derivative Works thereof in any medium, with or without
++      modifications, and in Source or Object form, provided that You
++      meet the following conditions:
++
++      (a) You must give any other recipients of the Work or
++          Derivative Works a copy of this License; and
++
++      (b) You must cause any modified files to carry prominent notices
++          stating that You changed the files; and
++
++      (c) You must retain, in the Source form of any Derivative Works
++          that You distribute, all copyright, patent, trademark, and
++          attribution notices from the Source form of the Work,
++          excluding those notices that do not pertain to any part of
++          the Derivative Works; and
++
++      (d) If the Work includes a "NOTICE" text file as part of its
++          distribution, then any Derivative Works that You distribute must
++          include a readable copy of the attribution notices contained
++          within such NOTICE file, excluding those notices that do not
++          pertain to any part of the Derivative Works, in at least one
++          of the following places: within a NOTICE text file distributed
++          as part of the Derivative Works; within the Source form or
++          documentation, if provided along with the Derivative Works; or,
++          within a display generated by the Derivative Works, if and
++          wherever such third-party notices normally appear. The contents
++          of the NOTICE file are for informational purposes only and
++          do not modify the License. You may add Your own attribution
++          notices within Derivative Works that You distribute, alongside
++          or as an addendum to the NOTICE text from the Work, provided
++          that such additional attribution notices cannot be construed
++          as modifying the License.
++
++      You may add Your own copyright statement to Your modifications and
++      may provide additional or different license terms and conditions
++      for use, reproduction, or distribution of Your modifications, or
++      for any such Derivative Works as a whole, provided Your use,
++      reproduction, and distribution of the Work otherwise complies with
++      the conditions stated in this License.
++
++   5. Submission of Contributions. Unless You explicitly state otherwise,
++      any Contribution intentionally submitted for inclusion in the Work
++      by You to the Licensor shall be under the terms and conditions of
++      this License, without any additional terms or conditions.
++      Notwithstanding the above, nothing herein shall supersede or modify
++      the terms of any separate license agreement you may have executed
++      with Licensor regarding such Contributions.
++
++   6. Trademarks. This License does not grant permission to use the trade
++      names, trademarks, service marks, or product names of the Licensor,
++      except as required for reasonable and customary use in describing the
++      origin of the Work and reproducing the content of the NOTICE file.
++
++   7. Disclaimer of Warranty. Unless required by applicable law or
++      agreed to in writing, Licensor provides the Work (and each
++      Contributor provides its Contributions) on an "AS IS" BASIS,
++      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++      implied, including, without limitation, any warranties or conditions
++      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
++      PARTICULAR PURPOSE. You are solely responsible for determining the
++      appropriateness of using or redistributing the Work and assume any
++      risks associated with Your exercise of permissions under this License.
++
++   8. Limitation of Liability. In no event and under no legal theory,
++      whether in tort (including negligence), contract, or otherwise,
++      unless required by applicable law (such as deliberate and grossly
++      negligent acts) or agreed to in writing, shall any Contributor be
++      liable to You for damages, including any direct, indirect, special,
++      incidental, or consequential damages of any character arising as a
++      result of this License or out of the use or inability to use the
++      Work (including but not limited to damages for loss of goodwill,
++      work stoppage, computer failure or malfunction, or any and all
++      other commercial damages or losses), even if such Contributor
++      has been advised of the possibility of such damages.
++
++   9. Accepting Warranty or Additional Liability. While redistributing
++      the Work or Derivative Works thereof, You may choose to offer,
++      and charge a fee for, acceptance of support, warranty, indemnity,
++      or other liability obligations and/or rights consistent with this
++      License. However, in accepting such obligations, You may act only
++      on Your own behalf and on Your sole responsibility, not on behalf
++      of any other Contributor, and only if You agree to indemnify,
++      defend, and hold each Contributor harmless for any liability
++      incurred by, or claims asserted against, such Contributor by reason
++      of your accepting any such warranty or additional liability.
++
++   END OF TERMS AND CONDITIONS
++
++   APPENDIX: How to apply the Apache License to your work.
++
++      To apply the Apache License to your work, attach the following
++      boilerplate notice, with the fields enclosed by brackets "[]"
++      replaced with your own identifying information. (Don't include
++      the brackets!)  The text should be enclosed in the appropriate
++      comment syntax for the file format. We also recommend that a
++      file or class name and description of purpose be included on the
++      same "printed page" as the copyright notice for easier
++      identification within third-party archives.
++
++   Copyright [yyyy] [name of copyright owner]
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
+diff --git a/external/liblhdcdec/MODULE_LICENSE_APACHE2 b/external/liblhdcdec/MODULE_LICENSE_APACHE2
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcdec/NOTICE b/external/liblhdcdec/NOTICE
+new file mode 100644
+index 000000000..ea044d3be
+--- /dev/null
++++ b/external/liblhdcdec/NOTICE
+@@ -0,0 +1,27 @@
++/******************************************************************************
++ *
++ * Copyright (C) 2015 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at:
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ *
++ *****************************************************************************
++ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
++ */
++
++---------------
++ Certification
++---------------
++   Taking the certification process is required to use LHDC in your products.
++   For the detail of certification process, see the following URL:
++      https://www.savitech.co/
++
+diff --git a/external/liblhdcdec/inc/lhdcBT_dec.h b/external/liblhdcdec/inc/lhdcBT_dec.h
+new file mode 100644
+index 000000000..97beb5ed1
+--- /dev/null
++++ b/external/liblhdcdec/inc/lhdcBT_dec.h
+@@ -0,0 +1,41 @@
++
++
++#ifndef _LHDCBT_DEC_H_
++#define _LHDCBT_DEC_H_
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#include "lhdcUtil.h"
++
++
++
++typedef struct  
++{
++  lhdc_ver_t version;
++  uint32_t   sample_rate;
++  uint8_t    bits_depth;
++} tLHDCV3_DEC_CONFIG;
++
++
++
++int lhdcBT_dec_init_decoder(tLHDCV3_DEC_CONFIG *config);
++int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
++int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
++int lhdcBT_dec_deinit_decoder(void);
++
++
++#define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
++#define LHDCBT_DEC_UPD_SEQ_NO				1
++
++
++#define LHDCBT_DEC_FUNC_SUCCEED             0
++#define LHDCBT_DEC_FUNC_FAIL                -1
++#define LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH    -2
++#define LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH   -3
++#define LHDCBT_DEC_FUNC_INVALID_SEQ_NO		-4
++
++#ifdef __cplusplus
++}
++#endif
++#endif /* _LHDCBT_DEC_H_ */
+diff --git a/external/liblhdcdec/include/lhdcUtil.h b/external/liblhdcdec/include/lhdcUtil.h
+new file mode 100644
+index 000000000..6a08e540b
+--- /dev/null
++++ b/external/liblhdcdec/include/lhdcUtil.h
+@@ -0,0 +1,101 @@
++/*
++ * lhdcUtil.h
++ *
++ *  Created on: 2001/1/3
++ *      Author: eric.lee
++ */
++
++#ifndef LHDC_UTIL_H
++#define LHDC_UTIL_H
++
++#include <stdbool.h>
++#include <stdint.h>
++
++
++
++
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++// Copy definition from external
++#define BTIF_BD_ADDR_SIZE    6
++
++
++// Define for LHDC stream type.
++typedef enum {
++    LHDC_STRM_TYPE_COMBINE,
++    LHDC_STRM_TYPE_SPLIT
++}LHDC_STRM_TYPE;
++
++typedef enum {
++  VERSION_2 = 200,
++  VERSION_3 = 300,
++  VERSION_4 = 400,
++  VERSION_LLAC = 500
++}lhdc_ver_t;
++
++typedef enum {
++  LHDCV2_BLOCK_SIZE = 512,
++  LHDCV3_BLOCK_SIZE = 256,
++}lhdc_block_size_t;
++
++typedef struct savi_bt_local_info_t{
++    uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
++    const char *bt_name;
++    uint8_t bt_len;
++    uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
++    const char *ble_name;
++    uint8_t ble_len;
++}savi_bt_local_info;
++
++typedef struct _lhdc_frame_Info
++{
++    uint32_t frame_len; //  frame  frame 
++    uint32_t isSplit;   // 
++    uint32_t isLeft;    //  == true  == false
++
++} lhdc_frame_Info_t;
++
++
++typedef enum {
++    LHDC_OUTPUT_STEREO = 0,
++    LHDC_OUTPUT_LEFT_CAHNNEL,
++    LHDC_OUTPUT_RIGHT_CAHNNEL,
++} lhdc_channel_t;
++
++typedef int LHDCSample;
++
++typedef void (*print_log_fp)(char*  msg);
++typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
++
++
++
++#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
++#define A2DP_LHDC_HDR_LATENCY_MID   0x01
++#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
++#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
++
++#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
++
++
++void lhdcInit(uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
++
++uint32_t lhdcDecodeProcess(uint8_t * pOutBuf, uint8_t * pInput, uint32_t len);
++bool lhdcSetLicenseKeyTable(uint8_t * licTable, LHDC_GET_BT_INFO pFunc);
++void lhdcSetLicenseKeyChkPeriod (uint8_t period);
++char * getVersionCode();
++
++void lhdcDestroy();
++
++void lhdc_register_log_cb(print_log_fp cb);
++
++uint32_t lhdcGetSampleSize( void);
++bool lhdcFetchFrameInfo(uint8_t * frameData, lhdc_frame_Info_t * frameInfo);
++
++uint32_t lhdcChannelSelsect(lhdc_channel_t channel_type);
++
++#ifdef __cplusplus
++}
++#endif
++#endif /* End of LHDC_UTIL_H */
+diff --git a/external/liblhdcdec/libs/arm64-v8a/.gitkeep b/external/liblhdcdec/libs/arm64-v8a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcdec/libs/armeabi-v7a/.gitkeep b/external/liblhdcdec/libs/armeabi-v7a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcdec/release_note b/external/liblhdcdec/release_note
+new file mode 100644
+index 000000000..5a42cb9e0
+--- /dev/null
++++ b/external/liblhdcdec/release_note
+@@ -0,0 +1,8 @@
++Release Note.
++=========================================================
++2022/05/11
++1. Upgrade LHDCV4 decoder version to V4.0.2
++
++2021/11/22
++Add LHDC v3/v4 Decoder
++
+diff --git a/external/liblhdcdec/src/lhdcBT_dec.c b/external/liblhdcdec/src/lhdcBT_dec.c
+new file mode 100644
+index 000000000..fa20c66b8
+--- /dev/null
++++ b/external/liblhdcdec/src/lhdcBT_dec.c
+@@ -0,0 +1,405 @@
++
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdint.h>
++#include <stdbool.h>
++#include "lhdcBT_dec.h"
++
++
++#define LOG_NDEBUG 0
++#define LOG_TAG "lhdcBT_dec"
++#include <cutils/log.h>
++
++static uint8_t serial_no = 0xff;
++
++static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len, uint8_t **pLout, uint32_t *pLlen, int upd_seq_no);
++
++// description
++//   a function to log information in LHDC decoder library
++// Parameter
++//   config: configuration data for LHDC v4 decoder
++// return:
++//   == 0: succeed
++//   < 0: error
++static void print_log_cb(char*  msg)
++{
++	if (msg == NULL)
++	{
++		return;
++	}
++
++    ALOGD("[WL50-ex] %s: %s", __func__, msg);
++}
++
++// description
++//   init. LHDC v4 decoder 
++// Parameter
++//   config: configuration data for LHDC v4 decoder
++// return:
++//   == 0: succeed
++//   < 0: error
++int lhdcBT_dec_init_decoder(tLHDCV3_DEC_CONFIG *config)
++{
++	//ALOGD("[WL50] %s: enter", __func__);
++    if (config == NULL)
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++
++    //ALOGD("[WL50] %s: bits_depth:%d sample_rate=%d version=%d", __func__,	config->bits_depth, config->sample_rate, config->version);
++
++    if ((config->bits_depth != 16) && (config->bits_depth != 24))
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++
++    if ((config->sample_rate != 44100) && (config->sample_rate != 48000) &&
++	    (config->sample_rate != 96000))
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++
++    if ((config->version != VERSION_3) && (config->version != VERSION_4) &&
++	    (config->version != VERSION_LLAC))
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++
++	lhdc_register_log_cb(&print_log_cb);
++
++    //ALOGD("[WL50] %s: start lhdcInit..", __func__);
++    lhdcInit(config->bits_depth, config->sample_rate, 400000, config->version);
++
++    lhdcChannelSelsect(LHDC_OUTPUT_STEREO);
++
++    serial_no = 0xff;
++    //ALOGD("[WL50] %s: end", __func__);
++	return LHDCBT_DEC_FUNC_SUCCEED;
++}
++
++
++
++// description
++//   check whether all frames of one packet are in buffer?
++// Parameter
++//   frameData: pointer to input buffer
++//   frameBytes: length (bytes) of input buffer pointed by frameData
++// return:
++//   == 0: succeed
++//   < 0: error
++int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes)
++{
++	uint8_t *frameDataStart = (uint8_t *)frameData;
++    uint8_t *in_buf = NULL;
++    uint32_t in_len = 0;
++	uint32_t frame_num = 0;
++	lhdc_frame_Info_t lhdc_frame_Info;
++	uint32_t ptr_offset = 0;
++	bool fn_ret;
++
++
++    ALOGD("[WL50] %s: enter, frameBytes (%d)", __func__, (int)frameBytes);
++
++	if ((frameData == NULL) || (packetBytes == NULL))
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++	
++	*packetBytes = 0;
++
++    frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len, LHDCBT_DEC_NOT_UPD_SEQ_NO);
++    if (frame_num == 0)
++	{
++        ALOGD("%s: assemble_lhdc_packet (%d)", __func__, (int)frame_num);
++		return LHDCBT_DEC_FUNC_SUCCEED;
++	}
++	//else if (frame_num < 0)
++	//{
++	//	// Fail to check packet header (including invalid packet number)!
++	//	return frame_num;
++	//}
++	
++	ALOGD("[WL50] %s: in_buf (%p), frameData (%p), in_len (%d), frame_num (%d)", __func__, in_buf, frameData, (int)in_len, (int) frame_num);
++	
++	ptr_offset = 0;
++
++	while ((frame_num > 0) && (ptr_offset < in_len))
++	{
++		fn_ret = lhdcFetchFrameInfo (in_buf + ptr_offset, &lhdc_frame_Info);
++		if (fn_ret == false)
++		{
++			ALOGD("[WL50] %s: lhdcFetchFrameInfo(%d) fail..", __func__, (int)frame_num);
++			return LHDCBT_DEC_FUNC_FAIL;
++		}
++		
++		ALOGD("[WL50] %s: lhdcFetchFrameInfo  frame_num (%d), ptr_offset (%d), lhdc_frame_Info.frame_len (%d), in_len (%d)", __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
++		
++		if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len)
++		{
++			ALOGD("[WL50] %s: Not Enough... frame_num(%d), ptr_offset(%d), frame_len(%d), in_len (%d)", __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
++			return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
++		}
++
++        ptr_offset += lhdc_frame_Info.frame_len;
++
++        frame_num--;
++	}
++
++
++	*packetBytes = ptr_offset;
++
++    ALOGD("[WL50] %s: end ", __func__);
++    return LHDCBT_DEC_FUNC_SUCCEED;
++
++}
++
++
++/*
++	uint8_t llac_test_ptn[0x100] = {
++		0x90, 0x01, 0x04, 0xF7, 0x7C, 0x65, 0xEA, 0x83, 
++		0xBB, 0x66, 0x4B, 0xA0, 0xF6, 0x51, 0xB8, 0x48, 
++		0x0C, 0xE7, 0x9D, 0xB9, 0x3B, 0x28, 0x0E, 0x82, 
++		0x73, 0xC6, 0xD7, 0xF9, 0xFC, 0x60, 0x34, 0xA9, 
++		0xEA, 0x46, 0x03, 0xD4, 0xA9, 0x63, 0x41, 0x30, 
++		0x37, 0x54, 0xBF, 0x47, 0x61, 0xAD, 0x7A, 0xB7, 
++		0xF0, 0x6E, 0x49, 0x00, 0xC7, 0xF9, 0xC6, 0x23, 
++		0x99, 0x01, 0xA1, 0x08, 0x79, 0xF4, 0x53, 0xC2, 
++		0xDF, 0xD8, 0x6F, 0x81, 0xB9, 0x8D, 0x65, 0x71, 
++		0xA2, 0x77, 0xF7, 0x0C, 0x65, 0x2D, 0x78, 0x80, 
++		0xA8, 0xBA, 0xC0, 0xA0, 0xD4, 0x98, 0xB4, 0xF5, 
++		0xB3, 0x6C, 0x61, 0x14, 0xD4, 0x93, 0xA5, 0x2D, 
++		0x07, 0x4D, 0x49, 0x1B, 0x78, 0x9F, 0x4E, 0xC7, 
++		0x28, 0x15, 0x35, 0x2E, 0x00, 0x44, 0xD5, 0x62, 
++		0xA3, 0x95, 0x86, 0xE4, 0xDC, 0x9E, 0xD7, 0xAC, 
++		0xC0, 0x90, 0x6D, 0x62, 0xED, 0xBA, 0x4A, 0x89, 
++		0xAE, 0x7F, 0x50, 0xC6, 0xAD, 0x57, 0xBA, 0x47, 
++		0xBA, 0x45, 0xEC, 0x0F, 0x99, 0xA6, 0xA0, 0x3F, 
++		0xBD, 0x14, 0xAA, 0xBD, 0x74, 0x5B, 0x49, 0x7E, 
++		0xF9, 0xD1, 0xB7, 0x6A, 0x4F, 0xF3, 0x31, 0xD9, 
++		0x3D, 0x79, 0xBF, 0x79, 0x1C, 0x99, 0x74, 0xD7, 
++		0x1B, 0x3B, 0x04, 0xF9, 0x61, 0xB4, 0xC3, 0x7B, 
++		0x86, 0x6B, 0x5A, 0x6F, 0xAD, 0x95, 0xB2, 0xD7, 
++		0x6D, 0xCC, 0xC8, 0x33, 0x0D, 0x87, 0xC6, 0x06, 
++		0xFC, 0xD1, 0x17, 0x8C, 0xD0, 0x33, 0x37, 0x55, 
++		0xA1, 0x07, 0x6F, 0x70, 0xD1, 0x97, 0x2A, 0x97, 
++		0x44, 0xE8, 0x8A, 0xBA, 0xC1, 0x28, 0xA9, 0x23, 
++		0x54, 0xD8, 0x89, 0x63, 0x56, 0x8B, 0x32, 0xA6, 
++		0x38, 0xA1, 0xFA, 0x83, 0x87, 0x2A, 0x2B, 0x6F, 
++		0xD7, 0x8E, 0x18, 0x79, 0xEC, 0x53, 0xAE, 0x10, 
++		0xC8, 0xF6, 0x49, 0xD7, 0xA2, 0xC5, 0x00, 0xED, 
++		0x62, 0xFD, 0xBA, 0x48, 0x00, 0x00, 0x00, 0x00};
++	uint8_t llac_ptn[0x100];
++*/
++
++// description
++//   decode all frames in one packet
++// Parameter
++//   frameData: pointer to input buffer
++//   frameBytes: length (bytes) of input buffer pointed by frameData
++//   pcmData: pointer to output buffer
++//   pcmBytes: length (bytes) of pcm samples in output buffer
++// return:
++//   == 0: succeed
++//   < 0: error
++int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth)
++{
++	uint8_t *frameDataStart = (uint8_t *)frameData;
++    uint32_t dec_sum = 0;
++	uint32_t lhdc_out_len = 0;
++    uint8_t *in_buf = NULL;
++    uint32_t in_len = 0;
++	uint32_t frame_num = 0;
++	lhdc_frame_Info_t lhdc_frame_Info;
++	uint32_t ptr_offset = 0;
++	bool fn_ret;
++    uint32_t frame_samples;
++	uint32_t frame_bytes;
++	uint32_t pcmSpaceBytes;
++
++    //ALOGD("[WL50] %s: enter, assemble_lhdc_packet(frameBytes %d)", __func__, (int)frameBytes);
++
++    if ((frameData == NULL) || 
++	    (pcmData == NULL) ||
++		(pcmBytes == NULL))
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++
++    pcmSpaceBytes = *pcmBytes;
++	*pcmBytes = 0;
++
++/*
++    if(frameBytes >= 16)
++    {
++		for(int i=0; i<16; i++)
++		{
++			ALOGD("[WL50] %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
++		}
++    }
++    else
++    {
++		for(int i=0; i<(int)frameBytes; i++)
++		{
++			ALOGD("[WL50] %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
++		}
++    }
++*/
++
++    frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len, LHDCBT_DEC_UPD_SEQ_NO);
++    if (frame_num == 0)
++	{
++		return LHDCBT_DEC_FUNC_SUCCEED;
++	}
++	//ALOGD("[WL50] %s: frameData=0x%p, in_buf=0x%p, in_len=%d", __func__, frameData, in_buf, in_len);
++    //ALOGD("[WL50] %s: get frame_num=%d", __func__, (int)frame_num);
++
++    frame_samples = lhdcGetSampleSize ();
++	if (bits_depth == 16)
++	{
++		frame_bytes = frame_samples * 2 * 2;
++	}
++	else
++	{
++		frame_bytes = frame_samples * 4 * 2;
++	}
++    ALOGD("[WL50] %s: frame_samples=%d", __func__, (int)frame_samples);
++
++    ptr_offset = 0;
++    dec_sum = 0;
++
++	while ((frame_num > 0) && (ptr_offset < in_len))
++	{
++		fn_ret = lhdcFetchFrameInfo (in_buf + ptr_offset, &lhdc_frame_Info);
++		if (fn_ret == false)
++		{
++			//ALOGD("[WL50] %s: lhdcFetchFrameInfo(%d) fail..", __func__, (int)frame_num);
++			return LHDCBT_DEC_FUNC_FAIL;
++		}
++
++		if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len)
++		{
++			return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
++		}
++
++		if ((dec_sum + frame_bytes) > pcmSpaceBytes)
++		{
++			return LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH;
++		}
++
++ 		//ALOGD("[WL50] %s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
++        lhdc_out_len = lhdcDecodeProcess(((uint8_t *)pcmData) + dec_sum, in_buf + ptr_offset, lhdc_frame_Info.frame_len);
++        //ALOGD("[WL50] %s: lhdcDecodeProcess(frm=%d, frame_len=%d out_len=%d)..", __func__, (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
++
++        //if (lhdc_out_len % frame_samples)
++        //{
++        //    TRACE_A2DP_DECODER_I("[CP][LHDC]error!!! dec_sum: %d decode_temp: %d", dec_sum, lhdc_decode_temp);
++        //    return LHDCBT_DEC_FUNC_FAIL;
++        //}
++
++        ptr_offset += lhdc_frame_Info.frame_len;
++        dec_sum += lhdc_out_len;
++
++        frame_num--;
++	}
++
++    *pcmBytes = (uint32_t) dec_sum;
++
++    //ALOGD("[WL50] %s: end (dec_sum=%d pcmBytes=%d)", __func__, (int)dec_sum, (int)*pcmBytes);
++    return LHDCBT_DEC_FUNC_SUCCEED;
++}
++
++
++// description
++//   de-initialize (free) all resources allocated by LHDC v4 decoder
++// Parameter
++//   none
++// return:
++//   == 0: succceed
++int lhdcBT_dec_deinit_decoder(void)
++{
++	ALOGD("[WL50] %s: enter", __func__);
++    lhdcDestroy();
++
++    return LHDCBT_DEC_FUNC_SUCCEED;
++}
++
++// description
++//   check number of frames in one packet and return pointer to first byte of 1st frame in current packet
++// Parameter
++//   input: pointer to input buffer
++//   input_len: length (bytes) of input buffer pointed by input
++//   pLout: pointer to pointer to output buffer
++//   pLlen: length (bytes) of encoded stream in output buffer
++// return:
++//   > 0: number of frames in current packet
++//   == 0: No frames in current packet
++//   < 0: error
++static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len, uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
++{
++    uint8_t hdr = 0, seqno = 0xff;
++    int ret = LHDCBT_DEC_FUNC_FAIL;
++    uint32_t status = 0;
++	uint32_t lhdc_total_frame_nb = 0;
++
++
++    if ((input == NULL) || 
++		(pLout == NULL) || 
++		(pLlen == NULL)) 
++	{
++
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++	
++	if (input_len < 2)
++	{
++		return LHDCBT_DEC_FUNC_FAIL;
++	}
++
++    hdr = (*input);
++    input++;
++    seqno = (*input);
++    input++;
++    input_len -= 2;
++
++    //Check latency and update value when changed.
++    status = hdr & A2DP_LHDC_HDR_LATENCY_MASK;
++
++    //Get number of frame in packet.
++    status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
++
++    ALOGD("[WL50] %s: enter", __func__);
++
++    if (status <= 0)
++    {
++        ALOGD("%s: No any frame in packet.", __func__);
++        return 0;
++    }
++
++
++    lhdc_total_frame_nb = status;
++
++    if (seqno != serial_no)
++    {
++        ALOGD("%s: Packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
++        //serial_no = seqno;
++		//return LHDCBT_DEC_FUNC_INVALID_SEQ_NO;
++    }
++	
++	if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO)
++	{
++        serial_no = seqno + 1;
++	}
++
++    // log average bit rate
++    //sav_lhdc_log_bytes_len(input_len);
++
++    *pLlen = input_len;
++    *pLout = input;
++
++    ret = (int) lhdc_total_frame_nb;
++
++    ALOGD("[WL50] %s: end frame number (%d)", __func__, ret);
++    return ret;
++}
++
+diff --git a/external/liblhdcv5/Android.bp b/external/liblhdcv5/Android.bp
+new file mode 100644
+index 000000000..b8fe3fa60
+--- /dev/null
++++ b/external/liblhdcv5/Android.bp
+@@ -0,0 +1,50 @@
++
++cc_prebuilt_library_shared {
++    name: "liblhdcv5",
++
++    export_include_dirs: ["include"],
++    arch: {
++        arm: {
++            srcs: ["libs/armeabi-v7a/liblhdcv5.so",],
++        },
++        arm64: {
++            srcs: ["libs/arm64-v8a/liblhdcv5.so",],
++        },
++    },
++
++    strip: {
++        none:true,
++    },
++
++    shared_libs: [
++        "liblog",
++        "libstdc++",
++    ],
++}
++
++cc_library_shared {
++    name: "liblhdcv5BT_enc",
++   // vendor_available: true,
++   // vndk: {
++   //     enabled: true,
++   // },
++    arch: {
++        arm: {
++            instruction_set: "arm",
++        },
++    },
++    export_include_dirs: ["inc"],
++    local_include_dirs: ["inc", "include", ],
++    srcs: [
++        "src/lhdcv5BT_enc.c",
++    ],
++    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
++    // unit such as ARM Cortex-R series or external 32-bit DSPs.
++    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
++
++    shared_libs: [
++        "libcutils",
++        "liblog",
++        "liblhdcv5",
++    ],
++}
+diff --git a/external/liblhdcv5/CHANGES b/external/liblhdcv5/CHANGES
+new file mode 100644
+index 000000000..10de496d1
+--- /dev/null
++++ b/external/liblhdcv5/CHANGES
+@@ -0,0 +1,7 @@
++Release Note.
++=========================================================
++Jul 20, 2022, by jimmy.chen@savitech.co
++  Summary for 5.0.5 liblhdcv5 release  
++  
++Feb 21, 2022, by jimmy.chen@savitech.co
++  Summary for 5.0.1 liblhdcv5 release
+\ No newline at end of file
+diff --git a/external/liblhdcv5/LICENSE b/external/liblhdcv5/LICENSE
+new file mode 100644
+index 000000000..261eeb9e9
+--- /dev/null
++++ b/external/liblhdcv5/LICENSE
+@@ -0,0 +1,201 @@
++                                 Apache License
++                           Version 2.0, January 2004
++                        http://www.apache.org/licenses/
++
++   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
++
++   1. Definitions.
++
++      "License" shall mean the terms and conditions for use, reproduction,
++      and distribution as defined by Sections 1 through 9 of this document.
++
++      "Licensor" shall mean the copyright owner or entity authorized by
++      the copyright owner that is granting the License.
++
++      "Legal Entity" shall mean the union of the acting entity and all
++      other entities that control, are controlled by, or are under common
++      control with that entity. For the purposes of this definition,
++      "control" means (i) the power, direct or indirect, to cause the
++      direction or management of such entity, whether by contract or
++      otherwise, or (ii) ownership of fifty percent (50%) or more of the
++      outstanding shares, or (iii) beneficial ownership of such entity.
++
++      "You" (or "Your") shall mean an individual or Legal Entity
++      exercising permissions granted by this License.
++
++      "Source" form shall mean the preferred form for making modifications,
++      including but not limited to software source code, documentation
++      source, and configuration files.
++
++      "Object" form shall mean any form resulting from mechanical
++      transformation or translation of a Source form, including but
++      not limited to compiled object code, generated documentation,
++      and conversions to other media types.
++
++      "Work" shall mean the work of authorship, whether in Source or
++      Object form, made available under the License, as indicated by a
++      copyright notice that is included in or attached to the work
++      (an example is provided in the Appendix below).
++
++      "Derivative Works" shall mean any work, whether in Source or Object
++      form, that is based on (or derived from) the Work and for which the
++      editorial revisions, annotations, elaborations, or other modifications
++      represent, as a whole, an original work of authorship. For the purposes
++      of this License, Derivative Works shall not include works that remain
++      separable from, or merely link (or bind by name) to the interfaces of,
++      the Work and Derivative Works thereof.
++
++      "Contribution" shall mean any work of authorship, including
++      the original version of the Work and any modifications or additions
++      to that Work or Derivative Works thereof, that is intentionally
++      submitted to Licensor for inclusion in the Work by the copyright owner
++      or by an individual or Legal Entity authorized to submit on behalf of
++      the copyright owner. For the purposes of this definition, "submitted"
++      means any form of electronic, verbal, or written communication sent
++      to the Licensor or its representatives, including but not limited to
++      communication on electronic mailing lists, source code control systems,
++      and issue tracking systems that are managed by, or on behalf of, the
++      Licensor for the purpose of discussing and improving the Work, but
++      excluding communication that is conspicuously marked or otherwise
++      designated in writing by the copyright owner as "Not a Contribution."
++
++      "Contributor" shall mean Licensor and any individual or Legal Entity
++      on behalf of whom a Contribution has been received by Licensor and
++      subsequently incorporated within the Work.
++
++   2. Grant of Copyright License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      copyright license to reproduce, prepare Derivative Works of,
++      publicly display, publicly perform, sublicense, and distribute the
++      Work and such Derivative Works in Source or Object form.
++
++   3. Grant of Patent License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      (except as stated in this section) patent license to make, have made,
++      use, offer to sell, sell, import, and otherwise transfer the Work,
++      where such license applies only to those patent claims licensable
++      by such Contributor that are necessarily infringed by their
++      Contribution(s) alone or by combination of their Contribution(s)
++      with the Work to which such Contribution(s) was submitted. If You
++      institute patent litigation against any entity (including a
++      cross-claim or counterclaim in a lawsuit) alleging that the Work
++      or a Contribution incorporated within the Work constitutes direct
++      or contributory patent infringement, then any patent licenses
++      granted to You under this License for that Work shall terminate
++      as of the date such litigation is filed.
++
++   4. Redistribution. You may reproduce and distribute copies of the
++      Work or Derivative Works thereof in any medium, with or without
++      modifications, and in Source or Object form, provided that You
++      meet the following conditions:
++
++      (a) You must give any other recipients of the Work or
++          Derivative Works a copy of this License; and
++
++      (b) You must cause any modified files to carry prominent notices
++          stating that You changed the files; and
++
++      (c) You must retain, in the Source form of any Derivative Works
++          that You distribute, all copyright, patent, trademark, and
++          attribution notices from the Source form of the Work,
++          excluding those notices that do not pertain to any part of
++          the Derivative Works; and
++
++      (d) If the Work includes a "NOTICE" text file as part of its
++          distribution, then any Derivative Works that You distribute must
++          include a readable copy of the attribution notices contained
++          within such NOTICE file, excluding those notices that do not
++          pertain to any part of the Derivative Works, in at least one
++          of the following places: within a NOTICE text file distributed
++          as part of the Derivative Works; within the Source form or
++          documentation, if provided along with the Derivative Works; or,
++          within a display generated by the Derivative Works, if and
++          wherever such third-party notices normally appear. The contents
++          of the NOTICE file are for informational purposes only and
++          do not modify the License. You may add Your own attribution
++          notices within Derivative Works that You distribute, alongside
++          or as an addendum to the NOTICE text from the Work, provided
++          that such additional attribution notices cannot be construed
++          as modifying the License.
++
++      You may add Your own copyright statement to Your modifications and
++      may provide additional or different license terms and conditions
++      for use, reproduction, or distribution of Your modifications, or
++      for any such Derivative Works as a whole, provided Your use,
++      reproduction, and distribution of the Work otherwise complies with
++      the conditions stated in this License.
++
++   5. Submission of Contributions. Unless You explicitly state otherwise,
++      any Contribution intentionally submitted for inclusion in the Work
++      by You to the Licensor shall be under the terms and conditions of
++      this License, without any additional terms or conditions.
++      Notwithstanding the above, nothing herein shall supersede or modify
++      the terms of any separate license agreement you may have executed
++      with Licensor regarding such Contributions.
++
++   6. Trademarks. This License does not grant permission to use the trade
++      names, trademarks, service marks, or product names of the Licensor,
++      except as required for reasonable and customary use in describing the
++      origin of the Work and reproducing the content of the NOTICE file.
++
++   7. Disclaimer of Warranty. Unless required by applicable law or
++      agreed to in writing, Licensor provides the Work (and each
++      Contributor provides its Contributions) on an "AS IS" BASIS,
++      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++      implied, including, without limitation, any warranties or conditions
++      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
++      PARTICULAR PURPOSE. You are solely responsible for determining the
++      appropriateness of using or redistributing the Work and assume any
++      risks associated with Your exercise of permissions under this License.
++
++   8. Limitation of Liability. In no event and under no legal theory,
++      whether in tort (including negligence), contract, or otherwise,
++      unless required by applicable law (such as deliberate and grossly
++      negligent acts) or agreed to in writing, shall any Contributor be
++      liable to You for damages, including any direct, indirect, special,
++      incidental, or consequential damages of any character arising as a
++      result of this License or out of the use or inability to use the
++      Work (including but not limited to damages for loss of goodwill,
++      work stoppage, computer failure or malfunction, or any and all
++      other commercial damages or losses), even if such Contributor
++      has been advised of the possibility of such damages.
++
++   9. Accepting Warranty or Additional Liability. While redistributing
++      the Work or Derivative Works thereof, You may choose to offer,
++      and charge a fee for, acceptance of support, warranty, indemnity,
++      or other liability obligations and/or rights consistent with this
++      License. However, in accepting such obligations, You may act only
++      on Your own behalf and on Your sole responsibility, not on behalf
++      of any other Contributor, and only if You agree to indemnify,
++      defend, and hold each Contributor harmless for any liability
++      incurred by, or claims asserted against, such Contributor by reason
++      of your accepting any such warranty or additional liability.
++
++   END OF TERMS AND CONDITIONS
++
++   APPENDIX: How to apply the Apache License to your work.
++
++      To apply the Apache License to your work, attach the following
++      boilerplate notice, with the fields enclosed by brackets "[]"
++      replaced with your own identifying information. (Don't include
++      the brackets!)  The text should be enclosed in the appropriate
++      comment syntax for the file format. We also recommend that a
++      file or class name and description of purpose be included on the
++      same "printed page" as the copyright notice for easier
++      identification within third-party archives.
++
++   Copyright [yyyy] [name of copyright owner]
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
+diff --git a/external/liblhdcv5/MODULE_LICENSE_APACHE2 b/external/liblhdcv5/MODULE_LICENSE_APACHE2
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcv5/NOTICE b/external/liblhdcv5/NOTICE
+new file mode 100644
+index 000000000..ea044d3be
+--- /dev/null
++++ b/external/liblhdcv5/NOTICE
+@@ -0,0 +1,27 @@
++/******************************************************************************
++ *
++ * Copyright (C) 2015 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at:
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ *
++ *****************************************************************************
++ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
++ */
++
++---------------
++ Certification
++---------------
++   Taking the certification process is required to use LHDC in your products.
++   For the detail of certification process, see the following URL:
++      https://www.savitech.co/
++
+diff --git a/external/liblhdcv5/inc/lhdcv5BT.h b/external/liblhdcv5/inc/lhdcv5BT.h
+new file mode 100644
+index 000000000..c955b3bcc
+--- /dev/null
++++ b/external/liblhdcv5/inc/lhdcv5BT.h
+@@ -0,0 +1,127 @@
++#ifndef _LHDCV5BT_H_
++#define _LHDCV5BT_H_
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#include "lhdcv5_api.h"
++
++int32_t lhdcv5BT_free_handle 
++(
++    HANDLE_LHDCV5_BT	handle
++);
++
++int32_t lhdcv5BT_get_handle 
++(
++    uint32_t			version,
++    HANDLE_LHDCV5_BT	*handle
++);
++
++int32_t lhdcv5BT_get_bitrate
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			* bitrate
++);
++
++int32_t lhdcv5BT_set_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			bitrate_inx
++);
++
++int32_t lhdcv5BT_set_max_bitrate
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			max_bitrate_inx
++);
++
++int32_t lhdcv5BT_set_min_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			min_bitrate_inx
++);
++
++int32_t lhdcv5BT_adjust_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			queueLen
++);
++
++int32_t lhdcv5BT_set_ext_func_state
++(
++    HANDLE_LHDCV5_BT 	handle,
++    LHDCV5_EXT_FUNC_T	field,
++    bool 				enabled,
++    void 				* priv,
++    uint32_t 			priv_data_len
++);
++
++int32_t lhdcv5BT_init_encoder
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t 			sampling_freq,
++    uint32_t 			bits_per_sample,
++    uint32_t 			bitrate_inx,
++    uint32_t 			mtu,
++    uint32_t 			interval
++) ;
++
++int32_t lhdcv5BT_get_block_Size
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			* samples_per_frame
++);
++
++int32_t lhdcv5BT_encode
++(
++    HANDLE_LHDCV5_BT 	handle,
++    void				* p_in_pcm,
++    uint32_t			pcm_bytes,
++    uint8_t				* p_out_buf,
++    uint32_t			out_buf_bytes,
++    uint32_t 			* p_out_bytes,
++    uint32_t 			* p_out_frames
++);
++
++//
++// LHDCV5 Extended APIs
++//
++// Extended API -- Get Version
++int lhdcv5BT_get_user_exApiver
++(
++    HANDLE_LHDCV5_BT handle,
++    char *userConfig,
++    int clen
++);
++
++// Extended API -- Get User Config
++int lhdcv5BT_get_user_exconfig
++(
++    HANDLE_LHDCV5_BT handle,
++    char* userConfig,
++    int clen
++);
++
++// Extended API -- Set User Config
++int lhdcv5BT_set_user_exconfig
++(
++    HANDLE_LHDCV5_BT handle,
++    const char* userConfig,
++    const int clen
++);
++
++// Extended API -- Set User Data
++void lhdcv5BT_set_user_exdata
++(
++    HANDLE_LHDCV5_BT handle,
++    const char* userConfig,
++    const int clen
++);
++
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* _LHDCV5BT_H_ */
+diff --git a/external/liblhdcv5/include/lhdcv5BT_ext_func.h b/external/liblhdcv5/include/lhdcv5BT_ext_func.h
+new file mode 100644
+index 000000000..f8612162a
+--- /dev/null
++++ b/external/liblhdcv5/include/lhdcv5BT_ext_func.h
+@@ -0,0 +1,188 @@
++
++
++#ifndef _LHDCBT_EXT_FUNC_H_
++#define _LHDCBT_EXT_FUNC_H_
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++
++#define EXTEND_FUNC_RET_OK                      ((int) 0)
++#define EXTEND_FUNC_RET_INVALID_HANDLE          ((int) 0xE01)
++#define EXTEND_FUNC_RET_INVALID_PARAMETER       ((int) 0xE02)
++#define EXTEND_FUNC_RET_FUNC_NOT_SUPPORT        ((int) 0xE03)
++#define EXTEND_FUNC_RET_VERSION_NOT_SUPPORT     ((int) 0xE04)
++#define EXTEND_FUNC_RET_BUF_UNDERRUN            ((int) 0xE05)
++#define EXTEND_FUNC_RET_ERROR                   ((int) 0xE06)
++#define EXTEND_FUNC_RET_NOT_READY               ((int) 0xE07)
++#define EXTEND_FUNC_RET_REQ_BUFSIZE_NOT_MATCH   ((int) 0xE08)
++
++
++/* **********************************************
++ *  API: Version Control
++ * ***********************************************/
++#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V1               ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_GENERIC_VERSION_NUMBER_V2               ((unsigned int) 0x02000000)
++#define EXTEND_FUNC_MIN_BUFFER_LEN                          (8)
++
++/* **********************************************
++ *  LIB API: Config Type
++ * ***********************************************/
++/* * * * * * * * * * * * * * * *
++ *   META                      *
++ * * * * * * * * * * * * * * * */
++//   META :: API Code
++#define EXTEND_FUNC_CODE_SET_CONFIG_META        ((unsigned int) 0x0C000001)
++#define EXTEND_FUNC_CODE_GET_CONFIG_META        ((unsigned int) 0x0C010001)
++//   META :: API Version
++#define EXTEND_FUNC_VER_SET_CONFIG_META_V1      ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_SET_CONFIG_META_V2      ((unsigned int) 0x02000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_META_V1      ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_META_V2      ((unsigned int) 0x02000000)
++//   META :: API Min Required Buffer Size
++#define EXTEND_FUNC_VER_SET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
++#define EXTEND_FUNC_VER_GET_CONFIG_META_REQ_BUFSIZE_V2      16  //TBD
++
++/* * * * * * * * * * * * * * * *
++ *   AR                        *
++ * * * * * * * * * * * * * * * */
++//   AR :: API Code
++#define EXTEND_FUNC_CODE_SET_CONFIG_AR          ((unsigned int) 0x0C000002)
++#define EXTEND_FUNC_CODE_GET_CONFIG_AR          ((unsigned int) 0x0C010002)
++//   AR :: API Version
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_V3        ((unsigned int) 0x03000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_AR_V1        ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_GET_CONFIG_AR_V2        ((unsigned int) 0x02000000)
++//   AR :: API Min Required Buffer Size
++#define EXTEND_FUNC_VER_SET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
++#define EXTEND_FUNC_VER_GET_CONFIG_AR_REQ_BUFSIZE_V2      16    //TBD
++
++
++/* **********************************************
++ *  LIB API: Data Type
++ * ***********************************************/
++/* * * * * * * * * * * * * * * *
++ *   GYRO2D                    *
++ * * * * * * * * * * * * * * * */
++//   GYRO2D :: API Code
++#define EXTEND_FUNC_CODE_SET_DATA_GYRO2D        ((unsigned int) 0x0D000001)
++//   GYRO2D :: API Version
++#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1      ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_V2      ((unsigned int) 0x02000000)
++//   GYRO2D :: API Min Required Buffer Size
++#define EXTEND_FUNC_VER_SET_DATA_GYRO2D_REQ_BUFSIZE_V2      16    //TBD (8 + 2gyro + 6pad)
++
++
++/* * * * * * * * * * * * * * * *
++ *   GetA2DPSpecifis           *
++ * * * * * * * * * * * * * * * */
++//   GetA2DPSpecifis :: API Code
++#define EXTEND_FUNC_CODE_GET_SPECIFIC           ((unsigned int) 0x0A010001)
++//   GetA2DPSpecifis :: API Version
++#define EXTEND_FUNC_VER_GET_SPECIFIC_V2         ((unsigned int) 0x02000000)
++
++//
++// META
++//
++#define META_ST_VER_V1                           ((unsigned int) 0x00010000)
++#define META_ST_VER_V2                           ((unsigned int) 0x00020000)
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_SET_META {
++
++  unsigned char     header[8];
++  unsigned int      meta_ver;
++  unsigned char     meta_mem_size;
++  unsigned char     meta_enable;
++  unsigned char     meta_set;
++  unsigned char     meta_metadata_length;
++  //  unsigned char     meta_metadata[64];
++
++} ST_LHDC_SET_META, *PST_LHDC_SET_META;
++#pragma pack(pop)
++
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_GET_META {
++
++  unsigned char     header[8];
++  unsigned int      meta_ver;
++  unsigned char     meta_mem_size;
++  unsigned char     meta_st;     // [0] 1: reserved bit, [1] 1: in meta mode/0: not in meta mode
++  unsigned char     jas_status;
++
++} ST_LHDC_GET_META, *PST_LHDC_GET_META;
++#pragma pack(pop)
++
++//
++// AR
++//
++
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_AR
++{
++  unsigned char     header[8];
++  unsigned int      ver;
++  unsigned int      size;
++  unsigned int      app_ar_enabled;
++  int Ch1_Pos;
++  int Ch2_Pos;
++  int Ch3_Pos;
++  int Ch4_Pos;
++  int Ch5_Pos;
++  int Ch6_Pos;
++  float Ch1_L_PreGain;
++  float Ch1_R_PreGain;
++  float Ch2_L_PreGain;
++  float Ch2_R_PreGain;
++  float Ch3_L_PreGain;
++  float Ch3_R_PreGain;
++  float Ch4_L_PreGain;
++  float Ch4_R_PreGain;
++  float Ch5_L_PreGain;
++  float Ch5_R_PreGain;
++  float Ch6_L_PreGain;
++  float Ch6_R_PreGain;
++  float Ch1_PostGain;
++  float Ch2_PostGain;
++  float Ch3_PostGain;
++  float Ch4_PostGain;
++  float Ch5_PostGain;
++  float Ch6_PostGain;
++  float Dry_Val;
++  float Wet_Val;
++  float Dis_1;
++  float Dis_2;
++  float Dis_3;
++  float Dis_4;
++  float Dis_5;
++  float Rev_1;
++  float Rev_2;
++  float Rev_3;
++  float Rev_4;
++  float Rev_5;
++  float Rev_gain;
++  float ThreeD_gain;
++} ST_LHDC_AR, *PST_LHDC_AR;
++#pragma pack(pop)
++
++#pragma pack (push)
++#pragma pack (1)
++typedef struct __ST_LHDC_AR_GYRO
++{
++  unsigned char     header[8];
++  int world_coordinate_x;
++  int world_coordinate_y;
++  int world_coordinate_z;
++
++} ST_LHDC_AR_GYRO, *PST_LHDC_AR_GYRO;
++#pragma pack(pop)
++
++
++#ifdef __cplusplus
++}
++#endif
++#endif /* _LHDCBT_EXT_FUNC_H_ */
+diff --git a/external/liblhdcv5/include/lhdcv5_api.h b/external/liblhdcv5/include/lhdcv5_api.h
+new file mode 100644
+index 000000000..860e4e04b
+--- /dev/null
++++ b/external/liblhdcv5/include/lhdcv5_api.h
+@@ -0,0 +1,322 @@
++#ifndef __LHDCV5_API_H__
++#define __LHDCV5_API_H__
++
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++
++typedef enum __LHDCV5_SAMPLE_FREQ__
++{
++  LHDCV5_SR_44100HZ  =  44100,
++  LHDCV5_SR_48000HZ  =  48000,
++  LHDCV5_SR_96000HZ  =  96000,
++  LHDCV5_SR_192000HZ = 192000,
++} LHDCV5BT_SAMPLE_FREQ_T;
++
++
++typedef enum __LHDCV5BT_SMPL_FMT__
++{
++  LHDCV5BT_SMPL_FMT_S16 = 16,
++  LHDCV5BT_SMPL_FMT_S24 = 24,
++  LHDCV5BT_SMPL_FMT_S32 = 32,
++} LHDCV5BT_SMPL_FMT_T;
++
++
++typedef enum __LHDCV5_SAMPLE_FRAME__
++{
++  LHDCV5_SAMPLE_FRAME_5MS_44100KHZ  = 240,
++  LHDCV5_SAMPLE_FRAME_5MS_48000KHZ  = 240,
++  LHDCV5_SAMPLE_FRAME_5MS_96000KHZ  = 480,
++  LHDCV5_SAMPLE_FRAME_5MS_192000KHZ = 960,
++  LHDCV5_MAX_SAMPLE_FRAME = 960,
++} LHDCV5_SAMPLE_FRAME_T;
++
++
++typedef enum __LHDCV5_FRAME_DURATION__
++{
++  LHDCV5_FRAME_5MS   = 50,
++  LHDCV5_FRAME_7P5MS = 75,
++  LHDCV5_FRAME_10MS  = 100,
++  LHDCV5_FRAME_1S    = 10000,
++} LHDCV5_FRAME_DURATION_T;
++
++
++typedef enum __LHDCV5_ENC_INTERVAL__
++{
++  LHDCV5_ENC_INTERVAL_10MS = 10,
++  LHDCV5_ENC_INTERVAL_20MS = 20,
++} LHDCV5_ENC_INTERVAL_T;
++
++
++typedef enum __LHDCV5_QUALITY__
++{
++  LHDCV5_QUALITY_LOW0 = 0,
++  LHDCV5_QUALITY_LOW1,
++  LHDCV5_QUALITY_LOW2,
++  LHDCV5_QUALITY_LOW3,
++  LHDCV5_QUALITY_LOW4,
++  LHDCV5_QUALITY_LOW,
++  LHDCV5_QUALITY_MID,
++  LHDCV5_QUALITY_HIGH,
++  LHDCV5_QUALITY_HIGH1,
++  LHDCV5_QUALITY_AUTO,
++  LHDCV5_QUALITY_RESET_AUTO,
++  LHDCV5_QUALITY_INVALID
++} LHDCV5_QUALITY_T;
++
++
++typedef enum __LHDCV5_MTU_SIZE__
++{
++  LHDCV5_MTU_MIN   = 300,
++  LHDCV5_MTU_2MBPS = 660,
++  LHDCV5_MTU_MAX   = 1023,
++} LHDCV5_MTU_SIZE_T;
++
++
++typedef enum __LHDCV5_VERSION__
++{
++  LHDCV5_VERSION_1 = 1,
++  LHDCV5_VERSION_INVALID
++} LHDCV5_VERSION_T;
++
++
++typedef enum __LHDCV5_ENC_TYPE__ 
++{
++  LHDCV5_ENC_TYPE_UNKNOWN = 0,
++  LHDCV5_ENC_TYPE_LHDCV5,
++  LHDCV5_ENC_TYPE_INVALID
++} LHDCV5_ENC_TYPE_T;
++
++
++typedef enum __LHDCV5_EXT_FUNC__
++{
++  LHDCV5_EXT_FUNC_AR = 0,
++  LHDCV5_EXT_FUNC_LARC,
++  LHDCV5_EXT_FUNC_JAS,
++  LHDCV5_EXT_FUNC_META,
++  LHDCV5_EXT_FUNC_INVALID
++} LHDCV5_EXT_FUNC_T;
++
++
++typedef enum __LHDCV5_META_PARAM__
++{
++  LHDCV5_META_LOOP_CNT_MAX = 100,
++  LHDCV5_META_LOOP_CNT_STD = 20,
++  LHDCV5_META_LEN_FIXED = 8,
++  LHDCV5_META_LEN_MAX = 128
++} LHDCV5_META_PARAM_T;
++
++
++typedef enum __LHDCV5_ABR_TYPE__ 
++{
++  LHDCV5_ABR_44K_RES = 0,
++  LHDCV5_ABR_48K_RES,
++  LHDCV5_ABR_96K_RES,
++  LHDCV5_ABR_192K_RES,
++  LHDCV5_ABR_INVALID
++} LHDCV5_ABR_TYPE_T;
++
++
++typedef struct _lhdcv5_abr_para_t 
++{
++  uint32_t	version;			// version of LHDC 5.0 CODEC
++  uint32_t	sample_rate;		// sample rate (Hz)
++  uint32_t 	bits_per_sample;	// bits per sample (bit)
++  uint32_t 	bits_per_sample_ui;	// bits per sample (bit) (from UI)
++
++  uint32_t 	upBitrateCnt;		// (ABR) up bitrate check parameter
++  uint32_t 	upBitrateSum;		// (ABR) up bitrate check parameter
++
++  uint32_t 	dnBitrateCnt;		// (ABR) down bitrate check parameter
++  uint32_t 	dnBitrateSum;		// (ABR) down bitrate check parameter
++
++  uint32_t 	lastBitrate;     	// Last bit rate (kbps) set for LHDC 5.0 encoder
++  uint32_t 	qualityStatus;      // current bit rate (index) (LOW0 ~ AUTO) is same as UI setting
++
++  //----------------------------------// Above is shared ABR parameters
++
++} lhdcv5_abr_para_t;
++
++
++
++typedef void * HANDLE_LHDCV5_BT;
++
++
++
++/*
++ ******************************************************************
++ LHDC v5 common utilities functions group
++ ******************************************************************
++ */
++
++extern int32_t lhdcv5_util_free_handle 
++(
++    HANDLE_LHDCV5_BT	handle
++);
++
++extern int32_t lhdcv5_util_get_mem_req 
++(
++    uint32_t			version,
++    uint32_t			* mem_req_bytes
++);
++
++extern int32_t lhdcv5_util_get_handle 
++(
++    uint32_t			version,
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t            mem_size
++);
++
++extern int32_t lhdcv5_util_get_target_bitrate
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			* bitrate
++);
++
++extern int32_t lhdcv5_util_set_target_bitrate_inx
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t 			bitrate_inx,
++    uint32_t			* bitrate_inx_set,
++    bool				upd_qual_status
++);
++
++extern int32_t lhdcv5_util_set_max_bitrate_inx
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			max_bitrate_inx,
++    uint32_t			* max_bitrate_inx_set
++);
++
++extern int32_t lhdcv5_util_set_min_bitrate_inx
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			min_bitrate_inx,
++    uint32_t			* min_bitrate_inx_set
++);
++
++extern int32_t lhdcv5_util_adjust_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    LHDCV5_ENC_TYPE_T	* enc_type_ptr,
++    lhdcv5_abr_para_t	** abr_para_ptr
++);
++
++extern int32_t lhdcv5_util_reset_up_bitrate
++(
++    lhdcv5_abr_para_t	* handle
++);
++
++extern int32_t lhdcv5_util_reset_down_bitrate
++(
++    lhdcv5_abr_para_t 	* handle
++);
++
++extern int32_t lhdcv5_util_get_ext_func_state
++(
++    HANDLE_LHDCV5_BT 	handle,
++    LHDCV5_EXT_FUNC_T 	ext_type,
++    bool				* enable_ptr
++);
++
++extern int32_t lhdcv5_util_set_ext_func_state
++(
++    HANDLE_LHDCV5_BT 	handle,
++    LHDCV5_EXT_FUNC_T 	ext_type,
++    bool 				func_enable,
++    uint8_t				* data_ptr,
++    uint32_t			data_len,
++    uint32_t			loop_cnt
++);
++
++extern int32_t lhdcv5_util_init_encoder
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t 			sampling_freq,
++    uint32_t 			bits_per_sample,
++    uint32_t 			bitrate_inx,
++    uint32_t 			frame_duration,
++    uint32_t 			mtu,
++    uint32_t 			interval
++);
++
++extern int32_t lhdcv5_util_get_block_Size
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			* block_size
++);
++
++extern int32_t lhdcv5_util_enc_process
++(
++    HANDLE_LHDCV5_BT 	handle,
++    void				* p_pcm,
++    uint32_t			pcm_bytes,
++    uint8_t				* out_put,
++    uint32_t			out_buf_bytes,
++    uint32_t 			* written,
++    uint32_t 			* out_frames
++);
++
++extern int32_t lhdcv5_util_get_bitrate
++(
++    uint32_t	bitrate_inx,
++    uint32_t	* bitrate
++);
++
++extern int32_t lhdcv5_util_get_bitrate_inx
++(
++    uint32_t	bitrate,
++    uint32_t	* bitrate_inx
++);
++
++extern int32_t lhdcv5_util_ar_set_gyro_pos 
++(
++    HANDLE_LHDCV5_BT 	handle,
++    int32_t 			world_coordinate_x,
++    int32_t 			world_coordinate_y,
++    int32_t				world_coordinate_z
++);
++
++extern int32_t lhdcv5_util_ar_set_cfg
++(
++    HANDLE_LHDCV5_BT 	handle,
++    int32_t 			* pos_ptr,
++    uint32_t			pos_item_num,
++    float 				* gain_ptr,
++    uint32_t			gain_item_num,
++    uint32_t	 		app_ar_enabled
++);
++
++extern int32_t lhdcv5_util_ar_get_cfg 
++(
++    HANDLE_LHDCV5_BT 	handle,
++    int32_t 			* pos_ptr,
++    uint32_t			pos_item_num,
++    float 				* gain_ptr,
++    uint32_t			gain_item_num
++);
++
++
++typedef enum __LHDCV5_FUNC_RET__
++{
++  LHDCV5_FRET_SUCCESS 				=	  0,
++  LHDCV5_FRET_INVALID_INPUT_PARAM		=	 -1,
++  LHDCV5_FRET_INVALID_HANDLE_CB		=	 -2,
++  LHDCV5_FRET_INVALID_HANDLE_PARA		=	 -3,
++  LHDCV5_FRET_INVALID_HANDLE_ENC		=	 -4,
++  LHDCV5_FRET_INVALID_HANDLE_CBUF		=	 -5,
++  LHDCV5_FRET_INVALID_HANDLE_AR		=	 -6,
++  LHDCV5_FRET_INVALID_CODEC			=	 -7,
++  LHDCV5_FRET_CODEC_NOT_READY			=	 -8,
++  LHDCV5_FRET_AR_NOT_READY			=	 -9,
++  LHDCV5_FRET_ERROR					=	-10,
++  LHDCV5_FRET_BUF_NOT_ENOUGH			=	-11,
++} LHDCV5_FUNC_RET_T;
++
++
++#ifdef __cplusplus
++}
++#endif
++#endif //End of __LHDCV5_API_H__
+diff --git a/external/liblhdcv5/libs/arm64-v8a/.gitkeep b/external/liblhdcv5/libs/arm64-v8a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcv5/libs/armeabi-v7a/.gitkeep b/external/liblhdcv5/libs/armeabi-v7a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcv5/src/lhdcv5BT_enc.c b/external/liblhdcv5/src/lhdcv5BT_enc.c
+new file mode 100644
+index 000000000..7719fbe7c
+--- /dev/null
++++ b/external/liblhdcv5/src/lhdcv5BT_enc.c
+@@ -0,0 +1,1779 @@
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdint.h>
++#include <stdbool.h>
++#include "lhdcv5BT.h"
++#include "lhdcv5BT_ext_func.h"
++
++#define LOG_TAG "lhdcv5BT_enc"
++#include <cutils/log.h>
++
++#define UP_RATE_TIME_CNT         			3000    // ABR bitrate upgrade checking time interval(ms): (UP_RATE_TIME_CNT * 20ms)
++#define DOWN_RATE_TIME_CNT       			4  		  // ABR bitrate downgrade checking time interval(ms): (DOWN_RATE_TIME_CNT * 20ms)
++#define ABR_UP_QUEUE_LENGTH_THRESHOLD     1   // A threshold of ABR bitrate upgrade check
++#define ABR_DOWN_QUEUE_LENGTH_THRESHOLD   0   // A threshold of ABR bitrate downgrade check
++
++// ABR: bit rate adjustment tables
++//static uint32_t auto_bitrate_adjust_table_lhdcv5_std[] = {128, 192, 256, 320, 400, 600};
++//static uint32_t auto_bitrate_adjust_table_lhdcv5_hi[] = {256, 320, 400, 600, 600, 600};
++//static uint32_t auto_bitrate_adjust_table_lhdcv5_std[] = {128, 192, 256, 320, 400, 400};
++//static uint32_t auto_bitrate_adjust_table_lhdcv5_hi[] = {256, 320, 400, 400, 400, 400};
++static uint32_t auto_bitrate_adjust_table_lhdcv5_44k[] = {128, 192, 240, 320, 400, 400};
++static uint32_t auto_bitrate_adjust_table_lhdcv5_48k[] = {128, 192, 256, 320, 400, 400};
++static uint32_t auto_bitrate_adjust_table_lhdcv5_96k[] = {256, 320, 400, 400, 400, 400};
++static uint32_t auto_bitrate_adjust_table_lhdcv5_192k[] = {256, 320, 400, 400, 400, 400};
++
++//#define LHDCV5_STD_BITRATE_ELEMENTS_SIZE	(sizeof(auto_bitrate_adjust_table_lhdcv5_std) / sizeof(uint32_t))
++//#define LHDCV5_HI_BITRATE_ELEMENTS_SIZE		(sizeof(auto_bitrate_adjust_table_lhdcv5_hi) / sizeof(uint32_t))
++#define LHDCV5_44K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_44k) / sizeof(uint32_t))
++#define LHDCV5_48K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_48k) / sizeof(uint32_t))
++#define LHDCV5_96K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_96k) / sizeof(uint32_t))
++#define LHDCV5_192K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_192k) / sizeof(uint32_t))
++
++#define LHDCV5_ABR_DEFAULT_BITRATE     (LHDCV5_QUALITY_LOW)
++
++
++static const char * rate_to_string
++(
++    LHDCV5_QUALITY_T	q
++)
++{
++  switch (q)
++  {
++  case LHDCV5_QUALITY_LOW0:
++    return "LHDCV5_QUALITY_LOW0";
++  case LHDCV5_QUALITY_LOW1:
++    return "LHDCV5_QUALITY_LOW1";
++  case LHDCV5_QUALITY_LOW2:
++    return "LHDCV5_QUALITY_LOW2";
++  case LHDCV5_QUALITY_LOW3:
++    return "LHDCV5_QUALITY_LOW3";
++  case LHDCV5_QUALITY_LOW4:
++    return "LHDCV5_QUALITY_LOW4";
++  case LHDCV5_QUALITY_LOW:
++    return "LHDCV5_QUALITY_LOW";
++  case LHDCV5_QUALITY_MID:
++    return "LHDCV5_QUALITY_MID";
++  case LHDCV5_QUALITY_HIGH:
++    return "LHDCV5_QUALITY_HIGH";
++  case LHDCV5_QUALITY_HIGH1:
++    return "LHDCV5_QUALITY_HIGH1";
++  case LHDCV5_QUALITY_AUTO:
++    return "LHDCV5_QUALITY_AUTO";
++  default:
++    ALOGW ("%s: Incorrect quality(%d)",  __func__, q);
++    return "UNKNOW_QUALITY";
++  }
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5_encoder_inx_of_abr_bitrate ()
++//
++// return the bit rate (index) respond to input bit rate (kbps)
++//	Parameter
++//		abr_type: ABR type
++//		bitrate: bit rate (kbps)
++//		bitrate_inx: ABR bit rate (index) returned
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to return the bit rate (index)
++//		otherwise: fail to return the bit rate (index)
++//----------------------------------------------------------------
++static int lhdcv5_encoder_inx_of_abr_bitrate
++(
++    LHDCV5_ABR_TYPE_T abr_type,
++    uint32_t  bitrate,
++    uint32_t  *bitrate_inx
++)
++{
++  uint32_t element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
++  uint32_t *abr_table = NULL;
++
++  if (bitrate_inx == NULL)
++  {
++    ALOGW ("%s: Input parameter is NULL!!!", __func__);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  if (abr_type == LHDCV5_ABR_44K_RES)
++  {
++    element_size = LHDCV5_44K_BITRATE_ELEMENTS_SIZE;
++
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_44k[0]);
++  }
++  else if (abr_type == LHDCV5_ABR_48K_RES)
++  {
++    element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
++
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
++  }
++  else if (abr_type == LHDCV5_ABR_96K_RES)
++  {
++    element_size = LHDCV5_96K_BITRATE_ELEMENTS_SIZE;
++
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_96k[0]);
++  }
++  else if (abr_type == LHDCV5_ABR_192K_RES)
++  {
++    element_size = LHDCV5_192K_BITRATE_ELEMENTS_SIZE;
++
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_192k[0]);
++  }
++  else
++  {
++    ALOGW ("%s: Invalid ABR type (%d)!", __func__, abr_type);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  if ((bitrate <= 0) || (bitrate > abr_table[element_size - 1]))
++  {
++    ALOGW ("%s: bit rate is out of range (%d)!!!", __func__, bitrate);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++
++  for (uint32_t i = 0; i < element_size; i++)
++  {
++    if (abr_table[i] >= bitrate)
++    {
++      *bitrate_inx = i;
++      return LHDCV5_FRET_SUCCESS;
++    }
++  }
++
++  ALOGW ("%s: Fail to find bit rate (index) (%d)!", __func__, bitrate);
++  return LHDCV5_FRET_ERROR;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5_encoder_adjust_bitrate ()
++//
++// Adjust bit rate automatically according to number of packets in queue for LHDC 5.0 encoding
++//	Parameter
++//		lhdcBT: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		handle: a pointer to ABR parameters
++//		queueLen: number of packets in queue
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to adjust bit rate automatically 
++//		otherwise: fail to adjust bit rate automatically 
++//----------------------------------------------------------------
++static int lhdcv5_encoder_adjust_bitrate
++(
++    HANDLE_LHDCV5_BT  lhdcBT,
++    lhdcv5_abr_para_t *handle,
++    uint32_t  queueLen
++) 
++{
++  uint32_t element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
++  uint32_t new_abr_bitrate_inx = 0;
++  uint32_t new_bitrate_inx = 0;
++  uint32_t new_bitrate_inx_set = 0;
++  uint32_t last_bitrate_inx = 0;
++  uint32_t *abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
++  LHDCV5_ABR_TYPE_T	abr_type = LHDCV5_ABR_48K_RES;
++  int32_t func_ret = LHDCV5_FRET_SUCCESS;
++  uint32_t queueLength = 0;
++
++  if (lhdcBT == NULL)
++  {
++    ALOGW ("%s: lhdcBT is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_PARA;
++  }
++
++  if (handle->qualityStatus != LHDCV5_QUALITY_AUTO)
++  {
++    ALOGW ("%s: Not ABR (%d)", __func__, handle->qualityStatus);
++    return LHDCV5_FRET_SUCCESS;
++  }
++
++  if (queueLen < 0)
++  {
++    ALOGW ("%s: Invalid queue length (%u)!", __func__, queueLen);
++    return LHDCV5_FRET_INVALID_HANDLE_PARA;
++  }
++
++  if (handle->sample_rate == LHDCV5_SR_44100HZ)
++  {
++    abr_type = LHDCV5_ABR_44K_RES;
++    element_size = LHDCV5_44K_BITRATE_ELEMENTS_SIZE;
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_44k[0]);
++  }
++  else if (handle->sample_rate == LHDCV5_SR_48000HZ)
++  {
++    abr_type = LHDCV5_ABR_48K_RES;
++    element_size = LHDCV5_48K_BITRATE_ELEMENTS_SIZE;
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_48k[0]);
++  }
++  else if (handle->sample_rate == LHDCV5_SR_96000HZ)
++  {
++    abr_type = LHDCV5_ABR_96K_RES;
++    element_size = LHDCV5_96K_BITRATE_ELEMENTS_SIZE;
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_96k[0]);
++  }
++  else if (handle->sample_rate == LHDCV5_SR_192000HZ)
++  {
++    abr_type = LHDCV5_ABR_192K_RES;
++    element_size = LHDCV5_192K_BITRATE_ELEMENTS_SIZE;
++    abr_table = &(auto_bitrate_adjust_table_lhdcv5_192k[0]);
++  }
++  else
++  {
++    ALOGW ("%s: Sample rate is invalid (%u)!", __func__, handle->sample_rate);
++    return LHDCV5_FRET_CODEC_NOT_READY;
++  }
++
++  if (handle->dnBitrateCnt > 0 && handle->dnBitrateCnt >= DOWN_RATE_TIME_CNT)
++  {
++    queueLength = handle->dnBitrateSum / handle->dnBitrateCnt;
++
++    //handle->dnBitrateSum = 0;
++    //handle->dnBitrateCnt = 0;
++    func_ret = lhdcv5_util_reset_down_bitrate (handle);
++    if (func_ret != LHDCV5_FRET_SUCCESS)
++    {
++      ALOGW ("%s:(DN) lhdcv5_util_reset_down_bitrate error %d",  __func__, func_ret);
++      goto fail;
++    }
++
++    if (queueLength > ABR_DOWN_QUEUE_LENGTH_THRESHOLD)
++    {
++      ALOGD ("%s:(DN) dnBitrateSum:%u / dnBitrateCnt:%u = queueLength:%u", __func__,
++          handle->dnBitrateSum, handle->dnBitrateCnt, queueLength);
++
++      new_abr_bitrate_inx = 0;
++      func_ret = lhdcv5_util_get_bitrate_inx (abr_table[new_abr_bitrate_inx], &new_bitrate_inx);
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("%s:(DN) lhdcv5_util_get_bitrate_inx error %d",  __func__, func_ret);
++        goto fail;
++      }
++
++      func_ret = lhdcv5_util_get_bitrate_inx (handle->lastBitrate, &last_bitrate_inx);
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("%s:(DN) lhdcv5_util_get_bitrate_inx error %d",  __func__, func_ret);
++        goto fail;
++      }
++
++      if (new_bitrate_inx < last_bitrate_inx)
++      {
++        func_ret = lhdcv5_util_set_target_bitrate_inx (lhdcBT, new_bitrate_inx, &new_bitrate_inx_set, false);
++        if (func_ret != LHDCV5_FRET_SUCCESS)
++        {
++          ALOGW ("%s:(DN) lhdcv5_util_set_target_bitrate_inx error %d", __func__, func_ret);
++          goto fail;
++        }
++
++        ALOGD ("%s:(DN) [AutoBiTrAtE] Down bitrate[%u] to new bitrate(%u)[%u], queueLength(%u)",  __func__,
++            last_bitrate_inx, abr_table[new_abr_bitrate_inx], new_bitrate_inx_set, queueLength);
++
++        func_ret = lhdcv5_util_reset_up_bitrate (handle);
++        if (func_ret != LHDCV5_FRET_SUCCESS)
++        {
++          ALOGW ("%s:(DN) lhdcv5_util_reset_up_bitrate error %d", __func__, func_ret);
++          goto fail;
++        }
++      }
++      else
++      {
++        ALOGD ("%s:(DN) [AutoBiTrAtE] Down bitrate condition fails, new rate:%u, current rate:%u",  __func__,
++            abr_table[new_abr_bitrate_inx],
++            handle->lastBitrate);
++      }
++    }
++  }
++
++  if (handle->upBitrateCnt > 0 && handle->upBitrateCnt >= UP_RATE_TIME_CNT)
++  {
++    uint32_t queueLength = handle->upBitrateSum / handle->upBitrateCnt;
++    uint32_t queuSumTmp = handle->upBitrateSum;
++
++    ALOGV ("%s:(UP) Before upBitrateSum:%u / upBitrateCnt:%u = queueLength:%u", __func__,
++        handle->upBitrateSum, handle->upBitrateCnt, queueLength);
++
++    //handle->upBitrateSum = 0;
++    //handle->upBitrateCnt = 0;
++    func_ret = lhdcv5_util_reset_up_bitrate (handle);
++    if (func_ret != LHDCV5_FRET_SUCCESS)
++    {
++      ALOGW ("%s:(UP) lhdcv5_util_reset_up_bitrate error %d", __func__, func_ret);
++      goto fail;
++    }
++
++    func_ret = lhdcv5_encoder_inx_of_abr_bitrate (abr_type,
++        handle->lastBitrate,
++        &new_abr_bitrate_inx);
++    if (func_ret != LHDCV5_FRET_SUCCESS)
++    {
++      ALOGW ("%s:(UP) lhdcv5_encoder_inx_of_abr_bitrate error %d", __func__, func_ret);
++      goto fail;
++    }
++
++    if (new_abr_bitrate_inx < (element_size - 1))
++    {
++      new_abr_bitrate_inx++;
++    }
++
++    func_ret = lhdcv5_util_get_bitrate_inx (abr_table[new_abr_bitrate_inx], &new_bitrate_inx);
++    if (func_ret != LHDCV5_FRET_SUCCESS)
++    {
++      ALOGW ("%s:(UP) lhdcv5_util_get_bitrate_inx error %d", __func__, func_ret);
++      goto fail;
++    }
++
++    func_ret = lhdcv5_util_get_bitrate_inx (handle->lastBitrate, &last_bitrate_inx);
++    if (func_ret != LHDCV5_FRET_SUCCESS)
++    {
++      ALOGW ("%s:(UP) lhdcv5_util_get_bitrate_inx error %d", __func__, func_ret);
++      goto fail;
++    }
++
++    if ((new_bitrate_inx > last_bitrate_inx) && (queuSumTmp < ABR_UP_QUEUE_LENGTH_THRESHOLD))
++    {
++      func_ret = lhdcv5_util_set_target_bitrate_inx (lhdcBT, new_bitrate_inx, &new_bitrate_inx_set, false);
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("%s:(UP) lhdcv5_util_set_target_bitrate_inx error %d", __func__, func_ret);
++        goto fail;
++      }
++      ALOGD ("%s:(UP) [AutoBiTrAtE] Up bitrate[%u] to new_bitrate(%u)[%u], queueLength(%u)",
++          __func__, last_bitrate_inx, abr_table[new_abr_bitrate_inx], new_bitrate_inx_set, queueLength);
++
++      func_ret = lhdcv5_util_reset_down_bitrate (handle);
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("%s:(UP) lhdcv5_util_reset_down_bitrate error %d", __func__, func_ret);
++        goto fail;
++      }
++    }
++    else
++    {
++      ALOGD ("%s:(UP) [AutoBiTrAtE] Up bitrate condition fails, new rate:%u, current rate:%u, queue sum:%u",  __func__,
++          abr_table[new_abr_bitrate_inx],
++          handle->lastBitrate,
++          queuSumTmp);
++    }
++  }
++
++  if (queueLen > 0)
++  {
++    handle->upBitrateSum += queueLen;
++    handle->dnBitrateSum += queueLen;
++  }
++
++  handle->upBitrateCnt++;
++  handle->dnBitrateCnt++;
++
++  fail:
++  return func_ret;
++}
++
++
++/*
++ ******************************************************************
++ LHDC library public API group
++ ******************************************************************
++ */
++
++//----------------------------------------------------------------
++// lhdcv5BT_free_handle ()
++//
++// Free all resources allocated
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcv5BT_get_handle ()
++//	Return
++//		LHDCV5_FRET_SUCCESS: Succeed to free all resources
++//		otherwise: Fail to free all resources
++//----------------------------------------------------------------
++int32_t lhdcv5BT_free_handle
++(
++    HANDLE_LHDCV5_BT	handle
++) 
++{
++  int32_t func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  // reset resources
++  func_ret = lhdcv5_util_free_handle (handle);
++
++  // free handle
++  if(handle)
++  {
++    ALOGD ("%s: free handle %p!", __func__, handle);
++    free(handle);
++    handle = NULL;
++  }
++
++  return func_ret;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_get_handle ()
++//
++// Allocate resources required by LHDC 5.0 Encoder 
++// 	Parameter
++//		version: version defined in BT A2DP capability
++//		handle: a pointer to the resource allocated 
++// 	Return
++//		LHDCV5_FRET_SUCCESS: Succeed to allocate resources
++//		otherwise: Fail to allocate resources
++//----------------------------------------------------------------
++int32_t lhdcv5BT_get_handle
++(
++    uint32_t			version,
++    HANDLE_LHDCV5_BT	*handle
++) 
++{
++  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
++  uint32_t mem_req_bytes = 0;
++  HANDLE_LHDCV5_BT hLhdcBT = NULL;
++
++  if (version != LHDCV5_VERSION_1)
++  {
++    ALOGW ("%s: Invalid version (%u)!", __func__, version);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Input parameter is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_get_mem_req (version, &mem_req_bytes);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS || mem_req_bytes <= 0)
++  {
++    ALOGW ("%s: Fail to get required memory size (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
++  if (hLhdcBT == NULL)
++  {
++    ALOGW ("%s: Fail to allocate memory for encoder!", __func__);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  func_ret = lhdcv5_util_get_handle (version, hLhdcBT, mem_req_bytes);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: Fail to get handle (%d)!", __func__, func_ret);
++    free(hLhdcBT);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  *handle = hLhdcBT;
++
++  if ((*handle) == NULL)
++  {
++    ALOGW ("%s: Get handle NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_get_bitrate ()
++//
++// Get the bit rate used during LHDC 5.0 encoding
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcv5BT_get_handle ()
++//		bitrate: a pointer to bit rate used during LHDC 5.0 encoding,
++//				 range [64000, 1000000]
++//	Return
++//		LHDCV5_FRET_SUCCESS: Succeed to allocate resources
++//		otherwise: Fail to allocate resources
++//----------------------------------------------------------------
++int32_t lhdcv5BT_get_bitrate
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			*bitrate
++) 
++{
++  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if (bitrate == NULL)
++  {
++    ALOGW ("%s: Input parameter is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_get_target_bitrate (handle, bitrate);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: Failed to get bit rate (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  if ((*bitrate < 64000) || (*bitrate > 1000000))
++  {
++    ALOGW ("%s: Invalid bit rate returned (%u)!", __func__, *bitrate);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_set_bitrate ()
++//
++// Set the bit rate used during LHDC 5.0 encoding
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		bitrate_inx: an index of bit rate to set
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to set the bit rate
++//		Other: fail to set the bit rate
++//----------------------------------------------------------------
++int32_t lhdcv5BT_set_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			bitrate_inx
++)
++{
++  uint32_t	bitrate_inx_set = bitrate_inx;
++  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
++      (bitrate_inx >= LHDCV5_QUALITY_INVALID))
++  {
++    ALOGW ("%s: Invalid bit rate index (%u)!", __func__, bitrate_inx);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  if (bitrate_inx == LHDCV5_QUALITY_RESET_AUTO) {
++    bitrate_inx_set = LHDCV5_ABR_DEFAULT_BITRATE;
++    ALOGD ("%s: [Reset BiTrAtE] reset to bitrate (%s)", __func__, rate_to_string (bitrate_inx_set));
++    bitrate_inx = LHDCV5_ABR_DEFAULT_BITRATE;
++    // change bitrate only, not update quality index
++    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, false);
++  } else {
++    // also update quality index
++    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
++  }
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: failed to set bitrate (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  ALOGD ("%s: Update target bitrate(%s)",  __func__,
++      rate_to_string (bitrate_inx_set));
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_set_max_bitrate ()
++//
++// Set the MAX. bit rate for LHDC 5.0 encoding
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		max_bitrate_inx: MAX. bit rate (index) for LHDC 5.0 encoding
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to set the MAX. bit rate
++//		Other: fail to set the MAX. bit rate
++//----------------------------------------------------------------
++int32_t lhdcv5BT_set_max_bitrate
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			max_bitrate_inx
++) 
++{
++  uint32_t max_bitrate_inx_set = max_bitrate_inx;
++  int32_t func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if ((max_bitrate_inx < LHDCV5_QUALITY_LOW) ||
++      (max_bitrate_inx >= LHDCV5_QUALITY_AUTO))
++  {
++    ALOGW ("%s: Invalid max bit rate index (%u)!", __func__, max_bitrate_inx);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_set_max_bitrate_inx (handle, max_bitrate_inx, &max_bitrate_inx_set);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: failed to set max. bit rate index (%u), (%d)!", __func__, max_bitrate_inx, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  ALOGD ("%s: Update Max target bitrate(%s)",  __func__, rate_to_string (max_bitrate_inx_set));
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_set_min_bitrate ()
++//
++// Set the MIN. bit rate for LHDC 5.0 encoding
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		min_bitrate_inx: MIN. bit rate (index) for LHDC 5.0 encoding
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to set the MIN. bit rate
++//		Other: fail to set the MIN. bit rate
++//----------------------------------------------------------------
++
++int32_t lhdcv5BT_set_min_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			min_bitrate_inx
++)
++{
++  uint32_t 	min_bitrate_inx_set = (uint32_t) LHDCV5_QUALITY_LOW0;
++  int32_t			func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if ((min_bitrate_inx < LHDCV5_QUALITY_LOW0) ||
++      (min_bitrate_inx > LHDCV5_QUALITY_LOW))
++  {
++    ALOGW ("%s: Invalid min bit rate index (%u)!", __func__, min_bitrate_inx);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_set_min_bitrate_inx (handle, min_bitrate_inx, &min_bitrate_inx_set);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: failed to set min. bit rate (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_adjust_bitrate ()
++//
++// Adjust bit rate automatically according to number of packets in queue for LHDC 5.0 encoding
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		queue_len: number of packets in queue
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to adjust bit rate automatically 
++//		Other: fail to adjust bit rate automatically 
++//----------------------------------------------------------------
++
++int32_t lhdcv5BT_adjust_bitrate
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t			queueLen
++) 
++{
++  LHDCV5_ENC_TYPE_T	enc_type = LHDCV5_ENC_TYPE_LHDCV5;
++  lhdcv5_abr_para_t	* abr_para = NULL;
++  int32_t				func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if (queueLen < 0)
++  {
++    ALOGW ("%s: Invalid input queue length (%u)!", __func__, queueLen);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_adjust_bitrate (handle, &enc_type, &abr_para);
++
++  if ((func_ret != LHDCV5_FRET_SUCCESS) || (abr_para == NULL))
++  {
++    ALOGW ("%s: Failed to get auto bit rate parameters (%d) (%p)!", __func__, func_ret, abr_para);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  switch (enc_type)
++  {
++  case LHDCV5_ENC_TYPE_LHDCV5:
++
++    func_ret = lhdcv5_encoder_adjust_bitrate (handle, abr_para, queueLen);
++
++    if (func_ret != LHDCV5_FRET_SUCCESS)
++    {
++      ALOGW ("%s: Failed to adjust auto bit rate (%d)!", __func__, func_ret);
++      return LHDCV5_FRET_ERROR;
++    }
++    break;
++
++  default:
++    ALOGW ("%s: Invalid encode type (%d)!", __func__, enc_type);
++    return LHDCV5_FRET_INVALID_CODEC;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_set_ext_func_state ()
++//
++// Set the ext. function state (AR, JAS, Meta, LARC)
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		field: specify the ext. function
++//		enabled: ext. function is set to enabled (true) or disabled (false)
++//		priv: a pointer to the exra data needed for ext. function
++//		priv_data_len: number of bytes of the extra data
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to set specified ext. function to enabled (true) or disabled (false)
++//		Other: fail to set .
++//----------------------------------------------------------------
++
++int32_t lhdcv5BT_set_ext_func_state
++(
++    HANDLE_LHDCV5_BT 	handle,
++    LHDCV5_EXT_FUNC_T	field,
++    bool 				enabled,
++    void 				* priv,
++    uint32_t 			priv_data_len
++)
++{
++  int32_t	func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if ((field < LHDCV5_EXT_FUNC_AR) ||
++      (field >= LHDCV5_EXT_FUNC_INVALID))
++  {
++    ALOGW ("%s: Invalid ext. func. field (%d)!", __func__, field);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_set_ext_func_state (handle,
++      (LHDCV5_EXT_FUNC_T) field,
++      enabled,
++      priv,
++      priv_data_len,	// data length MUST be 8 for META
++      LHDCV5_META_LOOP_CNT_STD);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: failed to set ext. function state (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_init_encoder ()
++//
++// Initialize LHDC 5.0 encoder
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		sampling_freq: sample frequency
++//		bit_per_sample: bits per sample
++//		bitrate_inx: bit rate index
++//		mtu: BT A2DP MTU 
++//		interval: interval: period of time triggering LHDC 5.0 encoding in ms
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to initialize 
++//		Other: fail to initialize.
++//----------------------------------------------------------------
++int32_t lhdcv5BT_init_encoder
++(
++    HANDLE_LHDCV5_BT 	handle,
++    uint32_t 			sampling_freq,
++    uint32_t 			bits_per_sample,
++    uint32_t 			bitrate_inx,
++    uint32_t 			mtu,
++    uint32_t 			interval
++) 
++{
++  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if ((sampling_freq != LHDCV5_SR_44100HZ) &&
++      (sampling_freq != LHDCV5_SR_48000HZ) &&
++      (sampling_freq != LHDCV5_SR_96000HZ) &&
++      (sampling_freq != LHDCV5_SR_192000HZ))
++  {
++    ALOGW ("%s: Invalid sampling frequency (%u)!", __func__, sampling_freq);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  if ((bits_per_sample != LHDCV5BT_SMPL_FMT_S16) &&
++      (bits_per_sample != LHDCV5BT_SMPL_FMT_S24) &&
++      (bits_per_sample != LHDCV5BT_SMPL_FMT_S32))
++  {
++    ALOGW ("%s: Invalid bits per sample (%u)!", __func__, bits_per_sample);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
++      (bitrate_inx > LHDCV5_QUALITY_AUTO))
++  {
++    ALOGW ("%s: Invalid bit rate (index) (%d)!", __func__, bitrate_inx);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++
++  func_ret = lhdcv5_util_init_encoder (handle,
++      (unsigned int) sampling_freq,
++      (unsigned int) bits_per_sample,
++      (unsigned int) bitrate_inx,
++      (unsigned int) LHDCV5_FRAME_5MS,
++      (unsigned int) mtu,
++      (unsigned int) interval);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: Failed to init LHDC 5.0 encoder (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_get_block_Size ()
++//
++// Get number of samples per block for LHDC 5.0 encoder
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned by function lhdcv5Bt_get_handle ()
++//		samples_per_frame: number of samples per block returned
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to get number of samples per block 
++//		Other: fail to get number of samples per block.
++//----------------------------------------------------------------
++int32_t lhdcv5BT_get_block_Size
++(
++    HANDLE_LHDCV5_BT	handle,
++    uint32_t			* samples_per_frame
++)
++{
++  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
++
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if (samples_per_frame == NULL)
++  {
++    ALOGW ("%s: Input parameter is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_get_block_Size (handle, samples_per_frame);
++
++  if ((func_ret != LHDCV5_FRET_SUCCESS) || ((*samples_per_frame) <= 0))
++  {
++    ALOGW ("%s: Failed to get block size (%d) (%d)!", __func__, func_ret, *samples_per_frame);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++//----------------------------------------------------------------
++// lhdcv5BT_encode ()
++//
++// Encode pcm samples by LHDC 5.0
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		p_in_pcm: a pointer to a buffer contains PCM samples for encoding
++//		p_out_buf: a pointer to a buffer to put encoded stream
++//		out_buf_bytes: output buffer's size (in byte)
++//		p_out_bytes: a pointer to number of bytes of encoded stream in buffer
++//		p_out_frames: a pointer to number of frames of encoded stream in buffer
++//	Return
++//		LHDCV5_FRET_SUCCESS: succeed to encode pcm samples
++//		Other: fail to encode pcm samples
++//----------------------------------------------------------------
++int32_t lhdcv5BT_encode
++(
++    HANDLE_LHDCV5_BT 	handle,
++    void				* p_in_pcm,
++    uint32_t			pcm_bytes,
++    uint8_t				* p_out_buf,
++    uint32_t			out_buf_bytes,
++    uint32_t 			* p_out_bytes,
++    uint32_t 			* p_out_frames
++)
++{
++  int32_t		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("%s: Handle is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_HANDLE_CB;
++  }
++
++  if ((p_in_pcm == NULL) || (p_out_buf == NULL) ||
++      (p_out_bytes == NULL) || (p_out_frames == NULL))
++  {
++    ALOGW ("%s: input parameter is NULL!", __func__);
++    return LHDCV5_FRET_INVALID_INPUT_PARAM;
++  }
++
++  func_ret = lhdcv5_util_enc_process (handle,
++      p_in_pcm,
++      pcm_bytes,
++      p_out_buf,
++      out_buf_bytes,
++      p_out_bytes,
++      p_out_frames);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("%s: Failed to encode pcm samples (%d)!", __func__, func_ret);
++    return LHDCV5_FRET_ERROR;
++  }
++
++  return LHDCV5_FRET_SUCCESS;
++}
++
++
++
++/*
++ ******************************************************************
++ Extend API functions group
++ ******************************************************************
++ */
++static bool lhdcBT_code_ver_wrap
++(
++    unsigned char *pucConfig,
++    unsigned int *exFuncCode,
++    unsigned int *exFuncVer
++)
++{
++  *exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
++      ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
++      ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
++      ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
++
++  *exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
++      ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
++      ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
++      ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
++
++  return true;
++}
++
++//
++// META, JAS
++//
++//----------------------------------------------------------------
++// lhdcBT_set_cfg_meta_v1 ()
++//
++// Set configuration for meta data
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userConfig: a pointer to configuration
++//		configLen: number of bytes of configuration
++//	Return
++//		EXTEND_FUNC_RET_OK: succeed to set configuration  
++//		Other: fail to set configuration.
++//----------------------------------------------------------------
++static int lhdcBT_set_cfg_meta_v1
++(
++    HANDLE_LHDCV5_BT 	handle,
++    const char			*userConfig,
++    const int 			configLen
++) 
++{
++  PST_LHDC_SET_META pset_meta = (PST_LHDC_SET_META) userConfig;
++  unsigned char	* pmeta_metadata = NULL;
++  int				func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userConfig == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Config is NULL (%p)!",  __func__, userConfig);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (configLen < (int) sizeof (ST_LHDC_SET_META))
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  if (pset_meta->meta_ver != META_ST_VER_V2)
++  {
++    ALOGW ("(LHDC-exAPI) %s: version is not match (%d)!",  __func__, pset_meta->meta_ver);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (pset_meta->meta_mem_size != (int) sizeof (ST_LHDC_SET_META))
++  {
++    ALOGW("(LHDC-exAPI) %s: META data size is  not match (%d)!", __func__, pset_meta->meta_mem_size);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (configLen < ((int) pset_meta->meta_metadata_length) + ((int) sizeof (ST_LHDC_SET_META)))
++  {
++    ALOGW("(LHDC-exAPI) %s: cfg size too small (%d)!", __func__, configLen);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  pmeta_metadata = (uint8_t*) (pset_meta + 1);
++
++  func_ret = lhdcv5_util_set_ext_func_state (handle,
++      LHDCV5_EXT_FUNC_META,
++      pset_meta->meta_enable,
++      pmeta_metadata,
++      pset_meta->meta_metadata_length,
++      pset_meta->meta_set);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Fail to set META data (%d)!",  __func__, func_ret);
++    return EXTEND_FUNC_RET_ERROR;
++  }
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++
++//----------------------------------------------------------------
++// lhdcBT_get_cfg_meta_v1 ()
++//
++// Get configuration for meta data
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userConfig: a pointer to configuration
++//		configLen: number of bytes of configuration
++//	Return
++//		EXTEND_FUNC_RET_OK: succeed to get configuration   
++//		Other: fail to get configuration.
++//----------------------------------------------------------------
++static int lhdcBT_get_cfg_meta_v1
++(
++    HANDLE_LHDCV5_BT 	handle,
++    char				* userConfig,
++    const int 			configLen
++) 
++{
++  PST_LHDC_GET_META pget_meta = (PST_LHDC_GET_META) userConfig;
++  bool 		jas_enabled = false;
++  bool		meta_enabled = false;
++  int			func_ret = LHDCV5_FRET_SUCCESS;
++
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userConfig == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (configLen < (int) sizeof (ST_LHDC_GET_META))
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  func_ret = lhdcv5_util_get_ext_func_state (handle, LHDCV5_EXT_FUNC_META, &meta_enabled);
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Fail to get META flag (%d)!",  __func__, func_ret);
++    return EXTEND_FUNC_RET_ERROR;
++  }
++  ALOGW ("(LHDC-exAPI) %s: LHDCV5_EXT_FUNC_META: meta_enabled=%d",  __func__, meta_enabled);
++
++  func_ret = lhdcv5_util_get_ext_func_state (handle, LHDCV5_EXT_FUNC_JAS, &jas_enabled);
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Fail to get JAS flag (%d)!",  __func__, func_ret);
++    return EXTEND_FUNC_RET_ERROR;
++  }
++  ALOGW ("(LHDC-exAPI) %s: LHDCV5_EXT_FUNC_JAS: jas_enabled=%d",  __func__, jas_enabled);
++
++  pget_meta->meta_ver = META_ST_VER_V2;
++  pget_meta->meta_mem_size = (int) sizeof (ST_LHDC_GET_META);
++  pget_meta->meta_st = meta_enabled ? 0x03 : 0x01;  // Get current frame include metadata or not
++  pget_meta->jas_status = jas_enabled ? 1 : 0;
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++
++//
++// AR Function
++//
++//----------------------------------------------------------------
++// lhdcBT_set_data_gyro_2d_v1 ()
++//
++// Set data for gyro (x, y)
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userData: a pointer to data
++//		dataLen: number of bytes of data
++//	Return
++//		0: succeed to set data  
++//		Other: fail to set data.
++//----------------------------------------------------------------
++static int lhdcBT_set_data_gyro_2d_v1
++(
++    HANDLE_LHDCV5_BT 	handle,
++    const char 			* userData,
++    const int 			dataLen
++) 
++{
++  PST_LHDC_AR_GYRO pargyro = (PST_LHDC_AR_GYRO) userData;
++  int 		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userData == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: User Data is NULL (%p)!",  __func__, userData);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (dataLen < (int) sizeof (ST_LHDC_AR_GYRO))
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, dataLen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++
++  ALOGV ("(LHDC-exAPI) %s: set coordinate[x:%d y:%d z:%d]",  __func__,
++      pargyro->world_coordinate_x,
++      pargyro->world_coordinate_y,
++      pargyro->world_coordinate_z);
++
++  func_ret = lhdcv5_util_ar_set_gyro_pos (handle,
++      pargyro->world_coordinate_x,
++      pargyro->world_coordinate_y,
++      pargyro->world_coordinate_z);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGD ("(LHDC-exAPI) %s: Fail to set gyro's position[x:%d y:%d z:%d] for AR (%d)!",  __func__,
++        pargyro->world_coordinate_x,
++        pargyro->world_coordinate_y,
++        pargyro->world_coordinate_z,
++        func_ret);
++    return EXTEND_FUNC_RET_ERROR;
++  }
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++
++//----------------------------------------------------------------
++// lhdcBT_set_cfg_ar_v3 ()
++//
++// Set configuration for AR
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userConfig: a pointer to configuration
++//		configLen: number of bytes of configuration
++//	Return
++//		0: succeed to set configuration  
++//		Other: fail to set configuration.
++//----------------------------------------------------------------
++static int lhdcBT_set_cfg_ar_v3
++(
++    HANDLE_LHDCV5_BT 	handle,
++    const char 			* userConfig,
++    const int 			configLen
++) 
++{
++  PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR) userConfig;
++  int 		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userConfig == NULL)
++  {
++    ALOGW("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (configLen < (int) sizeof (ST_LHDC_AR))
++  {
++    // Buffer is to small
++    ALOGW("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  ALOGD("(LHDC-exAPI) %s: ver(%d) size(%d) app_ar_enabled(%d) Ch_Pos(%d %d %d %d %d %d)"
++      , __func__,
++      pset_ar_cfg->ver,
++      pset_ar_cfg->size,
++      pset_ar_cfg->app_ar_enabled,
++      pset_ar_cfg->Ch1_Pos, pset_ar_cfg->Ch2_Pos, pset_ar_cfg->Ch2_Pos,
++      pset_ar_cfg->Ch4_Pos, pset_ar_cfg->Ch5_Pos, pset_ar_cfg->Ch6_Pos);
++
++  ALOGD("(LHDC-exAPI) %s: PreGain(L:R): ch1[%f:%f] ch2[%f:%f] ch3[%f:%f] ch4[%f:%f] ch5[%f:%f] ch6[%f:%f]"
++      , __func__,
++      pset_ar_cfg->Ch1_L_PreGain, pset_ar_cfg->Ch1_R_PreGain,
++      pset_ar_cfg->Ch2_L_PreGain, pset_ar_cfg->Ch2_R_PreGain,
++      pset_ar_cfg->Ch3_L_PreGain, pset_ar_cfg->Ch3_R_PreGain,
++      pset_ar_cfg->Ch4_L_PreGain, pset_ar_cfg->Ch4_R_PreGain,
++      pset_ar_cfg->Ch5_L_PreGain, pset_ar_cfg->Ch5_R_PreGain,
++      pset_ar_cfg->Ch6_L_PreGain, pset_ar_cfg->Ch6_R_PreGain);
++
++  ALOGD("(LHDC-exAPI) %s: PostGain: ch1[%f] ch2[%f] ch3[%f] ch4[%f] ch5[%f] ch6[%f]"
++      , __func__,
++      pset_ar_cfg->Ch1_PostGain, pset_ar_cfg->Ch2_PostGain,
++      pset_ar_cfg->Ch3_PostGain, pset_ar_cfg->Ch4_PostGain,
++      pset_ar_cfg->Ch5_PostGain, pset_ar_cfg->Ch6_PostGain);
++
++  ALOGD("(LHDC-exAPI) %s: Dry_Val(%f) Wet_Val(%f)" , __func__,
++      pset_ar_cfg->Dry_Val, pset_ar_cfg->Wet_Val);
++
++  ALOGD("(LHDC-exAPI) %s: Dis[%f %f %f %f %f] Rev[%f %f %f %f %f]" , __func__,
++      pset_ar_cfg->Dis_1, pset_ar_cfg->Dis_2, pset_ar_cfg->Dis_3, pset_ar_cfg->Dis_4, pset_ar_cfg->Dis_5,
++      pset_ar_cfg->Rev_1, pset_ar_cfg->Rev_2, pset_ar_cfg->Rev_3, pset_ar_cfg->Rev_4, pset_ar_cfg->Rev_5);
++
++  ALOGD("(LHDC-exAPI) %s: Rev_gain(%f) ThreeD_gain(%f)" , __func__,
++      pset_ar_cfg->Rev_gain, pset_ar_cfg->ThreeD_gain);
++
++  ALOGD ("(LHDC-exAPI) %s: to set AR enable: %d",  __func__, pset_ar_cfg->app_ar_enabled);
++  func_ret = lhdcv5_util_ar_set_cfg (handle,
++      &pset_ar_cfg->Ch1_Pos,
++      6,
++      &pset_ar_cfg->Ch1_L_PreGain,
++      32,
++      pset_ar_cfg->app_ar_enabled);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("(LHDC-exAPI) %s: func_ret %d",  __func__, func_ret);
++    return EXTEND_FUNC_RET_ERROR;
++  }
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++
++//----------------------------------------------------------------
++// lhdcBT_get_cfg_ar_v1 ()
++//
++// Get configuration for AR
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userConfig: a pointer to configuration
++//		configLen: number of bytes of configuration
++//	Return
++//		EXTEND_FUNC_RET_OK: succeed to get configuration   
++//		Other: fail to get configuration.
++//----------------------------------------------------------------
++static int lhdcBT_get_cfg_ar_v1
++(
++    HANDLE_LHDCV5_BT 	handle,
++    char 				* userConfig,
++    const int 			configLen
++) 
++{
++  PST_LHDC_AR pset_ar_cfg = (PST_LHDC_AR) userConfig;
++  int 		func_ret = LHDCV5_FRET_SUCCESS;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userConfig == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (configLen < (int) sizeof (ST_LHDC_AR))
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, configLen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  func_ret = lhdcv5_util_ar_get_cfg (handle,
++      &pset_ar_cfg->Ch1_Pos,
++      6,
++      &pset_ar_cfg->Ch1_L_PreGain,
++      32);
++
++  if (func_ret != LHDCV5_FRET_SUCCESS)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Fail to get AR config (%d)!",  __func__, func_ret);
++    return EXTEND_FUNC_RET_ERROR;
++  }
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++// 1. API -- Set User Config (Extend)
++//----------------------------------------------------------------
++// lhdcv5BT_set_user_exconfig ()
++//
++// Set configuration
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userConfig: a pointer to configuration
++//		clen: number of bytes of configuration
++//	Return
++//		EXTEND_FUNC_RET_OK: succeed to set configuration   
++//		Other: fail to set configuration.
++//----------------------------------------------------------------
++int lhdcv5BT_set_user_exconfig
++(
++    HANDLE_LHDCV5_BT 	handle,
++    const char			* userConfig,
++    const int 			clen
++) 
++{
++  unsigned char 	* pucConfig = (unsigned char *) userConfig;
++  unsigned int 	exFuncVer;
++  unsigned int 	exFuncCode;
++  int 			func_ret = EXTEND_FUNC_RET_OK;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userConfig == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (clen < (int) EXTEND_FUNC_MIN_BUFFER_LEN)
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  lhdcBT_code_ver_wrap(pucConfig, &exFuncCode , &exFuncVer);
++
++  switch (exFuncCode)
++  {
++  case EXTEND_FUNC_CODE_SET_CONFIG_META:
++
++    switch (exFuncVer)
++    {
++    case EXTEND_FUNC_VER_SET_CONFIG_META_V1:
++      ALOGD ("(LHDC-exAPI) %s: SET_CONFIG_META",  __func__);
++      func_ret = lhdcBT_set_cfg_meta_v1 (handle, userConfig, clen);
++
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("(LHDC-exAPI) %s: Fail to set META data (%d)!",  __func__, func_ret);
++        return EXTEND_FUNC_RET_ERROR;
++      }
++      break;
++
++    default:
++      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
++      return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++    }
++    break;
++
++    case EXTEND_FUNC_CODE_SET_CONFIG_AR:
++      switch (exFuncVer)
++      {
++      case EXTEND_FUNC_VER_SET_CONFIG_AR_V3:
++        ALOGD ("(LHDC-exAPI) %s: SET_CONFIG_AR",  __func__);
++        func_ret = lhdcBT_set_cfg_ar_v3 (handle, userConfig, clen);
++
++        if (func_ret != LHDCV5_FRET_SUCCESS)
++        {
++          ALOGW ("(LHDC-exAPI) %s: Fail to set AR config (%d)!",  __func__, func_ret);
++          return EXTEND_FUNC_RET_ERROR;
++        }
++        break;
++
++      default:
++        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
++        return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++      }
++      break;
++
++      default:
++        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++  } // switch (exFuncCode)
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++
++// 2. API -- Get User Config (Extend)
++//----------------------------------------------------------------
++// lhdcv5BT_get_user_exconfig ()
++//
++// Get configuration
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userConfig: a pointer to configuration
++//		clen: number of bytes of configuration
++//	Return
++//		EXTEND_FUNC_RET_OK: succeed to get configuration   
++//		Other: fail to get configuration.
++//----------------------------------------------------------------
++
++int lhdcv5BT_get_user_exconfig
++(
++    HANDLE_LHDCV5_BT 	handle,
++    char				* userConfig,
++    int 				clen
++) 
++{
++  unsigned char 	* pucConfig = (unsigned char *) userConfig;
++  unsigned int 	exFuncVer;
++  unsigned int 	exFuncCode;
++  int 			func_ret = EXTEND_FUNC_RET_OK;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userConfig == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: User Config is NULL (%p)!",  __func__, userConfig);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN)
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  lhdcBT_code_ver_wrap(pucConfig, &exFuncCode , &exFuncVer);
++
++  switch (exFuncCode)
++  {
++  case EXTEND_FUNC_CODE_GET_CONFIG_META:
++
++    switch (exFuncVer)
++    {
++    case EXTEND_FUNC_VER_GET_CONFIG_META_V1:
++      ALOGD ("(LHDC-exAPI) %s: GET_CONFIG_META",  __func__);
++      func_ret = lhdcBT_get_cfg_meta_v1 (handle, userConfig, clen);
++
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("(LHDC-exAPI) %s: Fail to get META data (%d)!",  __func__, func_ret);
++        return EXTEND_FUNC_RET_ERROR;
++      }
++      break;
++
++    default:
++      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
++      return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++    }
++    break;
++
++    case EXTEND_FUNC_CODE_GET_CONFIG_AR:
++
++      switch (exFuncVer)
++      {
++      case EXTEND_FUNC_VER_GET_CONFIG_AR_V1:
++        ALOGD ("(LHDC-exAPI) %s: GET_CONFIG_AR",  __func__);
++        func_ret = lhdcBT_get_cfg_ar_v1 (handle, userConfig, clen);
++
++        if (func_ret != LHDCV5_FRET_SUCCESS)
++        {
++          ALOGW ("(LHDC-exAPI) %s: Fail to get AR config (%d)!",  __func__, func_ret);
++          return EXTEND_FUNC_RET_ERROR;
++        }
++        break;
++
++      default:
++        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
++        return EXTEND_FUNC_RET_VERSION_NOT_SUPPORT;
++      }
++      break;
++
++      default:
++        ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
++        return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++  } // switch (exFuncCode)
++
++
++  return EXTEND_FUNC_RET_OK;
++}
++
++
++// 3. API -- Set User Data (Extend)
++//----------------------------------------------------------------
++// lhdcv5BT_set_user_exdata ()
++//
++// Set data
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		userData: a pointer to data
++//		clen: number of bytes of data
++//	Return
++//		EXTEND_FUNC_RET_OK: succeed to set data   
++//		Other: fail to set data.
++//----------------------------------------------------------------
++void lhdcv5BT_set_user_exdata
++(
++    HANDLE_LHDCV5_BT 	handle,
++    const char			* userData,
++    const int 			clen
++) 
++{
++  unsigned char 	* pucData = (unsigned char *) userData;
++  unsigned int 	exFuncVer;
++  unsigned int 	exFuncCode;
++  int 			func_ret = EXTEND_FUNC_RET_OK;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return; // EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (userData == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: User Data is NULL (%p)!",  __func__, userData);
++    return; // EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (clen < (int) EXTEND_FUNC_MIN_BUFFER_LEN)
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer is too small (%d)!",  __func__, clen);
++    return;
++  }
++
++  lhdcBT_code_ver_wrap(pucData, &exFuncCode , &exFuncVer);
++
++  switch (exFuncCode)
++  {
++  case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
++
++    switch (exFuncVer)
++    {
++    case EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1:
++      ALOGD ("(LHDC-exAPI) %s: SET_DATA_GYRO",  __func__);
++      func_ret = lhdcBT_set_data_gyro_2d_v1 (handle, userData, clen);
++
++      if (func_ret != LHDCV5_FRET_SUCCESS)
++      {
++        ALOGW ("(LHDC-exAPI) %s: Fail to get gyro's data (%d)!",  __func__, func_ret);
++        return;
++      }
++      break;
++
++    default:
++      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Version (0x%X)!",  __func__, exFuncVer);
++      break; // EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++    }
++    break;
++
++    default:
++      ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
++      break;
++  } // switch (exFuncCode)
++
++  return;
++}
++
++
++// 4. API -- Get Version
++//----------------------------------------------------------------
++// lhdcv5BT_get_user_exApiver ()
++//
++// Get version
++//	Parameter
++//		handle: a pointer to the resource allocated and is returned 
++//				by function lhdcBT_get_handle ()
++//		version: a pointer to version
++//		clen: number of bytes of version
++//	Return
++//		0: succeed to set data   
++//		Other: fail to set data.
++//----------------------------------------------------------------
++int lhdcv5BT_get_user_exApiver
++(
++    HANDLE_LHDCV5_BT 	handle,
++    char 				* version,
++    int 				clen
++) 
++{
++  unsigned char 	* pucApiVer = (unsigned char *) version;
++  unsigned int 	exFuncVer = 0;
++  unsigned int 	exFuncCode = 0;
++
++  if (handle == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: Handle is NULL (%p)!",  __func__, handle);
++    return EXTEND_FUNC_RET_INVALID_HANDLE;
++  }
++
++  if (version == NULL)
++  {
++    ALOGW ("(LHDC-exAPI) %s: API verion pointer is NULL (%p)!",  __func__, version);
++    return EXTEND_FUNC_RET_INVALID_PARAMETER;
++  }
++
++  if (clen < (int)EXTEND_FUNC_MIN_BUFFER_LEN)
++  {
++    // Buffer is to small
++    ALOGW ("(LHDC-exAPI) %s: Buffer too small (%d)!",  __func__, clen);
++    return EXTEND_FUNC_RET_BUF_UNDERRUN;
++  }
++
++  lhdcBT_code_ver_wrap(pucApiVer, &exFuncCode , &exFuncVer);
++
++  switch (exFuncCode)
++  {
++  // Config APIs:
++  case EXTEND_FUNC_CODE_SET_CONFIG_META:
++    exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_META_V1;
++    break;
++
++  case EXTEND_FUNC_CODE_SET_CONFIG_AR:
++    exFuncVer = EXTEND_FUNC_VER_SET_CONFIG_AR_V3;
++    break;
++
++  case EXTEND_FUNC_CODE_GET_CONFIG_META:
++    exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_META_V1;
++    break;
++
++  case EXTEND_FUNC_CODE_GET_CONFIG_AR:
++    exFuncVer = EXTEND_FUNC_VER_GET_CONFIG_AR_V1;
++    break;
++
++    // Data APIs:
++  case EXTEND_FUNC_CODE_SET_DATA_GYRO2D:
++    exFuncVer = EXTEND_FUNC_VER_SET_DATA_GYRO2D_V1;
++    break;
++
++    // A2DP codec config APIs:
++  case EXTEND_FUNC_CODE_GET_SPECIFIC:
++    exFuncVer = EXTEND_FUNC_VER_GET_SPECIFIC_V2;
++    break;
++
++  default:
++    ALOGW ("(LHDC-exAPI) %s: Invalid Ex. Function Code (0x%X)!",  __func__, exFuncCode);
++    return EXTEND_FUNC_RET_FUNC_NOT_SUPPORT;
++  } // switch (exFuncCode)
++
++  // fill version of target API
++  pucApiVer[3] = (unsigned char) (exFuncVer & ((unsigned int)0xff));
++  pucApiVer[2] = (unsigned char) ((exFuncVer >> 8) & ((unsigned int)0xff));
++  pucApiVer[1] = (unsigned char) ((exFuncVer >> 16) & ((unsigned int)0xff));
++  pucApiVer[0] = (unsigned char) ((exFuncVer >> 24) & ((unsigned int)0xff));
++
++  ALOGD ("(LHDC-exAPI) %s: APICode:[%02X %02X %02X %02X] Ver:[%02X %02X %02X %02X]",  __func__,
++      pucApiVer[4],
++      pucApiVer[5],
++      pucApiVer[6],
++      pucApiVer[7],
++      pucApiVer[0],
++      pucApiVer[1],
++      pucApiVer[2],
++      pucApiVer[3]);
++
++  return EXTEND_FUNC_RET_OK;
++}
++
+diff --git a/external/liblhdcv5dec/Android.bp b/external/liblhdcv5dec/Android.bp
+new file mode 100644
+index 000000000..942aadb61
+--- /dev/null
++++ b/external/liblhdcv5dec/Android.bp
+@@ -0,0 +1,50 @@
++
++cc_prebuilt_library_shared {
++    name: "liblhdcv5dec",
++    
++    export_include_dirs: ["include"],
++    arch: {
++        arm: {
++            srcs: ["libs/armeabi-v7a/liblhdcv5dec.so",],
++        },
++        arm64: {
++            srcs: ["libs/arm64-v8a/liblhdcv5dec.so",],
++        },
++    },
++
++    strip: {
++        none:true,
++    },
++
++    shared_libs: [
++        "liblog",
++        "libstdc++",
++    ],
++}
++
++cc_library_shared {
++    name: "liblhdcv5BT_dec",
++    //vendor_available: true,
++    //vndk: {
++    //    enabled: true,
++    //},
++    arch: {
++        arm: {
++            instruction_set: "arm",
++        },
++    },
++    export_include_dirs: ["inc"],
++    local_include_dirs: ["inc", "include", ],
++    srcs: [
++        "src/lhdcv5BT_dec.c",
++    ],
++    // -D_32BIT_FIXED_POINT should be added to cflags for devices without a FPU
++    // unit such as ARM Cortex-R series or external 32-bit DSPs.
++    cflags: ["-O2", "-Wall", "-Wextra", "-Wmacro-redefined"],
++
++    shared_libs: [
++        "libcutils",
++        "liblog",
++        "liblhdcv5dec",
++    ],
++}
+diff --git a/external/liblhdcv5dec/CHANGES b/external/liblhdcv5dec/CHANGES
+new file mode 100644
+index 000000000..123e86335
+--- /dev/null
++++ b/external/liblhdcv5dec/CHANGES
+@@ -0,0 +1,7 @@
++Release Note.
++=========================================================
++Jun 21, 2022, by jimmy.chen@savitech.co
++  *Update version to 5.0.5
++
++Feb, 21, 2022, by jimmy.chen@savitech.co
++  *Add LHDCV5 Decoder v5.0.1
+diff --git a/external/liblhdcv5dec/LICENSE b/external/liblhdcv5dec/LICENSE
+new file mode 100644
+index 000000000..261eeb9e9
+--- /dev/null
++++ b/external/liblhdcv5dec/LICENSE
+@@ -0,0 +1,201 @@
++                                 Apache License
++                           Version 2.0, January 2004
++                        http://www.apache.org/licenses/
++
++   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
++
++   1. Definitions.
++
++      "License" shall mean the terms and conditions for use, reproduction,
++      and distribution as defined by Sections 1 through 9 of this document.
++
++      "Licensor" shall mean the copyright owner or entity authorized by
++      the copyright owner that is granting the License.
++
++      "Legal Entity" shall mean the union of the acting entity and all
++      other entities that control, are controlled by, or are under common
++      control with that entity. For the purposes of this definition,
++      "control" means (i) the power, direct or indirect, to cause the
++      direction or management of such entity, whether by contract or
++      otherwise, or (ii) ownership of fifty percent (50%) or more of the
++      outstanding shares, or (iii) beneficial ownership of such entity.
++
++      "You" (or "Your") shall mean an individual or Legal Entity
++      exercising permissions granted by this License.
++
++      "Source" form shall mean the preferred form for making modifications,
++      including but not limited to software source code, documentation
++      source, and configuration files.
++
++      "Object" form shall mean any form resulting from mechanical
++      transformation or translation of a Source form, including but
++      not limited to compiled object code, generated documentation,
++      and conversions to other media types.
++
++      "Work" shall mean the work of authorship, whether in Source or
++      Object form, made available under the License, as indicated by a
++      copyright notice that is included in or attached to the work
++      (an example is provided in the Appendix below).
++
++      "Derivative Works" shall mean any work, whether in Source or Object
++      form, that is based on (or derived from) the Work and for which the
++      editorial revisions, annotations, elaborations, or other modifications
++      represent, as a whole, an original work of authorship. For the purposes
++      of this License, Derivative Works shall not include works that remain
++      separable from, or merely link (or bind by name) to the interfaces of,
++      the Work and Derivative Works thereof.
++
++      "Contribution" shall mean any work of authorship, including
++      the original version of the Work and any modifications or additions
++      to that Work or Derivative Works thereof, that is intentionally
++      submitted to Licensor for inclusion in the Work by the copyright owner
++      or by an individual or Legal Entity authorized to submit on behalf of
++      the copyright owner. For the purposes of this definition, "submitted"
++      means any form of electronic, verbal, or written communication sent
++      to the Licensor or its representatives, including but not limited to
++      communication on electronic mailing lists, source code control systems,
++      and issue tracking systems that are managed by, or on behalf of, the
++      Licensor for the purpose of discussing and improving the Work, but
++      excluding communication that is conspicuously marked or otherwise
++      designated in writing by the copyright owner as "Not a Contribution."
++
++      "Contributor" shall mean Licensor and any individual or Legal Entity
++      on behalf of whom a Contribution has been received by Licensor and
++      subsequently incorporated within the Work.
++
++   2. Grant of Copyright License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      copyright license to reproduce, prepare Derivative Works of,
++      publicly display, publicly perform, sublicense, and distribute the
++      Work and such Derivative Works in Source or Object form.
++
++   3. Grant of Patent License. Subject to the terms and conditions of
++      this License, each Contributor hereby grants to You a perpetual,
++      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
++      (except as stated in this section) patent license to make, have made,
++      use, offer to sell, sell, import, and otherwise transfer the Work,
++      where such license applies only to those patent claims licensable
++      by such Contributor that are necessarily infringed by their
++      Contribution(s) alone or by combination of their Contribution(s)
++      with the Work to which such Contribution(s) was submitted. If You
++      institute patent litigation against any entity (including a
++      cross-claim or counterclaim in a lawsuit) alleging that the Work
++      or a Contribution incorporated within the Work constitutes direct
++      or contributory patent infringement, then any patent licenses
++      granted to You under this License for that Work shall terminate
++      as of the date such litigation is filed.
++
++   4. Redistribution. You may reproduce and distribute copies of the
++      Work or Derivative Works thereof in any medium, with or without
++      modifications, and in Source or Object form, provided that You
++      meet the following conditions:
++
++      (a) You must give any other recipients of the Work or
++          Derivative Works a copy of this License; and
++
++      (b) You must cause any modified files to carry prominent notices
++          stating that You changed the files; and
++
++      (c) You must retain, in the Source form of any Derivative Works
++          that You distribute, all copyright, patent, trademark, and
++          attribution notices from the Source form of the Work,
++          excluding those notices that do not pertain to any part of
++          the Derivative Works; and
++
++      (d) If the Work includes a "NOTICE" text file as part of its
++          distribution, then any Derivative Works that You distribute must
++          include a readable copy of the attribution notices contained
++          within such NOTICE file, excluding those notices that do not
++          pertain to any part of the Derivative Works, in at least one
++          of the following places: within a NOTICE text file distributed
++          as part of the Derivative Works; within the Source form or
++          documentation, if provided along with the Derivative Works; or,
++          within a display generated by the Derivative Works, if and
++          wherever such third-party notices normally appear. The contents
++          of the NOTICE file are for informational purposes only and
++          do not modify the License. You may add Your own attribution
++          notices within Derivative Works that You distribute, alongside
++          or as an addendum to the NOTICE text from the Work, provided
++          that such additional attribution notices cannot be construed
++          as modifying the License.
++
++      You may add Your own copyright statement to Your modifications and
++      may provide additional or different license terms and conditions
++      for use, reproduction, or distribution of Your modifications, or
++      for any such Derivative Works as a whole, provided Your use,
++      reproduction, and distribution of the Work otherwise complies with
++      the conditions stated in this License.
++
++   5. Submission of Contributions. Unless You explicitly state otherwise,
++      any Contribution intentionally submitted for inclusion in the Work
++      by You to the Licensor shall be under the terms and conditions of
++      this License, without any additional terms or conditions.
++      Notwithstanding the above, nothing herein shall supersede or modify
++      the terms of any separate license agreement you may have executed
++      with Licensor regarding such Contributions.
++
++   6. Trademarks. This License does not grant permission to use the trade
++      names, trademarks, service marks, or product names of the Licensor,
++      except as required for reasonable and customary use in describing the
++      origin of the Work and reproducing the content of the NOTICE file.
++
++   7. Disclaimer of Warranty. Unless required by applicable law or
++      agreed to in writing, Licensor provides the Work (and each
++      Contributor provides its Contributions) on an "AS IS" BASIS,
++      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
++      implied, including, without limitation, any warranties or conditions
++      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
++      PARTICULAR PURPOSE. You are solely responsible for determining the
++      appropriateness of using or redistributing the Work and assume any
++      risks associated with Your exercise of permissions under this License.
++
++   8. Limitation of Liability. In no event and under no legal theory,
++      whether in tort (including negligence), contract, or otherwise,
++      unless required by applicable law (such as deliberate and grossly
++      negligent acts) or agreed to in writing, shall any Contributor be
++      liable to You for damages, including any direct, indirect, special,
++      incidental, or consequential damages of any character arising as a
++      result of this License or out of the use or inability to use the
++      Work (including but not limited to damages for loss of goodwill,
++      work stoppage, computer failure or malfunction, or any and all
++      other commercial damages or losses), even if such Contributor
++      has been advised of the possibility of such damages.
++
++   9. Accepting Warranty or Additional Liability. While redistributing
++      the Work or Derivative Works thereof, You may choose to offer,
++      and charge a fee for, acceptance of support, warranty, indemnity,
++      or other liability obligations and/or rights consistent with this
++      License. However, in accepting such obligations, You may act only
++      on Your own behalf and on Your sole responsibility, not on behalf
++      of any other Contributor, and only if You agree to indemnify,
++      defend, and hold each Contributor harmless for any liability
++      incurred by, or claims asserted against, such Contributor by reason
++      of your accepting any such warranty or additional liability.
++
++   END OF TERMS AND CONDITIONS
++
++   APPENDIX: How to apply the Apache License to your work.
++
++      To apply the Apache License to your work, attach the following
++      boilerplate notice, with the fields enclosed by brackets "[]"
++      replaced with your own identifying information. (Don't include
++      the brackets!)  The text should be enclosed in the appropriate
++      comment syntax for the file format. We also recommend that a
++      file or class name and description of purpose be included on the
++      same "printed page" as the copyright notice for easier
++      identification within third-party archives.
++
++   Copyright [yyyy] [name of copyright owner]
++
++   Licensed under the Apache License, Version 2.0 (the "License");
++   you may not use this file except in compliance with the License.
++   You may obtain a copy of the License at
++
++       http://www.apache.org/licenses/LICENSE-2.0
++
++   Unless required by applicable law or agreed to in writing, software
++   distributed under the License is distributed on an "AS IS" BASIS,
++   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++   See the License for the specific language governing permissions and
++   limitations under the License.
+diff --git a/external/liblhdcv5dec/MODULE_LICENSE_APACHE2 b/external/liblhdcv5dec/MODULE_LICENSE_APACHE2
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcv5dec/NOTICE b/external/liblhdcv5dec/NOTICE
+new file mode 100644
+index 000000000..ea044d3be
+--- /dev/null
++++ b/external/liblhdcv5dec/NOTICE
+@@ -0,0 +1,27 @@
++/******************************************************************************
++ *
++ * Copyright (C) 2015 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at:
++ *
++ * http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ *
++ *****************************************************************************
++ * Originally developed and contributed by Ittiam Systems Pvt. Ltd, Bangalore
++ */
++
++---------------
++ Certification
++---------------
++   Taking the certification process is required to use LHDC in your products.
++   For the detail of certification process, see the following URL:
++      https://www.savitech.co/
++
+diff --git a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
+new file mode 100644
+index 000000000..0785b9fe2
+--- /dev/null
++++ b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
+@@ -0,0 +1,69 @@
++#ifndef _LHDCV5BT_DEC_H_
++#define _LHDCV5BT_DEC_H_
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++#include "lhdcv5_util_dec.h"
++
++#define LHDCV5BT_SAMPLE_RATE_44K    (44100)
++#define LHDCV5BT_SAMPLE_RATE_48K    (48000)
++#define LHDCV5BT_SAMPLE_RATE_96K    (96000)
++#define LHDCV5BT_SAMPLE_RATE_192K   (192000)
++
++#define LHDCV5BT_BIT_DEPTH_16    (16)
++#define LHDCV5BT_BIT_DEPTH_24    (24)
++#define LHDCV5BT_BIT_DEPTH_32    (32)
++
++#define LHDCV5BT_BIT_RATE_64K    (64000)
++#define LHDCV5BT_BIT_RATE_128K   (128000)
++#define LHDCV5BT_BIT_RATE_192K   (192000)
++#define LHDCV5BT_BIT_RATE_256K   (256000)
++#define LHDCV5BT_BIT_RATE_320K   (320000)
++#define LHDCV5BT_BIT_RATE_400K   (400000)
++#define LHDCV5BT_BIT_RATE_600K   (600000)
++#define LHDCV5BT_BIT_RATE_900K   (900000)
++#define LHDCV5BT_BIT_RATE_1000K  (1000000)
++
++
++
++typedef struct
++{
++  lhdc_ver_t version;
++  uint32_t sample_rate;
++  uint32_t bits_depth;
++  uint32_t bit_rate;
++} tLHDCV5_DEC_CONFIG;
++
++
++// lib APIs
++int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config);
++int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
++int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
++int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle);
++
++#define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
++#define LHDCBT_DEC_UPD_SEQ_NO				1
++
++typedef enum __LHDCV5BT_DEC_API_RET__
++{
++  LHDCV5BT_DEC_API_SUCCEED            =  0,
++  LHDCV5BT_DEC_API_FAIL               = -1,
++  LHDCV5BT_DEC_API_INVALID_INPUT      = -2,
++  LHDCV5BT_DEC_API_INVALID_OUTPUT     = -3,
++  LHDCV5BT_DEC_API_INVALID_SEQ_NO     = -4,
++  LHDCV5BT_DEC_API_INIT_DECODER_FAIL  = -5,
++  LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL = -6,
++  LHDCV5BT_DEC_API_FRAME_INFO_FAIL    = -7,
++  LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH   = -8,
++  LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH  = -9,
++  LHDCV5BT_DEC_API_DECODE_FAIL        = -10,
++  LHDCV5BT_DEC_API_ALLOC_MEM_FAIL  = -11,
++
++} LHDCV5BT_DEC_API_RET_T;
++
++
++#ifdef __cplusplus
++}
++#endif
++#endif /* _LHDCBT_DEC_H_ */
+diff --git a/external/liblhdcv5dec/include/lhdcv5_util_dec.h b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
+new file mode 100644
+index 000000000..576d8c5c2
+--- /dev/null
++++ b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
+@@ -0,0 +1,100 @@
++/*
++ * lhdcv5_util_dec.h
++ *
++ */
++
++#ifndef LHDCV5_UTIL_DEC_H
++#define LHDCV5_UTIL_DEC_H
++
++#include <stdbool.h>
++#include <stdint.h>
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++typedef void * HANDLE_LHDCV5_BT;
++
++// Copy definition from external
++#define BTIF_BD_ADDR_SIZE    6
++
++// Define for LHDC stream type.
++typedef enum {
++  LHDC_STRM_TYPE_COMBINE,
++  LHDC_STRM_TYPE_SPLIT
++}LHDC_STRM_TYPE;
++
++typedef enum {
++  VERSION_5 = 550
++}lhdc_ver_t;
++
++typedef enum {
++  LHDCV2_BLOCK_SIZE = 512,
++  LHDCV3_BLOCK_SIZE = 256,
++}lhdc_block_size_t;
++
++typedef struct savi_bt_local_info_t{
++  uint8_t bt_addr[BTIF_BD_ADDR_SIZE];
++  const char *bt_name;
++  uint8_t bt_len;
++  uint8_t ble_addr[BTIF_BD_ADDR_SIZE];
++  const char *ble_name;
++  uint8_t ble_len;
++}savi_bt_local_info;
++
++typedef struct _lhdc_frame_Info
++{
++  uint32_t frame_len;
++  uint32_t isSplit;
++  uint32_t isLeft;
++
++} lhdc_frame_Info_t;
++
++
++typedef enum {
++  LHDC_OUTPUT_STEREO = 0,
++  LHDC_OUTPUT_LEFT_CAHNNEL,
++  LHDC_OUTPUT_RIGHT_CAHNNEL,
++} lhdc_channel_t;
++
++typedef int LHDCSample;
++
++typedef void (*print_log_fp)(char*  msg);
++typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
++
++
++
++#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
++#define A2DP_LHDC_HDR_LATENCY_MID   0x01
++#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
++#define A2DP_LHDC_HDR_LATENCY_MASK  (A2DP_LHDC_HDR_LATENCY_MID | A2DP_LHDC_HDR_LATENCY_HIGH)
++
++#define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
++
++
++int32_t lhdcv5_util_init_decoder(uint32_t *ptr, uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
++
++int32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t InLen, uint32_t *OutLen);
++char *lhdcv5_util_dec_get_version();
++
++int32_t lhdcv5_util_dec_destroy();
++
++void lhdcv5_util_dec_register_log_cb(print_log_fp cb);
++
++int32_t lhdcv5_util_dec_get_sample_size (uint32_t *frame_samples);
++int32_t lhdcv5_util_dec_fetch_frame_info(uint8_t *frameData, uint32_t frameDataLen, lhdc_frame_Info_t *frameInfo);
++
++int32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
++int32_t lhdcv5_util_dec_get_mem_req(lhdc_ver_t version, uint32_t *mem_req_bytes);
++
++//Return
++#define LHDCV5_UTIL_DEC_SUCCESS 0
++#define LHDCV5_UTIL_DEC_ERROR_NO_INIT -1
++#define LHDCV5_UTIL_DEC_ERROR_PARAM -2
++#define LHDCV5_UTIL_DEC_ERROR -3
++#define LHDCV5_UTIL_DEC_ERROR_WRONG_DEC -10
++
++#ifdef __cplusplus
++}
++#endif
++#endif /* End of LHDCV5_UTIL_DEC_H */
+diff --git a/external/liblhdcv5dec/libs/arm64-v8a/.gitkeep b/external/liblhdcv5dec/libs/arm64-v8a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcv5dec/libs/armeabi-v7a/.gitkeep b/external/liblhdcv5dec/libs/armeabi-v7a/.gitkeep
+new file mode 100644
+index 000000000..e69de29bb
+diff --git a/external/liblhdcv5dec/src/lhdcv5BT_dec.c b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
+new file mode 100644
+index 000000000..92f1534d7
+--- /dev/null
++++ b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
+@@ -0,0 +1,409 @@
++#include <stdio.h>
++#include <string.h>
++#include <stdlib.h>
++#include <stdint.h>
++#include <stdbool.h>
++#include "lhdcv5BT_dec.h"
++
++#define LOG_NDEBUG 0
++#define LOG_TAG "lhdcv5BT_dec"
++#include <cutils/log.h>
++
++static uint8_t serial_no = 0xff;
++
++// description
++//   a function to log in LHDC decoder library
++// Parameter
++//   msg: char string to print
++static void print_log_cb(char *msg)
++{
++  if (msg == NULL) {
++    return;
++  }
++
++  ALOGD("[V5Dec_lib] %s", msg);
++}
++
++
++// description
++//   check number of frames in one packet and return pointer to first byte of 1st frame in current packet
++// Parameter
++//   input: pointer to input buffer
++//   input_len: length (bytes) of input buffer pointed by input
++//   pLout: pointer to pointer to output buffer
++//   pLlen: length (bytes) of encoded stream in output buffer
++//   upd_seq_no: sequence number type
++// return:
++//   > 0: number of frames in current packet
++//   == 0: No frames in current packet
++//   < 0: error
++static int32_t assemble_lhdcv5_packet(uint32_t *frame_num, uint8_t *input, uint32_t input_len,
++    uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
++{
++  uint8_t hdr = 0, seqno = 0xff;
++  uint32_t status = 0;
++  uint32_t lhdc_total_frame_nb = 0;
++
++  if ((input == NULL) ||
++      (pLout == NULL) ||
++      (pLlen == NULL)) {
++    ALOGD("%s: null ptr", __func__);
++    return -1;
++  }
++
++  if (input_len < 2) {
++    ALOGD("%s: input len too small", __func__);
++    return -1;
++  }
++
++  hdr = (*input);
++  input++;
++  seqno = (*input);
++  input++;
++  input_len -= 2;
++
++  //Check latency and update value when changed.
++  status = hdr & A2DP_LHDC_HDR_LATENCY_MASK;
++
++  //Get number of frame in packet.
++  status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
++
++  if (status <= 0) {
++    ALOGD("%s: no any frame in packet.", __func__);
++    *frame_num = 0;
++    return 0;
++  }
++
++  lhdc_total_frame_nb = status;
++
++  if (seqno != serial_no) {
++    ALOGD("%s: packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
++    //serial_no = seqno;
++    //return -1;
++  }
++
++  if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO) {
++    serial_no = seqno + 1;
++  }
++
++  *pLlen = input_len;
++  *pLout = input;
++
++  *frame_num = (int) lhdc_total_frame_nb;
++
++  ALOGD("%s: total frame number (%d)", __func__, *frame_num);
++  return 0;
++}
++
++
++// description
++//   init. LHDC V5 decoder
++// Parameter
++//   handle: codec handle(ptr for heap) from bt stack
++//   config: configuration for LHDC V5 decoder
++// return:
++//   == 0: succeed
++//   != 0: error code
++int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config)
++{
++  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
++  uint32_t mem_req_bytes = 0;
++  HANDLE_LHDCV5_BT hLhdcBT = NULL;
++
++  ALOGD("%s: decoder lib version = %s", __func__, lhdcv5_util_dec_get_version());
++
++  if (handle == NULL || config == NULL) {
++    ALOGD("%s: null ptr handle %p config %p", __func__, handle, config);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  ALOGD("%s: bits_depth:%u sample_rate=%u bit_rate=%u version=%d", __func__,
++      config->bits_depth, config->sample_rate, config->bit_rate, config->version);
++
++  if ((config->bits_depth != LHDCV5BT_BIT_DEPTH_16) &&
++      (config->bits_depth != LHDCV5BT_BIT_DEPTH_24) &&
++      (config->bits_depth != LHDCV5BT_BIT_DEPTH_32)) {
++    ALOGD("%s: bits_depth %d not supported", __func__, config->bits_depth);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  if ((config->sample_rate != LHDCV5BT_SAMPLE_RATE_44K) &&
++      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_48K) &&
++      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_96K) &&
++      (config->sample_rate != LHDCV5BT_SAMPLE_RATE_192K)) {
++    ALOGD("%s: sample_rate %d not supported", __func__, config->sample_rate);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  if ((0 > config->bit_rate) || (config->bit_rate > LHDCV5BT_BIT_RATE_1000K)) {
++    ALOGD("%s: bit_rate %d not supported", __func__, config->bit_rate);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  if ((config->version != VERSION_5)) {
++    ALOGD("%s: version %d not supported", __func__, config->version);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  lhdcv5_util_dec_register_log_cb(&print_log_cb);
++
++  func_ret = lhdcv5_util_dec_get_mem_req(config->version, &mem_req_bytes);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS || mem_req_bytes <= 0) {
++    ALOGW("%s: Fail to get required memory size (%d)!", __func__, func_ret);
++    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
++  }
++
++  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
++  if (hLhdcBT == NULL) {
++    ALOGW ("%s: Fail to allocate memory!", __func__);
++    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
++  }
++
++  ALOGD("%s: init lhdcv5 decoder...", __func__);
++  //TODO: send mem_req_bytes for size check
++  func_ret = lhdcv5_util_init_decoder(hLhdcBT, config->bits_depth,
++      config->sample_rate, config->bit_rate, config->version);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGW ("%s: failed to init decoder (%d)!", __func__, func_ret);
++    free(hLhdcBT);
++    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
++  }
++
++  *handle = hLhdcBT;
++  if ((*handle) == NULL) {
++    ALOGW ("%s: handle return NULL!", __func__);
++    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
++  }
++
++  func_ret = lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGW ("%s: failed to configure channel (%d)!", __func__, func_ret);
++    return LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL;
++  }
++
++  serial_no = 0xff;
++
++  ALOGD("%s: init lhdcv5 decoder success", __func__);
++  return LHDCV5BT_DEC_API_SUCCEED;
++}
++
++
++// description
++//   check whether all frames of one packet are in buffer?
++// Parameter
++//   frameData: pointer to input buffer
++//   frameBytes: length (bytes) of input buffer pointed by frameData
++//   packetBytes: return the final number of queued data in decoder lib (for validation)
++// return:
++//   == 0: succeed
++//   < 0: error
++int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData,
++    uint32_t frameBytes, uint32_t *packetBytes)
++{
++  uint8_t *frameDataStart = (uint8_t *)frameData;
++  uint8_t *in_buf = NULL;
++  uint32_t in_len = 0;
++  uint32_t frame_num = 0;
++  lhdc_frame_Info_t lhdc_frame_Info;
++  uint32_t ptr_offset = 0;
++  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
++
++  if ((frameData == NULL) || (packetBytes == NULL)) {
++    return LHDCV5_UTIL_DEC_ERROR_PARAM;
++  }
++
++  *packetBytes = 0;
++
++  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
++      LHDCBT_DEC_NOT_UPD_SEQ_NO);
++  if (func_ret < 0 || in_buf == NULL) {
++    ALOGE("%s: failed setup input buffer", __func__);
++    return LHDCV5BT_DEC_API_FAIL;
++  }
++
++  if (frame_num == 0) {
++    return LHDCV5BT_DEC_API_SUCCEED;
++  }
++
++  ALOGD("%s: incoming frame size(%d), decoding size(%d), total frame num(%d)", __func__,
++      frameBytes, in_len, frame_num);
++
++  ptr_offset = 0;
++
++  while ((frame_num > 0) && (ptr_offset < in_len))
++  {
++    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
++    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
++      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
++    }
++
++    ALOGV("%s: frame_num[%d]: ptr_offset (%d), frame_len (%d)", __func__,
++        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
++
++    if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
++      ALOGD(" %s: frame_num[%d]: Not Enough... ptr_offset(%d), frame_len(%d)",
++          __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
++      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
++    }
++
++    ptr_offset += lhdc_frame_Info.frame_len;
++
++    frame_num--;
++  }
++
++  *packetBytes = ptr_offset;
++
++  return LHDCV5BT_DEC_API_SUCCEED;
++}
++
++
++// description
++//   decode all frames in one packet
++// Parameter
++//   frameData: pointer to input buffer from bt stack
++//   frameBytes: length (bytes) of input buffer pointed by frameData
++//   pcmData: pointer to output buffer to bt stack
++//   pcmBytes: length (bytes) of pcm samples in output buffer
++//   bits_depth: bit per sample
++// return:
++//   == 0: succeed
++//   < 0: error
++int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
++    uint8_t *pcmData, uint32_t *pcmBytes, uint32_t bits_depth)
++{
++  uint8_t *frameDataStart = (uint8_t *)frameData;
++  uint32_t dec_sum = 0;
++  uint32_t lhdc_out_len = 0;
++  uint8_t *in_buf = NULL;   //buffer position to input to decode process
++  uint32_t in_len = 0;
++  uint32_t frame_num = 0;
++  lhdc_frame_Info_t lhdc_frame_Info;
++  uint32_t ptr_offset = 0;
++  uint32_t frame_samples;
++  uint32_t frame_bytes;
++  uint32_t pcmSpaceBytes;
++  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
++
++  ALOGV("%s: enter frameBytes %d", __func__, (int)frameBytes);
++
++  if ((frameData == NULL) ||
++      (pcmData == NULL) ||
++      (pcmBytes == NULL)) {
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  pcmSpaceBytes = *pcmBytes;
++  *pcmBytes = 0;
++
++  /*
++  if(frameBytes >= 16) {
++    for(int i=0; i<16; i++) {
++      ALOGD(" %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
++    }
++  } else {
++    for(int i=0; i<(int)frameBytes; i++) {
++      ALOGD(" %s: dumpFrame[%d]= 0x%02X", __func__, i, (int)*(frameDataStart+i));
++    }
++  }
++   */
++
++  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
++      LHDCBT_DEC_UPD_SEQ_NO);
++  if (func_ret < 0 || in_buf == NULL) {
++    ALOGE("%s: failed setup input buffer", __func__);
++    return LHDCV5BT_DEC_API_FAIL;
++  }
++
++  if (frame_num == 0) {
++    return LHDCV5BT_DEC_API_SUCCEED;
++  }
++
++  func_ret = lhdcv5_util_dec_get_sample_size(&frame_samples);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGD("%s: fetch frame samples failed (%d)", __func__, func_ret);
++    return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
++  }
++  ALOGV("%s: output frame samples %d", __func__, (int)frame_samples);
++
++  if (bits_depth == LHDCV5BT_BIT_DEPTH_16) {
++    frame_bytes = frame_samples * 2 * 2;
++  } else {
++    // 24 or 32
++    frame_bytes = frame_samples * 4 * 2;
++  }
++
++  ptr_offset = 0;
++  dec_sum = 0;
++
++  while ((frame_num > 0) && (ptr_offset < in_len))
++  {
++    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
++    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
++      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
++    }
++
++    if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
++      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
++    }
++
++    if ((dec_sum + frame_bytes) > pcmSpaceBytes) {
++      return LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH;
++    }
++
++    //ALOGD("%s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
++    func_ret = lhdcv5_util_dec_process(
++        ((uint8_t *)pcmData) + dec_sum,
++        in_buf + ptr_offset,
++        lhdc_frame_Info.frame_len,
++        &lhdc_out_len);
++    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++      ALOGD("%s: decode fail (%d)", __func__, func_ret);
++      return LHDCV5BT_DEC_API_DECODE_FAIL;
++    }
++
++    ALOGD("%s: frame_num[%d]: input_frame_len %d output_len %d", __func__,
++        (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
++
++    ptr_offset += lhdc_frame_Info.frame_len;
++    dec_sum += lhdc_out_len;
++
++    frame_num--;
++  }
++
++  *pcmBytes = (uint32_t) dec_sum;
++
++  return LHDCV5BT_DEC_API_SUCCEED;
++}
++
++
++// description
++//   de-initialize (free) all resources allocated by LHDC V5 decoder
++// Parameter
++//   none
++// return:
++//   == 0: success
++int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle)
++{
++  int32_t func_ret = 0;
++
++  if(handle == NULL) {
++    ALOGD("%s: empty handle", __func__);
++    return LHDCV5BT_DEC_API_SUCCEED;
++  }
++
++  func_ret = lhdcv5_util_dec_destroy();
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGD("%s: deinit decoder error (%d)", __func__, func_ret);
++    return LHDCV5BT_DEC_API_FAIL;
++  }
++
++  if(handle) {
++    ALOGD ("%s: free handle %p!", __func__, handle);
++    free(handle);
++  }
++
++  return LHDCV5BT_DEC_API_SUCCEED;
++}
++
+diff --git a/frameworks_base/core/api/current.txt b/frameworks_base/core/api/current.txt
+index 1dd401d04..9b9a9a9a2 100644
+--- a/frameworks_base/core/api/current.txt
++++ b/frameworks_base/core/api/current.txt
+@@ -8628,7 +8628,14 @@ package android.bluetooth {
+     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public java.util.List<android.bluetooth.BluetoothDevice> getConnectedDevices();
+     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public int getConnectionState(android.bluetooth.BluetoothDevice);
+     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public java.util.List<android.bluetooth.BluetoothDevice> getDevicesMatchingConnectionStates(int[]);
++    method @Nullable public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
++    method @Nullable public int getLhdcCodecExtendApiConfigAr(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
++    method @Nullable public int getLhdcCodecExtendApiConfigMeta(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
++    method @Nullable public int getLhdcCodecExtendApiVer(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+     method @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public boolean isA2dpPlaying(android.bluetooth.BluetoothDevice);
++    method @Nullable public int setLhdcCodecExtendApiConfigAr(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
++    method @Nullable public int setLhdcCodecExtendApiConfigMeta(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
++    method @Nullable public void setLhdcCodecExtendApiDataGyro2D(@NonNull android.bluetooth.BluetoothDevice, @NonNull byte[]);
+     field @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public static final String ACTION_CONNECTION_STATE_CHANGED = "android.bluetooth.a2dp.profile.action.CONNECTION_STATE_CHANGED";
+     field @RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT) public static final String ACTION_PLAYING_STATE_CHANGED = "android.bluetooth.a2dp.profile.action.PLAYING_STATE_CHANGED";
+     field public static final int STATE_NOT_PLAYING = 11; // 0xb
+@@ -35392,6 +35399,7 @@ package android.provider {
+     field @Deprecated public static final String ALLOW_MOCK_LOCATION = "mock_location";
+     field public static final String ANDROID_ID = "android_id";
+     field @Deprecated public static final String BACKGROUND_DATA = "background_data";
++    field @Deprecated public static final String BLUETOOTH_A2DP_SINK = "bluetooth_a2dp_sink";
+     field @Deprecated public static final String BLUETOOTH_ON = "bluetooth_on";
+     field public static final android.net.Uri CONTENT_URI;
+     field @Deprecated public static final String DATA_ROAMING = "data_roaming";
+@@ -35486,6 +35494,7 @@ package android.provider {
+     field @Deprecated public static final String ANIMATOR_DURATION_SCALE = "animator_duration_scale";
+     field @Deprecated public static final String AUTO_TIME = "auto_time";
+     field @Deprecated public static final String AUTO_TIME_ZONE = "auto_time_zone";
++    field @Deprecated public static final String BLUETOOTH_A2DP_SINK = "bluetooth_a2dp_sink";
+     field public static final String BLUETOOTH_DISCOVERABILITY = "bluetooth_discoverability";
+     field public static final String BLUETOOTH_DISCOVERABILITY_TIMEOUT = "bluetooth_discoverability_timeout";
+     field @Deprecated public static final String BLUETOOTH_ON = "bluetooth_on";
+diff --git a/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java b/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java
+index 1dd32fec2..56ef441e1 100644
+--- a/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java
++++ b/frameworks_base/core/java/android/bluetooth/BluetoothA2dp.java
+@@ -792,6 +792,159 @@ public final class BluetoothA2dp implements BluetoothProfile {
+         }
+     }
+ 
++    //LHDC Extended Function APIs Start
++    @Nullable
++    public int getLhdcCodecExtendApiVer(@NonNull BluetoothDevice device,
++                                        @NonNull byte[] exApiVer) {
++        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiVer(" + device + ")");
++        verifyDeviceNotNull(device, "setCodecConfigPreference");
++        if (exApiVer == null) {
++            Log.e(TAG, "exApiVer can't be null");
++            throw new IllegalArgumentException("codecConfig cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                return service.getLhdcCodecExtendApiVer(device, exApiVer);
++            }
++            if (service == null) Log.w(TAG, "Proxy not attached to service");
++            return -1;
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++            return -1;
++        }
++    }
++
++    @Nullable
++    public int setLhdcCodecExtendApiConfigAr(@NonNull BluetoothDevice device, 
++                                             @NonNull byte[] codecConfig) {
++        if (DBG) Log.d(TAG, "setLhdcCodecExtendApiConfigAr(" + device + ")");
++        verifyDeviceNotNull(device, "setLhdcCodecExtendApiConfigAr");
++        if (codecConfig == null) {
++            Log.e(TAG, "codecConfig can't be null");
++            throw new IllegalArgumentException("codecConfig cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                return service.setLhdcCodecExtendApiConfigAr(device, codecConfig);
++            }
++            if (service == null) Log.w(TAG, "Proxy not attached to service");
++            return -1;
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++            return -1;
++        }
++    }
++
++    @Nullable
++    public int getLhdcCodecExtendApiConfigAr(@NonNull BluetoothDevice device,
++                                             @NonNull byte[] codecConfig) {
++        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiConfigAr(" + device + ")");
++        verifyDeviceNotNull(device, "getLhdcCodecExtendApiConfigAr");
++        if (codecConfig == null) {
++            Log.e(TAG, "codecConfig can't be null");
++            throw new IllegalArgumentException("codecConfig cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                return service.getLhdcCodecExtendApiConfigAr(device, codecConfig);
++            }
++            if (service == null) Log.w(TAG, "Proxy not attached to service");
++            return -1;
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++            return -1;
++        }
++    }
++
++    @Nullable
++    public int setLhdcCodecExtendApiConfigMeta(@NonNull BluetoothDevice device,
++                                               @NonNull byte[] codecConfig) {
++        if (DBG) Log.d(TAG, "setLhdcCodecExtendApiConfigMeta(" + device + ")");
++        verifyDeviceNotNull(device, "setLhdcCodecExtendApiConfigMeta");
++        if (codecConfig == null) {
++            Log.e(TAG, "codecConfig can't be null");
++            throw new IllegalArgumentException("codecConfig cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                return service.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
++            }
++            if (service == null) Log.w(TAG, "Proxy not attached to service");
++            return -1;
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++            return -1;
++        }
++    }
++
++    @Nullable
++    public int getLhdcCodecExtendApiConfigMeta(@NonNull BluetoothDevice device,
++                                               @NonNull byte[] codecConfig) {
++        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiConfigMeta(" + device + ")");
++        verifyDeviceNotNull(device, "getLhdcCodecExtendApiConfigMeta");
++        if (codecConfig == null) {
++            Log.e(TAG, "codecConfig can't be null");
++            throw new IllegalArgumentException("codecConfig cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                return service.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
++            }
++            if (service == null) Log.w(TAG, "Proxy not attached to service");
++            return -1;
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++            return -1;
++        }
++    }
++
++    @Nullable 
++    public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(@NonNull BluetoothDevice device, 
++                                                            @NonNull byte[] codecConfig) {
++        if (DBG) Log.d(TAG, "getLhdcCodecExtendApiConfigA2dpCodecSpecific(" + device + ")");
++        verifyDeviceNotNull(device, "getLhdcCodecExtendApiConfigA2dpCodecSpecific");
++        if (codecConfig == null) {
++            Log.e(TAG, "codecConfig can't be null");
++            throw new IllegalArgumentException("codecConfig cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                return service.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
++            }
++            if (service == null) Log.w(TAG, "Proxy not attached to service");
++            return -1;
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++            return -1;
++        }
++    }
++
++    @Nullable
++    public void setLhdcCodecExtendApiDataGyro2D(@NonNull BluetoothDevice device,
++                                                @NonNull byte[] codecData) {
++        if (DBG) Log.d(TAG, "setLhdcCodecExtendApiDataGyro2D(" + device + ")");
++        verifyDeviceNotNull(device, "setLhdcCodecExtendApiDataGyro2D");
++        if (codecData == null) {
++            Log.e(TAG, "codecData can't be null");
++            throw new IllegalArgumentException("codecData cannot be null");
++        }
++        try {
++            final IBluetoothA2dp service = getService();
++            if (service != null && isEnabled()) {
++                service.setLhdcCodecExtendApiDataGyro2D(device, codecData);
++            }
++        } catch (RemoteException e) {
++            Log.e(TAG, "Error talking to BT service", e);
++        }
++    }
++    //LHDC Extended Function APIs End
++
+     /**
+      * Enables the optional codecs.
+      *
+diff --git a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
+index 1d0bf97c3..9f4d953fe 100644
+--- a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
++++ b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
+@@ -46,6 +46,9 @@ public final class BluetoothCodecConfig implements Parcelable {
+             SOURCE_CODEC_TYPE_APTX,
+             SOURCE_CODEC_TYPE_APTX_HD,
+             SOURCE_CODEC_TYPE_LDAC,
++            SOURCE_CODEC_TYPE_LHDCV3,
++            SOURCE_CODEC_TYPE_LHDCV2,
++            SOURCE_CODEC_TYPE_LHDCV5,
+             SOURCE_CODEC_TYPE_MAX,
+             SOURCE_CODEC_TYPE_INVALID
+     })
+@@ -67,8 +70,19 @@ public final class BluetoothCodecConfig implements Parcelable {
+     @UnsupportedAppUsage
+     public static final int SOURCE_CODEC_TYPE_LDAC = 4;
+ 
++    // Savitech LHDC -- START
+     @UnsupportedAppUsage
+-    public static final int SOURCE_CODEC_TYPE_MAX = 5;
++    public static final int SOURCE_CODEC_TYPE_LHDCV3 = 5;
++
++    @UnsupportedAppUsage
++    public static final int SOURCE_CODEC_TYPE_LHDCV2 = 6;
++
++    @UnsupportedAppUsage
++    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 7;
++    // Savitech LHDC -- END
++
++    @UnsupportedAppUsage
++    public static final int SOURCE_CODEC_TYPE_MAX = 8;
+ 
+     @UnsupportedAppUsage
+     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
+@@ -403,6 +417,13 @@ public final class BluetoothCodecConfig implements Parcelable {
+                 return "aptX HD";
+             case SOURCE_CODEC_TYPE_LDAC:
+                 return "LDAC";
++            // Savitech LHDC -- START
++            case SOURCE_CODEC_TYPE_LHDCV2:
++                return "LHDC V2";
++            case SOURCE_CODEC_TYPE_LHDCV3:
++                return "LHDC V3";
++            case SOURCE_CODEC_TYPE_LHDCV5:
++                return "LHDC V5";
+             case SOURCE_CODEC_TYPE_INVALID:
+                 return "INVALID CODEC";
+             default:
+@@ -598,7 +619,10 @@ public final class BluetoothCodecConfig implements Parcelable {
+     public boolean sameAudioFeedingParameters(BluetoothCodecConfig other) {
+         return (other != null && other.mSampleRate == mSampleRate
+                 && other.mBitsPerSample == mBitsPerSample
+-                && other.mChannelMode == mChannelMode);
++                && other.mChannelMode == mChannelMode
++                && other.mCodecSpecific1 == mCodecSpecific1
++                && other.mCodecSpecific2 == mCodecSpecific2
++                && other.mCodecSpecific3 == mCodecSpecific3);
+     }
+ 
+     /**
+@@ -652,6 +676,16 @@ public final class BluetoothCodecConfig implements Parcelable {
+                 if (mCodecSpecific1 != other.mCodecSpecific1) {
+                     return false;
+                 }
++                return true;
++            // LHDC: Playback Quality at CodecSpecific1, Low Latency at CodecSpecific2; other feature flags at CodecSpecific3.
++            case SOURCE_CODEC_TYPE_LHDCV2:
++            case SOURCE_CODEC_TYPE_LHDCV3:
++            case SOURCE_CODEC_TYPE_LHDCV5:
++                if (mCodecSpecific1 != other.mCodecSpecific1 ||
++                    mCodecSpecific2 != other.mCodecSpecific2 ||
++                    mCodecSpecific3 != other.mCodecSpecific3) {
++                    return false;
++                }
+                 // fall through
+             default:
+                 return true;
+diff --git a/frameworks_base/core/java/android/provider/Settings.java b/frameworks_base/core/java/android/provider/Settings.java
+index 54952fc2d..289780712 100644
+--- a/frameworks_base/core/java/android/provider/Settings.java
++++ b/frameworks_base/core/java/android/provider/Settings.java
+@@ -5415,6 +5415,13 @@ public final class Settings {
+         @Deprecated
+         public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
+ 
++        /**
++         * Savitech Add - A2DP_Source_Sink_Switch
++         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_A2DP_SINK} instead
++         */
++        @Deprecated
++        public static final String BLUETOOTH_A2DP_SINK = Global.BLUETOOTH_A2DP_SINK;
++
+         /**
+          * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
+          */
+@@ -5696,6 +5703,7 @@ public final class Settings {
+             MOVED_TO_GLOBAL.add(Settings.Global.ADB_ENABLED);
+             MOVED_TO_GLOBAL.add(Settings.Global.ASSISTED_GPS_ENABLED);
+             MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_ON);
++            MOVED_TO_GLOBAL.add(Settings.Global.BLUETOOTH_A2DP_SINK);	// Savitech Add -- A2DP_Source_Sink_Switch
+             MOVED_TO_GLOBAL.add(Settings.Global.BUGREPORT_IN_POWER_MENU);
+             MOVED_TO_GLOBAL.add(Settings.Global.CDMA_CELL_BROADCAST_SMS);
+             MOVED_TO_GLOBAL.add(Settings.Global.CDMA_ROAMING_MODE);
+@@ -6438,6 +6446,13 @@ public final class Settings {
+          */
+         @Deprecated
+         public static final String BLUETOOTH_ON = Global.BLUETOOTH_ON;
++        
++        /**
++         * Savitech Add - A2DP_Source_Sink_Switch
++         * @deprecated Use {@link android.provider.Settings.Global#BLUETOOTH_A2DP_SINK} instead
++         */
++        @Deprecated
++        public static final String BLUETOOTH_A2DP_SINK = Global.BLUETOOTH_A2DP_SINK;
+ 
+         /**
+          * @deprecated Use {@link android.provider.Settings.Global#DATA_ROAMING} instead
+@@ -10741,6 +10756,14 @@ public final class Settings {
+         @Readable
+         public static final String BLUETOOTH_ON = "bluetooth_on";
+ 
++        /**
++         * Savitech Add - A2DP_Source_Sink_Switch
++         * Whether bluetooth A2DP is initialized as Source or Sink
++         * @hide
++         */
++        @Readable
++        public static final String BLUETOOTH_A2DP_SINK = "bluetooth_a2dp_sink";
++
+         /**
+          * CDMA Cell Broadcast SMS
+          *                            0 = CDMA Cell Broadcast SMS disabled
+diff --git a/frameworks_base/media/java/android/media/AudioManager.java b/frameworks_base/media/java/android/media/AudioManager.java
+index 38f9607c9..e985855dd 100644
+--- a/frameworks_base/media/java/android/media/AudioManager.java
++++ b/frameworks_base/media/java/android/media/AudioManager.java
+@@ -6844,6 +6844,15 @@ public class AudioManager {
+             int btSourceCodec = AudioSystem.audioFormatToBluetoothSourceCodec(format);
+             if (btSourceCodec
+                     != BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID) {
++                // Savitech Patch - START  Offload
++                // Add all LHDC series codecs to offload path
++                /*
++                if (btSourceCodec == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2));
++                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3));
++                }
++                */
++                // Savitech Patch - END
+                 codecConfigList.add(new BluetoothCodecConfig(btSourceCodec));
+             }
+         }
+diff --git a/frameworks_base/media/java/android/media/AudioSystem.java b/frameworks_base/media/java/android/media/AudioSystem.java
+index 6ff551a68..dd8ca8181 100644
+--- a/frameworks_base/media/java/android/media/AudioSystem.java
++++ b/frameworks_base/media/java/android/media/AudioSystem.java
+@@ -230,6 +230,12 @@ public class AudioSystem
+     public static final int AUDIO_FORMAT_APTX_HD        = 0x21000000;
+     /** @hide */
+     public static final int AUDIO_FORMAT_LDAC           = 0x23000000;
++    // Savitech Patch - START  Offload
++    /** @hide */
++    //public static final int AUDIO_FORMAT_LHDC           = 0x28000000;
++    /** @hide */
++    //public static final int AUDIO_FORMAT_LHDC_LL        = 0x29000000;
++    // Savitech Patch - END
+ 
+     /** @hide */
+     @IntDef(flag = false, prefix = "AUDIO_FORMAT_", value = {
+@@ -239,7 +245,10 @@ public class AudioSystem
+             AUDIO_FORMAT_SBC,
+             AUDIO_FORMAT_APTX,
+             AUDIO_FORMAT_APTX_HD,
+-            AUDIO_FORMAT_LDAC }
++            AUDIO_FORMAT_LDAC,
++            //AUDIO_FORMAT_LHDC,    // Savitech Patch - START  Offload
++            //AUDIO_FORMAT_LHDC_LL,
++            }
+     )
+     @Retention(RetentionPolicy.SOURCE)
+     public @interface AudioFormatNativeEnumForBtCodec {}
+@@ -256,6 +265,14 @@ public class AudioSystem
+             case AUDIO_FORMAT_APTX: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX;
+             case AUDIO_FORMAT_APTX_HD: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD;
+             case AUDIO_FORMAT_LDAC: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
++            // Savitech Patch - START  Offload
++            /*
++            case AUDIO_FORMAT_LHDC:
++                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
++            case AUDIO_FORMAT_LHDC_LL:
++                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
++            */
++            // Savitech Patch - END
+             default:
+                 Log.e(TAG, "Unknown audio format 0x" + Integer.toHexString(audioFormat)
+                         + " for conversion to BT codec");
+@@ -281,6 +298,16 @@ public class AudioSystem
+                 return AudioSystem.AUDIO_FORMAT_APTX_HD;
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
+                 return AudioSystem.AUDIO_FORMAT_LDAC;
++            // Savitech Patch - START  Offload
++            /*
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
++                return AudioSystem.AUDIO_FORMAT_LHDC;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
++                return AudioSystem.AUDIO_FORMAT_LHDC;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
++                return AudioSystem.AUDIO_FORMAT_LHDC;
++            */
++            // Savitech Patch - END
+             default:
+                 Log.e(TAG, "Unknown BT codec 0x" + Integer.toHexString(btCodec)
+                         + " for conversion to audio format");
+diff --git a/frameworks_base/packages/SettingsLib/res/values/arrays.xml b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
+index 2b5e9cdc0..cd7f9d29f 100644
+--- a/frameworks_base/packages/SettingsLib/res/values/arrays.xml
++++ b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
+@@ -154,6 +154,11 @@
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
+         <item>LDAC</item>
++        <!-- Savitech Patch - START -->
++        <item>Savitech LHDC V2</item>
++        <item>Savitech LHDC V3/V4</item>
++        <item>Savitech LHDC-V</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Values for Bluetooth Audio Codec selection preference. -->
+@@ -164,6 +169,11 @@
+         <item>2</item>
+         <item>3</item>
+         <item>4</item>
++        <!-- Savitech Patch - START -->
++        <item>5</item>
++        <item>6</item>
++        <item>7</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Summaries for Bluetooth Audio Codec selection preference. [CHAR LIMIT=50]-->
+@@ -174,6 +184,11 @@
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
+         <item>LDAC</item>
++        <!-- Savitech Patch - START -->
++        <item>Savitech LHDC V2</item>
++        <item>Savitech LHDC V3/V4</item>
++        <item>Savitech LHDC-V</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Titles for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50] -->
+@@ -183,6 +198,10 @@
+         <item>48.0 kHz</item>
+         <item>88.2 kHz</item>
+         <item>96.0 kHz</item>
++        <!-- Savitech Patch - START -->
++        <item>176.4 kHz</item>
++        <item>192.0 kHz</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Values for Bluetooth Audio Codec Sample Rate selection preference. -->
+@@ -192,6 +211,10 @@
+         <item>2</item>
+         <item>4</item>
+         <item>8</item>
++        <!-- Savitech Patch - START -->
++        <item>16</item>
++        <item>32</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Summaries for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50]-->
+@@ -201,6 +224,10 @@
+         <item>48.0 kHz</item>
+         <item>88.2 kHz</item>
+         <item>96.0 kHz</item>
++        <!-- Savitech Patch - START -->
++        <item>176.4 kHz</item>
++        <item>192.0 kHz</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Titles for Bluetooth Audio Codec Bits Per Sample selection preference. [CHAR LIMIT=50] -->
+@@ -272,6 +299,103 @@
+         <item>Best Effort (Adaptive Bit Rate)</item>
+     </string-array>
+ 
++    <!-- Titles for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70] -->
++    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_titles" translatable="false" >
++        <item>Optimized for Connection Quality (64kbps)</item>
++        <item>Optimized for Connection Quality (128kbps)</item>
++        <item>Optimized for Connection Quality (192kbps)</item>
++        <item>Optimized for Connection Quality (256kbps)</item>
++        <item>Optimized for Connection Quality (320kbps)</item>
++        <item>Optimized for Connection Quality (400kbps)</item>
++        <item>Balanced Audio And Connection Quality (500kbps)</item>
++        <item>High Audio Quality (900kbps)</item>
++        <item>Extremely High Audio Quality (1000kbps)</item>
++        <item>Best Effort (Auto Bit Rate)</item>
++    </string-array>
++
++    <!-- Values for Bluetooth Audio Codec LHDC Playback Quaility selection preference. -->
++    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_values" translatable="false" >
++        <item>32768</item>
++        <item>32769</item>
++        <item>32770</item>
++        <item>32771</item>
++        <item>32772</item>
++        <item>32773</item>
++        <item>32774</item>
++        <item>32775</item>
++        <item>32776</item>
++        <item>32777</item>
++    </string-array>
++
++    <!-- Summaries for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70]-->
++    <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_summaries" translatable="false" >
++        <item>Optimized for Connection Quality (64kbps)</item>
++        <item>Optimized for Connection Quality (128kbps)</item>
++        <item>Optimized for Connection Quality (192kbps)</item>
++        <item>Optimized for Connection Quality (256kbps)</item>
++        <item>Optimized for Connection Quality (320kbps)</item>
++        <item>Optimized for Connection Quality (400kbps)</item>
++        <item>Balanced Audio And Connection Quality</item>
++        <item>High Audio Quality</item>
++        <item>Extremely High Audio Quality</item>
++        <item>Best Effort (Auto Bit Rate)</item>
++    </string-array>
++
++    <!-- Titles for Bluetooth Audio Codec LHDC Low Latency selection preference. [CHAR LIMIT=70] -->
++    <string-array name="bluetooth_a2dp_codec_lhdc_latency_titles" translatable="false" >
++        <item>Low Latency Mode Disable</item>
++        <item>Low Latency Mode Enable</item>
++    </string-array>
++
++    <!-- Values for Bluetooth Audio Codec LHDC Latency selection preference. -->
++    <string-array name="bluetooth_a2dp_codec_lhdc_latency_values" translatable="false" >
++        <item>49152</item>
++        <item>49153</item>
++    </string-array>
++
++    <!-- Summaries for Bluetooth Audio Codec LHDC Latency selection preference. [CHAR LIMIT=70]-->
++    <string-array name="bluetooth_a2dp_codec_lhdc_latency_summaries" translatable="false" >
++        <item>Low Latency OFF</item>
++        <item>Low Latency ON</item>
++    </string-array>
++
++    <!-- Titles for Bluetooth Audio Codec LHDC 3DAR Effect selection preference. [CHAR LIMIT=70] -->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles" translatable="false" >
++        <item>OFF</item>
++        <item>ON</item>
++    </string-array>
++
++    <!-- Values for Bluetooth Audio Codec LHDC AR Effect selection preference -->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" translatable="false" >
++        <item>0</item>
++        <item>2</item>
++    </string-array>
++
++    <!-- Summaries for Bluetooth Audio Codec LHDC AR Effect selection preference [CHAR LIMIT=70]-->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries" translatable="false" >
++        <item>LHDC 3DAR Effect OFF</item>
++        <item>LHDC 3DAR Effect ON</item>
++    </string-array>
++
++    <!-- Titles for Bluetooth Audio Codec LHDC Lossless selection preference. [CHAR LIMIT=70] -->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_titles" translatable="false" >
++        <item>OFF</item>
++        <item>ON</item>
++    </string-array>
++
++    <!-- Values for Bluetooth Audio Codec LHDC Lossless selection preference -->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_values" translatable="false" >
++        <item>0</item>
++        <item>2</item>
++    </string-array>
++
++    <!-- Summaries for Bluetooth Audio Codec LHDC Lossless selection preference [CHAR LIMIT=70]-->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_summaries" translatable="false" >
++        <item>LHDC Lossless OFF</item>
++        <item>LHDC Lossless ON</item>
++    </string-array>
++    <!-- Savitech Patch - END -->
++
+     <!-- Summaries for Android Auto Bluetooth Audio Active Device status. [CHAR LIMIT=50]-->
+     <string-array name="bluetooth_audio_active_device_summaries" >
+         <!-- Status message when the device is not Active. -->
+diff --git a/frameworks_base/packages/SettingsLib/res/values/strings.xml b/frameworks_base/packages/SettingsLib/res/values/strings.xml
+index 6b840bd79..954dcb725 100644
+--- a/frameworks_base/packages/SettingsLib/res/values/strings.xml
++++ b/frameworks_base/packages/SettingsLib/res/values/strings.xml
+@@ -704,6 +704,30 @@
+     <!-- UI debug setting: Select Bluetooth Audio LDAC Codec: LDAC Playback Quality -->
+     <string name="bluetooth_select_a2dp_codec_ldac_playback_quality_dialog_title">Trigger Bluetooth Audio LDAC\u000ACodec Selection: Playback Quality</string>
+ 
++    <!-- Savitech LHDC - START -->
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Playback Quality -->
++    <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality">Bluetooth Audio LHDC Codec: Playback Quality</string>
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
++    <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality_dialog_title">Select Bluetooth Audio LHDC Codec:\u000APlayback Quality</string>
++
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Low Latency -->
++    <string name="bluetooth_select_a2dp_codec_lhdc_latency">Bluetooth Audio LHDC Codec: Low Latency</string>
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency -->
++    <string name="bluetooth_select_a2dp_codec_lhdc_latency_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALatency</string>
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency Summary -->
++    <string name="bluetooth_select_a2dp_codec_lhdc_latency_summary">LHDC Codec:\u000ALow Latency</string>
++
++    <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect -->
++    <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect">Enable LHDC 3DAR Effect</string>
++    <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect: LHDC AR Audio -->
++    <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title">Select Bluetooth Audio LHDC Codec:\u000AAR Audio</string>
++
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless -->
++    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless">Enable LHDC Lossless</string>
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless: LHDC Lossless Audio -->
++    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALossless Audio</string>
++    <!-- Savitech LHDC - END -->
++
+     <!-- [CHAR LIMIT=NONE] Label for displaying Bluetooth Audio Codec Parameters while streaming -->
+     <string name="bluetooth_select_a2dp_codec_streaming_label">Streaming: <xliff:g id="streaming_parameter">%1$s</xliff:g></string>
+ 
+diff --git a/frameworks_base/packages/SettingsProvider/res/values/defaults.xml b/frameworks_base/packages/SettingsProvider/res/values/defaults.xml
+index 8e6e251ff..d42ba16ca 100644
+--- a/frameworks_base/packages/SettingsProvider/res/values/defaults.xml
++++ b/frameworks_base/packages/SettingsProvider/res/values/defaults.xml
+@@ -35,8 +35,9 @@
+     <fraction name="def_window_animation_scale">100%</fraction>
+     <fraction name="def_window_transition_scale">100%</fraction>
+     <bool name="def_haptic_feedback">true</bool>
+-
+     <bool name="def_bluetooth_on">true</bool>
++    <!-- Savitech Add A2DP_Source_Sink_Switch -->
++    <bool name="def_bluetooth_a2dp_sink">false</bool>
+     <bool name="def_wifi_display_on">false</bool>
+     <bool name="def_install_non_market_apps">false</bool>
+     <!-- 0 == off, 3 == on -->
+diff --git a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java
+index db33c3f2c..0c28a4764 100644
+--- a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java
++++ b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/backup/GlobalSettings.java
+@@ -63,6 +63,7 @@ public class GlobalSettings {
+         Settings.Global.LOW_POWER_MODE_STICKY_AUTO_DISABLE_ENABLED,
+         Settings.Global.LOW_POWER_MODE_STICKY_AUTO_DISABLE_LEVEL,
+         Settings.Global.BLUETOOTH_ON,
++        Settings.Global.BLUETOOTH_A2DP_SINK, //Savitech Add - A2DP_Source_Sink_Switch
+         Settings.Global.PRIVATE_DNS_MODE,
+         Settings.Global.PRIVATE_DNS_SPECIFIER,
+         Settings.Global.SOFT_AP_TIMEOUT_ENABLED,
+diff --git a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java
+index d0448ef63..55ddc7e55 100644
+--- a/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java
++++ b/frameworks_base/packages/SettingsProvider/src/android/provider/settings/validators/GlobalSettingsValidators.java
+@@ -114,6 +114,10 @@ public class GlobalSettingsValidators {
+         VALIDATORS.put(
+                 Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, PERCENTAGE_INTEGER_VALIDATOR);
+         VALIDATORS.put(Global.BLUETOOTH_ON, BOOLEAN_VALIDATOR);
++
++        //Savitech Add -- A2DP_Source_Sink_Switch
++        VALIDATORS.put(Global.BLUETOOTH_A2DP_SINK, BOOLEAN_VALIDATOR);
++
+         VALIDATORS.put(Global.PRIVATE_DNS_MODE, ANY_STRING_VALIDATOR);
+         VALIDATORS.put(Global.PRIVATE_DNS_SPECIFIER, ANY_STRING_VALIDATOR);
+         VALIDATORS.put(Global.SOFT_AP_TIMEOUT_ENABLED, BOOLEAN_VALIDATOR);
+diff --git a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+index 268603fa8..391d5574b 100644
+--- a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
++++ b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+@@ -2467,6 +2467,10 @@ class DatabaseHelper extends SQLiteOpenHelper {
+             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
+                     R.bool.def_bluetooth_on);
+ 
++            // Savitech Add -- A2DP_Source_Sink_Switch
++            loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_A2DP_SINK,
++                    R.bool.def_bluetooth_a2dp_sink);
++
+             // Enable or disable Cell Broadcast SMS
+             loadSetting(stmt, Settings.Global.CDMA_CELL_BROADCAST_SMS,
+                     RILConstants.CDMA_CELL_BROADCAST_SMS_DISABLED);
+diff --git a/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java b/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java
+index ff24c6f16..7977aa227 100644
+--- a/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java
++++ b/frameworks_base/services/core/java/com/android/server/BluetoothManagerService.java
+@@ -155,6 +155,8 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+ 
+     // Bluetooth persisted setting is off
+     private static final int BLUETOOTH_OFF = 0;
++    // Savitech Add -- A2DP_Source_Sink_Switch
++    private static final int BLUETOOTH_A2DP_SINK_OFF = 0;
+     // Bluetooth persisted setting is on
+     // and Airplane mode won't affect Bluetooth state at start up
+     private static final int BLUETOOTH_ON_BLUETOOTH = 1;
+@@ -236,6 +238,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+     // synchronize with broadcast receiver.
+     private boolean mQuietEnableExternal;
+     private boolean mEnableExternal;
++    private boolean mA2DPSinkEnableExternal; // Savitech Add -- A2DP_Source_Sink_Switch
+ 
+     // Map of apps registered to keep BLE scanning on.
+     private Map<IBinder, ClientDeathRecipient> mBleApps =
+@@ -484,6 +487,7 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+         mState = BluetoothAdapter.STATE_OFF;
+         mQuietEnableExternal = false;
+         mEnableExternal = false;
++        mA2DPSinkEnableExternal = false;	// Savitech Add - A2DP_Source_Sink_Switch
+         mAddress = null;
+         mName = null;
+         mErrorRecoveryRetryCounter = 0;
+@@ -526,6 +530,14 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+             mEnableExternal = true;
+         }
+ 
++        // Savitech Add -- A2DP_Source_Sink_Switch
++        if (isBluetoothPersistedA2DPSinkOn()) {
++            mA2DPSinkEnableExternal = true;
++            Slog.d(TAG, "Startup: A2DP Sink Persisted state is ON.");
++        } else {
++            Slog.d(TAG, "Startup: A2DP Sink Persisted state is OFF.");
++        }
++
+         String airplaneModeRadios =
+                 Settings.Global.getString(mContentResolver, Settings.Global.AIRPLANE_MODE_RADIOS);
+         if (airplaneModeRadios == null || airplaneModeRadios.contains(
+@@ -588,6 +600,19 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+         return state == BLUETOOTH_ON_AIRPLANE;
+     }
+ 
++    /**
++     *  Savitech Add -- A2DP_Source_Sink_Switch
++     *  Returns true if the Bluetooth A2DP Sink Mode State is "on"
++     */
++    private boolean isBluetoothPersistedA2DPSinkOn() {
++        if (!supportBluetoothPersistedState()) {
++            return false;
++        }
++        int state = Settings.Global.getInt(mContentResolver, Settings.Global.BLUETOOTH_A2DP_SINK, 0);
++        Slog.d(TAG, "Bluetooth A2DP Sink persisted state: " + state);
++        return state != BLUETOOTH_A2DP_SINK_OFF;
++    }
++
+     /**
+      *  Returns true if the Bluetooth saved state is BLUETOOTH_ON_BLUETOOTH
+      */
+@@ -612,6 +637,18 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+         Binder.restoreCallingIdentity(callingIdentity);
+     }
+ 
++    /**
++     *  Savitech Add -- A2DP_Source_Sink_Switch
++     *  Save the Bluetooth A2DP Sink ON/OFF state
++     */
++    private void persistBluetoothA2DPSinkSetting(int value) {
++        Slog.d(TAG, "Persisting Bluetooth A2DP Sink Setting: " + value);
++        // waive WRITE_SECURE_SETTINGS permission check
++        long callingIdentity = Binder.clearCallingIdentity();
++        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.BLUETOOTH_A2DP_SINK, value);
++        Binder.restoreCallingIdentity(callingIdentity);
++    }
++
+     /**
+      * Returns true if the Bluetooth Adapter's name and address is
+      * locally cached
+@@ -1200,6 +1237,17 @@ class BluetoothManagerService extends IBluetoothManager.Stub {
+             if (!isBluetoothPersistedStateOnAirplane()) {
+                 if (persist) {
+                     persistBluetoothSetting(BLUETOOTH_OFF);
++
++                    // Savitech Add -- A2DP_Source_Sink_Switch
++                    if(mA2DPSinkEnableExternal == false) {
++                        Slog.d(TAG, "Bluetooth disable(): Modify A2DP Sink state from OFF to ON!");
++                        mA2DPSinkEnableExternal = true;
++                        persistBluetoothA2DPSinkSetting(1);
++                    } else {
++                        Slog.d(TAG, "Bluetooth disable(): Modify A2DP Sink state from ON to OFF!");
++                        mA2DPSinkEnableExternal = false;
++                        persistBluetoothA2DPSinkSetting(0);
++                    }
+                 }
+                 mEnableExternal = false;
+             }
+diff --git a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
+index c36819746..b18640f9f 100644
+--- a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
++++ b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
+@@ -30,6 +30,10 @@ using ::android::hardware::bluetooth::audio::V2_0::AacVariableBitRate;
+ using ::android::hardware::bluetooth::audio::V2_0::AptxParameters;
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+@@ -46,12 +50,18 @@ static const PcmParameters kDefaultSoftwarePcmCapabilities = {
+     .sampleRate = static_cast<SampleRate>(
+         SampleRate::RATE_44100 | SampleRate::RATE_48000 |
+         SampleRate::RATE_88200 | SampleRate::RATE_96000 |
++        SampleRate::RATE_192000 |
+         SampleRate::RATE_16000 | SampleRate::RATE_24000),
+     .channelMode =
+         static_cast<ChannelMode>(ChannelMode::MONO | ChannelMode::STEREO),
+     .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |
+                                                 BitsPerSample::BITS_24 |
+-                                                BitsPerSample::BITS_32)};
++                                                BitsPerSample::BITS_32),
++    // Savitech Patch - Start
++    //   LHDC_Low_Latency(non-offload)
++    //.isLowLatencyEnabled = static_cast<LhdcLowLatencyEn>(LhdcLowLatencyEn::Disabled | LhdcLowLatencyEn::Disabled),
++    // Savitech Patch - End
++};
+ 
+ // Default Supported Codecs
+ // SBC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(MONO|STEREO)
+@@ -342,6 +352,7 @@ bool IsSoftwarePcmConfigurationValid(const PcmParameters& pcm_config) {
+        pcm_config.sampleRate != SampleRate::RATE_48000 &&
+        pcm_config.sampleRate != SampleRate::RATE_88200 &&
+        pcm_config.sampleRate != SampleRate::RATE_96000 &&
++       pcm_config.sampleRate != SampleRate::RATE_192000 &&
+        pcm_config.sampleRate != SampleRate::RATE_16000 &&
+        pcm_config.sampleRate != SampleRate::RATE_24000) ||
+       (pcm_config.bitsPerSample != BitsPerSample::BITS_16 &&
+diff --git a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
+index 963642705..fba3d580f 100644
+--- a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
++++ b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
+@@ -54,6 +54,18 @@
+             <include
+                 android:id="@+id/bluetooth_audio_codec_ldac"
+                 layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_audio_codec_lhdcv2"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_audio_codec_lhdcv3"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_audio_codec_lhdcv5"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
+         </RadioGroup>
+ 
+         <include
+diff --git a/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml
+index 03bbe48bd..f2cd2b729 100644
+--- a/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml
++++ b/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml
+@@ -50,6 +50,14 @@
+             <include
+                 android:id="@+id/bluetooth_audio_sample_rate_960"
+                 layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_audio_sample_rate_1764"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_audio_sample_rate_1920"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
+         </RadioGroup>
+ 
+         <include
+diff --git a/packages_apps_Settings/res/layout/bluetooth_lhdc_audio_quality_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_lhdc_audio_quality_dialog.xml
+new file mode 100644
+index 000000000..0ff2f3fe7
+--- /dev/null
++++ b/packages_apps_Settings/res/layout/bluetooth_lhdc_audio_quality_dialog.xml
+@@ -0,0 +1,82 @@
++<?xml version="1.0" encoding="utf-8"?>
++<!-- Copyright (C) 2019 The Android Open Source Project
++
++     Licensed under the Apache License, Version 2.0 (the "License");
++     you may not use this file except in compliance with the License.
++     You may obtain a copy of the License at
++
++          http://www.apache.org/licenses/LICENSE-2.0
++
++     Unless required by applicable law or agreed to in writing, software
++     distributed under the License is distributed on an "AS IS" BASIS,
++     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++     See the License for the specific language governing permissions and
++     limitations under the License.
++-->
++
++<ScrollView
++    xmlns:android="http://schemas.android.com/apk/res/android"
++    android:layout_width="match_parent"
++    android:layout_height="wrap_content">
++
++    <LinearLayout
++        android:layout_width="match_parent"
++        android:layout_height="wrap_content"
++        android:orientation="vertical"
++        android:padding="8dp">
++
++        <RadioGroup
++            android:id="@+id/bluetooth_lhdc_audio_quality_radio_group"
++            android:layout_width="match_parent"
++            android:layout_height="wrap_content"
++            android:layout_marginStart="@dimen/developer_option_dialog_margin_start">
++
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_low0"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_low1"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_low2"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_low3"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++                
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_low4"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++                
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_low"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++                
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_mid"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++                
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_high"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++                
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_high1"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++
++            <include
++                android:id="@+id/bluetooth_lhdc_audio_quality_best_effort"
++                layout="@layout/preference_widget_dialog_radiobutton"/>
++        </RadioGroup>
++
++        <include
++            android:id="@+id/bluetooth_audio_codec_help_info"
++            layout="@layout/preference_widget_dialog_summary"/>
++
++    </LinearLayout>
++
++</ScrollView>
++
+diff --git a/packages_apps_Settings/res/xml/development_settings.xml b/packages_apps_Settings/res/xml/development_settings.xml
+index 621351681..79d488363 100644
+--- a/packages_apps_Settings/res/xml/development_settings.xml
++++ b/packages_apps_Settings/res/xml/development_settings.xml
+@@ -375,6 +375,35 @@
+             android:positiveButtonText=""
+             android:negativeButtonText="@string/dlg_ok"/>
+ 
++        <com.android.settings.development.bluetooth.BluetoothLHDCQualityDialogPreference
++            android:key="bluetooth_select_a2dp_lhdc_playback_quality"
++            android:title="@string/bluetooth_select_a2dp_codec_lhdc_playback_quality"
++            android:dialogTitle="@string/bluetooth_select_a2dp_codec_lhdc_playback_quality_dialog_title"
++            android:dialogLayout="@layout/bluetooth_lhdc_audio_quality_dialog"
++            android:positiveButtonText=""
++            android:negativeButtonText="@string/dlg_ok"/>
++
++        <ListPreference
++            android:key="bluetooth_select_a2dp_codec_lhdc_latency"
++            android:title="@string/bluetooth_select_a2dp_codec_lhdc_latency"
++            android:dialogTitle="@string/bluetooth_select_a2dp_codec_lhdc_latency_dialog_title"
++            android:entries="@array/bluetooth_a2dp_codec_lhdc_latency_titles"
++            android:entryValues="@array/bluetooth_a2dp_codec_lhdc_latency_values" />
++
++        <ListPreference
++            android:key="bluetooth_enable_a2dp_codec_lhdc_ar_effect"
++            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect"
++            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title"
++            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles"
++            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" />
++            
++        <ListPreference
++            android:key="bluetooth_enable_a2dp_codec_lhdc_lossless"
++            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_lossless"
++            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title"
++            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_titles"
++            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_values" />
++
+         <ListPreference
+             android:key="bluetooth_max_connected_audio_devices"
+             android:title="@string/bluetooth_max_connected_audio_devices_string"
+diff --git a/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
+index 88dda2961..e1fbab4ab 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
+@@ -106,6 +106,10 @@ public abstract class AbstractBluetoothA2dpPreferenceController extends
+ 
+     @Override
+     public void updateState(Preference preference) {
++        if (mBluetoothA2dp == null) {
++            return;
++        }
++
+         BluetoothDevice activeDevice = mBluetoothA2dp.getActiveDevice();
+         if (activeDevice == null || getCodecConfig(activeDevice) == null || mPreference == null) {
+             return;
+@@ -191,6 +195,47 @@ public abstract class AbstractBluetoothA2dpPreferenceController extends
+         mBluetoothA2dp.setCodecConfigPreference(bluetoothDevice, config);
+     }
+ 
++    /************************************************
++     * Savitech LHDC EXT API -- START
++     ***********************************************/
++    @VisibleForTesting
++    int getLhdcCodecExtendApiVer(BluetoothDevice device, byte[] exApiVer) {
++        return mBluetoothA2dp.getLhdcCodecExtendApiVer(device, exApiVer);
++    }
++
++    @VisibleForTesting
++    int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
++        return mBluetoothA2dp.setLhdcCodecExtendApiConfigAr(device, codecConfig);
++    }
++
++    @VisibleForTesting
++    int getLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
++        return mBluetoothA2dp.getLhdcCodecExtendApiConfigAr(device, codecConfig);
++    }
++
++    @VisibleForTesting
++    int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
++        return mBluetoothA2dp.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
++    }
++
++    @VisibleForTesting
++    int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
++        return mBluetoothA2dp.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
++    }
++
++    @VisibleForTesting
++    int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device, byte[] codecConfig) {
++        return mBluetoothA2dp.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
++    }
++
++    @VisibleForTesting
++    void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device, byte[] codecData) {
++        mBluetoothA2dp.setLhdcCodecExtendApiDataGyro2D(device, codecData);
++    }
++    /************************************************
++     * Savitech LHDC EXT API -- END
++     ***********************************************/
++
+     @VisibleForTesting
+     BluetoothCodecConfig getCodecConfig(BluetoothDevice device) {
+         if (mBluetoothA2dp != null) {
+diff --git a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+index fbab1fd12..1af1465e4 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
++++ b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+@@ -56,6 +56,7 @@ import com.android.settings.development.bluetooth.BluetoothChannelModeDialogPref
+ import com.android.settings.development.bluetooth.BluetoothCodecDialogPreferenceController;
+ import com.android.settings.development.bluetooth.BluetoothHDAudioPreferenceController;
+ import com.android.settings.development.bluetooth.BluetoothQualityDialogPreferenceController;
++import com.android.settings.development.bluetooth.BluetoothLHDCQualityDialogPreferenceController;
+ import com.android.settings.development.bluetooth.BluetoothSampleRateDialogPreferenceController;
+ import com.android.settings.development.qstile.DevelopmentTiles;
+ import com.android.settings.development.storage.SharedDataPreferenceController;
+@@ -569,6 +570,16 @@ public class DevelopmentSettingsDashboardFragment extends RestrictedDashboardFra
+                 bluetoothA2dpConfigStore));
+         controllers.add(new BluetoothQualityDialogPreferenceController(context, lifecycle,
+                 bluetoothA2dpConfigStore));
++        // Savitech LHDC -- START
++        controllers.add(new BluetoothLHDCQualityDialogPreferenceController(context, lifecycle,
++                bluetoothA2dpConfigStore));
++        controllers.add(new BluetoothLHDCAudioLatencyPreferenceController(context, lifecycle,
++                bluetoothA2dpConfigStore));
++        controllers.add(new BluetoothLHDCAudioArEffectPreferenceController(context, lifecycle,
++                bluetoothA2dpConfigStore));
++        controllers.add(new BluetoothLHDCAudioLosslessPreferenceController(context, lifecycle,
++                bluetoothA2dpConfigStore));
++        // Savitech LHDC -- END
+         controllers.add(new BluetoothChannelModeDialogPreferenceController(context, lifecycle,
+                 bluetoothA2dpConfigStore));
+         controllers.add(new BluetoothHDAudioPreferenceController(context, lifecycle,
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
+index d66b8d8dc..2b305debb 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
+@@ -38,7 +38,11 @@ public abstract class AbstractBluetoothDialogPreferenceController extends
+ 
+     private static final String TAG = "AbstractBtDlgCtr";
+ 
+-    protected static final int[] CODEC_TYPES = {BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
++    protected static final int[] CODEC_TYPES = {
++            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
++            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
++            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
++            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_AAC,
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
+index 5cd8af28a..93b4f62bb 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
+@@ -61,8 +61,13 @@ public class BluetoothBitPerSampleDialogPreferenceController extends
+             case 0:
+                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+                 if (currentConfig != null) {
+-                    bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
+-                            currentConfig.getCodecType()));
++                /* Savitech patch: pick default by native decision, not always get the Highest one */
++                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                            bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
++                                currentConfig.getCodecType()));
++                    }
+                 }
+                 break;
+             case 1:
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
+index d156abde6..8603f6b5e 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
+@@ -61,8 +61,13 @@ public class BluetoothChannelModeDialogPreferenceController extends
+             case 0:
+                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+                 if (currentConfig != null) {
+-                    channelModeValue = getHighestChannelMode(getSelectableByCodecType(
+-                            currentConfig.getCodecType()));
++                    /* Savitech patch: pick default by native decision, not always get the Highest one */
++                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                            channelModeValue = getHighestChannelMode(getSelectableByCodecType(
++                                currentConfig.getCodecType()));
++                    }
+                 }
+                 break;
+             case 1:
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
+index 6a733f3fb..d9a2d8f83 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
+@@ -61,6 +61,9 @@ public class BluetoothCodecDialogPreference extends BaseBluetoothDialogPreferenc
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx_hd);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_ldac);
++        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv2);
++        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv3);
++        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv5);
+         String[] stringArray = context.getResources().getStringArray(
+                 R.array.bluetooth_a2dp_codec_titles);
+         for (int i = 0; i < stringArray.length; i++) {
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
+index 6b243c600..a73a0e315 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
+@@ -117,6 +117,18 @@ public class BluetoothCodecDialogPreferenceController extends
+                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
+                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                 break;
++            case 6:
++                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2;
++                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
++                break;
++            case 7:
++                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3;
++                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
++                break;
++            case 8:
++                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
++                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
++                break;
+             default:
+                 break;
+         }
+@@ -128,9 +140,19 @@ public class BluetoothCodecDialogPreferenceController extends
+         if (config == null) {
+             Log.d(TAG, "Selectable config is null. Unable to reset");
+         }
+-        mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
+-        mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
+-        mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
++
++        /* Savitech LHDC patch: use default when codec switching */
++        if (codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
++            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
++            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++            mBluetoothA2dpConfigStore.setSampleRate(BluetoothCodecConfig.SAMPLE_RATE_NONE);
++            mBluetoothA2dpConfigStore.setBitsPerSample(BluetoothCodecConfig.BITS_PER_SAMPLE_NONE);
++            mBluetoothA2dpConfigStore.setChannelMode(BluetoothCodecConfig.CHANNEL_MODE_NONE);
++        } else {
++            mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
++            mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
++            mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
++        }
+     }
+ 
+     @Override
+@@ -174,6 +196,15 @@ public class BluetoothCodecDialogPreferenceController extends
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
+                 index = 5;
+                 break;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
++                index = 6;
++                break;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
++                index = 7;
++                break;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
++                index = 8;
++                break;
+             default:
+                 Log.e(TAG, "Unsupported config:" + config);
+                 break;
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioArEffectPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioArEffectPreferenceController.java
+new file mode 100644
+index 000000000..a17f2ded4
+--- /dev/null
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioArEffectPreferenceController.java
+@@ -0,0 +1,98 @@
++/*
++ * Copyright (C) 2017 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.development;
++
++import android.bluetooth.BluetoothCodecConfig;
++import android.content.Context;
++
++import com.android.settings.R;
++import com.android.settingslib.core.lifecycle.Lifecycle;
++import android.util.Log;
++
++/**
++ * Switch preference controller for LHDC AR Effect ON/OFF
++ */
++public class BluetoothLHDCAudioArEffectPreferenceController extends
++        AbstractBluetoothA2dpPreferenceController {
++
++    private static final int DEFAULT_INDEX = 0;
++    private static final String BLUETOOTH_SELECT_A2DP_LHDC_AR_EFFECT_KEY =
++            "bluetooth_enable_a2dp_codec_lhdc_ar_effect";
++
++    private static final int LHDC_FEATURE_MASK = 0xFF000000;
++    private static final int LHDC_FEATURE_TAG = 0x4C000000;
++    private static final int LHDC_AR_FEATURE = 0x02;
++
++    public BluetoothLHDCAudioArEffectPreferenceController(Context context, Lifecycle lifecycle,
++            BluetoothA2dpConfigStore store) {
++        super(context, lifecycle, store);
++    }
++
++    @Override
++    public String getPreferenceKey() {
++        return BLUETOOTH_SELECT_A2DP_LHDC_AR_EFFECT_KEY;
++    }
++
++    @Override
++    protected String[] getListValues() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_enable_a2dp_codec_lhdc_ar_effect_values);
++    }
++
++    @Override
++    protected String[] getListSummaries() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries);
++    }
++
++    @Override
++    protected int getDefaultIndex() {
++        return DEFAULT_INDEX;
++    }
++
++    @Override
++    protected void writeConfigurationValues(Object newValue) {
++        final int index = mPreference.findIndexOfValue(newValue.toString());
++        
++        int codecSpecific3Value = 0; // default
++        codecSpecific3Value |= LHDC_FEATURE_TAG;
++        
++        if (index != 0) {
++            codecSpecific3Value |= LHDC_AR_FEATURE;
++        }else{
++	        codecSpecific3Value &= ~LHDC_AR_FEATURE;
++        }
++        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
++    }
++
++    @Override
++    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
++        int ret = 0;
++        int index = (int)config.getCodecSpecific3();
++        int tmp = index & LHDC_FEATURE_MASK;
++        if (tmp == LHDC_FEATURE_TAG) {
++            if ((index & LHDC_AR_FEATURE) != 0) {
++                ret = 1;
++            } else {
++                ret = 0;
++            }
++        } else {
++            ret = 0;
++        }
++        return ret;
++    }
++}
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLatencyPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLatencyPreferenceController.java
+new file mode 100644
+index 000000000..fd9278112
+--- /dev/null
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLatencyPreferenceController.java
+@@ -0,0 +1,88 @@
++/*
++ * Copyright (C) 2019 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.development;
++
++import android.bluetooth.BluetoothCodecConfig;
++import android.content.Context;
++
++import com.android.settings.R;
++import com.android.settingslib.core.lifecycle.Lifecycle;
++
++import android.util.Log;
++
++/**
++ * Switch preference controller for LHDC Low Latency Mode
++ */
++public class BluetoothLHDCAudioLatencyPreferenceController extends 
++        AbstractBluetoothA2dpPreferenceController {
++
++    private static final String KEY = "bluetooth_select_a2dp_codec_lhdc_latency";
++    private static final String TAG = "BtLhdcLowLatnecyCtr";
++    private static final int DEFAULT_TAG = 0xC000;
++    private static final int DEFAULT_INDEX = 0;
++
++    public BluetoothLHDCAudioLatencyPreferenceController(Context context, Lifecycle lifecycle,
++                                                BluetoothA2dpConfigStore store) {
++        super(context, lifecycle, store);
++    }
++
++    @Override
++    public String getPreferenceKey() {
++        return KEY;
++    }
++
++    @Override
++    protected String[] getListValues() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_a2dp_codec_lhdc_latency_values);
++    }
++
++    @Override
++    protected String[] getListSummaries() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_a2dp_codec_lhdc_latency_summaries);
++    }
++    
++    @Override
++    protected int getDefaultIndex() {
++        return DEFAULT_INDEX;
++    }
++
++    @Override
++    protected void writeConfigurationValues(Object newValue) {
++        final int index = mPreference.findIndexOfValue(newValue.toString());
++        int codecSpecific2Value = 0;
++        if (index <= 1) {
++            codecSpecific2Value = DEFAULT_TAG | index;
++        }else{
++            codecSpecific2Value = DEFAULT_TAG | DEFAULT_INDEX;
++        }
++        mBluetoothA2dpConfigStore.setCodecSpecific2Value(codecSpecific2Value);
++    }
++
++    @Override
++    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
++        int index = (int)config.getCodecSpecific2();
++        int tmp = index & DEFAULT_TAG;
++        if (tmp == DEFAULT_TAG) {
++            index &= 0x1;
++        } else {
++            index = DEFAULT_INDEX;
++        }
++        return index;
++    }
++}
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
+new file mode 100644
+index 000000000..4c7d0b3a0
+--- /dev/null
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
+@@ -0,0 +1,96 @@
++/*
++ * Copyright (C) 2022 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.development;
++
++import android.bluetooth.BluetoothCodecConfig;
++import android.content.Context;
++
++import com.android.settings.R;
++import com.android.settingslib.core.lifecycle.Lifecycle;
++import android.util.Log;
++
++/**
++ * Switch preference controller for LHDC Lossless ON/OFF
++ */
++public class BluetoothLHDCAudioLosslessPreferenceController extends
++        AbstractBluetoothA2dpPreferenceController {
++
++    private static final int DEFAULT_INDEX = 0;
++    private static final String BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY =
++            "bluetooth_enable_a2dp_codec_lhdc_lossless";
++
++    private static final int LHDC_FEATURE_MASK = 0xFF000000;
++    private static final int LHDC_FEATURE_TAG = 0x4C000000;
++    private static final int LHDC_LOSSLESS_FEATURE = 0x80;
++
++    public BluetoothLHDCAudioLosslessPreferenceController(Context context, Lifecycle lifecycle,
++            BluetoothA2dpConfigStore store) {
++        super(context, lifecycle, store);
++    }
++
++    @Override
++    public String getPreferenceKey() {
++        return BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY;
++    }
++
++    @Override
++    protected String[] getListValues() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_values);
++    }
++
++    @Override
++    protected String[] getListSummaries() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_summaries);
++    }
++
++    @Override
++    protected int getDefaultIndex() {
++        return DEFAULT_INDEX;
++    }
++
++    @Override
++    protected void writeConfigurationValues(Object newValue) {
++        final int index = mPreference.findIndexOfValue(newValue.toString());
++        int codecSpecific3Value = 0; // default
++        codecSpecific3Value |= LHDC_FEATURE_TAG;
++        if (index != 0) {
++            codecSpecific3Value |= LHDC_LOSSLESS_FEATURE;
++        }else{
++            codecSpecific3Value &= ~LHDC_LOSSLESS_FEATURE;
++        }
++        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
++    }
++
++    @Override
++    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
++        int ret = 0;
++        int index = (int)config.getCodecSpecific3();
++        int tmp = index & LHDC_FEATURE_MASK;
++        if (tmp == LHDC_FEATURE_TAG) {
++            if ((index & LHDC_LOSSLESS_FEATURE) != 0) {
++                ret = 1;
++            } else {
++                ret = 0;
++            }
++        } else {
++            ret = 0;
++        }
++        return ret;
++    }
++}
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreference.java
+new file mode 100644
+index 000000000..6d1610134
+--- /dev/null
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreference.java
+@@ -0,0 +1,84 @@
++/*
++ * Copyright (C) 2019 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.development.bluetooth;
++
++import android.content.Context;
++import android.util.AttributeSet;
++import android.widget.RadioGroup;
++
++import com.android.settings.R;
++
++/**
++ * Dialog preference to set the Bluetooth A2DP config of LHDC quality
++ */
++public class BluetoothLHDCQualityDialogPreference extends BaseBluetoothDialogPreference implements
++        RadioGroup.OnCheckedChangeListener {
++
++    public BluetoothLHDCQualityDialogPreference(Context context) {
++        super(context);
++        initialize(context);
++    }
++
++    public BluetoothLHDCQualityDialogPreference(Context context, AttributeSet attrs) {
++        super(context, attrs);
++        initialize(context);
++    }
++
++    public BluetoothLHDCQualityDialogPreference(Context context, AttributeSet attrs, int defStyleAttr) {
++        super(context, attrs, defStyleAttr);
++        initialize(context);
++    }
++
++    public BluetoothLHDCQualityDialogPreference(Context context, AttributeSet attrs, int defStyleAttr,
++                                            int defStyleRes) {
++        super(context, attrs, defStyleAttr, defStyleRes);
++        initialize(context);
++    }
++
++    @Override
++    protected int getRadioButtonGroupId() {
++        return R.id.bluetooth_lhdc_audio_quality_radio_group;
++    }
++
++    @Override
++    protected int getDefaultIndex() {
++        return 9; // Best Effort
++    }
++
++    private void initialize(Context context) {
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low0);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low1);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low2);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low3);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low4);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_mid);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_high);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_high1);
++        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_best_effort);
++        String[] stringArray = context.getResources().getStringArray(
++                R.array.bluetooth_a2dp_codec_lhdc_playback_quality_titles);
++        for (int i = 0; i < stringArray.length; i++) {
++            mRadioButtonStrings.add(stringArray[i]);
++        }
++        stringArray = context.getResources().getStringArray(
++                R.array.bluetooth_a2dp_codec_lhdc_playback_quality_summaries);
++        for (int i = 0; i < stringArray.length; i++) {
++            mSummaryStrings.add(stringArray[i]);
++        }
++    }
++}
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
+new file mode 100644
+index 000000000..772ae1eb4
+--- /dev/null
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
+@@ -0,0 +1,148 @@
++/*
++ * Copyright (C) 2019 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.development.bluetooth;
++
++import android.bluetooth.BluetoothCodecConfig;
++import android.content.Context;
++import android.util.Log;
++
++import androidx.annotation.VisibleForTesting;
++import androidx.preference.Preference;
++import androidx.preference.PreferenceScreen;
++
++import com.android.settings.development.BluetoothA2dpConfigStore;
++import com.android.settingslib.core.lifecycle.Lifecycle;
++
++import java.util.ArrayList;
++import java.util.List;
++
++/**
++ * Dialog preference controller to set the Bluetooth A2DP config of LHDC quality
++ */
++public class BluetoothLHDCQualityDialogPreferenceController extends
++        AbstractBluetoothDialogPreferenceController {
++
++    // In standard case, low0 is available
++    private static final int index_adjust_offset = 0;
++    // In case of low0 is removed, shift the rest indices
++    //private static final int index_adjust_offset = 1;
++
++    private static final String KEY = "bluetooth_select_a2dp_lhdc_playback_quality";
++    private static final String TAG = "BtLhdcAudioQualityCtr";
++    private static final int DEFAULT_TAG = 0xC000;
++    private static final int DEFAULT_MAGIC = 0x8000;
++    private static final int DEFAULT_INDEX = (5 - index_adjust_offset);
++    private static final int DEFAULT_MAX_INDEX = (9 - index_adjust_offset); //0~9
++
++    public BluetoothLHDCQualityDialogPreferenceController(Context context, Lifecycle lifecycle,
++                                                      BluetoothA2dpConfigStore store) {
++        super(context, lifecycle, store);
++    }
++
++    @Override
++    public String getPreferenceKey() {
++        return KEY;
++    }
++
++    @Override
++    public void displayPreference(PreferenceScreen screen) {
++        super.displayPreference(screen);
++        ((BaseBluetoothDialogPreference) mPreference).setCallback(this);
++    }
++
++    @Override
++    protected void writeConfigurationValues(final int index) {
++        long codecSpecific1Value = 0;
++        if (index <= DEFAULT_MAX_INDEX) {
++            codecSpecific1Value = DEFAULT_MAGIC | (index + index_adjust_offset);
++        }else{
++            codecSpecific1Value = DEFAULT_MAGIC | DEFAULT_INDEX;
++        }
++        mBluetoothA2dpConfigStore.setCodecSpecific1Value(codecSpecific1Value);
++    }
++
++    @Override
++    protected int getCurrentIndexByConfig(BluetoothCodecConfig config) {
++        if (config == null) {
++            Log.e(TAG, "Unable to get current config index. Config is null.");
++        }
++        return convertCfgToBtnIndex((int) config.getCodecSpecific1());
++    }
++
++    @Override
++    public List<Integer> getSelectableIndex() {
++        List<Integer> selectableIndex = new ArrayList<>();
++        final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
++        if (currentConfig != null) {
++            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
++                currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3) {
++                // excluding 1000Kbps
++                for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
++                    if(i != (8 - index_adjust_offset)) {
++                        selectableIndex.add(i);
++                    }
++                }
++            }
++            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                // All items of LHDCV5 are available.
++                for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
++                    selectableIndex.add(i);
++                }
++            }
++        }
++
++        // All items are available to set from UI but be filtered at native layer.
++        for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
++            selectableIndex.add(i);
++        }
++        return selectableIndex;
++    }
++
++    @Override
++    public void updateState(Preference preference) {
++        super.updateState(preference);
++        // Enable preference when current codec type is LHDC V2/V3/V5. For other cases, disable it.
++        final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
++        if (currentConfig != null
++                && (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
++                    currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
++                    currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5)
++                ) {
++            preference.setEnabled(true);
++        } else {
++            preference.setEnabled(false);
++            preference.setSummary("");
++        }
++    }
++
++    @Override
++    public void onHDAudioEnabled(boolean enabled) {
++        mPreference.setEnabled(false);
++    }
++
++    @VisibleForTesting
++    int convertCfgToBtnIndex(int config) {
++        int index = config;
++        int tmp = config & DEFAULT_TAG;  //0xC000
++        if (tmp != DEFAULT_MAGIC) {  //0x8000
++            index = getDefaultIndex();
++        } else {
++            index &= 0xff;
++        }
++        return (index - index_adjust_offset);
++    }
++}
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java
+index 622c47ae5..2abd2d24e 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java
+@@ -61,6 +61,8 @@ public class BluetoothSampleRateDialogPreference extends BaseBluetoothDialogPref
+         mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_480);
+         mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_882);
+         mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_960);
++        mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_1764);
++        mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_1920);
+         String[] stringArray = context.getResources().getStringArray(
+                 R.array.bluetooth_a2dp_codec_sample_rate_titles);
+         for (int i = 0; i < stringArray.length; i++) {
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
+index 9e4b99ef8..6228a6c64 100644
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
+@@ -61,8 +61,13 @@ public class BluetoothSampleRateDialogPreferenceController extends
+             case 0:
+                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+                 if (currentConfig != null) {
+-                    sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
+-                            currentConfig.getCodecType()));
++                    /* Savitech LHDC patch: use default by LHDC native when selecting system default */
++                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                            sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
++                                currentConfig.getCodecType()));
++                    }
+                 }
+                 break;
+             case 1:
+@@ -77,6 +82,12 @@ public class BluetoothSampleRateDialogPreferenceController extends
+             case 4:
+                 sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_96000;
+                 break;
++            case 5:
++                sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_176400;
++                break;
++            case 6:
++                sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_192000;
++                break;
+             default:
+                 break;
+         }
+@@ -124,6 +135,12 @@ public class BluetoothSampleRateDialogPreferenceController extends
+             case BluetoothCodecConfig.SAMPLE_RATE_96000:
+                 index = 4;
+                 break;
++            case BluetoothCodecConfig.SAMPLE_RATE_176400:
++                index = 5;
++                break;
++            case BluetoothCodecConfig.SAMPLE_RATE_192000:
++                index = 6;
++                break;
+             default:
+                 Log.e(TAG, "Unsupported config:" + config);
+                 break;
+diff --git a/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp b/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp
+index a94990437..f41361962 100644
+--- a/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp
++++ b/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp
+@@ -505,6 +505,182 @@ static jboolean setCodecConfigPreferenceNative(JNIEnv* env, jobject object,
+   return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
+ }
+ 
++/************************************************
++ * Savitech LHDC EXT API -- START
++ ***********************************************/
++static char *jByteArrayToChar(JNIEnv *env, jbyteArray buf) {
++    char *chars = NULL;
++    jbyte *bytes;
++    bytes = env->GetByteArrayElements(buf, 0);
++    if (!bytes) {
++      jniThrowIOException(env, EINVAL);
++      return JNI_FALSE;
++    }
++    int chars_len = env->GetArrayLength(buf);
++    chars = new char[chars_len + 1];
++    memset(chars, 0, chars_len + 1);
++    memcpy(chars, bytes, chars_len);
++    chars[chars_len] = 0;
++    env->ReleaseByteArrayElements(buf, bytes, 0);
++    return chars;
++}
++
++static jint getLhdcCodecExtendApiVerNative(JNIEnv* env, jobject object,
++                                           jbyteArray address,
++                                           jbyteArray codecConfig){
++
++  int status = BT_STATUS_FAIL;
++  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
++  if (!sBluetoothA2dpInterface) {
++    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
++    return status;
++  }
++
++  jbyte* addr = env->GetByteArrayElements(address, nullptr);
++  if (!addr) {
++    jniThrowIOException(env, EINVAL);
++    return status;
++  }
++
++  RawAddress bd_addr;
++  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
++
++  char *chars = NULL;
++  int chars_len = env->GetArrayLength(codecConfig);
++  chars = jByteArrayToChar(env, codecConfig);
++  if(!chars)
++  {
++    env->ReleaseByteArrayElements(address, addr, 0);
++    return status;
++  }
++
++  status =
++      sBluetoothA2dpInterface->getApiVer_lhdc(bd_addr, chars, chars_len);
++
++  if (status != BT_STATUS_SUCCESS) {
++    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
++  }
++  else {
++    env->SetByteArrayRegion(codecConfig, 0, chars_len, reinterpret_cast<jbyte *>(chars));
++  }
++
++  env->ReleaseByteArrayElements(address, addr, 0);
++  delete[] chars;
++
++  return status;
++}
++
++static jint getLhdcCodecExtendApiConfigNative(JNIEnv* env, jobject object,
++                                           jbyteArray address,
++                                           jbyteArray codecConfig){
++
++  int status = BT_STATUS_FAIL;
++  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
++  if (!sBluetoothA2dpInterface) {
++    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
++    return status;
++  }
++
++  jbyte* addr = env->GetByteArrayElements(address, nullptr);
++  if (!addr) {
++    jniThrowIOException(env, EINVAL);
++    return status;
++  }
++
++  RawAddress bd_addr;
++  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
++
++  char *chars = NULL;
++  int chars_len = env->GetArrayLength(codecConfig);
++  chars = jByteArrayToChar(env, codecConfig);
++  if(!chars)
++  {
++    env->ReleaseByteArrayElements(address, addr, 0);
++    return status;
++  }
++
++  status =
++      sBluetoothA2dpInterface->getApiCfg_lhdc(bd_addr, chars, chars_len);
++
++  if (status != BT_STATUS_SUCCESS) {
++    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
++  }
++  else {
++    env->SetByteArrayRegion(codecConfig, 0, chars_len, reinterpret_cast<jbyte *>(chars));
++  }
++
++  env->ReleaseByteArrayElements(address, addr, 0);
++  delete[] chars;
++
++  return status;
++}
++
++static jint setLhdcCodecExtendApiConfigNative(JNIEnv* env, jobject object,
++                                           jbyteArray address,
++                                           jbyteArray codecConfig){
++
++  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
++  if (!sBluetoothA2dpInterface) {
++    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
++    return JNI_FALSE;
++  }
++
++  jbyte* addr = env->GetByteArrayElements(address, nullptr);
++  if (!addr) {
++    jniThrowIOException(env, EINVAL);
++    return JNI_FALSE;
++  }
++
++  RawAddress bd_addr;
++  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
++
++  char *chars = NULL;
++  int chars_len = env->GetArrayLength(codecConfig);
++  chars = jByteArrayToChar(env, codecConfig);
++
++  int status =
++      sBluetoothA2dpInterface->setApiCfg_lhdc(bd_addr, chars, chars_len);
++
++  if (status != BT_STATUS_SUCCESS) {
++    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
++    return status;
++  }
++  env->ReleaseByteArrayElements(address, addr, 0);
++  delete[] chars;
++
++  return status;
++}
++
++static void setLhdcCodecExtendApiDataNative(JNIEnv* env, jobject object,
++                                           jbyteArray address,
++                                           jbyteArray codecData){
++
++  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
++  if (!sBluetoothA2dpInterface) {
++    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
++    return;
++  }
++
++  jbyte* addr = env->GetByteArrayElements(address, nullptr);
++  if (!addr) {
++    jniThrowIOException(env, EINVAL);
++    return;
++  }
++
++  RawAddress bd_addr;
++  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
++
++  char *chars = NULL;
++  int chars_len = env->GetArrayLength(codecData);
++  chars = jByteArrayToChar(env, codecData);
++
++  sBluetoothA2dpInterface->setAPiData_lhdc(bd_addr, chars, chars_len);
++
++  env->ReleaseByteArrayElements(address, addr, 0);
++  delete[] chars;
++}
++//Savitech LHDC EXT API -- END
++
+ static JNINativeMethod sMethods[] = {
+     {"classInitNative", "()V", (void*)classInitNative},
+     {"initNative",
+@@ -518,6 +694,20 @@ static JNINativeMethod sMethods[] = {
+     {"setCodecConfigPreferenceNative",
+      "([B[Landroid/bluetooth/BluetoothCodecConfig;)Z",
+      (void*)setCodecConfigPreferenceNative},
++    // Savitech LHDC EXT API -- START
++    {"getLhdcCodecExtendApiVerNative",
++     "([B[B)I",
++     (void*)getLhdcCodecExtendApiVerNative},
++    {"getLhdcCodecExtendApiConfigNative",
++     "([B[B)I",
++     (void*)getLhdcCodecExtendApiConfigNative},
++    {"setLhdcCodecExtendApiConfigNative",
++     "([B[B)I",
++     (void*)setLhdcCodecExtendApiConfigNative},
++    {"setLhdcCodecExtendApiDataNative",
++     "([B[B)V",
++     (void*)setLhdcCodecExtendApiDataNative},
++    // Savitech LHDC EXT API -- END
+ };
+ 
+ int register_com_android_bluetooth_a2dp(JNIEnv* env) {
+diff --git a/packages_apps_bluetooth/res/values/config.xml b/packages_apps_bluetooth/res/values/config.xml
+index 0fc3fdc4f..88152d5d0 100644
+--- a/packages_apps_bluetooth/res/values/config.xml
++++ b/packages_apps_bluetooth/res/values/config.xml
+@@ -101,6 +101,9 @@
+     <integer name="a2dp_source_codec_priority_aptx">3001</integer>
+     <integer name="a2dp_source_codec_priority_aptx_hd">4001</integer>
+     <integer name="a2dp_source_codec_priority_ldac">5001</integer>
++    <integer name="a2dp_source_codec_priority_lhdcv2">6001</integer>
++    <integer name="a2dp_source_codec_priority_lhdcv3">6002</integer>
++    <integer name="a2dp_source_codec_priority_lhdcv5">6003</integer>
+ 
+     <!-- For enabling the AVRCP Target Cover Artowrk feature-->
+     <bool name="avrcp_target_enable_cover_art">true</bool>
+diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+index 6e0b1c022..e6f7c040f 100644
+--- a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
++++ b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+@@ -51,6 +51,12 @@ class A2dpCodecConfig {
+             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+     private @CodecPriority int mA2dpSourceCodecPriorityLdac =
+             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
++    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV2 =
++            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
++    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV3 =
++            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
++    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV5 =
++            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+ 
+     private BluetoothCodecConfig[] mCodecConfigOffloading = new BluetoothCodecConfig[0];
+ 
+@@ -231,6 +237,38 @@ class A2dpCodecConfig {
+             mA2dpSourceCodecPriorityLdac = value;
+         }
+ 
++        // Savitech LHDC -- START
++        try {
++            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv2);
++        } catch (NotFoundException e) {
++            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
++        }
++        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
++                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
++            mA2dpSourceCodecPriorityLhdcV2 = value;
++        }
++
++        try {
++            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv3);
++        } catch (NotFoundException e) {
++            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
++        }
++        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
++                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
++            mA2dpSourceCodecPriorityLhdcV3 = value;
++        }
++
++        try {
++            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv5);
++        } catch (NotFoundException e) {
++            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
++        }
++        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
++                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
++            mA2dpSourceCodecPriorityLhdcV5 = value;
++        }
++        // Savitech LHDC -- END
++
+         BluetoothCodecConfig codecConfig;
+         BluetoothCodecConfig[] codecConfigArray =
+                 new BluetoothCodecConfig[BluetoothCodecConfig.SOURCE_CODEC_TYPE_MAX];
+@@ -265,7 +303,69 @@ class A2dpCodecConfig {
+                 0 /* codecSpecific2 */, 0 /* codecSpecific3 */, 0 /* codecSpecific4 */);
+         codecConfigArray[4] = codecConfig;
+ 
++        // Savitech LHDC -- START
++        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
++                mA2dpSourceCodecPriorityLhdcV2, BluetoothCodecConfig.SAMPLE_RATE_NONE,
++                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
++                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
++                0 /* codecSpecific4 */);
++        codecConfigArray[5] = codecConfig;
++        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
++                mA2dpSourceCodecPriorityLhdcV3, BluetoothCodecConfig.SAMPLE_RATE_NONE,
++                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
++                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
++                0 /* codecSpecific4 */);
++        codecConfigArray[6] = codecConfig;
++        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
++                mA2dpSourceCodecPriorityLhdcV5, BluetoothCodecConfig.SAMPLE_RATE_NONE,
++                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
++                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
++                0 /* codecSpecific4 */);
++        codecConfigArray[7] = codecConfig;
++        // Savitech LHDC -- END
++
+         return codecConfigArray;
+     }
++
++    /************************************************
++     * Savitech LHDC EXT API -- START
++     ***********************************************/
++    int getLhdcCodecExtendApiVer(BluetoothDevice device,
++                                byte[] exApiVer) {
++        return mA2dpNativeInterface.getLhdcCodecExtendApiVer(device, exApiVer);
++    }
++
++    int setLhdcCodecExtendApiConfigAr(BluetoothDevice device,
++                                byte[] codecConfig) {
++        return mA2dpNativeInterface.setLhdcCodecExtendApiConfigAr(device, codecConfig);
++    }
++
++    int getLhdcCodecExtendApiConfigAr(BluetoothDevice device,
++                                byte[] codecConfig) {
++        return mA2dpNativeInterface.getLhdcCodecExtendApiConfigAr(device, codecConfig);
++    }
++
++    int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
++                                byte[] codecConfig) {
++        return mA2dpNativeInterface.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
++    }
++
++    int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
++                                byte[] codecConfig) {
++        return mA2dpNativeInterface.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
++    }
++
++    int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device,
++                                byte[] codecConfig) {
++        return mA2dpNativeInterface.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
++    }
++
++    void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device,
++                                byte[] codecData) {
++        mA2dpNativeInterface.setLhdcCodecExtendApiDataGyro2D(device, codecData);
++    }
++    /************************************************
++     * Savitech LHDC EXT API -- END
++     ***********************************************/
+ }
+ 
+diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
+index 2530f82a8..340c801e9 100644
+--- a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
++++ b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
+@@ -220,6 +220,34 @@ public class A2dpNativeInterface {
+         }
+     }
+ 
++    /************************************************
++     * Savitech LHDC EXT API -- START
++     ***********************************************/
++    public int getLhdcCodecExtendApiVer(BluetoothDevice device, byte[] exApiVer) {
++        return getLhdcCodecExtendApiVerNative(getByteAddress(device), exApiVer);
++    }
++    public int getLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
++        return getLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
++    }
++    public int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
++        return setLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
++    }
++    public int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
++        return getLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
++    }
++    public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device, byte[] codecConfig) {
++        return getLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
++    }
++    public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
++        return setLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
++    }
++    public void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device, byte[] codecData) {
++    	setLhdcCodecExtendApiDataNative(getByteAddress(device), codecData);
++    }
++    /************************************************
++     * Savitech LHDC EXT API -- END
++     ***********************************************/
++
+     // Native methods that call into the JNI interface
+     private static native void classInitNative();
+     private native void initNative(int maxConnectedAudioDevices,
+@@ -232,4 +260,10 @@ public class A2dpNativeInterface {
+     private native boolean setActiveDeviceNative(byte[] address);
+     private native boolean setCodecConfigPreferenceNative(byte[] address,
+                 BluetoothCodecConfig[] codecConfigArray);
++    // Savitech LHDC EXT API
++    private native int getLhdcCodecExtendApiVerNative(byte[] address, byte[] exApiVer);
++    private native int setLhdcCodecExtendApiConfigNative(byte[] address, byte[] codecConfig);
++    private native int getLhdcCodecExtendApiConfigNative(byte[] address, byte[] codecConfig);
++    private native int getLhdcCodecExtendApiA2dpCodecConfigNative(byte[] address, byte[] codecConfig);
++    private native void setLhdcCodecExtendApiDataNative(byte[] address, byte[] codecData);
+ }
+diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+index c6b17594a..2137780f2 100644
+--- a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
++++ b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+@@ -751,6 +751,68 @@ public class A2dpService extends ProfileService {
+         mA2dpCodecConfig.setCodecConfigPreference(device, codecStatus, codecConfig);
+     }
+ 
++    /************************************************
++     * Savitech LHDC EXT API -- START
++     ***********************************************/
++    public int getLhdcCodecExtendApiVer(BluetoothDevice device, byte[] exApiVer) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return -1;
++        }
++        return mA2dpCodecConfig.getLhdcCodecExtendApiVer(device, exApiVer);
++    }
++
++    public int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return -1;
++        }
++        return mA2dpCodecConfig.setLhdcCodecExtendApiConfigAr(device, codecConfig);
++    }
++
++    public int getLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return -1;
++        }
++        return mA2dpCodecConfig.getLhdcCodecExtendApiConfigAr(device, codecConfig);
++    }
++
++    public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return -1;
++        }
++        return mA2dpCodecConfig.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
++    }
++
++    public int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return -1;
++        }
++        return mA2dpCodecConfig.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
++    }
++
++    public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device, byte[] codecConfig) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return -1;
++        }
++        return mA2dpCodecConfig.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
++    }
++
++    public void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device, byte[] codecData) {
++        if (device == null) {
++            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
++            return;
++        }
++        mA2dpCodecConfig.setLhdcCodecExtendApiDataGyro2D(device, codecData);
++    }
++    /************************************************
++     * Savitech LHDC EXT API -- END
++     ***********************************************/
++
+     /**
+      * Enables the optional codecs.
+      *
+@@ -1226,6 +1288,20 @@ public class A2dpService extends ProfileService {
+             return mService;
+         }
+ 
++        // Savitech - comaptible to API before Android 12.0 
++        private A2dpService getServiceLhdc() {
++            if (!Utils.checkCallerIsSystemOrActiveUser()
++                    || !Utils.checkServiceAvailable(mService, TAG)) {
++                Log.w(TAG, "A2DP call not allowed for non-active user");
++                return null;
++            }
++
++            if (mService != null && mService.isAvailable()) {
++                return mService;
++            }
++            return null;
++        }
++
+         BluetoothA2dpBinder(A2dpService svc) {
+             mService = svc;
+         }
+@@ -1409,6 +1485,82 @@ public class A2dpService extends ProfileService {
+             service.setCodecConfigPreference(device, codecConfig);
+         }
+ 
++        /************************************************
++         * Savitech Patch - LHDC Extended API Start
++         ***********************************************/
++        @Override
++        public int getLhdcCodecExtendApiVer(BluetoothDevice device,
++                byte[] exApiVer) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return -1;
++            }
++            return service.getLhdcCodecExtendApiVer(device, exApiVer);
++        }
++
++        @Override
++        public int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, 
++                byte[] codecConfig) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return -1;
++            }
++            return service.setLhdcCodecExtendApiConfigAr(device, codecConfig);
++        }
++
++        @Override
++        public int getLhdcCodecExtendApiConfigAr(BluetoothDevice device,
++                byte[] codecConfig) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return -1;
++            }
++            return service.getLhdcCodecExtendApiConfigAr(device, codecConfig);
++        }
++
++        @Override
++        public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
++                byte[] codecConfig) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return -1;
++            }
++            return service.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
++        }
++
++        @Override
++        public int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
++                byte[] codecConfig) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return -1;
++            }
++            return service.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
++        }
++
++        @Override
++        public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device,
++                byte[] codecConfig) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return -1;
++            }
++            return service.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
++        }
++
++        @Override
++        public void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device,
++                byte[] codecData) {
++            A2dpService service = getServiceLhdc();
++            if (service == null) {
++                return;
++            }
++            service.setLhdcCodecExtendApiDataGyro2D(device, codecData);
++        }
++        /************************************************
++         * Savitech Patch - LHDC Extended API End
++         ***********************************************/
++
+         @Override
+         public void enableOptionalCodecs(BluetoothDevice device, AttributionSource source) {
+             Attributable.setAttributionSource(device, source);
+diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java b/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java
+index 41535377a..7b9a960c4 100644
+--- a/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java
++++ b/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java
+@@ -111,6 +111,13 @@ public class Config {
+ 
+     private static Class[] sSupportedProfiles = new Class[0];
+ 
++    // Savitech Add -- A2DP_Source_Sink_Switch
++    private static boolean isBluetoothPersistedA2DPSinkOn(Context context) {
++        final ContentResolver resolver = context.getContentResolver();
++        int state = Settings.Global.getInt(resolver, Settings.Global.BLUETOOTH_A2DP_SINK, 0);
++        return (state != 0);
++    }
++
+     private static boolean sIsGdEnabledUptoScanningLayer = false;
+ 
+     static void init(Context ctx) {
+@@ -139,6 +146,21 @@ public class Config {
+                         + " by components configuration");
+             }
+ 
++            /* Savitech Add -- A2DP_Source_Sink_Switch
++             * 	check a2dp sink persist settings to load A2DP sink or not
++             * */
++            /*
++            if (supported == true && config.mClass == A2dpSinkService.class) {
++                if (isBluetoothPersistedA2DPSinkOn(ctx)) {
++                    Log.d(TAG, "A2DP sink service load");
++                    supported = true;
++                } else {
++                    Log.d(TAG, "A2DP sink service not load");
++                    supported = false;
++                }
++            }
++            */
++
+             if (supported && !isProfileDisabled(ctx, config.mMask)) {
+                 Log.v(TAG, "Adding " + config.mClass.getSimpleName());
+                 profiles.add(config.mClass);
+diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.cc b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
+index afa87426b..19a5c8b4f 100644
+--- a/system_bt/audio_bluetooth_hw/device_port_proxy.cc
++++ b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
+@@ -37,6 +37,10 @@ using ::android::bluetooth::audio::BluetoothAudioSessionControl_2_1;
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::PcmParameters;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using SampleRate = ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+ using SampleRate_2_1 = ::android::hardware::bluetooth::audio::V2_1::SampleRate;
+ using BluetoothAudioStatus =
+@@ -108,6 +112,22 @@ audio_format_t BitsPerSampleToAudioFormat(BitsPerSample bits_per_sample) {
+   }
+ }
+ 
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++/*
++bool isLhdcLowLatencyToAudioFormat(LhdcLowLatencyEn low_latency_enabled) {
++  switch (low_latency_enabled) {
++    case LhdcLowLatencyEn::Enabled:
++      return true;
++    case LhdcLowLatencyEn::Disabled:
++      return false;
++    default:
++      return kBluetoothDefaultAudioFormatLhdcLowLatency;
++  }
++}
++*/
++// Savitech Patch - End
++
+ // The maximum time to wait in std::condition_variable::wait_for()
+ constexpr unsigned int kMaxWaitingTimeMs = 4500;
+ 
+@@ -320,6 +340,10 @@ bool BluetoothAudioPortOut::LoadAudioConfig(audio_config_t* audio_cfg) const {
+            ? AUDIO_CHANNEL_OUT_STEREO
+            : OutputChannelModeToAudioFormat(pcm_cfg.channelMode));
+   audio_cfg->format = BitsPerSampleToAudioFormat(pcm_cfg.bitsPerSample);
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  //_lowLatencyEnabled = isLhdcLowLatencyToAudioFormat(pcm_cfg.isLowLatencyEnabled);
++  // Savitech Patch - End
+   return true;
+ }
+ 
+diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.h b/system_bt/audio_bluetooth_hw/device_port_proxy.h
+index 9e113926f..c8b18893a 100644
+--- a/system_bt/audio_bluetooth_hw/device_port_proxy.h
++++ b/system_bt/audio_bluetooth_hw/device_port_proxy.h
+@@ -54,6 +54,15 @@ class BluetoothAudioPort {
+   // Bluetooth stack
+   virtual bool LoadAudioConfig(audio_config_t* audio_cfg) const = 0;
+ 
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  /*
++  bool isLowLatencyEnabled() const {
++    return _lowLatencyEnabled;
++  }
++  */
++  // Savitech Patch - End
++
+   // WAR to support Mono mode / 16 bits per sample
+   void ForcePcmStereoToMono(bool force) {
+     is_stereo_to_mono_ = force;
+@@ -89,6 +98,11 @@ class BluetoothAudioPort {
+            session_type_ == SessionType_2_1::A2DP_HARDWARE_OFFLOAD_DATAPATH;
+   }
+ 
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  //mutable bool _lowLatencyEnabled = false;
++  // Savitech Patch - End
++
+  protected:
+   uint16_t cookie_;
+   BluetoothStreamState state_;
+diff --git a/system_bt/audio_bluetooth_hw/stream_apis.cc b/system_bt/audio_bluetooth_hw/stream_apis.cc
+index aafe547f7..28e1648fc 100644
+--- a/system_bt/audio_bluetooth_hw/stream_apis.cc
++++ b/system_bt/audio_bluetooth_hw/stream_apis.cc
+@@ -86,8 +86,18 @@ void out_calculate_feeding_delay_ms(const BluetoothStreamOut* out,
+     //   frames_count = buffer_size / frame_size
+     //   latency (sec.) = frames_count / samples_per_second (sample_rate)
+     // Sync from audio_a2dp_hw to add extra delay kExtraAudioSyncMs(+200ms)
++#if 0
++    bool lowLatencySt = false;
++    // Savitech Patch - Start
++    //   LHDC_Low_Latency(non-offload)
++    lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
++    delay_report_ms =
++        out->frames_count_ * 1000 / out->sample_rate_ + (lowLatencySt == true ? 0 : kExtraAudioSyncMs);
++    // Savitech Patch - End
++#else
+     delay_report_ms =
+         out->frames_count_ * 1000 / out->sample_rate_ + kExtraAudioSyncMs;
++#endif
+     if (timestamp != nullptr) {
+       clock_gettime(CLOCK_MONOTONIC, &absorbed_timestamp);
+     }
+@@ -220,6 +230,13 @@ static size_t out_get_buffer_size(const struct audio_stream* stream) {
+   const auto* out = reinterpret_cast<const BluetoothStreamOut*>(stream);
+   size_t buffer_size =
+       out->frames_count_ * audio_stream_out_frame_size(&out->stream_out_);
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  /*
++  bool lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
++  if (lowLatencySt) buffer_size = buffer_size/2;
++  */
++  // Savitech Patch - End
+   LOG(VERBOSE) << __func__ << ": state=" << out->bluetooth_output_.GetState()
+                << ", buffer_size=" << buffer_size;
+   return buffer_size;
+diff --git a/system_bt/audio_bluetooth_hw/stream_apis.h b/system_bt/audio_bluetooth_hw/stream_apis.h
+index 55512d7fb..a1d5daeb3 100644
+--- a/system_bt/audio_bluetooth_hw/stream_apis.h
++++ b/system_bt/audio_bluetooth_hw/stream_apis.h
+@@ -26,6 +26,11 @@ constexpr unsigned int kBluetoothDefaultSampleRate = 44100;
+ constexpr audio_format_t kBluetoothDefaultAudioFormatBitsPerSample =
+     AUDIO_FORMAT_PCM_16_BIT;
+ 
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//constexpr bool kBluetoothDefaultAudioFormatLhdcLowLatency = 0;
++// Savitech Patch - End
++
+ constexpr unsigned int kBluetoothDefaultInputBufferMs = 20;
+ constexpr unsigned int kBluetoothDefaultInputStateTimeoutMs = 20;
+ 
+diff --git a/system_bt/audio_hal_interface/a2dp_encoding.cc b/system_bt/audio_hal_interface/a2dp_encoding.cc
+index 44a4828fc..761791b8f 100644
+--- a/system_bt/audio_hal_interface/a2dp_encoding.cc
++++ b/system_bt/audio_hal_interface/a2dp_encoding.cc
+@@ -44,7 +44,14 @@ using ::bluetooth::audio::codec::A2dpAptxToHalConfig;
+ using ::bluetooth::audio::codec::A2dpCodecToHalBitsPerSample;
+ using ::bluetooth::audio::codec::A2dpCodecToHalChannelMode;
+ using ::bluetooth::audio::codec::A2dpCodecToHalSampleRate;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::bluetooth::audio::codec::A2dpCodecToHalLhdcLowLatencyMode;
++// Savitech Patch - End
+ using ::bluetooth::audio::codec::A2dpLdacToHalConfig;
++// Savitech Patch - Offload
++//using ::bluetooth::audio::codec::A2dpLhdcv5ToHalConfig;
++// Savitech Patch - End
+ using ::bluetooth::audio::codec::A2dpSbcToHalConfig;
+ using ::bluetooth::audio::codec::CodecConfiguration;
+ 
+@@ -264,6 +271,25 @@ bool a2dp_get_selected_hal_codec_config(CodecConfiguration* codec_config) {
+       }
+       break;
+     }
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5: {
++#if 0
++      // Savitech Patch Offload
++      if (!A2dpLhdcv5ToHalConfig(codec_config, a2dp_config)) {
++        LOG(ERROR) << __func__
++                   << ": Fail to call A2dpLhdcv5ToHalConfig(), codec_type=" << current_codec.codec_type;
++        return false;
++      }
++      break;
++#else
++      // for non-offload only
++      return true;
++#endif
++      // Savitech Patch - End
++    }
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+       [[fallthrough]];
+     default:
+@@ -307,6 +333,18 @@ bool a2dp_get_selected_hal_pcm_config(PcmParameters* pcm_config) {
+   pcm_config->sampleRate = A2dpCodecToHalSampleRate(current_codec);
+   pcm_config->bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
+   pcm_config->channelMode = A2dpCodecToHalChannelMode(current_codec);
++
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  /*
++  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3 ||
++      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2 ||
++      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
++    pcm_config->isLowLatencyEnabled = A2dpCodecToHalLhdcLowLatencyMode(current_codec);
++  }
++  */
++  // Savitech Patch - End
++
+   return (pcm_config->sampleRate != SampleRate::RATE_UNKNOWN &&
+           pcm_config->bitsPerSample != BitsPerSample::BITS_UNKNOWN &&
+           pcm_config->channelMode != ChannelMode::UNKNOWN);
+diff --git a/system_bt/audio_hal_interface/client_interface.h b/system_bt/audio_hal_interface/client_interface.h
+index b9f18b9ed..4cd4de3f8 100644
+--- a/system_bt/audio_hal_interface/client_interface.h
++++ b/system_bt/audio_hal_interface/client_interface.h
+@@ -43,6 +43,10 @@ using AudioConfiguration_2_1 =
+     ::android::hardware::bluetooth::audio::V2_1::AudioConfiguration;
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using IBluetoothAudioProvider =
+     ::android::hardware::bluetooth::audio::V2_0::IBluetoothAudioProvider;
+ using IBluetoothAudioProvider_2_1 =
+@@ -221,7 +225,12 @@ class BluetoothAudioClientInterface {
+   static constexpr PcmParameters kInvalidPcmConfiguration = {
+       .sampleRate = SampleRate::RATE_UNKNOWN,
+       .channelMode = ChannelMode::UNKNOWN,
+-      .bitsPerSample = BitsPerSample::BITS_UNKNOWN};
++      .bitsPerSample = BitsPerSample::BITS_UNKNOWN,
++      // Savitech Patch - Start
++      //   LHDC_Low_Latency(non-offload)
++      //.isLowLatencyEnabled = LhdcLowLatencyEn::Disabled,
++      // Savitech Patch - End
++  };
+ 
+  protected:
+   mutable std::mutex internal_mutex_;
+diff --git a/system_bt/audio_hal_interface/client_interface_unittest.cc b/system_bt/audio_hal_interface/client_interface_unittest.cc
+index 33954c720..996060db5 100644
+--- a/system_bt/audio_hal_interface/client_interface_unittest.cc
++++ b/system_bt/audio_hal_interface/client_interface_unittest.cc
+@@ -32,6 +32,8 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
++// Savitech Patch  Offload
++//using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcChannelMode;
+@@ -121,11 +123,15 @@ constexpr ChannelModePair kChannelModePairs[3] = {
+     {.hal_channel_mode_ = ChannelMode::STEREO,
+      .btav_channel_mode_ = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO}};
+ 
++// Savitech Patch  Offload
+ constexpr btav_a2dp_codec_index_t codec_indexes[] = {
+     BTAV_A2DP_CODEC_INDEX_SOURCE_SBC,  BTAV_A2DP_CODEC_INDEX_SOURCE_AAC,
+     BTAV_A2DP_CODEC_INDEX_SOURCE_APTX, BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
+-    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SINK_SBC,
+-    BTAV_A2DP_CODEC_INDEX_SINK_AAC,    BTAV_A2DP_CODEC_INDEX_SINK_LDAC};
++    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
++    BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
++    BTAV_A2DP_CODEC_INDEX_SINK_SBC,
++    BTAV_A2DP_CODEC_INDEX_SINK_AAC, BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
++    BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3, BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5};
+ constexpr uint16_t kPeerMtus[5] = {660, 663, 883, 1005, 1500};
+ 
+ class TestSinkTransport
+@@ -307,6 +313,24 @@ class BluetoothAudioClientInterfaceTest : public Test {
+              ldac_config.bitsPerSample & ldac_capability.bitsPerSample);
+         return is_codec_config_supported;
+       }
++      // Savitech Patch - START  Offload
++      /*
++      case CodecType::LHDCV3:
++        [[fallthrough]];
++      case CodecType::LHDCV2:
++        [[fallthrough]];
++      case CodecType::LHDCV5: {
++        Lhdcv5Parameters lhdcv5_config = codec_config.config.lhdcv5Config();
++        Lhdcv5Parameters lhdcv5_capability =
++            codec_capability.capabilities.lhdcv5Capabilities();
++        is_codec_config_supported =
++            (lhdcv5_config.sampleRate & lhdcv5_capability.sampleRate &&
++             lhdcv5_config.channelMode & lhdcv5_capability.channelMode &&
++             lhdcv5_config.bitsPerSample & lhdcv5_capability.bitsPerSample);
++        return is_codec_config_supported;
++      }
++      */
++      // Savitech Patch - END
+       case CodecType::APTX:
+         [[fallthrough]];
+       case CodecType::APTX_HD: {
+@@ -649,6 +673,81 @@ TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLdacSession) {
+   }
+ }
+ 
++// Savitech Patch - START  Offload
++/*
++std::vector<CodecConfiguration> Lhdcv5CodecConfigurationsGenerator() {
++  std::vector<CodecConfiguration> lhdcv5_codec_configs;
++  CodecConfiguration codec_config = {};
++  Lhdcv5QualityIndex quality_indexes[10] = {
++      Lhdcv5QualityIndex::QUALITY_LOW4, Lhdcv5QualityIndex::QUALITY_LOW3,
++      Lhdcv5QualityIndex::QUALITY_LOW2, Lhdcv5QualityIndex::QUALITY_LOW1,
++    Lhdcv5QualityIndex::QUALITY_LOW0, Lhdcv5QualityIndex::QUALITY_LOW,
++    Lhdcv5QualityIndex::QUALITY_MID, Lhdcv5QualityIndex::QUALITY_HIGH,
++    Lhdcv5QualityIndex::QUALITY_HIGH1, Lhdcv5QualityIndex::QUALITY_ABR};
++  for (auto sample_rate_pair : kSampleRatePairs) {
++    for (auto bits_per_sample_pair : kBitsPerSamplePairs) {
++      for (auto channel_mode_pair : kChannelModePairs) {
++        for (auto peer_mtu : kPeerMtus) {
++          for (auto quality_index : quality_indexes) {
++            codec_config.codecType = CodecType::LHDCV5;
++            codec_config.peerMtu = peer_mtu;
++            codec_config.isScmstEnabled = false;
++            codec_config.encodedAudioBitrate = 400000;
++            Lhdcv5Parameters lhdc = {
++                .sampleRate = sample_rate_pair.hal_sample_rate_,
++                .channelMode = ChannelMode::STEREO,
++                .qualityIndex = quality_index,
++                .bitsPerSample = bits_per_sample_pair.hal_bits_per_sample_};
++            codec_config.config.lhdcv5Config(lhdc);
++            lhdcv5_codec_configs.push_back(codec_config);
++          }  // LdacQualityIndex
++        }    // peerMtu
++      }      // ChannelMode
++    }        // BitsPerSampple
++  }          // SampleRate
++  return lhdcv5_codec_configs;
++}
++
++TEST_F(BluetoothAudioClientInterfaceTest, A2dpLhdcv5CodecOffloadingState) {
++  test_sink_transport_ =
++      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
++  clientif_sink_ =
++      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
++  auto lhdcv5_codec_configs = Lhdcv5CodecConfigurationsGenerator();
++  for (auto codec_offloading_preference :
++       CodecOffloadingPreferenceGenerator(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
++    UpdateOffloadingCapabilities(codec_offloading_preference.preference_);
++    for (CodecConfiguration codec_config : lhdcv5_codec_configs) {
++      if (IsCodecOffloadingSupported(codec_config) &&
++          codec_offloading_preference.is_target_codec_included_) {
++        ASSERT_TRUE(IsCodecOffloadingEnabled(codec_config));
++      } else {
++        ASSERT_FALSE(IsCodecOffloadingEnabled(codec_config));
++      }
++    }
++  }
++}
++
++TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLhdcv5Session) {
++  test_sink_transport_ =
++      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
++  clientif_sink_ =
++      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
++  AudioConfiguration audio_config = {};
++  for (CodecConfiguration codec_config : Lhdcv5CodecConfigurationsGenerator()) {
++    audio_config.codecConfig(codec_config);
++    clientif_sink_->UpdateAudioConfig(audio_config);
++    if (IsCodecOffloadingSupported(codec_config)) {
++      ASSERT_EQ(clientif_sink_->StartSession(), kClientIfReturnSuccess);
++    } else {
++      ASSERT_NE(clientif_sink_->StartSession(), kClientIfReturnSuccess);
++    }
++    ASSERT_EQ(clientif_sink_->EndSession(), kClientIfReturnSuccess);
++  }
++}
++*/
++// Savitech Patch - END
++
+ std::vector<CodecConfiguration> AptxCodecConfigurationsGenerator(
+     CodecType codec_type) {
+   std::vector<CodecConfiguration> aptx_codec_configs;
+diff --git a/system_bt/audio_hal_interface/codec_status.cc b/system_bt/audio_hal_interface/codec_status.cc
+index cd9d88e05..8ebcdb745 100644
+--- a/system_bt/audio_hal_interface/codec_status.cc
++++ b/system_bt/audio_hal_interface/codec_status.cc
+@@ -24,6 +24,7 @@
+ #include "a2dp_vendor_aptx_constants.h"
+ #include "a2dp_vendor_aptx_hd_constants.h"
+ #include "a2dp_vendor_ldac_constants.h"
++#include "a2dp_vendor_lhdc_constants.h"
+ #include "bta/av/bta_av_int.h"
+ 
+ namespace {
+@@ -39,6 +40,16 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
++// Savitech Patch - START Offload
++/*
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5QualityIndex;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5FrameDuration;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5DataInterval;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Version;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Specific;
++*/
++// Savitech Patch - END
+ using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
+@@ -148,6 +159,30 @@ bool ldac_offloading_capability_match(const LdacParameters& ldac_capability,
+           << " capability=" << toString(ldac_capability);
+   return true;
+ }
++
++// Savitech Patch - START  Offload
++/*
++bool lhdcv5_offloading_capability_match(const Lhdcv5Parameters& lhdcv5_capability,
++                                        const Lhdcv5Parameters& lhdcv5_config) {
++  if ((static_cast<SampleRate>(lhdcv5_capability.sampleRate &
++                               lhdcv5_config.sampleRate) ==
++       SampleRate::RATE_UNKNOWN) ||
++      (static_cast<ChannelMode>(lhdcv5_capability.channelMode &
++                                    lhdcv5_config.channelMode) ==
++       ChannelMode::UNKNOWN) ||
++      (static_cast<BitsPerSample>(lhdcv5_capability.bitsPerSample &
++                                  lhdcv5_config.bitsPerSample) ==
++       BitsPerSample::BITS_UNKNOWN)) {
++    LOG(WARNING) << __func__ << ": software codec=" << toString(lhdcv5_config)
++                 << " capability=" << toString(lhdcv5_capability);
++    return false;
++  }
++  VLOG(1) << __func__ << ": offloading codec=" << toString(lhdcv5_config)
++          << " capability=" << toString(lhdcv5_capability);
++  return true;
++}
++*/
++// Savitech Patch - END
+ }  // namespace
+ 
+ namespace bluetooth {
+@@ -211,6 +246,26 @@ ChannelMode A2dpCodecToHalChannelMode(
+   }
+ }
+ 
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++/*
++LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
++    const btav_a2dp_codec_config_t& a2dp_codec_config) {
++  switch ((int)(a2dp_codec_config.codec_specific_2 & 0x1)) {
++    case 0:
++      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
++      return LhdcLowLatencyEn::Disabled;
++    case 1:
++      LOG(INFO) << __func__ << ": LHDC low latency Enabled";
++      return LhdcLowLatencyEn::Enabled;
++    default:
++      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
++      return LhdcLowLatencyEn::Disabled;
++  }
++}
++*/
++// Savitech Patch - End
++
+ bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config) {
+   btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
+@@ -470,6 +525,88 @@ bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
+   return true;
+ }
+ 
++// Savitech Patch - START  Offload
++#if 0
++//require definition supported in hardware/interfaces/bluetooth/audio/types.hal
++bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
++                         A2dpCodecConfig* a2dp_config) {
++  btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
++  if ((current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) &&
++      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) &&
++      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
++    codec_config = {};
++    return false;
++  }
++  LOG(INFO) << __func__ << ": enter: codec_type = " << current_codec.codec_type;
++
++  tBT_A2DP_OFFLOAD a2dp_offload;
++  if (false == a2dp_config->getCodecSpecificConfig(&a2dp_offload) ) {
++    LOG(ERROR) << __func__ << ": getCodecSpecificConfig fail";
++    return false;
++  }
++
++  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) {
++    codec_config->codecType = CodecType::LHDCV3;
++  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) {
++    codec_config->codecType = CodecType::LHDCV2;
++  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
++    codec_config->codecType = CodecType::LHDCV5;
++  }
++  codec_config->config.lhdcv5Config({});
++  auto lhdcv5Config = codec_config->config.lhdcv5Config();
++
++  lhdcv5Config.sampleRate = A2dpCodecToHalSampleRate(current_codec);
++  if (lhdcv5Config.sampleRate == SampleRate::RATE_UNKNOWN) {
++    LOG(ERROR) << __func__
++               << ": Unknown LHDC Vn sample_rate=" << current_codec.sample_rate;
++    return false;
++  }
++
++  lhdcv5Config.channelMode = A2dpCodecToHalChannelMode(current_codec);
++  if (lhdcv5Config.channelMode == ChannelMode::UNKNOWN) {
++    LOG(ERROR) << __func__
++               << ": Unknown LHDC Vn channel_mode=" << current_codec.channel_mode;
++    return false;
++  }
++
++  lhdcv5Config.bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
++  if (lhdcv5Config.bitsPerSample == BitsPerSample::BITS_UNKNOWN) {
++    LOG(ERROR) << __func__ << ": Unknown LHDC Vn bits_per_sample="
++               << current_codec.bits_per_sample;
++    return false;
++  }
++
++  lhdcv5Config.codecVersion            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Version) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_VER];
++  lhdcv5Config.qualityIndex            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
++                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L]));
++  lhdcv5Config.maxQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
++                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L]));
++  lhdcv5Config.minQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
++                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]));
++  lhdcv5Config.frameDuration           = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5FrameDuration) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR];
++  lhdcv5Config.dataInterval            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5DataInterval)  a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL];
++  lhdcv5Config.codecSpecific_1         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1];
++  lhdcv5Config.codecSpecific_2         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2];
++  lhdcv5Config.metaData[0]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META];
++  lhdcv5Config.metaData[1]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 1];
++  lhdcv5Config.metaData[2]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 2];
++  lhdcv5Config.metaData[3]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 3];
++  lhdcv5Config.metaData[4]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 4];
++  lhdcv5Config.metaData[5]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 5];
++  lhdcv5Config.metaData[6]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 6];
++  lhdcv5Config.metaData[7]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 7];
++
++  codec_config->config.lhdcv5Config(lhdcv5Config);
++
++  LOG(INFO) << __func__ << ": debug: sampleRate = " << current_codec.sample_rate;
++  LOG(INFO) << __func__ << ": debug: bitsPerSample = " << current_codec.bits_per_sample;
++  LOG(INFO) << __func__ << ": debug: channelMode = " << current_codec.channel_mode;
++
++  return true;
++}
++#endif
++// Savitech Patch - END
++
+ bool UpdateOffloadingCapabilities(
+     const std::vector<btav_a2dp_codec_config_t>& framework_preference) {
+   audio_hal_capabilities = BluetoothAudioClientInterface::GetAudioCapabilities(
+@@ -492,10 +629,38 @@ bool UpdateOffloadingCapabilities(
+       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+         codec_type_masks |= CodecType::LDAC;
+         break;
++      // Savitech Patch - START  Offload
++#if 0
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++        codec_type_masks |= CodecType::LHDCV3;
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++        codec_type_masks |= CodecType::LHDCV2;
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++        codec_type_masks |= CodecType::LHDCV5;
++        break;
++#else
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++        [[fallthrough]];
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++        [[fallthrough]];
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++        LOG(WARNING) << __func__
++                     << ": Ignore source codec_type=" << preference.codec_type;
++        break;
++#endif
++      // Savitech Patch - END
+       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
+         [[fallthrough]];
+       case BTAV_A2DP_CODEC_INDEX_SINK_AAC:
+         [[fallthrough]];
++      // Savitech Patch - START  Offload
++      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++          [[fallthrough]];
++      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++        [[fallthrough]];
++      // Savitech Patch - END
+       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+         LOG(WARNING) << __func__
+                      << ": Ignore sink codec_type=" << preference.codec_type;
+@@ -554,6 +719,21 @@ bool IsCodecOffloadingEnabled(const CodecConfiguration& codec_config) {
+         auto ldac_config = codec_config.config.ldacConfig();
+         return ldac_offloading_capability_match(ldac_capability, ldac_config);
+       }
++      // Savitech Patch - START  Offload
++      /*
++      case CodecType::LHDCV3:
++        [[fallthrough]];
++      case CodecType::LHDCV2:
++        [[fallthrough]];
++      case CodecType::LHDCV5: {
++        LOG(INFO) << __func__ << ": LHDC aDSP codecType="
++                   << toString(codec_capability.codecType);
++        auto lhdcv5_capability = codec_capability.capabilities.lhdcv5Capabilities();
++        auto lhdcv5_config = codec_config.config.lhdcv5Config();
++        return lhdcv5_offloading_capability_match(lhdcv5_capability, lhdcv5_config);
++      }
++      */
++      // Savitech Patch - END
+       case CodecType::UNKNOWN:
+         [[fallthrough]];
+       default:
+diff --git a/system_bt/audio_hal_interface/codec_status.h b/system_bt/audio_hal_interface/codec_status.h
+index e0e074438..6a476f086 100644
+--- a/system_bt/audio_hal_interface/codec_status.h
++++ b/system_bt/audio_hal_interface/codec_status.h
+@@ -28,6 +28,10 @@ namespace codec {
+ 
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using ::android::hardware::bluetooth::audio::V2_0::CodecConfiguration;
+ using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+ 
+@@ -39,6 +43,13 @@ BitsPerSample A2dpCodecToHalBitsPerSample(
+     const btav_a2dp_codec_config_t& a2dp_codec_config);
+ ChannelMode A2dpCodecToHalChannelMode(
+     const btav_a2dp_codec_config_t& a2dp_codec_config);
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++/*
++LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
++    const btav_a2dp_codec_config_t& a2dp_codec_config);
++    */
++// Savitech Patch - End
+ 
+ bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config);
+@@ -48,7 +59,10 @@ bool A2dpAptxToHalConfig(CodecConfiguration* codec_config,
+                          A2dpCodecConfig* a2dp_config);
+ bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
+                          A2dpCodecConfig* a2dp_config);
+-
++// Savitech Patch - START  Offload
++bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
++                         A2dpCodecConfig* a2dp_config);
++// Savitech Patch - END
+ bool UpdateOffloadingCapabilities(
+     const std::vector<btav_a2dp_codec_config_t>& framework_preference);
+ // Check whether this codec is supported by the audio HAL and is allowed to use
+diff --git a/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl b/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl
+index 94379af56..3d06096cd 100644
+--- a/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl
++++ b/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl
+@@ -90,4 +90,17 @@ interface IBluetoothA2dp {
+     boolean setBufferLengthMillis(int codec, int size, in AttributionSource attributionSource);
+     @JavaPassthrough(annotation="@android.annotation.RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)")
+     int getPriority(in BluetoothDevice device, in AttributionSource attributionSource);
++
++    //Savitech LHDC EXT API -- START
++    //  get revision of the API
++    int getLhdcCodecExtendApiVer(in BluetoothDevice device, inout byte[] exApiVer);
++    //  get/set config-type APIs
++    int setLhdcCodecExtendApiConfigAr(in BluetoothDevice device, in byte[] codecConfig);
++    int getLhdcCodecExtendApiConfigAr(in BluetoothDevice device, inout byte[] codecConfig);
++    int setLhdcCodecExtendApiConfigMeta(in BluetoothDevice device, in byte[] codecConfig);
++    int getLhdcCodecExtendApiConfigMeta(in BluetoothDevice device, inout byte[] codecConfig);
++    int getLhdcCodecExtendApiConfigA2dpCodecSpecific(in BluetoothDevice device, inout byte[] codecConfig);
++    //  set data-type APIs
++    oneway void setLhdcCodecExtendApiDataGyro2D(in BluetoothDevice device, in byte[] codecData);
++    //Savitech LHDC EXT API -- END
+ }
+diff --git a/system_bt/bta/av/bta_av_aact.cc b/system_bt/bta/av/bta_av_aact.cc
+index 33298d649..50d7433c9 100644
+--- a/system_bt/bta/av/bta_av_aact.cc
++++ b/system_bt/bta/av/bta_av_aact.cc
+@@ -3198,6 +3198,17 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+       codec_type = BTA_AV_CODEC_TYPE_LDAC;
+       break;
++    // Savitech Patch - START  Offload
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      codec_type = BTA_AV_CODEC_TYPE_LHDCV3;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      codec_type = BTA_AV_CODEC_TYPE_LHDCV2;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      codec_type = BTA_AV_CODEC_TYPE_LHDCV5;
++      break;
++    // Savitech Patch - END
+     default:
+       APPL_TRACE_ERROR("%s: Unknown Codec type ", __func__);
+       return;
+@@ -3231,6 +3242,14 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
+     case 96000:
+       p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+       break;
++    // Savitech Patch - START  Offload
++    case 176400:
++      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_176400;
++      break;
++    case 192000:
++      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++      break;
++    // Savitech Patch - END
+   }
+   if (L2CA_GetRemoteCid(p_scb->l2c_cid, &p_a2dp_offload->l2c_rcid) == false) {
+     APPL_TRACE_ERROR("%s: Failed to fetch l2c rcid", __func__);
+diff --git a/system_bt/bta/include/bta_av_api.h b/system_bt/bta/include/bta_av_api.h
+index 4591bbaef..1aacad72c 100644
+--- a/system_bt/bta/include/bta_av_api.h
++++ b/system_bt/bta/include/bta_av_api.h
+@@ -151,7 +151,12 @@ typedef enum {
+   BTA_AV_CODEC_TYPE_AAC = 0x02,
+   BTA_AV_CODEC_TYPE_APTX = 0x04,
+   BTA_AV_CODEC_TYPE_APTXHD = 0x08,
+-  BTA_AV_CODEC_TYPE_LDAC = 0x10
++  BTA_AV_CODEC_TYPE_LDAC = 0x10,
++  // Savitech Patch - START
++  BTA_AV_CODEC_TYPE_LHDCV3 = 0x20,
++  BTA_AV_CODEC_TYPE_LHDCV2 = 0x40,
++  BTA_AV_CODEC_TYPE_LHDCV5 = 0x80,
++  // Savitech Patch - END
+ } tBTA_AV_CODEC_TYPE;
+ 
+ /* Event associated with BTA_AV_ENABLE_EVT */
+diff --git a/system_bt/btif/co/bta_av_co.cc b/system_bt/btif/co/bta_av_co.cc
+index 463612011..889f2ceaa 100644
+--- a/system_bt/btif/co/bta_av_co.cc
++++ b/system_bt/btif/co/bta_av_co.cc
+@@ -959,7 +959,7 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(
+   // Select the Source codec
+   const BtaAvCoSep* p_sink = nullptr;
+   if (p_peer->acceptor) {
+-    UpdateAllSelectableSourceCodecs(p_peer);
++    size_t updated_codecs = UpdateAllSelectableSourceCodecs(p_peer);
+     if (p_peer->p_sink == nullptr) {
+       // Update the selected codec
+       p_peer->p_sink =
+@@ -971,6 +971,10 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(
+                        __func__, p_peer->addr.ToString().c_str());
+       return A2DP_FAIL;
+     }
++    /* Savitech Patch: Dispatch the event to make sure the recent UPDATED info is reported. */
++    if (updated_codecs > 0) {
++      ReportSourceCodecState(p_peer);
++    }
+   } else {
+     if (btif_av_peer_prefers_mandatory_codec(p_peer->addr)) {
+       // Apply user preferred codec directly before first codec selected.
+@@ -2217,3 +2221,139 @@ btav_a2dp_scmst_info_t bta_av_co_get_scmst_info(
+ }
+ 
+ void btif_a2dp_codec_debug_dump(int fd) { bta_av_co_cb.DebugDump(fd); }
++
++/************************************************
++ * Savitech LHDC EXT API -- START
++ ***********************************************/
++// LHDC Extended API: get target API version
++int bta_av_co_get_codec_LHDC_user_ApiVer(
++    const RawAddress& peer_address,
++    const char *version, const int clen) {
++
++  int success = BT_STATUS_SUCCESS;
++  A2dpCodecConfig* peerCodec = NULL;
++
++  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
++  if (p_peer == nullptr) {
++    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
++        peer_address.ToString().c_str());
++    success = BT_STATUS_NOT_READY;
++    goto done;
++  }
++
++  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
++  if (peerCodec) {
++    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
++        peerCodec->name().c_str(), peerCodec->codecIndex());
++    success = p_peer->GetCodecs()->getLHDCCodecUserApiVer(peerCodec, version, clen);
++    goto done;
++  } else {
++    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
++    success = BT_STATUS_NOT_READY;
++    goto done;
++  }
++
++done:
++  return success;
++}
++
++// LHDC extended API: get user config
++int bta_av_co_get_codec_LHDC_user_config(
++    const RawAddress& peer_address,
++    const char *config, const int clen) {
++
++  int success = BT_STATUS_SUCCESS;
++  A2dpCodecConfig* peerCodec = NULL;
++
++  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
++  if (p_peer == nullptr) {
++    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
++        peer_address.ToString().c_str());
++    success = BT_STATUS_NOT_READY;
++    goto done;
++  }
++
++  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
++  if (peerCodec) {
++    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
++        peerCodec->name().c_str(), peerCodec->codecIndex());
++    success = p_peer->GetCodecs()->getLHDCCodecUserConfig(peerCodec, config, clen);
++    goto done;
++  } else {
++    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
++    success = BT_STATUS_NOT_READY;
++    goto done;
++  }
++
++done:
++  return success;
++}
++
++// LHDC extended API: set user config
++int bta_av_co_set_codec_LHDC_user_config(
++    const RawAddress& peer_address,
++    const char *config, const int clen) {
++
++  int success = BT_STATUS_SUCCESS;
++  A2dpCodecConfig* peerCodec = NULL;
++
++  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
++  if (p_peer == nullptr) {
++    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
++        peer_address.ToString().c_str());
++    success = BT_STATUS_NOT_READY;
++    goto done;
++  }
++
++  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
++  if (peerCodec) {
++    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
++        peerCodec->name().c_str(), peerCodec->codecIndex());
++    success = p_peer->GetCodecs()->setLHDCCodecUserConfig(peerCodec, config, clen);
++    goto done;
++  } else {
++    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
++    success = BT_STATUS_NOT_READY;
++    goto done;
++  }
++
++done:
++  return success;
++}
++
++// LHDC extended API: set user data
++bool bta_av_co_set_codec_LHDC_user_data(
++    const RawAddress& peer_address,
++    const char *data, const int clen) {
++
++  bool success = true;
++  A2dpCodecConfig* peerCodec = NULL;
++
++  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
++  if (p_peer == nullptr) {
++    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
++        peer_address.ToString().c_str());
++    success = false;
++    goto done;
++  }
++
++  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
++  if (peerCodec) {
++    APPL_TRACE_DEBUG("%s: peerCodec: name=%s, codecIndex=%d", __func__,
++        peerCodec->name().c_str(), peerCodec->codecIndex());
++    if (!p_peer->GetCodecs()->setLHDCCodecUserData(peerCodec, data, clen)) {
++      success = false;
++      goto done;
++    }
++  } else {
++    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
++    success = false;
++    goto done;
++  }
++
++done:
++  return success;
++}
++/************************************************
++ * Savitech LHDC EXT API -- END
++ ***********************************************/
+diff --git a/system_bt/btif/include/btif_a2dp_source.h b/system_bt/btif/include/btif_a2dp_source.h
+index 60e5e0d3d..01e32a743 100644
+--- a/system_bt/btif/include/btif_a2dp_source.h
++++ b/system_bt/btif/include/btif_a2dp_source.h
+@@ -133,4 +133,23 @@ void btif_a2dp_source_debug_dump(int fd);
+ void btif_a2dp_source_set_dynamic_audio_buffer_size(
+     uint8_t dynamic_audio_buffer_size);
+ 
++//
++// Savitech LHDC EXT API -- START
++//
++int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++
++int btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++
++int btif_a2dp_source_encoder_LHDC_user_config_update_req(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++
++void btif_a2dp_source_encoder_LHDC_user_data_update_req(
++    uint16_t event, char* p_param);
++// Savitech LHDC EXT API -- END
++
+ #endif /* BTIF_A2DP_SOURCE_H */
+diff --git a/system_bt/btif/include/btif_av_co.h b/system_bt/btif/include/btif_av_co.h
+index 01b3b2fd0..5a8943557 100644
+--- a/system_bt/btif/include/btif_av_co.h
++++ b/system_bt/btif/include/btif_av_co.h
+@@ -86,4 +86,24 @@ A2dpCodecConfig* bta_av_get_a2dp_peer_current_codec(
+ // information.
+ void btif_a2dp_codec_debug_dump(int fd);
+ 
++//
++// Savitech LHDC EXT API -- START
++//
++int bta_av_co_get_codec_LHDC_user_ApiVer(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++
++int bta_av_co_get_codec_LHDC_user_config(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++
++int bta_av_co_set_codec_LHDC_user_config(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++
++bool bta_av_co_set_codec_LHDC_user_data(
++    const RawAddress& peer_addr,
++    const char *config, const int clen);
++// Savitech LHDC EXT API -- END
++
+ #endif  // BTIF_AV_CO_H
+diff --git a/system_bt/btif/src/btif_a2dp_audio_interface.cc b/system_bt/btif/src/btif_a2dp_audio_interface.cc
+index 7d7a083a3..2b60cc72f 100644
+--- a/system_bt/btif/src/btif_a2dp_audio_interface.cc
++++ b/system_bt/btif/src/btif_a2dp_audio_interface.cc
+@@ -232,6 +232,23 @@ static void btif_a2dp_get_codec_configuration(
+       p_codec_info->codecSpecific.ldacData.bitrateIndex =
+           a2dp_offload.codec_info[6];
+       break;
++    // Savitech Patch - START  Offload
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      p_codec_info->codecType =
++          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
++          BTA_AV_CODEC_TYPE_LHDCV3;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      p_codec_info->codecType =
++          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
++          BTA_AV_CODEC_TYPE_LHDCV2;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      p_codec_info->codecType =
++          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
++          BTA_AV_CODEC_TYPE_LHDCV5;
++      break;
++    // Savitech Patch - END
+     default:
+       APPL_TRACE_ERROR("%s: Unknown Codec type :%d ", __func__,
+                        codec_config.codec_type);
+diff --git a/system_bt/btif/src/btif_a2dp_sink.cc b/system_bt/btif/src/btif_a2dp_sink.cc
+index fa02a8682..2d905b616 100644
+--- a/system_bt/btif/src/btif_a2dp_sink.cc
++++ b/system_bt/btif/src/btif_a2dp_sink.cc
+@@ -90,6 +90,7 @@ class BtifA2dpSinkControlBlock {
+         sample_rate(0),
+         channel_count(0),
+         rx_focus_state(BTIF_A2DP_SINK_FOCUS_NOT_GRANTED),
++        //rx_focus_state(BTIF_A2DP_SINK_FOCUS_GRANTED),   //Savitech -- Enable A2DP Sink
+         audio_track(nullptr),
+         decoder_interface(nullptr) {}
+ 
+@@ -105,6 +106,7 @@ class BtifA2dpSinkControlBlock {
+     decode_alarm = nullptr;
+     rx_flush = false;
+     rx_focus_state = BTIF_A2DP_SINK_FOCUS_NOT_GRANTED;
++    //rx_focus_state = BTIF_A2DP_SINK_FOCUS_GRANTED;  //Savitech -- Enable A2DP Sink
+     sample_rate = 0;
+     channel_count = 0;
+     decoder_interface = nullptr;
+diff --git a/system_bt/btif/src/btif_a2dp_source.cc b/system_bt/btif/src/btif_a2dp_source.cc
+index 19bf998ab..94c5bfd78 100644
+--- a/system_bt/btif/src/btif_a2dp_source.cc
++++ b/system_bt/btif/src/btif_a2dp_source.cc
+@@ -271,6 +271,24 @@ static void btm_read_rssi_cb(void* data);
+ static void btm_read_failed_contact_counter_cb(void* data);
+ static void btm_read_tx_power_cb(void* data);
+ 
++// Savitech LHDC EXT API -- START
++static int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(
++    const RawAddress& peer_address,
++    const char *version, const int clen);
++
++static int btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(
++    const RawAddress& peer_address,
++    const char *config, const int clen);
++
++static int btif_a2dp_source_encoder_LHDC_user_config_update_event(
++    const RawAddress& peer_address,
++    const char *config, const int clen);
++
++static void btif_a2dp_source_encoder_LHDC_user_data_update_event(
++    const RawAddress& peer_address,
++    const char *data, const int clen);
++// Savitech LHDC EXT API -- END
++
+ void btif_a2dp_source_accumulate_scheduling_stats(SchedulingStats* src,
+                                                   SchedulingStats* dst) {
+   dst->total_updates += src->total_updates;
+@@ -904,10 +922,26 @@ static uint32_t btif_a2dp_source_read_callback(uint8_t* p_buf, uint32_t len) {
+   uint16_t event;
+   uint32_t bytes_read = 0;
+ 
+-  if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
+-    bytes_read = bluetooth::audio::a2dp::read(p_buf, len);
+-  } else if (a2dp_uipc != nullptr) {
+-    bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf, len);
++  uint32_t bytes_offset = 0;
++  uint32_t len_read = len;
++  uint32_t timeout_cnt = 0;
++
++  while (true) {
++    if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
++      bytes_read = bluetooth::audio::a2dp::read(p_buf + bytes_offset, len_read);
++    } else if (a2dp_uipc != nullptr) {
++      bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len_read);
++    }
++
++    // Savitech LHDC -- Low Latency Mode
++    bytes_offset += bytes_read;
++    len_read -= bytes_read;
++    timeout_cnt++;
++    if (len_read <= 0 || timeout_cnt >= 5) {
++        bytes_read = bytes_offset;
++        break;
++    }
++    usleep(1000);
+   }
+ 
+   if (bytes_read < len) {
+@@ -1383,3 +1417,71 @@ static void btm_read_tx_power_cb(void* data) {
+   LOG_WARN("%s: device: %s, Tx Power: %d", __func__,
+            result->rem_bda.ToString().c_str(), result->tx_power);
+ }
++
++//
++// Savitech LHDC EXT API -- START
++//
++// LHDC extended API: get API revision
++int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(
++    const RawAddress& peer_address,
++    const char *version, const int clen) {
++
++  return btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(peer_address, version, clen);
++}
++static int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(
++    const RawAddress& peer_address,
++    const char *version, const int clen) {
++
++  return bta_av_co_get_codec_LHDC_user_ApiVer(peer_address, version, clen);
++}
++
++// LHDC extended API: get config
++int btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(
++    const RawAddress& peer_address,
++    const char *config, const int clen) {
++
++  return btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(peer_address, config, clen);
++}
++static int btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(
++    const RawAddress& peer_address,
++    const char *config, const int clen) {
++
++  return bta_av_co_get_codec_LHDC_user_config(peer_address, config, clen);
++}
++
++// LHDC extended API: set config
++int btif_a2dp_source_encoder_LHDC_user_config_update_req(
++    const RawAddress& peer_address,
++    const char *config, const int clen) {
++
++  return btif_a2dp_source_encoder_LHDC_user_config_update_event(peer_address, config, clen);
++}
++static int btif_a2dp_source_encoder_LHDC_user_config_update_event(
++    const RawAddress& peer_address,
++    const char *config, const int clen) {
++
++  return bta_av_co_set_codec_LHDC_user_config(peer_address, config, clen);
++}
++
++// LHDC extended API: set user data
++void btif_a2dp_source_encoder_LHDC_user_data_update_req(
++    uint16_t event, char* p_param){
++
++  btif_av_codec_lhdc_api_data_t *pData;
++  pData = (btif_av_codec_lhdc_api_data_t *) p_param;
++  RawAddress peer_address;
++  memcpy(&peer_address, &(pData->bd_addr), sizeof(RawAddress) );
++  char *data = pData->pData;
++  int clen = pData->clen;
++
++  btif_a2dp_source_thread.DoInThread(
++      FROM_HERE, base::Bind(&btif_a2dp_source_encoder_LHDC_user_data_update_event,
++          peer_address, data, clen));
++}
++static void btif_a2dp_source_encoder_LHDC_user_data_update_event(
++    const RawAddress& peer_address,
++    const char *data, const int clen) {
++
++  bta_av_co_set_codec_LHDC_user_data(peer_address, data, clen);
++}
++// Savitech LHDC EXT API -- END
+diff --git a/system_bt/btif/src/btif_av.cc b/system_bt/btif/src/btif_av.cc
+index 50717d9eb..aa642caf4 100644
+--- a/system_bt/btif/src/btif_av.cc
++++ b/system_bt/btif/src/btif_av.cc
+@@ -17,6 +17,7 @@
+  ******************************************************************************/
+ 
+ #define LOG_TAG "btif_av"
++#define SAVITECH_A2DP_SINKx  // Savitech Patch - A2DP_Sink_Enable
+ 
+ #include <base/bind.h>
+ #include <base/strings/stringprintf.h>
+@@ -700,6 +701,7 @@ static void btif_av_sink_initiate_av_open_timer_timeout(void* data);
+ static void bta_av_sink_media_callback(const RawAddress& peer_address,
+                                        tBTA_AV_EVT event,
+                                        tBTA_AV_MEDIA* p_data);
++static BtifAvPeer* btif_av_find_active_peer();
+ 
+ static BtifAvPeer* btif_av_source_find_peer(const RawAddress& peer_address) {
+   return btif_av_source.FindPeer(peer_address);
+@@ -708,16 +710,68 @@ static BtifAvPeer* btif_av_sink_find_peer(const RawAddress& peer_address) {
+   return btif_av_sink.FindPeer(peer_address);
+ }
+ static BtifAvPeer* btif_av_find_peer(const RawAddress& peer_address) {
++#ifdef SAVITECH_A2DP_SINK
++  BtifAvPeer* avPeer = NULL;
++  avPeer = btif_av_find_active_peer();
++  if(avPeer) {
++    if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
++      return btif_av_sink_find_peer(peer_address);
++    }
++    if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
++      return btif_av_source_find_peer(peer_address);
++    }
++  }
++  return nullptr;
++#else
+   if (btif_av_source.Enabled()) return btif_av_source_find_peer(peer_address);
+   if (btif_av_sink.Enabled()) return btif_av_sink_find_peer(peer_address);
+   return nullptr;
++#endif
+ }
+ static BtifAvPeer* btif_av_find_active_peer() {
++#ifdef SAVITECH_A2DP_SINK
++  BtifAvPeer* activePeerIsSink = NULL;
++  BtifAvPeer* activePeerIsSrc = NULL;
++
++  if (btif_av_source.Enabled()) {
++    BTIF_TRACE_VERBOSE("%s: SRC Find -> ActivePeer:%s (%p)", __func__,
++      btif_av_source.ActivePeer().ToString().c_str(),
++      btif_av_source_find_peer(btif_av_source.ActivePeer()));
++    activePeerIsSink = btif_av_source_find_peer(btif_av_source.ActivePeer());
++  }
++  if (btif_av_sink.Enabled()) {
++    BTIF_TRACE_VERBOSE("%s: Sink Find -> ActivePeer:%s (%p)", __func__,
++        btif_av_sink.ActivePeer().ToString().c_str(),
++        btif_av_sink_find_peer(btif_av_sink.ActivePeer()));
++    activePeerIsSrc = btif_av_sink_find_peer(btif_av_sink.ActivePeer());
++  }
++
++  if( activePeerIsSrc != NULL && activePeerIsSink != NULL) {
++    //should not happened here
++    BTIF_TRACE_WARNING("%s: WARNING! Have both Src/Sink ActivePeers! (use default: SRC)", __func__);
++    return activePeerIsSrc;
++  }
++  if( activePeerIsSink != NULL) {
++    //AVDT_TSEP_SNK(1)
++    BTIF_TRACE_VERBOSE("%s: activePeerIsSink:%s Sep:%d", __func__,
++        activePeerIsSink->PeerAddress().ToString().c_str(), activePeerIsSink->PeerSep());
++    return activePeerIsSink;
++  }
++  if( activePeerIsSrc != NULL) {
++    //AVDT_TSEP_SRC(0)
++    BTIF_TRACE_VERBOSE("%s: activePeerIsSrc:%s Sep:%d", __func__,
++        activePeerIsSrc->PeerAddress().ToString().c_str(), activePeerIsSrc->PeerSep());
++    return activePeerIsSrc;
++  }
++  BTIF_TRACE_VERBOSE("%s: no any active peer found, Ret null", __func__);
++  return nullptr;
++#else
+   if (btif_av_source.Enabled())
+     return btif_av_source_find_peer(btif_av_source.ActivePeer());
+   if (btif_av_sink.Enabled())
+     return btif_av_sink_find_peer(btif_av_sink.ActivePeer());
+   return nullptr;
++#endif
+ }
+ 
+ /*****************************************************************************
+@@ -1495,6 +1549,34 @@ bool BtifAvStateMachine::StateIdle::ProcessEvent(uint32_t event, void* p_data) {
+ 
+       bool can_connect = true;
+       // Check whether connection is allowed
++#ifdef SAVITECH_A2DP_SINK
++      if (peer_.IsSink()) {
++        can_connect = btif_av_source.AllowedToConnect(peer_.PeerAddress());
++        if (!can_connect) {
++          src_disconnect_sink(peer_.PeerAddress());
++        } else {
++          alarm_set_on_mloop(
++                peer_.AvOpenOnRcTimer(), BtifAvPeer::kTimeoutAvOpenOnRcMs,
++                btif_av_source_initiate_av_open_timer_timeout, &peer_);
++        }
++      } else if (peer_.IsSource()) {
++        can_connect = btif_av_sink.AllowedToConnect(peer_.PeerAddress());
++        if (!can_connect) {
++          sink_disconnect_src(peer_.PeerAddress());
++        } else {
++          alarm_set_on_mloop(peer_.AvOpenOnRcTimer(),
++                               BtifAvPeer::kTimeoutAvOpenOnRcMs,
++                               btif_av_sink_initiate_av_open_timer_timeout, &peer_);
++        }
++      }
++      if (!can_connect) {
++        BTIF_TRACE_ERROR(
++            "%s: Cannot connect to peer %s: too many connected "
++            "peers",
++            __PRETTY_FUNCTION__, peer_.PeerAddress().ToString().c_str());
++        break;
++      }
++#else
+       if (peer_.IsSink()) {
+         can_connect = btif_av_source.AllowedToConnect(peer_.PeerAddress());
+         if (!can_connect) src_disconnect_sink(peer_.PeerAddress());
+@@ -1518,6 +1600,7 @@ bool BtifAvStateMachine::StateIdle::ProcessEvent(uint32_t event, void* p_data) {
+                            BtifAvPeer::kTimeoutAvOpenOnRcMs,
+                            btif_av_sink_initiate_av_open_timer_timeout, &peer_);
+       }
++#endif
+       if (event == BTA_AV_RC_OPEN_EVT) {
+         btif_rc_handler(event, (tBTA_AV*)p_data);
+       }
+@@ -2380,6 +2463,32 @@ static void btif_report_connection_state(const RawAddress& peer_address,
+   LOG_INFO("%s: peer_address=%s state=%d", __func__,
+            peer_address.ToString().c_str(), state);
+ 
++#ifdef SAVITECH_A2DP_SINK
++  BtifAvPeer* activePeer = NULL;
++  activePeer = btif_av_find_active_peer();
++  if(activePeer) {
++    if(activePeer->PeerSep()==AVDT_TSEP_SRC) {
++      LOG_INFO( "%s: ImSink -> connection_state_cb..", __func__);
++      do_in_jni_thread(FROM_HERE,
++          base::Bind(btif_av_sink.Callbacks()->connection_state_cb, peer_address, state));
++    }
++    if(activePeer->PeerSep()==AVDT_TSEP_SNK) {
++      LOG_INFO( "%s: ImSRC -> connection_state_cb..", __func__);
++      do_in_jni_thread(FROM_HERE,
++          base::Bind(btif_av_source.Callbacks()->connection_state_cb, peer_address, state));
++    }
++  } else {
++      if (btif_av_source.Enabled()) {
++        LOG_INFO( "%s: no active peer, source->connection_state_cb..", __func__);
++        do_in_jni_thread(FROM_HERE,
++            base::Bind(btif_av_source.Callbacks()->connection_state_cb, peer_address, state));
++      } else if (btif_av_sink.Enabled()) {
++        LOG_INFO( "%s: no active peer, sink->connection_state_cb..", __func__);
++        do_in_jni_thread(FROM_HERE,
++            base::Bind(btif_av_sink.Callbacks()->connection_state_cb, peer_address, state));
++      }
++  }
++#else
+   if (btif_av_source.Enabled()) {
+     do_in_jni_thread(FROM_HERE,
+                      base::Bind(btif_av_source.Callbacks()->connection_state_cb,
+@@ -2389,6 +2498,7 @@ static void btif_report_connection_state(const RawAddress& peer_address,
+                      base::Bind(btif_av_sink.Callbacks()->connection_state_cb,
+                                 peer_address, state));
+   }
++#endif
+ }
+ 
+ /**
+@@ -2405,6 +2515,36 @@ static void btif_report_audio_state(const RawAddress& peer_address,
+   LOG_INFO("%s: peer_address=%s state=%d", __func__,
+            peer_address.ToString().c_str(), state);
+ 
++#ifdef SAVITECH_A2DP_SINK
++  BtifAvPeer* avPeer = NULL;
++  avPeer = btif_av_find_active_peer();
++  if(avPeer) {
++    if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
++      LOG_INFO( "%s: ImSink -> audio_state_cb..", __func__);
++        do_in_jni_thread(FROM_HERE,
++            base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
++                peer_address, state));
++    }
++    if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
++      LOG_INFO( "%s: ImSRC -> audio_state_cb..", __func__);
++        do_in_jni_thread(FROM_HERE,
++            base::Bind(btif_av_source.Callbacks()->audio_state_cb,
++                peer_address, state));
++    }
++  } else {
++      if (btif_av_source.Enabled()) {
++        LOG_INFO( "%s: no active peer, source->audio_state_cb..", __func__);
++          do_in_jni_thread(FROM_HERE,
++                           base::Bind(btif_av_source.Callbacks()->audio_state_cb,
++                                      peer_address, state));
++      } else if (btif_av_sink.Enabled()) {
++        LOG_INFO( "%s: no active peer, sink->audio_state_cb..", __func__);
++          do_in_jni_thread(FROM_HERE,
++                           base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
++                                      peer_address, state));
++      }
++  }
++#else
+   if (btif_av_source.Enabled()) {
+     do_in_jni_thread(FROM_HERE,
+                      base::Bind(btif_av_source.Callbacks()->audio_state_cb,
+@@ -2414,7 +2554,7 @@ static void btif_report_audio_state(const RawAddress& peer_address,
+                      base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
+                                 peer_address, state));
+   }
+-
++#endif
+   using android::bluetooth::a2dp::AudioCodingModeEnum;
+   using android::bluetooth::a2dp::PlaybackStateEnum;
+   PlaybackStateEnum playback_state = PlaybackStateEnum::PLAYBACK_STATE_UNKNOWN;
+@@ -3026,6 +3166,88 @@ static void cleanup_sink(void) {
+                                           base::Unretained(&btif_av_sink)));
+ }
+ 
++// Savitech LHDC EXT API -- START
++static int lhdc_getApiVer_src(
++    const RawAddress& peer_address,
++    char* version, int clen) {
++
++  int status = BT_STATUS_NOT_READY;
++
++  if (!btif_av_source.Enabled()) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
++    return BT_STATUS_NOT_READY;
++  }
++
++  status = btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(peer_address, version, clen);
++
++  if (status != BT_STATUS_SUCCESS) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
++  }
++
++  return status;
++}
++
++static int lhdc_getApiCfg_src(
++    const RawAddress& peer_address,
++    char* config, int clen) {
++
++  int status = BT_STATUS_NOT_READY;
++
++  if (!btif_av_source.Enabled()) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
++    return BT_STATUS_NOT_READY;
++  }
++
++  status = btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(peer_address, config, clen);
++
++  if (status != BT_STATUS_SUCCESS) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
++  }
++
++  return status;
++}
++
++static int lhdc_setApiCfg_src(
++    const RawAddress& peer_address,
++    char* config, int clen) {
++
++  int status = BT_STATUS_NOT_READY;
++
++  if (!btif_av_source.Enabled()) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
++    return BT_STATUS_NOT_READY;
++  }
++
++  status = btif_a2dp_source_encoder_LHDC_user_config_update_req(peer_address, config, clen);
++
++  if (status != BT_STATUS_SUCCESS) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
++  }
++
++  return status;
++}
++
++static void lhdc_setApiData_src(
++    const RawAddress& peer_address,
++    char* data, int clen) {
++
++  if (!btif_av_source.Enabled()) {
++    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
++    return;
++  }
++
++  btif_av_codec_lhdc_api_data_t codec_data;
++  memcpy(&codec_data.bd_addr, (uint8_t *)&peer_address, sizeof(RawAddress));
++  codec_data.clen = clen;
++  codec_data.pData = data;
++
++  btif_transfer_context(btif_a2dp_source_encoder_LHDC_user_data_update_req, 0,
++                          (char *)&codec_data, sizeof(codec_data), NULL);
++
++  return;
++}
++// Savitech LHDC EXT API -- END
++
+ static const btav_source_interface_t bt_av_src_interface = {
+     sizeof(btav_source_interface_t),
+     init_src,
+@@ -3035,6 +3257,10 @@ static const btav_source_interface_t bt_av_src_interface = {
+     src_set_active_sink,
+     codec_config_src,
+     cleanup_src,
++    lhdc_getApiVer_src,
++    lhdc_getApiCfg_src,
++    lhdc_setApiCfg_src,
++    lhdc_setApiData_src,
+ };
+ 
+ static const btav_sink_interface_t bt_av_sink_interface = {
+@@ -3351,11 +3577,26 @@ void btif_av_acl_disconnected(const RawAddress& peer_address) {
+   LOG_INFO("%s: Peer %s : ACL Disconnected", __func__,
+            peer_address.ToString().c_str());
+ 
++#ifdef SAVITECH_A2DP_SINK
++  BtifAvPeer* avPeer = NULL;
++  avPeer = btif_av_find_active_peer();
++  if(avPeer) {
++    if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
++      LOG_INFO( "%s: peer is SRC", __func__);
++        btif_av_sink_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
++    }
++    if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
++      LOG_INFO( "%s: peer is SNK", __func__);
++      btif_av_source_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
++    }
++  }
++#else
+   if (btif_av_source.Enabled()) {
+     btif_av_source_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
+   } else if (btif_av_sink.Enabled()) {
+     btif_av_sink_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
+   }
++#endif
+ }
+ 
+ static void btif_debug_av_peer_dump(int fd, const BtifAvPeer& peer) {
+diff --git a/system_bt/btif/src/btif_avrcp_audio_track.cc b/system_bt/btif/src/btif_avrcp_audio_track.cc
+index 8ca5c9798..0d7a93262 100644
+--- a/system_bt/btif/src/btif_avrcp_audio_track.cc
++++ b/system_bt/btif/src/btif_avrcp_audio_track.cc
+@@ -32,6 +32,7 @@ typedef struct {
+   AAudioStream* stream;
+   int bitsPerSample;
+   int channelCount;
++  aaudio_format_t format;
+   float* buffer;
+   size_t bufferLength;
+ } BtifAvrcpAudioTrack;
+@@ -41,6 +42,7 @@ FILE* outputPcmSampleFile;
+ char outputFilename[50] = "/data/misc/bluedroid/output_sample.pcm";
+ #endif
+ 
++
+ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
+                                 int channelCount) {
+   LOG_VERBOSE("%s Track.cpp: btCreateTrack freq %d bps %d channel %d ",
+@@ -48,9 +50,13 @@ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
+ 
+   AAudioStreamBuilder* builder;
+   AAudioStream* stream;
++  aaudio_format_t format;
++
+   aaudio_result_t result = AAudio_createStreamBuilder(&builder);
+   AAudioStreamBuilder_setSampleRate(builder, trackFreq);
+-  AAudioStreamBuilder_setFormat(builder, AAUDIO_FORMAT_PCM_FLOAT);
++
++  format = AAUDIO_FORMAT_PCM_FLOAT;
++  AAudioStreamBuilder_setFormat(builder, format);
+   AAudioStreamBuilder_setChannelCount(builder, channelCount);
+   AAudioStreamBuilder_setSessionId(builder, AAUDIO_SESSION_ID_ALLOCATE);
+   AAudioStreamBuilder_setPerformanceMode(builder,
+@@ -64,6 +70,7 @@ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
+   trackHolder->stream = stream;
+   trackHolder->bitsPerSample = bitsPerSample;
+   trackHolder->channelCount = channelCount;
++  trackHolder->format = format;
+   trackHolder->bufferLength =
+       trackHolder->channelCount * AAudioStream_getBufferSizeInFrames(stream);
+   trackHolder->buffer = new float[trackHolder->bufferLength]();
+@@ -71,6 +78,7 @@ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
+ #if (DUMP_PCM_DATA == TRUE)
+   outputPcmSampleFile = fopen(outputFilename, "ab");
+ #endif
++
+   return (void*)trackHolder;
+ }
+ 
+@@ -152,7 +160,7 @@ static size_t transcodeQ15ToFloat(uint8_t* buffer, size_t length,
+                                   BtifAvrcpAudioTrack* trackHolder) {
+   size_t sampleSize = sampleSizeFor(trackHolder);
+   size_t i = 0;
+-  for (; i <= length / sampleSize; i++) {
++  for (; i < length / sampleSize; i++) {
+     trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat;
+   }
+   return i * sampleSize;
+@@ -162,9 +170,12 @@ static size_t transcodeQ23ToFloat(uint8_t* buffer, size_t length,
+                                   BtifAvrcpAudioTrack* trackHolder) {
+   size_t sampleSize = sampleSizeFor(trackHolder);
+   size_t i = 0;
+-  for (; i <= length / sampleSize; i++) {
++  for (; i < length / sampleSize; i++) {
+     size_t offset = i * sampleSize;
+-    int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
++    //int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
++    // FIXME: out of range memory access at buffer[-1]
++    int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0xFFFFFF00;
++    sample = sample >> 8;
+     trackHolder->buffer[i] = sample * kScaleQ23ToFloat;
+   }
+   return i * sampleSize;
+@@ -172,9 +183,9 @@ static size_t transcodeQ23ToFloat(uint8_t* buffer, size_t length,
+ 
+ static size_t transcodeQ31ToFloat(uint8_t* buffer, size_t length,
+                                   BtifAvrcpAudioTrack* trackHolder) {
+-  size_t sampleSize = sampleSizeFor(trackHolder);
++  size_t sampleSize = sampleSizeFor(trackHolder); //4
+   size_t i = 0;
+-  for (; i <= length / sampleSize; i++) {
++  for (; i < length / sampleSize; i++) {
+     trackHolder->buffer[i] = ((int32_t*)buffer)[i] * kScaleQ31ToFloat;
+   }
+   return i * sampleSize;
+@@ -210,14 +221,19 @@ int BtifAvrcpAudioTrackWriteData(void* handle, void* audioBuffer,
+   size_t sampleSize = sampleSizeFor(trackHolder);
+   int transcodedCount = 0;
+   do {
++    // only PCM float
++    CHECK(trackHolder->format == AAUDIO_FORMAT_PCM_FLOAT);
++
+     transcodedCount +=
+         transcodeToPcmFloat(((uint8_t*)audioBuffer) + transcodedCount,
+                             bufferLength - transcodedCount, trackHolder);
+ 
++    // FIXME: should return status not number of frames
+     retval = AAudioStream_write(
+         trackHolder->stream, trackHolder->buffer,
+         transcodedCount / (sampleSize * trackHolder->channelCount),
+         kTimeoutNanos);
++
+     LOG_VERBOSE("%s Track.cpp: btWriteData len = %d ret = %d", __func__,
+                 bufferLength, retval);
+   } while (transcodedCount < bufferLength);
+diff --git a/system_bt/common/metrics.cc b/system_bt/common/metrics.cc
+index 9214dcbde..ada5d0692 100644
+--- a/system_bt/common/metrics.cc
++++ b/system_bt/common/metrics.cc
+@@ -249,6 +249,14 @@ static A2dpSourceCodec get_a2dp_source_codec(int64_t codec_index) {
+       return A2dpSourceCodec::A2DP_SOURCE_CODEC_APTX_HD;
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+       return A2dpSourceCodec::A2DP_SOURCE_CODEC_LDAC;
++    // Savitech Patch - START  Offload
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV3;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV2;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV5;
++    // Savitech Patch - END
+     default:
+       return A2dpSourceCodec::A2DP_SOURCE_CODEC_UNKNOWN;
+   }
+diff --git a/system_bt/gd/os/log.h b/system_bt/gd/os/log.h
+index 312de3dec..99e557442 100644
+--- a/system_bt/gd/os/log.h
++++ b/system_bt/gd/os/log.h
+@@ -51,6 +51,9 @@ static_assert(LOG_TAG != nullptr, "LOG_TAG is null after header inclusion");
+     if (bluetooth::common::InitFlags::IsDebugLoggingEnabledForTag(LOG_TAG)) { \
+       ALOGD("%s:%d %s: " fmt, __FILE__, __LINE__, __func__, ##args);          \
+     }                                                                         \
++    else {                                                                    \
++      ALOGD("DBG: " fmt, ##args);     \
++    }                                                                         \
+   } while (false)
+ 
+ #define LOG_INFO(fmt, args...) ALOGI("%s:%d %s: " fmt, __FILE__, __LINE__, __func__, ##args)
+diff --git a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
+index 676798782..31d606fab 100644
+--- a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
++++ b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
+@@ -138,6 +138,11 @@ enum A2dpSourceCodec {
+   A2DP_SOURCE_CODEC_APTX = 3;
+   A2DP_SOURCE_CODEC_APTX_HD = 4;
+   A2DP_SOURCE_CODEC_LDAC = 5;
++  // Savitech Patch - START  Offload
++  A2DP_SOURCE_CODEC_LHDCV3 = 6;
++  A2DP_SOURCE_CODEC_LHDCV2 = 7;
++  A2DP_SOURCE_CODEC_LHDCV5 = 8;
++  // Savitech Patch - END
+ }
+ 
+ // Session information that gets logged for A2DP session.
+diff --git a/system_bt/include/hardware/bt_av.h b/system_bt/include/hardware/bt_av.h
+index b3be7a234..432644ae3 100644
+--- a/system_bt/include/hardware/bt_av.h
++++ b/system_bt/include/hardware/bt_av.h
+@@ -54,6 +54,9 @@ typedef enum {
+   BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
+   BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
+   BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
++  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
++  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
++  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+ 
+   BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
+ 
+@@ -63,6 +66,8 @@ typedef enum {
+   BTAV_A2DP_CODEC_INDEX_SINK_SBC = BTAV_A2DP_CODEC_INDEX_SINK_MIN,
+   BTAV_A2DP_CODEC_INDEX_SINK_AAC,
+   BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
++  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
++  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+ 
+   BTAV_A2DP_CODEC_INDEX_SINK_MAX,
+ 
+@@ -154,6 +159,15 @@ typedef struct {
+       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+         codec_name_str = "LDAC";
+         break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++        codec_name_str = "LHDC V2";
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++        codec_name_str = "LHDC V3";
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++        codec_name_str = "LHDC V5";
++        break;
+       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
+         codec_name_str = "SBC (Sink)";
+         break;
+@@ -163,6 +177,12 @@ typedef struct {
+       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+         codec_name_str = "LDAC (Sink)";
+         break;
++      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++        codec_name_str = "LHDC V3 (Sink)";
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++        codec_name_str = "LHDC V5 (Sink)";
++        break;
+       case BTAV_A2DP_CODEC_INDEX_MAX:
+         codec_name_str = "Unknown(CODEC_INDEX_MAX)";
+         break;
+@@ -302,6 +322,15 @@ typedef struct {
+   btav_audio_sink_config_callback audio_config_cb;
+ } btav_sink_callbacks_t;
+ 
++/** Savitech LHDC EXT API -- START
++ *  Structure for LHDC Extended API data
++ */
++typedef struct {
++  RawAddress bd_addr;
++  int clen;
++  char* pData;
++} btif_av_codec_lhdc_api_data_t;
++
+ /**
+  * NOTE:
+  *
+@@ -346,6 +375,19 @@ typedef struct {
+   /** Closes the interface. */
+   void (*cleanup)(void);
+ 
++  // Savitech LHDC EXT API -- START
++  int (*getApiVer_lhdc)(   /* mapping to lhdc_getApiVer_src */
++      const RawAddress& bd_addr, char* version, int clen);
++
++  int (*getApiCfg_lhdc)(   /* mapping to lhdc_getApiCfg_src */
++      const RawAddress& bd_addr, char* config, int clen);
++
++  int (*setApiCfg_lhdc)(   /* mapping to lhdc_setApiCfg_src */
++      const RawAddress& bd_addr, char* config, int clen);
++
++  void (*setAPiData_lhdc)( /* mapping to lhdc_setApiData_src */
++      const RawAddress& bd_addr, char* data, int clen);
++  // Savitech LHDC EXT API -- END
+ } btav_source_interface_t;
+ 
+ /** Represents the standard BT-AV A2DP Sink interface.
+diff --git a/system_bt/internal_include/bt_target.h b/system_bt/internal_include/bt_target.h
+index dd8c74eba..bc06a2ee3 100644
+--- a/system_bt/internal_include/bt_target.h
++++ b/system_bt/internal_include/bt_target.h
+@@ -77,6 +77,7 @@
+ 
+ #ifndef BTA_AV_SINK_INCLUDED
+ #define BTA_AV_SINK_INCLUDED FALSE
++//#define BTA_AV_SINK_INCLUDED TRUE   // Savitech -- Enable A2DP Sink
+ #endif
+ 
+ #ifndef BTA_DISABLE_DELAY
+@@ -813,7 +814,7 @@
+ 
+ /* Number of simultaneous stream endpoints. */
+ #ifndef AVDT_NUM_SEPS
+-#define AVDT_NUM_SEPS 6
++#define AVDT_NUM_SEPS 14    //Savitech LHDC
+ #endif
+ 
+ /* Number of transport channels setup by AVDT for all media streams */
+diff --git a/system_bt/main/Android.bp b/system_bt/main/Android.bp
+index 67cb3eca4..9d7f922ff 100644
+--- a/system_bt/main/Android.bp
++++ b/system_bt/main/Android.bp
+@@ -156,6 +156,10 @@ cc_library_shared {
+     required: [
+         "bt_did.conf",
+         "bt_stack.conf",
++        "liblhdcBT_enc",
++        "liblhdcBT_dec",
++        "liblhdcv5BT_enc",
++        "liblhdcv5BT_dec",
+     ],
+     cflags: [
+         "-DBUILDCFG",
+diff --git a/system_bt/stack/Android.bp b/system_bt/stack/Android.bp
+index 9a5be5f67..10101e7ab 100644
+--- a/system_bt/stack/Android.bp
++++ b/system_bt/stack/Android.bp
+@@ -56,6 +56,14 @@ cc_library_static {
+         "external/aac/libSYS/include",
+         "external/libldac/inc",
+         "external/libldac/abr/inc",
++        "external/liblhdc/inc",
++        "external/liblhdc/include",
++        "external/liblhdcdec/inc",
++        "external/liblhdcdec/include",
++        "external/liblhdcv5/inc",
++        "external/liblhdcv5/include",
++        "external/liblhdcv5dec/inc",
++        "external/liblhdcv5dec/include",
+         "system/bt",
+         "system/bt/btcore/include",
+         "system/bt/vnd/include",
+@@ -88,6 +96,15 @@ cc_library_static {
+         "a2dp/a2dp_vendor_ldac_abr.cc",
+         "a2dp/a2dp_vendor_ldac_decoder.cc",
+         "a2dp/a2dp_vendor_ldac_encoder.cc",
++        "a2dp/a2dp_vendor_lhdcv2.cc",
++        "a2dp/a2dp_vendor_lhdcv2_encoder.cc",
++        "a2dp/a2dp_vendor_lhdcv3.cc",
++        "a2dp/a2dp_vendor_lhdcv3_encoder.cc",
++        "a2dp/a2dp_vendor_lhdcv3_dec.cc",
++        "a2dp/a2dp_vendor_lhdcv3_decoder.cc",
++        "a2dp/a2dp_vendor_lhdcv5.cc",
++        "a2dp/a2dp_vendor_lhdcv5_encoder.cc",
++        "a2dp/a2dp_vendor_lhdcv5_decoder.cc",
+         "avct/avct_api.cc",
+         "avct/avct_bcb_act.cc",
+         "avct/avct_ccb.cc",
+@@ -212,6 +229,10 @@ cc_library_static {
+     required: [
+         "libldacBT_enc",
+         "libldacBT_abr",
++        "liblhdcBT_enc",
++        "liblhdcBT_dec",
++        "liblhdcv5BT_enc",
++        "liblhdcv5BT_dec",
+     ],
+     host_supported: true,
+ }
+diff --git a/system_bt/stack/a2dp/a2dp_codec_config.cc b/system_bt/stack/a2dp/a2dp_codec_config.cc
+index a90c88108..0869fad5e 100644
+--- a/system_bt/stack/a2dp/a2dp_codec_config.cc
++++ b/system_bt/stack/a2dp/a2dp_codec_config.cc
+@@ -33,6 +33,10 @@
+ #include "a2dp_vendor_aptx.h"
+ #include "a2dp_vendor_aptx_hd.h"
+ #include "a2dp_vendor_ldac.h"
++#include "a2dp_vendor_lhdcv2.h"
++#include "a2dp_vendor_lhdcv3.h"
++#include "a2dp_vendor_lhdcv3_dec.h"
++#include "a2dp_vendor_lhdcv5.h"
+ #endif
+ 
+ #include "bta/av/bta_av_int.h"
+@@ -139,6 +143,21 @@ A2dpCodecConfig* A2dpCodecConfig::createCodec(
+     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+       codec_config = new A2dpCodecConfigLdacSink(codec_priority);
+       break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      codec_config = new A2dpCodecConfigLhdcV2(codec_priority);
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      codec_config = new A2dpCodecConfigLhdcV3(codec_priority);
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      codec_config = new A2dpCodecConfigLhdcV5Source(codec_priority);
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++      codec_config = new A2dpCodecConfigLhdcV3Sink(codec_priority);
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++      codec_config = new A2dpCodecConfigLhdcV5Sink(codec_priority);
++      break;
+ #endif
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+     default:
+@@ -248,12 +267,430 @@ bool A2dpCodecConfig::getCodecSpecificConfig(tBT_A2DP_OFFLOAD* p_a2dp_offload) {
+         LOG_VERBOSE("%s: Ldac specific channelmode =%d", __func__,
+                     p_a2dp_offload->codec_info[7]);
+       }
++      // Savitech Patch - START  Offload
++      else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++        //
++        // LHDC V3
++        //
++        // Main Version
++        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER3 &&
++            (codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER6) {
++          LOG_ERROR("%s: [LHDC V3] Unsupported version 0x%x", __func__,
++              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
++          goto fail;
++        }
++
++        LOG_DEBUG("%s: [LHDC V3] isLLAC=%d isLHDCV4=%d", __func__,
++            (codec_config[10] & A2DP_LHDC_FEATURE_LLAC),
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4));
++        // LHDC/LLAC handle Version
++        if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) != 0 &&
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
++          // LLAC (isLLAC && !isLHDCV4)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_LLAC-1);
++          LOG_DEBUG("%s: [LHDC V3] init to LLAC (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) != 0) {
++          // LHDC V4 Only (!isLLAC && isLHDCV4)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V4_ONLY-1);
++          LOG_DEBUG("%s: [LHDC V3] init to LHDCV4 only (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
++          // LHDC V3 Only (!isLLAC && !isLHDCV4)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
++          LOG_DEBUG("%s: [LHDC V3] init to LHDCV3 only (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        }else {
++          // LHDC V3 Only - default
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
++          LOG_DEBUG("%s: [LHDC V3] flags check incorrect. So init to LHDCV3 only (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        }
++
++        // bit rate index
++        switch (codec_config_.codec_specific_1 & 0x0F) {
++        case A2DP_LHDC_QUALITY_LOW0:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW2:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW3:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW4:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_MID:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_HIGH:
++        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V3
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_ABR:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        default:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        }
++        LOG_DEBUG("%s: [LHDC V3] Bit Rate = 0x%02X", __func__,
++            (uint8_t)(codec_config_.codec_specific_1 & 0x0F));
++
++        // max bit rate index
++        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V3] Max Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
++
++        // min bit rate index
++        if ((codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR) == A2DP_LHDC_FEATURE_MIN_BR) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++        } else {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V3] Min Bit Rate = 0x%02X", __func__,
++            codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR);
++
++        // frameDuration - not supported
++        // p_a2dp_offload->codec_info[13]
++
++        // data interval
++        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
++          // LL is enabled (10 ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
++          LOG_DEBUG("%s: [LHDC V3] Low Latency mode", __func__);
++        } else {
++          // LL is disabled (20ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
++          LOG_DEBUG("%s: [LHDC V3] Normal Latency mode", __func__);
++        }
++
++        // Codec specific 1
++        if ((codec_config[9] & A2DP_LHDC_FEATURE_AR) != 0) {
++          // AR
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
++          LOG_DEBUG("%s: [LHDC V3] Has feature AR", __func__);
++        }
++        if ((codec_config[9] & A2DP_LHDC_FEATURE_JAS) != 0) {
++          // JAS
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
++          LOG_DEBUG("%s: [LHDC V3] Has feature JAS", __func__);
++        }
++        if ((codec_config[11] & A2DP_LHDC_FEATURE_META) != 0) {
++          // META
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
++          LOG_DEBUG("%s: [LHDC V3] Has feature META", __func__);
++        }
++
++        // Codec specific 2
++        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
++          // split mode disabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
++          LOG_DEBUG("%s: [LHDC V3] No ch split", __func__);
++        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
++          // split mode enabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
++          LOG_DEBUG("%s: [LHDC V3] Has ch split", __func__);
++        } else {
++          LOG_ERROR("%s: [LHDC V3] Unsupported split mode 0x%x", __func__,
++              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
++          goto fail;
++        }
++
++      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++        //
++        // LHDC V2
++        //
++        // Version
++        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) > A2DP_LHDC_VER2) {
++          LOG_ERROR("%s: [LHDC V2] Unsupported version 0x%x", __func__,
++              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
++          goto fail;
++        }
++        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV2_VER_1-1);
++        LOG_DEBUG("%s: [LHDC V2] version (0x%02X)", __func__,
++            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++
++        // bit rate index
++        switch (codec_config_.codec_specific_1 & 0x0F) {
++        case A2DP_LHDC_QUALITY_LOW0:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW2:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW3:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW4:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_MID:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_HIGH:
++        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V2
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_ABR:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        default:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        }
++        LOG_DEBUG("%s: [LHDC V2] Bit Rate = 0x%02X", __func__,
++            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
++
++        // max bit rate index
++        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V2] Max Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
++
++        // min bit rate index - not supported
++        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]
++        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]
++
++        // frameDuration - not supported
++        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR]
++
++        // data interval
++        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
++          // LL is enabled (10 ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
++          LOG_DEBUG("%s: [LHDC V2] Low Latency mode", __func__);
++        } else {
++          // LL is disabled (20ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
++          LOG_DEBUG("%s: [LHDC V2] Normal Latency mode", __func__);
++        }
++
++        // Codec specific 1 - not supported
++        // p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1]
++
++        // Codec specific 2
++        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
++          // split mode disabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
++          LOG_DEBUG("%s: [LHDC V2] No ch split", __func__);
++        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
++          // split mode enabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
++          LOG_DEBUG("%s: [LHDC V2] Has ch split", __func__);
++        } else {
++          LOG_ERROR("%s: [LHDC V2] Unsupported split mode 0x%x", __func__,
++              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
++          goto fail;
++        }
++      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++        //
++        // LHDC V5
++        //
++
++        // Version
++        if ((codec_config[11] & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_1) {
++          LOG_ERROR("%s: [LHDC V5] unsupported version 0x%x", __func__,
++              (codec_config[11] & A2DP_LHDCV5_VERSION_MASK));
++          goto fail;
++        }
++        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV5_VER_1-1);
++        LOG_DEBUG("%s: [LHDC V5] version (0x%02X)", __func__,
++            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++
++        // bit rate index
++        switch (codec_config_.codec_specific_1 & 0xF) {
++        case A2DP_LHDCV5_QUALITY_LOW0:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW2:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW3:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW4:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_MID:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_HIGH:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_HIGH1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_ABR:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        default:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        }
++        LOG_DEBUG("%s: [LHDC V5] Bit Rate = 0x%02X", __func__,
++            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
++
++        // max bit rate index
++        if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++        } else {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V5] Max Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
++
++        // min bit rate index
++        if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++        } else {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V5] Min Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
++
++        // frame duration
++        if ((codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK) != 0) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR] = A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US;
++          LOG_DEBUG("%s: [LHDC V5] Frame Duration: 5ms ", __func__);
++        } else {
++          LOG_ERROR("%s: [LHDC V5] unsupported frame duration 0x%x", __func__,
++              codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK);
++          goto fail;
++        }
++
++        // data interval
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_LL) != 0) {
++          // LL is disabled (10 ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
++          LOG_DEBUG("%s: [LHDC V5] Low Latency mode", __func__);
++        } else {
++          // LL is enabled (20ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
++          LOG_DEBUG("%s: [LHDC V5] Normal Latency mode", __func__);
++        }
++
++        // Codec specific 1
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_AR) != 0) {
++          // AR
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
++          LOG_DEBUG("%s: [LHDC V5] Has feature AR", __func__);
++        }
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_JAS) != 0) {
++          // JAS
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
++          LOG_DEBUG("%s: [LHDC V5] Has feature JAS", __func__);
++        }
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_META) != 0) {
++          // META
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
++          LOG_DEBUG("%s: [LHDC V5] Has feature META", __func__);
++        }
++
++        // Codec specific 2
++        if ((codec_config[13] & A2DP_LHDCV5_AR_ON) != 0) {
++          // AR_ON
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON;
++          LOG_DEBUG("%s: [LHDC V5] AR_ON is set", __func__);
++        }
++      }
++      // Savitech Patch - END
+       break;
+ #endif
+     default:
+       break;
+   }
+   return true;
++
++fail:
++  return false;
+ }
+ 
+ bool A2dpCodecConfig::isValid() const { return true; }
+@@ -375,9 +812,11 @@ bool A2dpCodecConfig::setCodecUserConfig(
+   //
+   btav_a2dp_codec_config_t new_codec_config = getCodecConfig();
+   if ((saved_codec_config.sample_rate != new_codec_config.sample_rate) ||
+-      (saved_codec_config.bits_per_sample !=
+-       new_codec_config.bits_per_sample) ||
+-      (saved_codec_config.channel_mode != new_codec_config.channel_mode)) {
++      (saved_codec_config.bits_per_sample != new_codec_config.bits_per_sample) ||
++      (saved_codec_config.channel_mode != new_codec_config.channel_mode) ||
++      (saved_codec_config.codec_specific_1 != new_codec_config.codec_specific_1) || // Savitech LHDC
++      (saved_codec_config.codec_specific_2 != new_codec_config.codec_specific_2) ||
++      (saved_codec_config.codec_specific_3 != new_codec_config.codec_specific_3)) {
+     *p_restart_input = true;
+   }
+ 
+@@ -600,6 +1039,15 @@ bool A2dpCodecs::init() {
+       } else if (strcmp(tok, "ldac") == 0) {
+         LOG_INFO("%s: LDAC offload supported", __func__);
+         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC] = true;
++      } else if (strcmp(tok, "lhdcv2") == 0) {  // Savitech LHDC
++        LOG_INFO("%s: LHDCV2 offload not supported", __func__);
++        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2] = false;
++      } else if (strcmp(tok, "lhdcv3") == 0) {
++        LOG_INFO("%s: LHDCV3 offload not supported", __func__);
++        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3] = false;
++      } else if (strcmp(tok, "lhdcv5") == 0) {
++        LOG_INFO("%s: LHDCV5 offload not supported", __func__);
++        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5] = false;
+ #endif
+       }
+       tok = strtok_r(NULL, "-", &tmp_token);
+@@ -729,6 +1177,288 @@ bool A2dpCodecs::setSinkCodecConfig(const uint8_t* p_peer_codec_info,
+   return true;
+ }
+ 
++/***********************************************
++ * Savitech LHDC EXT API -- START
++ ***********************************************/
++static bool swapInt64toByteArray(unsigned char *byteArray, int64_t integer64)
++{
++  bool ret = false;
++  if (!byteArray) {
++    APPL_TRACE_ERROR("%s: null ptr", __func__);
++    return ret;
++  }
++
++  byteArray[7] = ((integer64 & 0x00000000000000FF) >> 0);
++  byteArray[6] = ((integer64 & 0x000000000000FF00) >> 8);
++  byteArray[5] = ((integer64 & 0x0000000000FF0000) >> 16);
++  byteArray[4] = ((integer64 & 0x00000000FF000000) >> 24);
++  byteArray[3] = ((integer64 & 0x000000FF00000000) >> 32);
++  byteArray[2] = ((integer64 & 0x0000FF0000000000) >> 40);
++  byteArray[1] = ((integer64 & 0x00FF000000000000) >> 48);
++  byteArray[0] = ((integer64 & 0xFF00000000000000) >> 56);
++
++  ret = true;
++  return ret;
++}
++
++static bool getLHDCA2DPSpecficV2(btav_a2dp_codec_config_t *a2dpCfg, unsigned char *pucConfig, const int clen)
++{
++  if (clen < (int)LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2 ) {
++    APPL_TRACE_ERROR("%s: payload size too small! clen=%d ",__func__, clen);
++    return false;
++  }
++
++  /* copy specifics into buffer */
++  if ( !(
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2], a2dpCfg->codec_specific_1) &&
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2], a2dpCfg->codec_specific_2) &&
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2], a2dpCfg->codec_specific_3) &&
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2], a2dpCfg->codec_specific_4)
++      )) {
++    APPL_TRACE_ERROR("%s: fail to copy specifics to buffer!",  __func__);
++    return false;
++  }
++
++  /* fill capability metadata fields */
++  if( A2DP_VendorGetSrcCapVectorLhdcv3(&pucConfig[LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2]) ) {
++    APPL_TRACE_DEBUG("%s: Get metadata of capabilities success!", __func__);
++  } else {
++    APPL_TRACE_ERROR("%s: fail to get capability fields!",  __func__);
++    return false;
++  }
++
++  return true;
++}
++
++static bool getLHDCA2DPSpecficV1(btav_a2dp_codec_config_t *a2dpCfg, unsigned char *pucConfig, const int clen)
++{
++  if (clen < (int)LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1 ) {
++    APPL_TRACE_ERROR("%s: payload size too small! clen=%d ",__func__, clen);
++    return false;
++  }
++
++  /* copy specifics into buffer */
++  if( !(
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1], a2dpCfg->codec_specific_1) &&
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1], a2dpCfg->codec_specific_2) &&
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1], a2dpCfg->codec_specific_3) &&
++      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1], a2dpCfg->codec_specific_4)
++      )) {
++    APPL_TRACE_ERROR("%s: fail to copy specifics to buffer!",  __func__);
++    return false;
++  }
++
++  return true;
++}
++
++int A2dpCodecs::getLHDCCodecUserConfig(
++    A2dpCodecConfig* peerCodec,
++    const char* codecConfig, const int clen) {
++
++  int result = BT_STATUS_FAIL;
++
++  if (peerCodec == nullptr || codecConfig == nullptr) {
++    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p codecConfig:%p)", __func__, peerCodec, codecConfig);
++    return BT_STATUS_FAIL;
++  }
++  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
++
++  switch(peerCodecIndex)
++  {
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++    result = peerCodec->getLhdcExtendAPIConfig(peerCodec, codecConfig, clen);
++    break;
++
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++    if (codecConfig[LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD] == LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK) {
++      /* **************************************
++       * LHDC A2DP related APIs:
++       * **************************************/
++      unsigned char *pucConfig = (unsigned char *) codecConfig;
++      unsigned int exFuncVer = 0;
++      unsigned int exFuncCode = 0;
++
++      if (pucConfig == NULL) {
++          APPL_TRACE_ERROR("%s: User Config error!(%p)",  __func__, codecConfig);
++          goto Fail;
++      }
++
++      /* check required buffer size for generic header */
++      if (clen < (int)(LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE)) {
++           // Buffer is too small for generic header size
++          APPL_TRACE_ERROR("%s: buffer is too small for command clen=%d",  __func__, clen);
++          goto Fail;
++      }
++
++      if (current_codec_config_ == NULL) {
++          APPL_TRACE_ERROR("%s: Can not get current a2dp codec config!",  __func__);
++          goto Fail;
++      }
++
++      A2dpCodecConfig *a2dp_codec_config = current_codec_config_;
++      btav_a2dp_codec_config_t codec_config_tmp;
++
++      exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
++                 ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
++                 ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
++                 ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
++      exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
++                  ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
++                  ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
++                  ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
++
++      switch (exFuncCode)
++      {
++        case EXTEND_FUNC_CODE_GET_SPECIFIC:
++          /* **************************************
++           * API::Get A2DP Specifics
++           * **************************************/
++          switch(pucConfig[LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD])
++          {
++            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG:
++              codec_config_tmp = a2dp_codec_config->getCodecConfig();
++              break;
++            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP:
++              codec_config_tmp = a2dp_codec_config->getCodecCapability();
++              break;
++            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP:
++              codec_config_tmp = a2dp_codec_config->getCodecLocalCapability();
++              break;
++            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP:
++              codec_config_tmp = a2dp_codec_config->getCodecSelectableCapability();
++              break;
++            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG:
++              codec_config_tmp = a2dp_codec_config->getCodecUserConfig();
++              break;
++            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG:
++              codec_config_tmp = a2dp_codec_config->getCodecAudioConfig();
++              break;
++            default:
++              APPL_TRACE_ERROR("%s: target a2dp config not found!",  __func__);
++              goto Fail;
++          }
++
++          switch (exFuncVer)
++          {
++            case EXTEND_FUNC_VER_GET_SPECIFIC_V1:
++              if (!getLHDCA2DPSpecficV1(&codec_config_tmp, pucConfig, clen))
++                goto Fail;
++              break;
++            case EXTEND_FUNC_VER_GET_SPECIFIC_V2:
++              if (!getLHDCA2DPSpecficV2(&codec_config_tmp, pucConfig, clen))
++                goto Fail;
++              break;
++            default:
++              APPL_TRACE_DEBUG("%s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
++              goto Fail;
++          }
++          result = BT_STATUS_SUCCESS;
++          break;
++
++      default:
++        APPL_TRACE_DEBUG("%s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
++        goto Fail;
++      } // switch (exFuncCode)
++    } else if ( codecConfig[LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD] == LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK ) {
++      result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(codecConfig, clen);
++    }
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++  default:
++    APPL_TRACE_DEBUG("%s: feature not support!", __func__);
++    goto Fail;
++  }
++
++Fail:
++  return result;
++}
++
++int A2dpCodecs::setLHDCCodecUserConfig(
++    A2dpCodecConfig* peerCodec,
++    const char* codecConfig, const int clen) {
++
++  int result = BT_STATUS_FAIL;
++
++  if (peerCodec == nullptr || codecConfig == nullptr) {
++    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, codecConfig);
++    return BT_STATUS_FAIL;
++  }
++  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
++
++  switch(peerCodecIndex)
++  {
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++    result = peerCodec->setLhdcExtendAPIConfig(peerCodec, codecConfig, clen);
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++    result = A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(codecConfig, clen);
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++  default:
++    APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
++    return result;
++  }
++
++  return result;
++}
++
++bool A2dpCodecs::setLHDCCodecUserData(
++    A2dpCodecConfig* peerCodec,
++    const char* codecData, const int clen) {
++
++  if (peerCodec == nullptr || codecData == nullptr) {
++    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, codecData);
++    return false;
++  }
++  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
++
++  switch(peerCodecIndex)
++  {
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++    peerCodec->setLhdcExtendAPIData(peerCodec, codecData, clen);
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++    A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(codecData, clen);
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++  default:
++    APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
++    return false;
++  }
++
++  return true;
++}
++
++int A2dpCodecs::getLHDCCodecUserApiVer(
++    A2dpCodecConfig* peerCodec,
++    const char* version, const int clen) {
++  int result = BT_STATUS_FAIL;
++
++  if (peerCodec == nullptr || version == nullptr) {
++    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, version);
++    return BT_STATUS_FAIL;
++  }
++  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
++
++  switch(peerCodecIndex) {
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++    result = peerCodec->getLhdcExtendAPIVersion(peerCodec, version, clen);
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++    result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(version, clen);
++    break;
++  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++  default:
++    APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
++    return result;
++  }
++
++  return result;
++}
++/***********************************************
++ * Savitech LHDC EXT API -- END
++ ***********************************************/
++
+ bool A2dpCodecs::setCodecUserConfig(
+     const btav_a2dp_codec_config_t& codec_user_config,
+     const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+@@ -1403,11 +2133,14 @@ const tA2DP_DECODER_INTERFACE* A2DP_GetDecoderInterface(
+ 
+   switch (codec_type) {
+     case A2DP_MEDIA_CT_SBC:
++      LOG_DEBUG("%s: SBC", __func__);
+       return A2DP_GetDecoderInterfaceSbc(p_codec_info);
+ #if !defined(EXCLUDE_NONSTANDARD_CODECS)
+     case A2DP_MEDIA_CT_AAC:
++      LOG_DEBUG("%s: AAC", __func__);
+       return A2DP_GetDecoderInterfaceAac(p_codec_info);
+     case A2DP_MEDIA_CT_NON_A2DP:
++      LOG_DEBUG("%s: VENDOR CODEC", __func__);
+       return A2DP_VendorGetDecoderInterface(p_codec_info);
+ #endif
+     default:
+diff --git a/system_bt/stack/a2dp/a2dp_vendor.cc b/system_bt/stack/a2dp/a2dp_vendor.cc
+index bcea13d1c..b9936427f 100644
+--- a/system_bt/stack/a2dp/a2dp_vendor.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor.cc
+@@ -24,6 +24,10 @@
+ #include "a2dp_vendor_aptx.h"
+ #include "a2dp_vendor_aptx_hd.h"
+ #include "a2dp_vendor_ldac.h"
++#include "a2dp_vendor_lhdcv3.h"
++#include "a2dp_vendor_lhdcv2.h"
++#include "a2dp_vendor_lhdcv3_dec.h"
++#include "a2dp_vendor_lhdcv5.h"
+ #include "bt_target.h"
+ #include "osi/include/log.h"
+ #include "osi/include/osi.h"
+@@ -49,6 +53,21 @@ bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorSourceCodecValidLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return false;
+@@ -66,6 +85,16 @@ bool A2DP_IsVendorSinkCodecValid(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorSinkCodecValidLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV3 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info);
++  }
++
+   return false;
+ }
+ 
+@@ -81,6 +110,15 @@ bool A2DP_IsVendorPeerSourceCodecValid(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorPeerSourceCodecValidLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV3 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_IsVendorPeerSourceCodecValidLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_IsVendorPeerSourceCodecValidLhdcV5(p_codec_info);
++  }
+   return false;
+ }
+ 
+@@ -105,6 +143,21 @@ bool A2DP_IsVendorPeerSinkCodecValid(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorPeerSinkCodecValidLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_IsVendorPeerSinkCodecValidLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_IsVendorPeerSinkCodecValidLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_IsVendorPeerSinkCodecValidLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return false;
+@@ -122,6 +175,16 @@ bool A2DP_IsVendorSinkCodecSupported(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorSinkCodecSupportedLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV3 Sink
++  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_IsVendorSinkCodecSupportedLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5 Sink
++  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_IsVendorSinkCodecSupportedLhdcV5(p_codec_info);
++  }
++
+   return false;
+ }
+ 
+@@ -137,6 +200,16 @@ bool A2DP_IsVendorPeerSourceCodecSupported(const uint8_t* p_codec_info) {
+     return A2DP_IsPeerSourceCodecSupportedLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV3 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_IsPeerSourceCodecSupportedLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_IsPeerSourceCodecSupportedLhdcV5(p_codec_info);
++  }
++
+   return false;
+ }
+ 
+@@ -183,6 +256,23 @@ bool A2DP_VendorUsesRtpHeader(bool content_protection_enabled,
+                                         p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorUsesRtpHeaderLhdcV2(content_protection_enabled,
++                                          p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorUsesRtpHeaderLhdcV3(content_protection_enabled,
++                                          p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorUsesRtpHeaderLhdcV5(content_protection_enabled,
++                                          p_codec_info);
++  }
+   // Add checks based on <content_protection_enabled, vendor_id, codec_id>
+ 
+   return true;
+@@ -209,6 +299,21 @@ const char* A2DP_VendorCodecName(const uint8_t* p_codec_info) {
+     return A2DP_VendorCodecNameLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorCodecNameLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorCodecNameLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorCodecNameLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return "UNKNOWN VENDOR CODEC";
+@@ -248,6 +353,21 @@ bool A2DP_VendorCodecTypeEquals(const uint8_t* p_codec_info_a,
+     return A2DP_VendorCodecTypeEqualsLdac(p_codec_info_a, p_codec_info_b);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorCodecTypeEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorCodecTypeEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorCodecTypeEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
++  }
++
+   // OPTIONAL: Add extra vendor-specific checks based on the
+   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
+ 
+@@ -288,6 +408,21 @@ bool A2DP_VendorCodecEquals(const uint8_t* p_codec_info_a,
+     return A2DP_VendorCodecEqualsLdac(p_codec_info_a, p_codec_info_b);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorCodecEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorCodecEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorCodecEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
++  }
++
+   // Add extra vendor-specific checks based on the
+   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
+ 
+@@ -315,6 +450,21 @@ int A2DP_VendorGetBitRate(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetBitRateLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetBitRateLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetBitRateLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetBitRateLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return -1;
+@@ -341,6 +491,21 @@ int A2DP_VendorGetTrackSampleRate(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetTrackSampleRateLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return -1;
+@@ -367,6 +532,21 @@ int A2DP_VendorGetTrackBitsPerSample(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetTrackBitsPerSampleLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetTrackBitsPerSampleLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetTrackBitsPerSampleLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return -1;
+@@ -393,6 +573,21 @@ int A2DP_VendorGetTrackChannelCount(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetTrackChannelCountLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return -1;
+@@ -410,6 +605,16 @@ int A2DP_VendorGetSinkTrackChannelType(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetSinkTrackChannelTypeLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDC V3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetSinkTrackChannelTypeLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDC V5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetSinkTrackChannelTypeLhdcV5(p_codec_info);
++  }
++
+   return -1;
+ }
+ 
+@@ -437,6 +642,21 @@ bool A2DP_VendorGetPacketTimestamp(const uint8_t* p_codec_info,
+     return A2DP_VendorGetPacketTimestampLdac(p_codec_info, p_data, p_timestamp);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetPacketTimestampLhdcV2(p_codec_info, p_data, p_timestamp);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetPacketTimestampLhdcV3(p_codec_info, p_data, p_timestamp);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetPacketTimestampLhdcV5(p_codec_info, p_data, p_timestamp);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return false;
+@@ -467,6 +687,24 @@ bool A2DP_VendorBuildCodecHeader(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                            frames_per_packet);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorBuildCodecHeaderLhdcV2(p_codec_info, p_buf,
++                                               frames_per_packet);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorBuildCodecHeaderLhdcV3(p_codec_info, p_buf,
++                                               frames_per_packet);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorBuildCodecHeaderLhdcV5(p_codec_info, p_buf,
++                                               frames_per_packet);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return false;
+@@ -494,6 +732,21 @@ const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterface(
+     return A2DP_VendorGetEncoderInterfaceLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetEncoderInterfaceLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetEncoderInterfaceLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetEncoderInterfaceLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return NULL;
+@@ -512,6 +765,16 @@ const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterface(
+     return A2DP_VendorGetDecoderInterfaceLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV3 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorGetDecoderInterfaceLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5 Sink
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorGetDecoderInterfaceLhdcV5(p_codec_info);
++  }
++
+   return NULL;
+ }
+ 
+@@ -536,6 +799,21 @@ bool A2DP_VendorAdjustCodec(uint8_t* p_codec_info) {
+     return A2DP_VendorAdjustCodecLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorAdjustCodecLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorAdjustCodecLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorAdjustCodecLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return false;
+@@ -563,6 +841,21 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(
+     return A2DP_VendorSourceCodecIndexLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorSourceCodecIndexLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorSourceCodecIndexLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorSourceCodecIndexLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return BTAV_A2DP_CODEC_INDEX_MAX;
+@@ -580,6 +873,16 @@ btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndex(const uint8_t* p_codec_info) {
+     return A2DP_VendorSinkCodecIndexLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDC V3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorSinkCodecIndexLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDC V5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorSinkCodecIndexLhdcV5(p_codec_info);
++  }
++
+   return BTAV_A2DP_CODEC_INDEX_MAX;
+ }
+ 
+@@ -599,6 +902,18 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
+       return A2DP_VendorCodecIndexStrLdac();
+     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+       return A2DP_VendorCodecIndexStrLdacSink();
++    // Savitech Patch - START
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      return A2DP_VendorCodecIndexStrLhdcV2();
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      return A2DP_VendorCodecIndexStrLhdcV3();
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      return A2DP_VendorCodecIndexStrLhdcV5();
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++      return A2DP_VendorCodecIndexStrLhdcV3Sink();
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++      return A2DP_VendorCodecIndexStrLhdcV5Sink();
++    // Savitech Patch - END
+     // Add a switch statement for each vendor-specific codec
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+       break;
+@@ -624,6 +939,18 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
+       return A2DP_VendorInitCodecConfigLdac(p_cfg);
+     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+       return A2DP_VendorInitCodecConfigLdacSink(p_cfg);
++    // Savitech Patch - START
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      return A2DP_VendorInitCodecConfigLhdcV2(p_cfg);
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      return A2DP_VendorInitCodecConfigLhdcV3(p_cfg);
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      return A2DP_VendorInitCodecConfigLhdcV5(p_cfg);
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++      return A2DP_VendorInitCodecConfigLhdcV3Sink(p_cfg);
++    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++      return A2DP_VendorInitCodecConfigLhdcV5Sink(p_cfg);
++    // Savitech Patch - END
+     // Add a switch statement for each vendor-specific codec
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+       break;
+@@ -653,6 +980,21 @@ std::string A2DP_VendorCodecInfoString(const uint8_t* p_codec_info) {
+     return A2DP_VendorCodecInfoStringLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorCodecInfoStringLhdcV2(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV3
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_VendorCodecInfoStringLhdcV3(p_codec_info);
++  }
++
++  // Check for Savitech LHDCV5
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++    return A2DP_VendorCodecInfoStringLhdcV5(p_codec_info);
++  }
++
+   // Add checks based on <vendor_id, codec_id>
+ 
+   return "Unsupported codec vendor_id: " + loghex(vendor_id) +
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
+new file mode 100644
+index 000000000..6b0cc11b3
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
+@@ -0,0 +1,1431 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++/******************************************************************************
++ *
++ *  Utility functions to help build and parse the LHDC Codec Information
++ *  Element and Media Payload.
++ *
++ ******************************************************************************/
++
++#define LOG_TAG "a2dp_vendor_lhdcv2"
++
++#include "bt_target.h"
++
++#include "a2dp_vendor_lhdcv2.h"
++
++#include <string.h>
++
++#include <base/logging.h>
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv2_encoder.h"
++#include "bt_utils.h"
++#include "btif_av_co.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++// data type for the LHDC Codec Information Element */
++// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
++typedef struct {
++  uint32_t vendorId;
++  uint16_t codecId;    /* Codec ID for LHDC */
++  uint8_t sampleRate;  /* Sampling Frequency */
++  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
++  uint8_t channelSplitMode;
++  uint8_t version;
++  uint8_t maxTargetBitrate;
++  bool isLLSupported;
++} tA2DP_LHDC_CIE;
++
++/* LHDC Source codec capabilities */
++static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV2_CODEC_ID,   // codecId
++    // sampleRate
++    //(A2DP_LHDC_SAMPLING_FREQ_48000),
++    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
++    // bits_per_sample
++    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
++    //Channel Separation
++    A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
++    //Version number
++    A2DP_LHDC_VER2,
++    //Max target bit Rate
++    A2DP_LHDC_MAX_BIT_RATE_900K,
++    //LL supported ?
++    false,
++};
++    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
++
++/* Default LHDC codec configuration */
++static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
++    A2DP_LHDC_VENDOR_ID,                // vendorId
++    A2DP_LHDCV2_CODEC_ID,                 // codecId
++    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
++    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
++    A2DP_LHDC_CH_SPLIT_NONE,
++    A2DP_LHDC_VER2,
++    A2DP_LHDC_MAX_BIT_RATE_900K,
++    false,
++};
++
++static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv2 = {
++    a2dp_vendor_lhdcv2_encoder_init,
++    a2dp_vendor_lhdcv2_encoder_cleanup,
++    a2dp_vendor_lhdcv2_feeding_reset,
++    a2dp_vendor_lhdcv2_feeding_flush,
++    a2dp_vendor_lhdcv2_get_encoder_interval_ms,
++    a2dp_vendor_lhdcv2_send_frames,
++    a2dp_vendor_lhdcv2_set_transmit_queue_length};
++
++UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV2(
++    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_peer_codec_info);
++
++
++// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
++// |p_ie| is a pointer to the LHDC Codec Information Element information.
++// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_BuildInfoLhdcV2(uint8_t media_type,
++                                       const tA2DP_LHDC_CIE* p_ie,
++                                       uint8_t* p_result) {
++
++  const uint8_t* tmpInfo = p_result;
++  if (p_ie == NULL || p_result == NULL) {
++    return A2DP_INVALID_PARAMS;
++  }
++
++  *p_result++ = A2DP_LHDCV2_CODEC_LEN;    //0
++  *p_result++ = (media_type << 4);      //1
++  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
++
++  // Vendor ID and Codec ID
++  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
++  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
++  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
++
++  // Sampling Frequency & Bits per sample
++  uint8_t para = 0;
++
++  // sample rate bit0 ~ bit2
++  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
++
++  if (p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
++      para |= A2DP_LHDC_BIT_FMT_24;
++  if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
++      para |= A2DP_LHDC_BIT_FMT_16;
++
++  // Save octet 9
++  *p_result++ = para;   //9
++
++  para = p_ie->version;
++
++  para |= p_ie->maxTargetBitrate;
++
++  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
++
++  // Save octet 10
++  *p_result++ = para;   //a
++
++  //Save octet 11
++  para = p_ie->channelSplitMode;
++
++  *p_result++ = para;   //b
++
++  LOG_DEBUG( "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
++                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
++     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
++                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
++  return A2DP_SUCCESS;
++}
++
++// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
++// |p_codec_info|. If |is_capability| is true, the byte sequence is
++// codec capabilities, otherwise is codec configuration.
++// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
++// status code.
++static tA2DP_STATUS A2DP_ParseInfoLhdcV2(tA2DP_LHDC_CIE* p_ie,
++                                       const uint8_t* p_codec_info,
++                                       bool is_capability) {
++  uint8_t losc;
++  uint8_t media_type;
++  tA2DP_CODEC_TYPE codec_type;
++  const uint8_t* tmpInfo = p_codec_info;
++
++  //LOG_DEBUG( "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
++  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
++
++  // Check the codec capability length
++  losc = *p_codec_info++;
++
++  if (losc != A2DP_LHDCV2_CODEC_LEN) return A2DP_WRONG_CODEC;
++
++  media_type = (*p_codec_info++) >> 4;
++  codec_type = *p_codec_info++;
++    //LOG_DEBUG( "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
++  /* Check the Media Type and Media Codec Type */
++  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
++      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  // Check the Vendor ID and Codec ID */
++  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
++                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
++                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
++                   (*(p_codec_info + 3) << 24 & 0xFF000000);
++  p_codec_info += 4;
++  p_ie->codecId =
++      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
++  p_codec_info += 2;
++  LOG_DEBUG( "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
++  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
++      p_ie->codecId != A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
++  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
++    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
++    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++  }
++
++
++  p_codec_info += 1;
++
++  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
++  //p_ie->version = 1;
++
++  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
++  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
++
++  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
++  //p_ie->isLLSupported = false;
++
++  p_codec_info += 1;
++
++  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
++  //p_ie->channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
++
++
++
++
++    LOG_DEBUG( "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
++            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
++                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
++
++  if (is_capability) return A2DP_SUCCESS;
++
++  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
++    return A2DP_BAD_SAMP_FREQ;
++
++  return A2DP_SUCCESS;
++}
++
++// Build the LHDC Media Payload Header.
++// |p_dst| points to the location where the header should be written to.
++// If |frag| is true, the media payload frame is fragmented.
++// |start| is true for the first packet of a fragmented frame.
++// |last| is true for the last packet of a fragmented frame.
++// If |frag| is false, |num| is the number of number of frames in the packet,
++// otherwise is the number of remaining fragments (including this one).
++/*
++static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
++  if (p == NULL) return;
++  *p = ( uint8_t)( num & 0xff);
++}
++*/
++
++static bool A2DP_MaxBitRatetoQualityLevelLhdcV2(uint8_t *mode, uint8_t bitrate) {
++  if (mode == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  switch (bitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
++  case A2DP_LHDC_MAX_BIT_RATE_900K:
++    *mode = A2DP_LHDC_QUALITY_HIGH;
++    return true;
++  case A2DP_LHDC_MAX_BIT_RATE_500K:
++    *mode = A2DP_LHDC_QUALITY_MID;
++    return true;
++  case A2DP_LHDC_MAX_BIT_RATE_400K:
++    *mode = A2DP_LHDC_QUALITY_LOW;
++    return true;
++  }
++  return false;
++}
++
++static std::string lhdcV2_QualityModeBitRate_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDC_QUALITY_ABR:
++    return "ABR";
++  case A2DP_LHDC_QUALITY_HIGH1:
++    return "HIGH 1 (1000 Kbps)";
++  case A2DP_LHDC_QUALITY_HIGH:
++    return "HIGH (900 Kbps)";
++  case A2DP_LHDC_QUALITY_MID:
++    return "MID (500 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW:
++    return "LOW (400 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW4:
++    return "LOW 4 (320 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW3:
++    return "LOW 3 (256 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW2:
++    return "LOW 2 (192 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW1:
++    return "LOW 1 (128 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW0:
++    return "LOW 0 (64 Kbps)";
++  default:
++    return "Unknown Bit Rate Mode";
++  }
++}
++
++bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE cfg_cie;
++
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
++         (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
++}
++
++bool A2DP_IsVendorPeerSinkCodecValidLhdcV2(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE cfg_cie;
++
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
++         (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
++}
++
++// Checks whether A2DP LHDC codec configuration matches with a device's codec
++// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
++// the device's codec capabilities.
++// If |is_capability| is true, the byte sequence is codec capabilities,
++// otherwise is codec configuration.
++// |p_codec_info| contains the codec capabilities for a peer device that
++// is acting as an A2DP source.
++// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV2(
++    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_capability) {
++  tA2DP_STATUS status;
++  tA2DP_LHDC_CIE cfg_cie;
++
++  /* parse configuration */
++  status = A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, is_capability);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: parsing failed %d", __func__, status);
++    return status;
++  }
++
++  /* verify that each parameter is in range */
++
++  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
++            cfg_cie.sampleRate, p_cap->sampleRate);
++
++  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
++            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
++
++  /* sampling frequency */
++  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
++
++  /* bit per sample */
++  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
++
++  return A2DP_SUCCESS;
++}
++
++bool A2DP_VendorUsesRtpHeaderLhdcV2(UNUSED_ATTR bool content_protection_enabled,
++                                  UNUSED_ATTR const uint8_t* p_codec_info) {
++  // TODO: Is this correct? The RTP header is always included?
++  return true;
++}
++
++const char* A2DP_VendorCodecNameLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info) {
++  return "LHDC V2";
++}
++
++bool A2DP_VendorCodecTypeEqualsLhdcV2(const uint8_t* p_codec_info_a,
++                                    const uint8_t* p_codec_info_b) {
++  tA2DP_LHDC_CIE lhdc_cie_a;
++  tA2DP_LHDC_CIE lhdc_cie_b;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status =
++      A2DP_ParseInfoLhdcV2(&lhdc_cie_a, p_codec_info_a, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie_b, p_codec_info_b, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
++                                const uint8_t* p_codec_info_b) {
++  tA2DP_LHDC_CIE lhdc_cie_a;
++  tA2DP_LHDC_CIE lhdc_cie_b;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status =
++      A2DP_ParseInfoLhdcV2(&lhdc_cie_a, p_codec_info_a, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie_b, p_codec_info_b, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++
++  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
++         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample);
++}
++
++// Savitech Patch - START  Offload
++int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info) {
++
++  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
++  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
++
++  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
++      A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
++      case A2DP_LHDC_QUALITY_LOW0:
++        return 64000;
++      case A2DP_LHDC_QUALITY_LOW1:
++        return 128000;
++      case A2DP_LHDC_QUALITY_LOW2:
++        return 192000;
++      case A2DP_LHDC_QUALITY_LOW3:
++        return 256000;
++      case A2DP_LHDC_QUALITY_LOW4:
++        return 320000;
++      case A2DP_LHDC_QUALITY_LOW:
++        return 400000;
++      case A2DP_LHDC_QUALITY_MID:
++        return 600000;
++      case A2DP_LHDC_QUALITY_HIGH:
++        return 900000;
++      case A2DP_LHDC_QUALITY_ABR:
++        return 9999999;
++      case A2DP_LHDC_QUALITY_HIGH1:
++        [[fallthrough]];
++      default:
++        return -1;
++    }
++  }
++  return 400000;
++}
++// Savitech Patch - END
++
++int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.sampleRate) {
++    case A2DP_LHDC_SAMPLING_FREQ_44100:
++      return 44100;
++    case A2DP_LHDC_SAMPLING_FREQ_48000:
++      return 48000;
++    case A2DP_LHDC_SAMPLING_FREQ_88200:
++      return 88200;
++    case A2DP_LHDC_SAMPLING_FREQ_96000:
++      return 96000;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
++    tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.bits_per_sample) {
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++      return 16;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++      return 24;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++      return 32;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++      return -1;
++  }
++}
++
++int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++  return 2;
++}
++
++int A2DP_VendorGetChannelModeCodeLhdcV2(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++  return A2DP_LHDC_CHANNEL_MODE_STEREO;
++}
++
++bool A2DP_VendorGetPacketTimestampLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info,
++                                       const uint8_t* p_data,
++                                       uint32_t* p_timestamp) {
++  // TODO: Is this function really codec-specific?
++  *p_timestamp = *(const uint32_t*)p_data;
++  return true;
++}
++
++int16_t A2DP_VendorGetMaxDatarateLhdcV2(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++/*
++#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
++#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
++#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
++
++#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
++#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
++#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
++*/
++  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
++      case A2DP_LHDC_MAX_BIT_RATE_900K:
++      return A2DP_LHDC_QUALITY_HIGH;
++      case A2DP_LHDC_MAX_BIT_RATE_500K:
++      return A2DP_LHDC_QUALITY_MID;
++      case A2DP_LHDC_MAX_BIT_RATE_400K:
++      return A2DP_LHDC_QUALITY_LOW;
++  }
++  return -1;
++}
++
++bool A2DP_VendorGetLowLatencyStateLhdcV2(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  LOG_INFO( "%s: isLLSupported =%d", __func__, lhdc_cie.isLLSupported);
++
++  return lhdc_cie.isLLSupported ? true : false;
++}
++
++uint8_t A2DP_VendorGetVersionLhdcV2(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  LOG_INFO( "%s: version =%d", __func__, lhdc_cie.version);
++
++  return lhdc_cie.version;
++}
++
++
++int8_t A2DP_VendorGetChannelSplitModeLhdcV2(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  LOG_INFO( "%s: channelSplitMode =%d", __func__, lhdc_cie.channelSplitMode);
++
++  return lhdc_cie.channelSplitMode;
++}
++
++bool A2DP_VendorBuildCodecHeaderLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info,
++                                     BT_HDR* p_buf,
++                                     uint16_t frames_per_packet) {
++  uint8_t* p;
++
++  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
++  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
++  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
++  p[0] = ( uint8_t)( frames_per_packet & 0xff);
++  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
++  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
++  return true;
++}
++
++void A2DP_VendorDumpCodecInfoLhdcV2(const uint8_t* p_codec_info) {
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  LOG_DEBUG( "%s", __func__);
++
++  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV2 fail:%d", __func__, a2dp_status);
++    return;
++  }
++
++  LOG_DEBUG( "\tsamp_freq: 0x%x", lhdc_cie.sampleRate);
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++    LOG_DEBUG( "\tsamp_freq: (44100)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++    LOG_DEBUG( "\tsamp_freq: (48000)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++    LOG_DEBUG( "\tsamp_freq: (88200)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++    LOG_DEBUG( "\tsamp_freq: (96000)");
++  }
++}
++
++std::string A2DP_VendorCodecInfoStringLhdcV2(const uint8_t* p_codec_info) {
++  std::stringstream res;
++  std::string field;
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    res << "A2DP_ParseInfoLhdcV2 fail: " << loghex(a2dp_status);
++    return res.str();
++  }
++
++  res << "\tname: LHDC\n";
++
++  // Sample frequency
++  field.clear();
++  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
++              "44100");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
++              "48000");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
++              "88200");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
++              "96000");
++  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
++      << ")\n";
++
++  // Channel mode
++  field.clear();
++  AppendField(&field, 1,
++             "Stereo");
++  res << "\tch_mode: " << field << " (" << "Only support stereo."
++      << ")\n";
++
++  // bits per sample
++  field.clear();
++  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
++              "16");
++  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
++              "24");
++  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
++      << ")\n";
++
++  // Max data rate...
++  field.clear();
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
++              "900Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
++              "500Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
++              "400Kbps");
++  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
++      << ")\n";
++
++  // Version
++  field.clear();
++  AppendField(&field, (lhdc_cie.version <= A2DP_LHDC_VER2),
++              "LHDC V2");
++  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
++      << ")\n";
++
++
++  /*
++  field.clear();
++  AppendField(&field, 0, "NONE");
++  AppendField(&field, 0,
++              "Mono");
++  AppendField(&field, 0,
++              "Dual");
++  AppendField(&field, 1,
++              "Stereo");
++  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
++      << ")\n";
++*/
++  return res.str();
++}
++
++const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV2(
++    const uint8_t* p_codec_info) {
++  if (!A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info)) return NULL;
++
++  return &a2dp_encoder_interface_lhdcv2;
++}
++
++bool A2DP_VendorAdjustCodecLhdcV2(uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE cfg_cie;
++
++  // Nothing to do: just verify the codec info is valid
++  if (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
++    return false;
++
++  return true;
++}
++
++btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV2(
++    UNUSED_ATTR const uint8_t* p_codec_info) {
++  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2;
++}
++
++const char* A2DP_VendorCodecIndexStrLhdcV2(void) { return "LHDC V2"; }
++
++bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg) {
++  if (A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
++                         p_cfg->codec_info) != A2DP_SUCCESS) {
++    return false;
++  }
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  /* Content protection info - support SCMS-T */
++  uint8_t* p = p_cfg->protect_info;
++  *p++ = AVDT_CP_LOSC;
++  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
++  p_cfg->num_protect = 1;
++#endif
++
++  return true;
++}
++
++UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
++                                           btav_a2dp_codec_config_t* result) {
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++
++  result->bits_per_sample = config_cie.bits_per_sample;
++
++  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++}
++
++A2dpCodecConfigLhdcV2::A2dpCodecConfigLhdcV2(
++    btav_a2dp_codec_priority_t codec_priority)
++    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2, "LHDC V2",
++                      codec_priority) {
++  // Compute the local capability
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  }
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  }
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++  }
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++  }
++  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
++
++  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++}
++
++A2dpCodecConfigLhdcV2::~A2dpCodecConfigLhdcV2() {}
++
++bool A2dpCodecConfigLhdcV2::init() {
++  if (!isValid()) return false;
++
++  // Load the encoder
++  if (!A2DP_VendorLoadEncoderLhdcV2()) {
++    LOG_ERROR( "%s: cannot load the encoder", __func__);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2dpCodecConfigLhdcV2::useRtpHeaderMarkerBit() const { return false; }
++
++//
++// Selects the best sample rate from |sampleRate|.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_best_sample_rate(uint8_t sampleRate,
++                                    tA2DP_LHDC_CIE* p_result,
++                                    btav_a2dp_codec_config_t* p_codec_config) {
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    return true;
++  }
++  return false;
++}
++
++//
++// Selects the audio sample rate from |p_codec_audio_config|.
++// |sampleRate| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_audio_sample_rate(
++    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
++    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
++  switch (p_codec_audio_config->sample_rate) {
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
++      break;
++  }
++  return false;
++}
++
++//
++// Selects the best bits per sample from |bits_per_sample|.
++// |bits_per_sample| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_best_bits_per_sample(
++    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    return true;
++  }
++  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    return true;
++  }
++  return false;
++}
++
++//
++// Selects the audio bits per sample from |p_codec_audio_config|.
++// |bits_per_sample| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_audio_bits_per_sample(
++    const btav_a2dp_codec_config_t* p_codec_audio_config,
++    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++  switch (p_codec_audio_config->bits_per_sample) {
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++      break;
++  }
++  return false;
++}
++
++bool A2dpCodecConfigLhdcV2::copySinkCapability(uint8_t * codec_info){
++    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++    memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
++    return true;
++}
++
++bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
++                                         bool is_capability,
++                                         uint8_t* p_result_codec_config) {
++  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++  tA2DP_LHDC_CIE sink_info_cie;
++  tA2DP_LHDC_CIE result_config_cie;
++  uint8_t sampleRate;
++  uint8_t qualityMode = 0;
++  uint8_t bitRateQmode = 0;
++  bool isLLEnabled;
++  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
++
++  // Save the internal state
++  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
++  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
++  btav_a2dp_codec_config_t saved_codec_selectable_capability =
++      codec_selectable_capability_;
++  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
++  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
++  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
++  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
++  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
++  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
++  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
++         sizeof(ota_codec_peer_capability_));
++  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
++         sizeof(ota_codec_peer_config_));
++
++  tA2DP_STATUS status =
++      A2DP_ParseInfoLhdcV2(&sink_info_cie, p_peer_codec_info, is_capability);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
++              __func__, status);
++    goto fail;
++  }
++
++  //
++  // Build the preferred configuration
++  //
++  memset(&result_config_cie, 0, sizeof(result_config_cie));
++  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
++  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
++
++  if (sink_info_cie.version > a2dp_lhdc_source_caps.version) {
++    LOG_ERROR( "%s: Sink capbility version miss match! peer(%d), host(%d)",
++              __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
++    goto fail;
++  }
++
++  result_config_cie.version = sink_info_cie.version;
++
++  if (sink_info_cie.channelSplitMode & A2DP_LHDC_CH_SPLIT_TWS) {
++      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_TWS;
++  }else{
++      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
++  }
++
++
++  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
++  result_config_cie.isLLSupported = false;
++  switch (codec_user_config_.codec_specific_2 & 0x1ULL) {
++    case A2DP_LHDC_LL_ENABLE:
++    if (isLLEnabled) {
++      result_config_cie.isLLSupported = true;
++      codec_config_.codec_specific_2 |= 0x1ULL;
++    }
++    break;
++    case A2DP_LHDC_LL_DISABLE:
++      result_config_cie.isLLSupported = false;
++      codec_config_.codec_specific_2 &= ~0x1ULL;
++    break;
++  }
++  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
++  LOG_ERROR( "%s: isLLSupported, Sink(0x%02x) Set(0x%08x), result(0x%02x)", __func__,
++                                sink_info_cie.isLLSupported,
++                                (uint32_t)codec_user_config_.codec_specific_2,
++                                result_config_cie.isLLSupported);
++
++  //
++  // Select the sample frequency
++  //
++  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
++  LOG_ERROR( "%s: samplrate = 0x%x", __func__, sampleRate);
++  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++  switch (codec_user_config_.sample_rate) {
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
++      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++      break;
++  }
++
++  // Select the sample frequency if there is no user preference
++  do {
++    // Compute the selectable capability
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    }
++
++    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) break;
++
++    // Compute the common capability
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++
++    // No user preference - try the codec audio config
++    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
++                                 &result_config_cie, &codec_config_)) {
++      break;
++    }
++
++    // No user preference - try the default config
++    if (select_best_sample_rate(
++            a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
++            &result_config_cie, &codec_config_)) {
++      break;
++    }
++
++    // No user preference - use the best match
++    if (select_best_sample_rate(sampleRate, &result_config_cie,
++                                &codec_config_)) {
++      break;
++    }
++  } while (false);
++  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
++    LOG_ERROR(
++              "%s: cannot match sample frequency: source caps = 0x%x "
++              "sink info = 0x%x",
++              __func__, a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
++    goto fail;
++  }
++
++  //
++  // Select the bits per sample
++  //
++  // NOTE: this information is NOT included in the LHDC A2DP codec description
++  // that is sent OTA.
++  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
++  LOG_ERROR( "%s: a2dp_lhdc_source_caps.bits_per_sample = 0x%02x, sink_info_cie.bits_per_sample = 0x%02x", __func__, a2dp_lhdc_source_caps.bits_per_sample, sink_info_cie.bits_per_sample);
++  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  switch (codec_user_config_.bits_per_sample) {
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++      break;
++  }
++
++  // Select the bits per sample if there is no user preference
++  do {
++    // Compute the selectable capability
++      // Compute the selectable capability
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++
++    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) break;
++
++    // Compute the common capability
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++
++    // No user preference - the the codec audio config
++    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
++                                     &result_config_cie, &codec_config_)) {
++      break;
++    }
++
++    // No user preference - try the default config
++    if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
++                                    &result_config_cie, &codec_config_)) {
++      break;
++    }
++
++    // No user preference - use the best match
++    if (select_best_bits_per_sample(bits_per_sample,
++                                    &result_config_cie, &codec_config_)) {
++      break;
++    }
++  } while (false);
++  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
++    LOG_ERROR(
++              "%s: cannot match bits per sample: default = 0x%x "
++              "user preference = 0x%x",
++              __func__, a2dp_lhdc_default_config.bits_per_sample,
++              codec_user_config_.bits_per_sample);
++    goto fail;
++  }
++
++  //
++  // Select the channel mode
++  //
++  LOG_ERROR( "%s: channelMode = Only supported stereo", __func__);
++  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++  switch (codec_user_config_.channel_mode) {
++    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
++      codec_capability_.channel_mode = codec_user_config_.channel_mode;
++      codec_config_.channel_mode = codec_user_config_.channel_mode;
++      break;
++    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
++    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
++      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++      break;
++  }
++  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
++    LOG_ERROR(
++              "%s: codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO "
++              , __func__);
++    goto fail;
++  }
++
++  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
++
++  LOG_DEBUG( "%s: max target bitrate: 0x%02x", __func__,
++      result_config_cie.maxTargetBitrate);
++
++
++  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
++  LOG_ERROR("%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
++
++  // quality mode (BitRate) adjust
++  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
++    LOG_DEBUG( "%s: tag not match, use default Mode: ABR", __func__);
++  }
++  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
++
++  //
++  // quality mode adjust when non-ABR
++  //
++  if (qualityMode != A2DP_LHDC_QUALITY_ABR) {
++    // get corresponding quality mode of the max target bit rate
++    if (!A2DP_MaxBitRatetoQualityLevelLhdcV2(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
++      LOG_ERROR( "%s: get quality mode from maxTargetBitrate error", __func__);
++      goto fail;
++    }
++    // downgrade audio quality according to the max target bit rate
++    if (qualityMode > bitRateQmode) {
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
++      qualityMode = bitRateQmode;
++      LOG_DEBUG( "%s: downgrade quality mode to 0x%02X by max target bitrate", __func__, qualityMode);
++    }
++
++    // High1(1000K) does not supported in V2, downgrade to High(900K)
++    if (qualityMode == A2DP_LHDC_QUALITY_HIGH1) {
++      LOG_DEBUG( "%s: reset non-supported quality mode %s to HIGH (900 Kbps)", __func__,
++          lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
++      qualityMode = A2DP_LHDC_QUALITY_HIGH;
++    }
++  }
++
++  LOG_DEBUG( "%s: => final quality mode(0x%02X) = %s", __func__,
++      qualityMode,
++      lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
++
++  if (int ret = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
++                         p_result_codec_config) != A2DP_SUCCESS) {
++    LOG_ERROR("%s: A2DP_BuildInfoLhdcV2 fail(0x%x)", __func__, ret);
++    goto fail;
++  }
++
++  //
++  // Copy the codec-specific fields if they are not zero
++  //
++  if (codec_user_config_.codec_specific_1 != 0)
++    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
++  if (codec_user_config_.codec_specific_2 != 0)
++    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
++  if (codec_user_config_.codec_specific_3 != 0)
++    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
++  //codec_config_.codec_specific_3 = result_config_cie.isLLSupported == true ? 1 : 0;
++
++  if (codec_user_config_.codec_specific_4 != 0)
++    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
++
++
++  // Create a local copy of the peer codec capability, and the
++  // result codec config.
++    LOG_ERROR("%s: is_capability = %d", __func__, is_capability);
++  if (is_capability) {
++    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
++                                ota_codec_peer_capability_);
++  } else {
++    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
++                                ota_codec_peer_config_);
++  }
++  CHECK(status == A2DP_SUCCESS);
++
++  status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
++                              ota_codec_config_);
++  CHECK(status == A2DP_SUCCESS);
++  return true;
++
++fail:
++  // Restore the internal state
++  codec_config_ = saved_codec_config;
++  codec_capability_ = saved_codec_capability;
++  codec_selectable_capability_ = saved_codec_selectable_capability;
++  codec_user_config_ = saved_codec_user_config;
++  codec_audio_config_ = saved_codec_audio_config;
++  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
++  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
++         sizeof(ota_codec_peer_capability_));
++  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
++         sizeof(ota_codec_peer_config_));
++  return false;
++}
++
++
++
++bool A2dpCodecConfigLhdcV2::setPeerCodecCapabilities(
++                                                   const uint8_t* p_peer_codec_capabilities) {
++    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++    tA2DP_LHDC_CIE peer_info_cie;
++    uint8_t sampleRate;
++    uint8_t bits_per_sample;
++
++    // Save the internal state
++    btav_a2dp_codec_config_t saved_codec_selectable_capability =
++    codec_selectable_capability_;
++    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
++    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
++           sizeof(ota_codec_peer_capability_));
++
++    tA2DP_STATUS status =
++    A2DP_ParseInfoLhdcV2(&peer_info_cie, p_peer_codec_capabilities, true);
++    if (status != A2DP_SUCCESS) {
++        LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
++                  __func__, status);
++        goto fail;
++    }
++
++    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
++        LOG_ERROR( "%s: can't parse peer's capabilities: Missmatch version(%u:%u)",
++                  __func__, a2dp_lhdc_source_caps.version, peer_info_cie.version);
++        goto fail;
++    }
++
++    codec_selectable_capability_.codec_specific_3 = peer_info_cie.isLLSupported ? 1 : 0;
++
++    // Compute the selectable capability - bits per sample
++    //codec_selectable_capability_.bits_per_sample =
++    //a2dp_lhdc_source_caps.bits_per_sample;
++    bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    }
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    }
++
++
++    // Compute the selectable capability - sample rate
++    sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++        codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++        codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++        codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    }
++
++
++    // Compute the selectable capability - channel mode
++    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++
++    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
++                                ota_codec_peer_capability_);
++    CHECK(status == A2DP_SUCCESS);
++    return true;
++
++fail:
++    // Restore the internal state
++    codec_selectable_capability_ = saved_codec_selectable_capability;
++    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
++           sizeof(ota_codec_peer_capability_));
++    return false;
++}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
+new file mode 100644
+index 000000000..675125a3d
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
+@@ -0,0 +1,941 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#define LOG_TAG "a2dp_vendor_lhdcv2_encoder"
++#define ATRACE_TAG ATRACE_TAG_AUDIO
++
++#include "a2dp_vendor_lhdcv2_encoder.h"
++
++#ifndef OS_GENERIC
++#include <cutils/trace.h>
++#endif
++#include <dlfcn.h>
++#include <inttypes.h>
++#include <stdio.h>
++#include <string.h>
++
++#include <lhdcBT.h>
++
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv2.h"
++#include "bt_common.h"
++#include "common/time_util.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++//
++// Encoder for LHDC Source Codec
++//
++
++//
++// The LHDC encoder shared library, and the functions to use
++//
++static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
++static void* lhdc_encoder_lib_handle = NULL;
++
++static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
++typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
++
++static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
++typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
++
++static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
++typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
++static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
++typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
++
++//static const char* LHDC_GET_SAMPLING_FREQ_NAME = "lhdcBT_get_sampling_freq";
++//typedef int (*tLHDC_GET_SAMPLING_FREQ)(HANDLE_LHDC_BT hLhdcParam);
++
++static const char* LHDC_INIT_HANDLE_ENCODE_NAME = "lhdcBT_init_encoder";
++typedef int (*tLHDC_INIT_HANDLE_ENCODE)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
++
++static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
++typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
++
++
++static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
++typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
++
++static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
++typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
++
++//static const char* LHDC_GET_ERROR_CODE_NAME = "lhdcBT_get_error_code";
++//typedef int (*tLHDC_GET_ERROR_CODE)(HANDLE_LHDC_BT hLhdcParam);
++
++//static const char* LHDC_GET_SUPPORTED_VERSION = "lhdcBT_getSupportedVersion";
++//typedef int (*tLHDC_GET_SUPPORTED_VERSION)(HANDLE_LHDC_BT hLhdcParam);
++
++static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
++typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
++
++static tLHDC_GET_HANDLE lhdc_get_handle_func;
++static tLHDC_FREE_HANDLE lhdc_free_handle_func;
++static tLHDC_GET_BITRATE lhdc_get_bitrate_func;
++static tLHDC_SET_BITRATE lhdc_set_bitrate_func;
++static tLHDC_INIT_HANDLE_ENCODE lhdc_init_handle_encode_func;
++static tLHDC_ENCODE lhdc_encode_func;
++static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate_func;
++//static tLHDC_GET_ERROR_CODE lhdc_get_error_code_func;
++static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
++//static tLHDC_GET_SUPPORTED_VERSION lhdc_get_supported_version;
++static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
++
++// A2DP LHDC encoder interval in milliseconds
++#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 11
++#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
++
++// offset
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
++#else
++#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
++#endif
++
++//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
++
++typedef struct {
++  uint32_t sample_rate;
++  uint8_t channel_mode;
++  uint8_t bits_per_sample;
++  int quality_mode_index;
++  int latency_mode_index;
++  int pcm_wlength;
++  LHDCBT_SMPL_FMT_T pcm_fmt;
++  int8_t channelSplitMode;
++  int8_t maxTargetBitrate;
++  bool isLLEnabled;
++} tA2DP_LHDC_ENCODER_PARAMS;
++
++typedef struct {
++  uint32_t counter;
++  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
++  uint64_t last_frame_us;
++  uint32_t n_frames;
++} tA2DP_LHDC_FEEDING_STATE;
++
++typedef struct {
++  uint64_t session_start_us;
++
++  size_t media_read_total_expected_packets;
++  size_t media_read_total_expected_reads_count;
++  size_t media_read_total_expected_read_bytes;
++
++  size_t media_read_total_dropped_packets;
++  size_t media_read_total_actual_reads_count;
++  size_t media_read_total_actual_read_bytes;
++} a2dp_lhdc_encoder_stats_t;
++
++typedef struct {
++  a2dp_source_read_callback_t read_callback;
++  a2dp_source_enqueue_callback_t enqueue_callback;
++  uint16_t TxAaMtuSize;
++  size_t TxQueueLength;
++
++  bool use_SCMS_T;
++  bool is_peer_edr;          // True if the peer device supports EDR
++  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
++  uint16_t peer_mtu;         // MTU of the A2DP peer
++  uint32_t timestamp;        // Timestamp for the A2DP frames
++
++  HANDLE_LHDC_BT lhdc_handle;
++  bool has_lhdc_handle;  // True if lhdc_handle is valid
++  uint8_t version;
++
++  tA2DP_FEEDING_PARAMS feeding_params;
++  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
++  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
++
++  a2dp_lhdc_encoder_stats_t stats;
++  uint32_t buf_seq;
++} tA2DP_LHDC_ENCODER_CB;
++
++//static bool lhdc_abr_loaded = false;
++
++
++
++typedef struct _lhdc_frame_Info {
++    uint32_t frame_len;
++    uint32_t isSplit;
++    uint32_t isLeft;
++
++} lhdc_frame_Info_t;
++
++
++#define _RECODER_FILE_
++#if defined(_RECODER_FILE_)
++static FILE  *RecFile = NULL;
++#endif
++
++static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
++
++static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
++                                            A2dpCodecConfig* a2dp_codec_config,
++                                            bool* p_restart_input,
++                                            bool* p_restart_output,
++                                            bool* p_config_updated);
++static void a2dp_lhdcv2_get_num_frame_iteration(uint8_t* num_of_iterations,
++                                              uint8_t* num_of_frames,
++                                              uint64_t timestamp_us);
++static void a2dp_lhdcv2_encode_frames(uint8_t nb_frame);
++static bool a2dp_lhdcv2_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
++static std::string quality_mode_index_to_name(int quality_mode_index);
++//static std::string latency_mode_index_to_name(int latency_mode_index);
++
++static void* load_func(const char* func_name) {
++  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
++  if (func_ptr == NULL) {
++    LOG_ERROR(
++              "%s: cannot find function '%s' in the encoder library: %s",
++              __func__, func_name, dlerror());
++    A2DP_VendorUnloadEncoderLhdcV2();
++    return NULL;
++  }
++  return func_ptr;
++}
++
++bool A2DP_VendorLoadEncoderLhdcV2(void) {
++  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
++
++  // Initialize the control block
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  // Open the encoder library
++  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
++  if (lhdc_encoder_lib_handle == NULL) {
++    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
++              LHDC_ENCODER_LIB_NAME, dlerror());
++    return false;
++  }
++
++
++  // Load all functions
++  lhdc_get_handle_func = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
++  if (lhdc_get_handle_func == NULL) return false;
++  lhdc_free_handle_func = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
++  if (lhdc_free_handle_func == NULL) return false;
++  lhdc_get_bitrate_func = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
++  if (lhdc_get_bitrate_func == NULL) return false;
++  lhdc_set_bitrate_func = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
++  if (lhdc_set_bitrate_func == NULL) return false;
++  lhdc_init_handle_encode_func =
++      (tLHDC_INIT_HANDLE_ENCODE)load_func(LHDC_INIT_HANDLE_ENCODE_NAME);
++  if (lhdc_init_handle_encode_func == NULL) return false;
++  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
++  if (lhdc_encode_func == NULL) return false;
++  lhdc_auto_adjust_bitrate_func = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
++  if (lhdc_auto_adjust_bitrate_func == NULL) return false;
++  //lhdc_get_error_code_func = (tLHDC_GET_ERROR_CODE)load_func(LHDC_GET_ERROR_CODE_NAME);
++  //if (lhdc_get_error_code_func == NULL) return false;
++
++
++  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
++  if (lhdc_set_limit_bitrate == NULL) return false;
++  //lhdc_get_supported_version = (tLHDC_GET_SUPPORTED_VERSION)load_func(LHDC_GET_SUPPORTED_VERSION);
++  //if (lhdc_get_supported_version == NULL) return false;
++  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
++  if (lhdc_get_block_size == NULL) return false;
++
++  return true;
++}
++
++void A2DP_VendorUnloadEncoderLhdcV2(void) {
++  // Cleanup any LHDC-related state
++
++    LOG_DEBUG( "%s: a2dp_lhdc_encoder_cb.has_lhdc_handle = %d, lhdc_free_handle_func = %p",
++              __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle_func);
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle_func != NULL)
++    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  lhdc_get_handle_func = NULL;
++  lhdc_free_handle_func = NULL;
++  lhdc_get_bitrate_func = NULL;
++  lhdc_set_bitrate_func = NULL;
++  lhdc_init_handle_encode_func = NULL;
++  lhdc_encode_func = NULL;
++  lhdc_auto_adjust_bitrate_func = NULL;
++  //lhdc_get_error_code_func = NULL;
++  lhdc_set_limit_bitrate = NULL;
++
++  if (lhdc_encoder_lib_handle != NULL) {
++    dlclose(lhdc_encoder_lib_handle);
++    lhdc_encoder_lib_handle = NULL;
++  }
++}
++
++void a2dp_vendor_lhdcv2_encoder_init(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    A2dpCodecConfig* a2dp_codec_config,
++    a2dp_source_read_callback_t read_callback,
++    a2dp_source_enqueue_callback_t enqueue_callback) {
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
++    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
++
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
++
++  a2dp_lhdc_encoder_cb.read_callback = read_callback;
++  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
++  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
++  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
++  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
++  a2dp_lhdc_encoder_cb.timestamp = 0;
++
++
++  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
++#endif
++
++  // NOTE: Ignore the restart_input / restart_output flags - this initization
++  // happens when the connection is (re)started.
++  bool restart_input = false;
++  bool restart_output = false;
++  bool config_updated = false;
++  a2dp_vendor_lhdcv2_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
++                                  a2dp_codec_config, &restart_input,
++                                  &restart_output, &config_updated);
++}
++
++bool A2dpCodecConfigLhdcV2::updateEncoderUserConfig(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
++    bool* p_restart_output, bool* p_config_updated) {
++  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
++  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
++  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
++  a2dp_lhdc_encoder_cb.timestamp = 0;
++
++  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
++    LOG_ERROR(
++              "%s: Cannot update the codec encoder for %s: "
++              "invalid peer MTU",
++              __func__, name().c_str());
++    return false;
++  }
++
++  a2dp_vendor_lhdcv2_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
++                                  p_restart_input, p_restart_output,
++                                  p_config_updated);
++  return true;
++}
++
++// Update the A2DP LHDC encoder.
++// |peer_mtu| is the peer MTU.
++// |a2dp_codec_config| is the A2DP codec to use for the update.
++static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
++                                            A2dpCodecConfig* a2dp_codec_config,
++                                            bool* p_restart_input,
++                                            bool* p_restart_output,
++                                            bool* p_config_updated) {
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
++      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  uint8_t codec_info[AVDT_CODEC_SIZE];
++
++  *p_restart_input = false;
++  *p_restart_output = false;
++  *p_config_updated = false;
++
++  //Example for limit bit rate
++  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
++
++
++  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
++    LOG_ERROR(
++              "%s: Cannot update the codec encoder for %s: "
++              "invalid codec config",
++              __func__, a2dp_codec_config->name().c_str());
++    return;
++  }
++  const uint8_t* p_codec_info = codec_info;
++  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
++
++  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle_func(A2DP_VendorGetVersionLhdcV2(p_codec_info) <= A2DP_LHDC_VER2 ? 1 : -1);
++      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
++        LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
++        return;  // TODO: Return an error?
++      }
++      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
++  }
++  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV2(p_codec_info);
++
++
++  // The feeding parameters
++  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
++  p_feeding_params->sample_rate =
++      A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
++  p_feeding_params->bits_per_sample =
++      a2dp_codec_config->getAudioBitsPerSample();
++  p_feeding_params->channel_count =
++      A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
++  LOG_DEBUG( "%s:(feeding) sample_rate=%u bits_per_sample=%u channel_count=%u",
++            __func__, p_feeding_params->sample_rate,
++            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
++
++  // The codec parameters
++  p_encoder_params->sample_rate =
++      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
++
++  uint16_t mtu_size =
++      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
++
++  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
++
++  a2dp_lhdc_encoder_cb.TxAaMtuSize = a2dp_lhdc_encoder_cb.TxAaMtuSize & ((uint16_t)0xFFFE);
++
++  //get separation feature.
++  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV2(p_codec_info);
++  // Set the quality mode index
++  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
++  LOG_DEBUG( "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
++  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
++      int newValue = codec_config.codec_specific_1 & 0xff;
++
++      // adjust non-supported quality modes and wrap to internal library used index
++      if (newValue == A2DP_LHDC_QUALITY_ABR) {
++        newValue = LHDCBT_QUALITY_AUTO; //9->8
++      }
++
++      if (newValue != p_encoder_params->quality_mode_index) {
++        p_encoder_params->quality_mode_index = newValue;
++        LOG_DEBUG( "%s: setting internal quality mode: %s(%d)", __func__,
++            quality_mode_index_to_name(p_encoder_params->quality_mode_index)
++            .c_str(), p_encoder_params->quality_mode_index);
++      }
++  }else {
++      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
++      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
++  }
++
++  //To correcting data to middle.
++  if (p_encoder_params->channelSplitMode >= A2DP_LHDC_CH_SPLIT_TWS
++       && p_encoder_params->quality_mode_index >= LHDCBT_QUALITY_HIGH) {
++      /* code */
++      LOG_DEBUG( "%s: Channel separation enabled, Max bit rate = LHDCBT_QUALITY_MID", __func__);
++      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_MID;
++  }
++
++  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV2(p_codec_info);
++
++/*
++  //p_encoder_params->latency_mode_index = 1;
++  if ((codec_config.codec_specific_2 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_LATENCY_MAGIC_NUM) {
++      int newValue = codec_config.codec_specific_2 & 0xff;
++      if (newValue != p_encoder_params->latency_mode_index) {
++          p_encoder_params->latency_mode_index = newValue;
++          LOG_DEBUG( "%s: setting latency value to %s(%d)", __func__,
++                    latency_mode_index_to_name(p_encoder_params->latency_mode_index).c_str(),
++                    p_encoder_params->latency_mode_index);
++      }
++  }else {
++      p_encoder_params->latency_mode_index = A2DP_LHDC_LATENCY_MID;
++  }
++*/
++
++  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
++
++
++  p_encoder_params->pcm_wlength =
++      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
++  // Set the Audio format from pcm_wlength
++  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
++  if (p_encoder_params->pcm_wlength == 2)
++    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
++  else if (p_encoder_params->pcm_wlength == 3)
++    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
++ // else if (p_encoder_params->pcm_wlength == 4)
++//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
++
++  LOG_DEBUG( "%s: MTU=%d, peer_mtu=%d", __func__,
++            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
++  LOG_DEBUG(
++            "%s: sample_rate: %d "
++            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
++            __func__, p_encoder_params->sample_rate,
++            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
++            p_encoder_params->pcm_fmt);
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
++#else
++    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
++#endif
++  // Initialize the encoder.
++  // NOTE: MTU in the initialization must include the AVDT media header size.
++  int result = lhdc_init_handle_encode_func(
++      a2dp_lhdc_encoder_cb.lhdc_handle,
++      p_encoder_params->sample_rate,
++      p_encoder_params->pcm_fmt,
++      p_encoder_params->quality_mode_index,
++      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
++      0 /* This parameter alaways is 0 in A2DP */ ,
++      max_mtu_len,
++      a2dp_vendor_lhdcv2_get_encoder_interval_ms()
++  );
++    lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
++
++    lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
++
++#if defined(_RECODER_FILE_)
++  if (RecFile == NULL) {
++      RecFile = fopen("/sdcard/Download/lhdc.raw","wb");
++    LOG_ERROR( "%s: Create recode file = %p", __func__, RecFile);
++  }
++#endif
++  if (result != 0) {
++    LOG_ERROR( "%s: error initializing the LHDC encoder: %d", __func__,
++              result);
++  }
++}
++
++void a2dp_vendor_lhdcv2_encoder_cleanup(void) {
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
++    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++#if defined(_RECODER_FILE_)
++  if (RecFile != NULL) {
++      fclose(RecFile);
++      RecFile = NULL;
++  }
++#endif
++}
++
++void a2dp_vendor_lhdcv2_feeding_reset(void) {
++  /* By default, just clear the entire state */
++  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
++         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
++
++  int encoder_interval = a2dp_vendor_lhdcv2_get_encoder_interval_ms();
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
++      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
++       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
++       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++       encoder_interval) /
++      1000;
++  a2dp_lhdc_encoder_cb.buf_seq = 0;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  LOG_DEBUG("%s: has_lhdc_handle %d (%d)", __func__,
++      a2dp_lhdc_encoder_cb.has_lhdc_handle,p_encoder_params->quality_mode_index);
++  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
++    if(lhdc_set_bitrate_func != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle)
++      lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
++  }
++  LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
++            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
++}
++
++void a2dp_vendor_lhdcv2_feeding_flush(void) {
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames = 0;
++  LOG_DEBUG( "%s", __func__);
++}
++
++uint64_t a2dp_vendor_lhdcv2_get_encoder_interval_ms(void) {
++  //LOG_DEBUG( "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",
++              //__func__, a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
++  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
++      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
++  }else{
++      return A2DP_LHDC_ENCODER_INTERVAL_MS;
++  }
++}
++
++void a2dp_vendor_lhdcv2_send_frames(uint64_t timestamp_us) {
++  uint8_t nb_frame = 0;
++  uint8_t nb_iterations = 0;
++
++  a2dp_lhdcv2_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
++  LOG_DEBUG( "%s: Sending %d frames per iteration, %d iterations",
++              __func__, nb_frame, nb_iterations);
++  if (nb_frame == 0) return;
++
++  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
++    // Transcode frame and enqueue
++    if (a2dp_lhdc_encoder_cb.version <= 1) {
++        a2dp_lhdcv2_encode_frames(nb_frame);
++    }
++  }
++}
++
++// Obtains the number of frames to send and number of iterations
++// to be used. |num_of_iterations| and |num_of_frames| parameters
++// are used as output param for returning the respective values.
++static void a2dp_lhdcv2_get_num_frame_iteration(uint8_t* num_of_iterations,
++                                              uint8_t* num_of_frames,
++                                              uint64_t timestamp_us) {
++  uint32_t result = 0;
++  uint8_t nof = 0;
++  uint8_t noi = 1;
++  uint32_t pcm_bytes_per_frame = LHDCV2_BT_ENC_BLOCK_SIZE *
++      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;;
++  //LOG_DEBUG( "%s: pcm_bytes_per_frame %u", __func__,
++//              pcm_bytes_per_frame);
++
++  int encoder_interval = a2dp_vendor_lhdcv2_get_encoder_interval_ms();
++  uint32_t us_this_tick = encoder_interval * 1000;
++  uint64_t now_us = timestamp_us;
++  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
++    us_this_tick =
++        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
++
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
++      (encoder_interval * 1000);
++
++  result =
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
++      result * pcm_bytes_per_frame;
++  nof = result;
++
++  //LOG_DEBUG( "%s: effective num of frames %u, iterations %u",
++//              __func__, nof, noi);
++
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames += nof;
++  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames > A2DP_LHDCV2_HDR_NUM_MAX) {
++    nof = A2DP_LHDCV2_HDR_NUM_MAX;
++  } else {
++    nof = a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames;
++  }
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames -= nof;
++  *num_of_frames = nof;
++  *num_of_iterations = noi;
++}
++
++static BT_HDR *bt_buf_new( void) {
++    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
++    if ( p_buf == NULL) {
++        // LeoKu(C): should not happen
++        LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
++        return  NULL;
++    }
++
++    p_buf->offset = A2DP_LHDC_OFFSET;
++    p_buf->len = 0;
++    p_buf->layer_specific = 0;
++    return  p_buf;
++}
++
++/**
++ * get lhdc frame header
++ */
++ /*
++static int a2dp_get_lhdc_header(uint8_t * in, lhdc_frame_Info_t * h) {
++    #define LHDC_HDR_LEN 4
++    uint32_t hdr = 0;
++    int ret = -1;
++    memcpy(&hdr, in , LHDC_HDR_LEN);
++    h->frame_len = ( int)( ( hdr >> 8) & 0x1fff);
++    h->isSplit = ( ( hdr & 0x00600000) == 0x00600000);
++    h->isLeft = ((hdr & 0xf) == 0);
++
++    if ( ( hdr & 0x4c000000) != 0x4c000000){
++        //printf( "lhdc hdr err!\n");
++    } else {
++        ret = 0;
++    }
++    return ret;
++}
++*/
++
++#include <vector>
++using namespace std;
++
++static void a2dp_lhdcv2_encode_frames(uint8_t nb_frame) {
++    BT_HDR * p_buf = NULL;
++    //BT_HDR * p_btBufs[128];
++    vector<BT_HDR * > btBufs;
++    uint8_t nb_frame_org = nb_frame;
++    //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
++    //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++    uint32_t pcm_bytes_per_frame = LHDCV2_BT_ENC_BLOCK_SIZE *
++                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
++#else
++    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
++#endif
++    uint8_t * read_buffer = (uint8_t*)malloc(pcm_bytes_per_frame * 2);
++    uint8_t * write_buffer = (uint8_t*)&(read_buffer[pcm_bytes_per_frame]);
++    uint8_t latency = 0;//p_encoder_params->latency_mode_index;
++    int out_offset = 0;
++    int out_len = 0;
++    static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
++    static uint32_t allSendbytes = 0;
++    uint32_t bytes_read = 0;
++
++        while( nb_frame) {
++
++            uint32_t temp_bytes_read = 0;
++            if ( !a2dp_lhdcv2_read_feeding(read_buffer, &temp_bytes_read)) {
++            LOG_WARN( "%s: underflow %d", __func__, nb_frame);
++            a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
++                      nb_frame * LHDCV2_BT_ENC_BLOCK_SIZE *
++                      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++                      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++                break;
++            }
++            bytes_read += temp_bytes_read;
++            out_offset = 0;
++            out_len = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, write_buffer);
++    #if defined(_RECODER_FILE_)
++            if (RecFile != NULL && out_len > 0) {
++                fwrite(write_buffer, sizeof(uint8_t), out_len, RecFile);
++            }
++    #endif
++            nb_frame--;
++
++            while (out_len > 0) {
++                if (p_buf == NULL) {
++                    if (NULL == (p_buf = bt_buf_new())) {
++                        LOG_ERROR ( "%s: ERROR", __func__);
++                        if (read_buffer) {
++                            free(read_buffer);
++                            read_buffer = NULL;
++                        }
++                        for(BT_HDR*  p : btBufs) {
++                            free(p);
++                        }
++                        btBufs.clear();
++                        return;
++                    }
++                }
++
++                uint8_t *p = ( uint8_t *)( p_buf + 1) + p_buf->offset + p_buf->len;
++                int space = max_mtu_len - p_buf->len;
++                int bytes = ( out_len < space)? out_len : space;
++                memcpy( p, &write_buffer[out_offset], bytes);
++                out_offset += bytes;
++                out_len -= bytes;
++                p_buf->len += bytes;
++                allSendbytes += bytes;
++
++                if ( p_buf->len >= max_mtu_len ) {
++                    btBufs.push_back(p_buf);
++                    // allocate new one
++                    p_buf = NULL;
++                    if (btBufs.size() >= 64) {
++                        LOG_ERROR( "%s: Packet buffer usage to big!(%u)", __func__, (uint32_t)btBufs.size());
++                        break;
++                    }
++                }
++            }
++        }
++        uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
++        if (now_ms - time_prev >= 1000 ) {
++            /* code */
++            LOG_WARN( "%s: Current data rate about %d kbps", __func__, (allSendbytes * 8) / 1000);
++            allSendbytes = 0;
++            time_prev = now_ms;
++        }
++
++        if ( p_buf) {
++            btBufs.push_back(p_buf);
++        }
++
++        LOG_DEBUG( "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
++        if ( btBufs.size() == 1) {
++            p_buf = btBufs[0];
++
++            p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
++            p_buf->layer_specific <<= 8;
++            p_buf->layer_specific |= ( latency | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
++
++            *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
++
++            a2dp_lhdc_encoder_cb.enqueue_callback( p_buf, 1, bytes_read);
++            LOG_DEBUG ( "%s: Read bytes(%d)", __func__, bytes_read);
++            bytes_read = 0;
++
++        } else {
++
++            uint8_t i;
++
++            for( i = 0; i < btBufs.size(); i++) {
++                p_buf = btBufs[i];
++
++                p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
++                p_buf->layer_specific <<= 8;
++                p_buf->layer_specific |= ( A2DP_LHDC_HDR_F_MSK | latency);
++
++                if ( i == 0) {
++                    p_buf->layer_specific |= ( A2DP_LHDC_HDR_S_MSK | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
++                } else if ( i == ( btBufs.size() - 1)) {
++                    p_buf->layer_specific |= A2DP_LHDC_HDR_L_MSK;
++                    bytes_read = 0;
++                }
++
++                *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
++
++                a2dp_lhdc_encoder_cb.enqueue_callback( p_buf, 1, bytes_read);
++                LOG_DEBUG ( "%s: Read bytes(%d)", __func__, bytes_read);
++            }
++        }
++
++        a2dp_lhdc_encoder_cb.timestamp += ( nb_frame_org * LHDCV2_BT_ENC_BLOCK_SIZE);
++        if (read_buffer) {
++            free(read_buffer);
++            read_buffer = NULL;
++        }
++        btBufs.clear();
++}
++
++static bool a2dp_lhdcv2_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
++    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++    uint32_t read_size = LHDCV2_BT_ENC_BLOCK_SIZE * bytes_per_sample;
++
++
++  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
++  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
++
++  /* Read Data from UIPC channel */
++  uint32_t nb_byte_read =
++      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
++  LOG_DEBUG( "%s: want to read size %u, read byte number %u",
++                    __func__, read_size, nb_byte_read);
++
++  if ((nb_byte_read % bytes_per_sample) != 0) {
++      LOG_ERROR( "%s: PCM data not alignment. The audio sample is shfit %d bytes.", __func__,(nb_byte_read % bytes_per_sample));
++  }
++  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
++
++  if (nb_byte_read < read_size) {
++    if (nb_byte_read == 0) return false;
++
++    /* Fill the unfilled part of the read buffer with silence (0) */
++    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
++    nb_byte_read = read_size;
++  }
++  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
++
++    *bytes_read = nb_byte_read;
++
++  return true;
++}
++
++// internal library: quality mode index table
++static std::string quality_mode_index_to_name(int quality_mode_index) {
++  switch (quality_mode_index) {
++    case LHDCBT_QUALITY_AUTO:
++      return "ABR";
++    case LHDCBT_QUALITY_HIGH:
++      return "HIGH";
++    case LHDCBT_QUALITY_MID:
++      return "MID";
++    case LHDCBT_QUALITY_LOW:
++      return "LOW";
++    case LHDCBT_QUALITY_LOW4:
++      return "LOW_320";
++    case LHDCBT_QUALITY_LOW3:
++      return "LOW_256";
++    case LHDCBT_QUALITY_LOW2:
++      return "LOW_192";
++    case LHDCBT_QUALITY_LOW1:
++      return "LOW_128";
++    case LHDCBT_QUALITY_LOW0:
++      return "LOW_64";
++    default:
++      return "Unknown";
++  }
++}
++/*
++static std::string latency_mode_index_to_name(int latency_mode_index){
++    switch (latency_mode_index) {
++      case A2DP_LHDC_LL_ENABLE:
++        return "LL is enabled";
++      case A2DP_LHDC_LL_DISABLE:
++        return "LL is diabled";
++      default:
++        return "Unknown";
++    }
++}
++*/
++
++void a2dp_vendor_lhdcv2_set_transmit_queue_length(size_t transmit_queue_length) {
++  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  LOG_DEBUG( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
++  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
++      LOG_DEBUG( "%s: Auto Bitrate Enabled!", __func__);
++      if (lhdc_auto_adjust_bitrate_func != NULL) {
++          lhdc_auto_adjust_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
++      }
++  }
++}
++
++uint64_t A2dpCodecConfigLhdcV2::encoderIntervalMs() const {
++  return a2dp_vendor_lhdcv2_get_encoder_interval_ms();
++}
++
++int A2dpCodecConfigLhdcV2::getEffectiveMtu() const {
++  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
++}
++
++void A2dpCodecConfigLhdcV2::debug_codec_dump(int fd) {
++  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
++      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++
++  A2dpCodecConfig::debug_codec_dump(fd);
++
++  dprintf(fd,
++          "  Packet counts (expected/dropped)                        : %zu / "
++          "%zu\n",
++          stats->media_read_total_expected_packets,
++          stats->media_read_total_dropped_packets);
++
++  dprintf(fd,
++          "  PCM read counts (expected/actual)                       : %zu / "
++          "%zu\n",
++          stats->media_read_total_expected_reads_count,
++          stats->media_read_total_actual_reads_count);
++
++  dprintf(fd,
++          "  PCM read bytes (expected/actual)                        : %zu / "
++          "%zu\n",
++          stats->media_read_total_expected_read_bytes,
++          stats->media_read_total_actual_read_bytes);
++
++  dprintf(
++      fd, "  LHDC quality mode                                       : %s\n",
++      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
++
++  dprintf(fd,
++          "  LHDC transmission bitrate (Kbps)                        : %d\n",
++          lhdc_get_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle));
++
++  dprintf(fd,
++          "  LHDC saved transmit queue length                        : %zu\n",
++          a2dp_lhdc_encoder_cb.TxQueueLength);
++/*
++  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
++    dprintf(fd,
++            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
++            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
++    dprintf(fd,
++            "  LHDC adaptive bit rate adjustments                      : %zu\n",
++            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
++  }
++  */
++}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
+new file mode 100644
+index 000000000..2269aad67
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
+@@ -0,0 +1,2613 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++/******************************************************************************
++ *
++ *  Utility functions to help build and parse the LHDC Codec Information
++ *  Element and Media Payload.
++ *
++ ******************************************************************************/
++
++#define LOG_TAG "a2dp_vendor_lhdcv3"
++
++#include "bt_target.h"
++
++#include "a2dp_vendor_lhdcv3.h"
++
++#include <string.h>
++
++#include <base/logging.h>
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv3_encoder.h"
++#include "bt_utils.h"
++#include "btif_av_co.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++
++typedef struct {
++  btav_a2dp_codec_config_t *_codec_config_;
++  btav_a2dp_codec_config_t *_codec_capability_;
++  btav_a2dp_codec_config_t *_codec_local_capability_;
++  btav_a2dp_codec_config_t *_codec_selectable_capability_;
++  btav_a2dp_codec_config_t *_codec_user_config_;
++  btav_a2dp_codec_config_t *_codec_audio_config_;
++}tA2DP_CODEC_CONFIGS_PACK;
++
++typedef struct {
++  uint8_t   featureCode;    /* code definition for LHDC API ex: LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE */
++  uint8_t   inSpecBank;     /* in which specific bank */
++  uint8_t   bitPos;         /* at which bit index number of the specific bank */
++}tA2DP_LHDC_FEATURE_POS;
++
++/* source side metadata of JAS feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_JAS = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_JAS_SPEC_BIT_POS,
++};
++/* source side metadata of AR feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_AR = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_AR_SPEC_BIT_POS
++};
++/* source side metadata of LLAC feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LLAC = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_LLAC_SPEC_BIT_POS
++};
++/* source side metadata of META feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_META = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_META_SPEC_BIT_POS
++};
++/* source side metadata of MBR feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_MBR = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_MBR_SPEC_BIT_POS
++};
++/* source side metadata of LARC feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LARC = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_LARC_SPEC_BIT_POS
++};
++/* source side metadata of LHDCV4 feature */
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LHDCV4 = {
++    LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
++    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
++    A2DP_LHDC_V4_SPEC_BIT_POS
++};
++
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_all[] = {
++    a2dp_lhdc_source_caps_JAS,
++    a2dp_lhdc_source_caps_AR,
++    a2dp_lhdc_source_caps_LLAC,
++    a2dp_lhdc_source_caps_META,
++    a2dp_lhdc_source_caps_MBR,
++    a2dp_lhdc_source_caps_LARC,
++    a2dp_lhdc_source_caps_LHDCV4,
++};
++
++
++// data type for the LHDC Codec Information Element */
++// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
++typedef struct {
++  uint32_t vendorId;
++  uint16_t codecId;    /* Codec ID for LHDC */
++  uint8_t sampleRate;  /* Sampling Frequency for LHDC*/
++  uint8_t llac_sampleRate;  /* Sampling Frequency for LLAC */
++  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
++  uint8_t channelSplitMode;
++  uint8_t version;
++  uint8_t maxTargetBitrate;
++  bool isLLSupported;
++  //uint8_t supportedBitrate;
++  bool hasFeatureJAS;
++  bool hasFeatureAR;
++  bool hasFeatureLLAC;
++  bool hasFeatureMETA;
++  bool hasFeatureMinBitrate;
++  bool hasFeatureLARC;
++  bool hasFeatureLHDCV4;
++} tA2DP_LHDC_CIE;
++
++/* LHDC Source codec capabilities */
++static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV3_CODEC_ID,   // codecId
++    // sampleRate
++    //(A2DP_LHDC_SAMPLING_FREQ_48000),
++    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
++	(A2DP_LHDC_SAMPLING_FREQ_48000),
++    // bits_per_sample
++    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
++    //Channel Separation
++    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
++    A2DP_LHDC_BITRATE_ALL,
++    //Version number
++    A2DP_LHDC_VER3 | A2DP_LHDC_VER4 | A2DP_LHDC_VER6,
++    //Target bit Rate
++    A2DP_LHDC_MAX_BIT_RATE_900K,
++    //LL supported ?
++    true,
++
++    /*******************************
++     *  LHDC features/capabilities:
++     *  hasFeatureJAS
++     *  hasFeatureAR
++     *  hasFeatureLLAC
++     *  hasFeatureMETA
++     *  hasFeatureMinBitrate
++     *  hasFeatureLARC
++     *  hasFeatureLHDCV4
++     *******************************/
++    //bool hasFeatureJAS;
++    true,
++
++    //bool hasFeatureAR;
++    true,
++
++    //bool hasFeatureLLAC;
++    true,
++
++    //bool hasFeatureMETA;
++    true,
++
++    //bool hasFeatureMinBitrate;
++    true,
++
++    //bool hasFeatureLARC;
++    false,
++
++    //bool hasFeatureLHDCV4;
++    true,
++};
++    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
++
++/* for response to API */
++static int A2DP_VendorGetSrcCapNumberLhdcv3()
++{
++  return (sizeof(a2dp_lhdc_source_caps_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
++}
++
++/* for response to API */
++bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t *capVector)
++{
++    int capNumber = 0, run = 0;
++
++    if(!capVector)
++    {
++        LOG_ERROR( "%s: null buffer!", __func__);
++        return false;
++    }
++
++    /* count and check the number of source available capabilities */
++    capNumber = A2DP_VendorGetSrcCapNumberLhdcv3();
++
++    if(capNumber <= 0)
++    {
++      LOG_DEBUG( "%s: no capabilities, nothing to do!", __func__);
++      return true;
++    }
++
++    /* configure capabilities vector for LHDC API */
++    /* Byte-1:      featureCode
++     * Byte-2[7-6]: inSpecBank
++     * Byte-2[5-0]: bitPos
++     */
++    for(int i=0; i<capNumber; i++)
++    {
++      capVector[run] = a2dp_lhdc_source_caps_all[i].featureCode;
++      capVector[run+1] = a2dp_lhdc_source_caps_all[i].inSpecBank | a2dp_lhdc_source_caps_all[i].bitPos;
++      //LOG_DEBUG( "%s: fill cap(%d):[0x%02X 0x%02X]", __func__, i, capVector[run], capVector[run+1]);
++      run+=2;
++    }
++
++    return true;
++}
++
++/* Default LHDC codec configuration */
++static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
++    A2DP_LHDC_VENDOR_ID,                // vendorId
++    A2DP_LHDCV3_CODEC_ID,                 // codecId
++    A2DP_LHDC_SAMPLING_FREQ_96000,      // LHDC default best sampleRate
++	A2DP_LHDC_SAMPLING_FREQ_48000,      // LLAC default best sampleRate
++    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
++    A2DP_LHDC_CH_SPLIT_NONE,
++    A2DP_LHDC_VER3,
++    A2DP_LHDC_MAX_BIT_RATE_900K,
++    false,
++
++    //bool hasFeatureJAS;
++    false,
++
++    //bool hasFeatureAR;
++    false,
++
++    //bool hasFeatureLLAC;
++    true,
++
++    //bool hasFeatureMETA;
++    false,
++
++    //bool hasFeatureMinBitrate;
++    true,
++
++    //bool hasFeatureLARC;
++    false,
++
++    //bool hasFeatureLHDCV4;
++    true,
++};
++
++static std::string lhdcV3_QualityModeBitRate_toString(uint32_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDC_QUALITY_ABR:
++    return "ABR";
++  case A2DP_LHDC_QUALITY_HIGH1:
++    return "HIGH 1 (1000 Kbps)";
++  case A2DP_LHDC_QUALITY_HIGH:
++    return "HIGH (900 Kbps)";
++  case A2DP_LHDC_QUALITY_MID:
++    return "MID (500 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW:
++    return "LOW (400 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW4:
++    return "LOW 4 (320 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW3:
++    return "LOW 3 (256 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW2:
++    return "LOW 2 (192 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW1:
++    return "LOW 1 (128 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW0:
++    return "LOW 0 (64 Kbps)";
++  default:
++    return "Unknown Bit Rate Mode";
++  }
++}
++
++static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv3 = {
++    a2dp_vendor_lhdcv3_encoder_init,
++    a2dp_vendor_lhdcv3_encoder_cleanup,
++    a2dp_vendor_lhdcv3_feeding_reset,
++    a2dp_vendor_lhdcv3_feeding_flush,
++    a2dp_vendor_lhdcv3_get_encoder_interval_ms,
++    a2dp_vendor_lhdcv3_send_frames,
++    a2dp_vendor_lhdcv3_set_transmit_queue_length};
++
++UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
++    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_peer_codec_info);
++
++
++// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
++// |p_ie| is a pointer to the LHDC Codec Information Element information.
++// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_BuildInfoLhdcV3(uint8_t media_type,
++                                       const tA2DP_LHDC_CIE* p_ie,
++                                       uint8_t* p_result) {
++
++  const uint8_t* tmpInfo = p_result;
++  if (p_ie == NULL || p_result == NULL) {
++    return A2DP_INVALID_PARAMS;
++  }
++
++  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
++  *p_result++ = (media_type << 4);      //1
++  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
++
++  // Vendor ID and Codec ID
++  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
++  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
++  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
++
++  // Sampling Frequency & Bits per sample
++  uint8_t para = 0;
++
++  // sample rate bit0 ~ bit2
++  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
++
++  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
++      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
++  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
++      para = para | A2DP_LHDC_BIT_FMT_24;
++  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
++      para = para | A2DP_LHDC_BIT_FMT_16;
++  }
++
++  if (p_ie->hasFeatureJAS)
++  {
++    para |= A2DP_LHDC_FEATURE_JAS;
++  }
++
++  if (p_ie->hasFeatureAR)
++  {
++    para |= A2DP_LHDC_FEATURE_AR;
++  }
++
++  // Save octet 9
++  *p_result++ = para;   //9
++
++  para = p_ie->version;
++
++  para |= p_ie->maxTargetBitrate;
++
++  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
++
++  if (p_ie->hasFeatureLLAC)
++  {
++    para |= A2DP_LHDC_FEATURE_LLAC;
++  }
++
++  // Save octet 10
++  *p_result++ = para;   //a
++
++  //Save octet 11
++  para = p_ie->channelSplitMode;
++
++  if (p_ie->hasFeatureMETA)
++  {
++    para |= A2DP_LHDC_FEATURE_META;
++  }
++
++  if (p_ie->hasFeatureMinBitrate)
++  {
++    para |= A2DP_LHDC_FEATURE_MIN_BR;
++  }
++
++  if (p_ie->hasFeatureLARC)
++  {
++    para |= A2DP_LHDC_FEATURE_LARC;
++  }
++
++  if (p_ie->hasFeatureLHDCV4)
++  {
++    para |= A2DP_LHDC_FEATURE_LHDCV4;
++  }
++
++  *p_result++ = para;   //b
++
++  //Save octet 12
++  //para = p_ie->supportedBitrate;
++  //*p_result++ = para;   //c
++
++  LOG_DEBUG( "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
++                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
++     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
++                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
++  return A2DP_SUCCESS;
++}
++
++// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
++// |p_codec_info|. If |is_capability| is true, the byte sequence is
++// codec capabilities, otherwise is codec configuration.
++// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
++// status code.
++static tA2DP_STATUS A2DP_ParseInfoLhdcV3(tA2DP_LHDC_CIE* p_ie,
++                                       const uint8_t* p_codec_info,
++                                       bool is_capability) {
++  uint8_t losc;
++  uint8_t media_type;
++  tA2DP_CODEC_TYPE codec_type;
++  const uint8_t* tmpInfo = p_codec_info;
++
++  //LOG_DEBUG( "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
++  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
++
++  // Check the codec capability length
++  losc = *p_codec_info++;
++
++  if (losc != A2DP_LHDCV3_CODEC_LEN) return A2DP_WRONG_CODEC;
++
++  media_type = (*p_codec_info++) >> 4;
++  codec_type = *p_codec_info++;
++    //LOG_DEBUG( "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
++  /* Check the Media Type and Media Codec Type */
++  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
++      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  // Check the Vendor ID and Codec ID */
++  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
++                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
++                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
++                   (*(p_codec_info + 3) << 24 & 0xFF000000);
++  p_codec_info += 4;
++  p_ie->codecId =
++      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
++  p_codec_info += 2;
++  LOG_VERBOSE( "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
++  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
++      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
++  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
++    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
++    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++  }
++
++  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDC_FEATURE_JAS) != 0) ? true : false;
++
++  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDC_FEATURE_AR) != 0) ? true : false;
++
++  p_codec_info += 1;
++
++  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
++
++  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
++
++  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
++
++  p_ie->hasFeatureLLAC = ((*p_codec_info & A2DP_LHDC_FEATURE_LLAC) != 0) ? true : false;
++
++  p_codec_info += 1;
++
++  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
++
++  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDC_FEATURE_META) != 0) ? true : false;
++
++  p_ie->hasFeatureMinBitrate = ((*p_codec_info & A2DP_LHDC_FEATURE_MIN_BR) != 0) ? true : false;
++
++  p_ie->hasFeatureLARC = ((*p_codec_info & A2DP_LHDC_FEATURE_LARC) != 0) ? true : false;
++
++  p_ie->hasFeatureLHDCV4 = ((*p_codec_info & A2DP_LHDC_FEATURE_LHDCV4) != 0) ? true : false;
++  
++  LOG_DEBUG( "%s:Has LL(%d) JAS(%d) AR(%d) META(%d) LLAC(%d) MBR(%d) LARC(%d) V4(%d)", __func__,
++      p_ie->isLLSupported,
++      p_ie->hasFeatureJAS,
++      p_ie->hasFeatureAR,
++      p_ie->hasFeatureMETA,
++      p_ie->hasFeatureLLAC,
++      p_ie->hasFeatureMinBitrate,
++      p_ie->hasFeatureLARC,
++      p_ie->hasFeatureLHDCV4);
++
++  LOG_DEBUG( "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
++            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
++                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
++
++  if (is_capability) return A2DP_SUCCESS;
++
++  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
++    return A2DP_BAD_SAMP_FREQ;
++
++  return A2DP_SUCCESS;
++}
++
++// Build the LHDC Media Payload Header.
++// |p_dst| points to the location where the header should be written to.
++// If |frag| is true, the media payload frame is fragmented.
++// |start| is true for the first packet of a fragmented frame.
++// |last| is true for the last packet of a fragmented frame.
++// If |frag| is false, |num| is the number of number of frames in the packet,
++// otherwise is the number of remaining fragments (including this one).
++/*
++static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
++  if (p == NULL) return;
++  *p = ( uint8_t)( num & 0xff);
++}
++*/
++
++bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE cfg_cie;
++
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
++         (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
++}
++
++bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE cfg_cie;
++
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
++         (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
++}
++
++// Checks whether A2DP LHDC codec configuration matches with a device's codec
++// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
++// the device's codec capabilities.
++// If |is_capability| is true, the byte sequence is codec capabilities,
++// otherwise is codec configuration.
++// |p_codec_info| contains the codec capabilities for a peer device that
++// is acting as an A2DP source.
++// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
++    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_capability) {
++  tA2DP_STATUS status;
++  tA2DP_LHDC_CIE cfg_cie;
++
++  /* parse configuration */
++  status = A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, is_capability);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: parsing failed %d", __func__, status);
++    return status;
++  }
++
++  /* verify that each parameter is in range */
++
++  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
++            cfg_cie.sampleRate, p_cap->sampleRate);
++
++  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
++            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
++
++  /* sampling frequency */
++  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
++
++  /* bit per sample */
++  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
++
++  return A2DP_SUCCESS;
++}
++
++bool A2DP_VendorUsesRtpHeaderLhdcV3(UNUSED_ATTR bool content_protection_enabled,
++                                  UNUSED_ATTR const uint8_t* p_codec_info) {
++  // TODO: Is this correct? The RTP header is always included?
++  return true;
++}
++
++const char* A2DP_VendorCodecNameLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info) {
++  return "LHDC V3";
++}
++
++bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
++                                    const uint8_t* p_codec_info_b) {
++  tA2DP_LHDC_CIE lhdc_cie_a;
++  tA2DP_LHDC_CIE lhdc_cie_b;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status =
++      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
++                                const uint8_t* p_codec_info_b) {
++  tA2DP_LHDC_CIE lhdc_cie_a;
++  tA2DP_LHDC_CIE lhdc_cie_b;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status =
++      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++
++  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
++         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
++         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
++         (lhdc_cie_a.hasFeatureLLAC == lhdc_cie_b.hasFeatureLLAC) &&
++         (lhdc_cie_a.hasFeatureLHDCV4 == lhdc_cie_b.hasFeatureLHDCV4) &&
++         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
++}
++
++// Savitech Patch - START  Offload
++int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info) {
++
++  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
++  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
++
++  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
++      A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
++      case A2DP_LHDC_QUALITY_LOW0:
++        return 64000;
++      case A2DP_LHDC_QUALITY_LOW1:
++        return 128000;
++      case A2DP_LHDC_QUALITY_LOW2:
++        return 192000;
++      case A2DP_LHDC_QUALITY_LOW3:
++        return 256000;
++      case A2DP_LHDC_QUALITY_LOW4:
++        return 320000;
++      case A2DP_LHDC_QUALITY_LOW:
++        return 400000;
++      case A2DP_LHDC_QUALITY_MID:
++        return 600000;
++      case A2DP_LHDC_QUALITY_HIGH:
++        return 900000;
++      case A2DP_LHDC_QUALITY_ABR:
++        return 9999999;
++      case A2DP_LHDC_QUALITY_HIGH1:
++        [[fallthrough]];
++      default:
++        return -1;
++    }
++  }
++  return 400000;
++}
++// Savitech Patch - END
++
++int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.sampleRate) {
++    case A2DP_LHDC_SAMPLING_FREQ_44100:
++      return 44100;
++    case A2DP_LHDC_SAMPLING_FREQ_48000:
++      return 48000;
++    case A2DP_LHDC_SAMPLING_FREQ_88200:
++      return 88200;
++    case A2DP_LHDC_SAMPLING_FREQ_96000:
++      return 96000;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
++    tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.bits_per_sample) {
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++      return 16;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++      return 24;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++      return 32;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++      return -1;
++  }
++}
++
++int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++  return 2;
++}
++
++int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++  return A2DP_LHDC_CHANNEL_MODE_STEREO;
++}
++
++bool A2DP_VendorGetPacketTimestampLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
++                                       const uint8_t* p_data,
++                                       uint32_t* p_timestamp) {
++  // TODO: Is this function really codec-specific?
++  *p_timestamp = *(const uint32_t*)p_data;
++  return true;
++}
++
++int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++/*
++#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
++#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
++#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
++
++#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
++#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
++#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
++*/
++  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
++      case A2DP_LHDC_MAX_BIT_RATE_900K:
++      return A2DP_LHDC_QUALITY_HIGH;
++      case A2DP_LHDC_MAX_BIT_RATE_500K:
++      return A2DP_LHDC_QUALITY_MID;
++      case A2DP_LHDC_MAX_BIT_RATE_400K:
++      return A2DP_LHDC_QUALITY_LOW;
++  }
++  return -1;
++}
++
++bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  LOG_DEBUG( "%s: isLLSupported =%d", __func__, lhdc_cie.isLLSupported);
++
++  return lhdc_cie.isLLSupported ? true : false;
++}
++
++
++
++
++//Always return newest version.
++uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++  uint8_t result;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++
++  for (result = 0x08; result != 0; ) {
++    if ((lhdc_cie.version & result) != 0) {
++      break;
++    }
++    result >>= 1;
++  }
++  //LOG_DEBUG( "%s: version = 0x%02x, result = 0x%02x", __func__, lhdc_cie.version, result);
++
++
++  switch (result) {
++    case A2DP_LHDC_VER3:
++    return 1;
++    case A2DP_LHDC_VER4:
++    return 2;
++    case A2DP_LHDC_VER5:
++    return 3;
++    case A2DP_LHDC_VER6:
++    return 4;
++    default:
++    return -1;
++  }
++}
++
++
++int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info){
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  LOG_DEBUG( "%s: channelSplitMode =%d", __func__, lhdc_cie.channelSplitMode);
++
++  return lhdc_cie.channelSplitMode;
++
++}
++
++bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureLHDCV4;
++}
++
++bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureJAS;
++}
++
++bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureAR;
++}
++
++bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureLLAC;
++}
++
++bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureMETA;
++}
++
++bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureMinBitrate;
++}
++
++bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE lhdc_cie;
++  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
++    return false;
++
++  return lhdc_cie.hasFeatureLARC;
++}
++
++bool A2DP_VendorBuildCodecHeaderLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
++                                     BT_HDR* p_buf,
++                                     uint16_t frames_per_packet) {
++  uint8_t* p;
++
++  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
++  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
++  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
++  p[0] = ( uint8_t)( frames_per_packet & 0xff);
++  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
++  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
++  return true;
++}
++
++void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  LOG_DEBUG( "%s", __func__);
++
++  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV3 fail:%d", __func__, a2dp_status);
++    return;
++  }
++
++  LOG_DEBUG( "\tsamp_freq: 0x%x", lhdc_cie.sampleRate);
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++    LOG_DEBUG( "\tsamp_freq: (44100)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++    LOG_DEBUG( "\tsamp_freq: (48000)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++    LOG_DEBUG( "\tsamp_freq: (88200)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++    LOG_DEBUG( "\tsamp_freq: (96000)");
++  }
++}
++
++std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info) {
++  std::stringstream res;
++  std::string field;
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDC_CIE lhdc_cie;
++
++  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    res << "A2DP_ParseInfoLhdcV3 fail: " << loghex(a2dp_status);
++    return res.str();
++  }
++
++  res << "\tname: LHDC\n";
++
++  // Sample frequency
++  field.clear();
++  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
++              "44100");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
++              "48000");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
++              "88200");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
++              "96000");
++  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
++      << ")\n";
++
++  // Channel mode
++  field.clear();
++  AppendField(&field, 1,
++             "Stereo");
++  res << "\tch_mode: " << field << " (" << "Only support stereo."
++      << ")\n";
++
++  // bits per sample
++  field.clear();
++  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
++              "16");
++  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
++              "24");
++  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
++      << ")\n";
++
++  // Max data rate...
++  field.clear();
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
++              "900Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
++              "500Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
++              "400Kbps");
++  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
++      << ")\n";
++
++  // Version
++  field.clear();
++  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
++              "LHDC V3");
++  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
++      << ")\n";
++
++
++  /*
++  field.clear();
++  AppendField(&field, 0, "NONE");
++  AppendField(&field, 0,
++              "Mono");
++  AppendField(&field, 0,
++              "Dual");
++  AppendField(&field, 1,
++              "Stereo");
++  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
++      << ")\n";
++*/
++  return res.str();
++}
++
++const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
++    const uint8_t* p_codec_info) {
++  if (!A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info)) return NULL;
++
++  return &a2dp_encoder_interface_lhdcv3;
++}
++
++bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info) {
++  tA2DP_LHDC_CIE cfg_cie;
++
++  // Nothing to do: just verify the codec info is valid
++  if (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
++    return false;
++
++  return true;
++}
++
++btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
++    UNUSED_ATTR const uint8_t* p_codec_info) {
++  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3;
++}
++
++const char* A2DP_VendorCodecIndexStrLhdcV3(void) { return "LHDC V3"; }
++
++bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg) {
++  if (A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
++                         p_cfg->codec_info) != A2DP_SUCCESS) {
++    return false;
++  }
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  /* Content protection info - support SCMS-T */
++  uint8_t* p = p_cfg->protect_info;
++  *p++ = AVDT_CP_LOSC;
++  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
++  p_cfg->num_protect = 1;
++#endif
++
++  return true;
++}
++
++UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
++                                           btav_a2dp_codec_config_t* result) {
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++
++  result->bits_per_sample = config_cie.bits_per_sample;
++
++  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++}
++
++A2dpCodecConfigLhdcV3::A2dpCodecConfigLhdcV3(
++    btav_a2dp_codec_priority_t codec_priority)
++    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, "LHDC V3",
++                      codec_priority) {
++  // Compute the local capability
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  }
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  }
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++  }
++  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++  }
++  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
++
++  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++}
++
++A2dpCodecConfigLhdcV3::~A2dpCodecConfigLhdcV3() {}
++
++bool A2dpCodecConfigLhdcV3::init() {
++  if (!isValid()) return false;
++
++  // Load the encoder
++  if (!A2DP_VendorLoadEncoderLhdcV3()) {
++    LOG_ERROR( "%s: cannot load the encoder", __func__);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2dpCodecConfigLhdcV3::useRtpHeaderMarkerBit() const { return false; }
++
++//
++// Selects the best sample rate from |sampleRate|.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_best_sample_rate(uint8_t sampleRate,
++                                    tA2DP_LHDC_CIE* p_result,
++                                    btav_a2dp_codec_config_t* p_codec_config) {
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    return true;
++  }
++  return false;
++}
++
++//
++// Selects the audio sample rate from |p_codec_audio_config|.
++// |sampleRate| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_audio_sample_rate(
++    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
++    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
++  switch (p_codec_audio_config->sample_rate) {
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
++        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
++      break;
++  }
++  return false;
++}
++
++//
++// Selects the best bits per sample from |bits_per_sample|.
++// |bits_per_sample| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_best_bits_per_sample(
++    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    return true;
++  }
++  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    return true;
++  }
++  return false;
++}
++
++//
++// Selects the audio bits per sample from |p_codec_audio_config|.
++// |bits_per_sample| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_audio_bits_per_sample(
++    const btav_a2dp_codec_config_t* p_codec_audio_config,
++    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++  switch (p_codec_audio_config->bits_per_sample) {
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        return true;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++      break;
++  }
++  return false;
++}
++
++bool A2dpCodecConfigLhdcV3::copySinkCapability(uint8_t * codec_info){
++    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++    memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
++    return true;
++}
++
++static bool A2DP_IsFeatureInUserConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
++{
++  switch(featureCode)
++  {
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
++      }
++      break;
++
++  default:
++    break;
++  }
++
++  return false;
++}
++static bool A2DP_IsFeatureInCodecConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
++{
++  switch(featureCode)
++  {
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
++      }
++      break;
++    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
++      {
++        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
++      }
++      break;
++
++  default:
++    break;
++  }
++
++  return false;
++}
++
++static void A2DP_UpdateFeatureToSpecLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
++    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value)
++{
++  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_)
++  {
++    SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
++  }
++  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_)
++  {
++    SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
++  }
++  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_)
++  {
++    SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
++  }
++  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_)
++  {
++    SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
++  }
++  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_)
++  {
++    SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
++  }
++  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_)
++  {
++    SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
++  }
++}
++
++static void A2DP_UpdateFeatureToA2dpConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
++    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature)
++{
++
++  //LOG_DEBUG( "%s: featureCode:0x%02X toCfgs:0x%04X, toSet:%d", __func__, featureCode, toCodecCfg, hasFeature);
++
++  switch(featureCode)
++  {
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
++    break;
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
++    break;
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
++    break;
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
++    break;
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
++    break;
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
++    break;
++  case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
++    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
++    break;
++
++  default:
++    break;
++  }
++}
++
++
++static uint32_t A2DP_MaxBitRatetoQualityLevelLhdcV3(uint8_t maxTargetBitrate)
++{
++	switch (maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK)
++	{
++	case A2DP_LHDC_MAX_BIT_RATE_900K:
++		return A2DP_LHDC_QUALITY_HIGH;
++	case A2DP_LHDC_MAX_BIT_RATE_500K:
++		return A2DP_LHDC_QUALITY_MID;
++	case A2DP_LHDC_MAX_BIT_RATE_400K:
++		return A2DP_LHDC_QUALITY_LOW;
++	default:
++		return (0xFF);
++	}
++}
++
++
++bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
++                                         bool is_capability,
++                                         uint8_t* p_result_codec_config) {
++  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++  tA2DP_LHDC_CIE sink_info_cie;
++  tA2DP_LHDC_CIE result_config_cie;
++  uint8_t sampleRate;
++  bool isLLEnabled;
++  bool hasFeature;
++  uint32_t quality_mode, maxBitRate_Qmode;
++  //uint8_t supportedBitrate;
++  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
++
++  // Save the internal state
++  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
++  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
++  btav_a2dp_codec_config_t saved_codec_selectable_capability =
++      codec_selectable_capability_;
++  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
++  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
++  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
++  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
++  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
++  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
++  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
++         sizeof(ota_codec_peer_capability_));
++  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
++         sizeof(ota_codec_peer_config_));
++
++  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
++  allCfgPack._codec_config_ = &codec_config_;
++  allCfgPack._codec_capability_ = &codec_capability_;
++  allCfgPack._codec_local_capability_ = &codec_local_capability_;
++  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
++  allCfgPack._codec_user_config_ = &codec_user_config_;
++  allCfgPack._codec_audio_config_ = &codec_audio_config_;
++
++  tA2DP_STATUS status =
++      A2DP_ParseInfoLhdcV3(&sink_info_cie, p_peer_codec_info, is_capability);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
++              __func__, status);
++    goto fail;
++  }
++
++  //
++  // Build the preferred configuration
++  //
++  memset(&result_config_cie, 0, sizeof(result_config_cie));
++  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
++  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
++
++
++  LOG_DEBUG( "%s: incoming version: peer(0x%02x), host(0x%02x)",
++            __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
++
++  // 2021/08/19: when sink's version is "V3_NotComapatible(version == A2DP_LHDC_VER6(0x8))",
++  //				wrap it to A2DP_LHDC_VER3 to accept and treat as an A2DP_LHDC_VER3 device.
++  if(sink_info_cie.version == A2DP_LHDC_VER6) {
++	  sink_info_cie.version = A2DP_LHDC_VER3;
++	  LOG_DEBUG( "%s: wrap V3_NotComapatible sink version to A2DP_LHDC_VER3", __func__);
++  }
++
++  if ((sink_info_cie.version & a2dp_lhdc_source_caps.version) == 0) {
++    LOG_ERROR( "%s: Sink versoin unsupported! peer(0x%02x), host(0x%02x)",
++              __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
++    goto fail;
++  }
++  result_config_cie.version = sink_info_cie.version;
++
++
++/*
++  if (sink_info_cie.channelSplitMode & A2DP_LHDC_CH_SPLIT_TWS) {
++      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_TWS;
++  }else{
++      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
++  }
++  */
++
++  LOG_DEBUG( "%s: Enter User_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
++		  (unsigned long long)(codec_user_config_.codec_specific_1),
++		  (unsigned long long)(codec_user_config_.codec_specific_2),
++		  (unsigned long long)(codec_user_config_.codec_specific_3),
++		  (unsigned long long)(codec_user_config_.codec_specific_4));
++  LOG_DEBUG( "%s: Enter Codec_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
++		  (unsigned long long)(codec_config_.codec_specific_1),
++		  (unsigned long long)(codec_config_.codec_specific_2),
++		  (unsigned long long)(codec_config_.codec_specific_3),
++		  (unsigned long long)(codec_config_.codec_specific_4));
++
++  /*******************************************
++   * Update Capabilities: LHDC Low Latency
++   * to A2DP specifics 2
++   *******************************************/
++  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
++  result_config_cie.isLLSupported = false;
++  switch (codec_user_config_.codec_specific_2 & A2DP_LHDC_LL_ENABLED) {
++    case A2DP_LHDC_LL_ENABLE:
++    if (isLLEnabled) {
++      result_config_cie.isLLSupported = true;
++      codec_config_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
++    }
++    break;
++    case A2DP_LHDC_LL_DISABLE:
++    if (!isLLEnabled) {
++      result_config_cie.isLLSupported = false;
++      codec_config_.codec_specific_2 &= ~A2DP_LHDC_LL_ENABLED;
++    }
++    break;
++  }
++  if (isLLEnabled) {
++    codec_selectable_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
++    codec_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
++  }
++  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
++  LOG_DEBUG( "%s: isLLSupported, Sink(0x%02x) Set(0x%08x), result(0x%02x)", __func__,
++                                sink_info_cie.isLLSupported,
++                                (uint32_t)codec_user_config_.codec_specific_2,
++                                result_config_cie.isLLSupported);
++
++  //
++  // Select the sample frequency
++  //
++  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
++  LOG_DEBUG( "%s: sampleRate src:0x%x sink:0x%x matched:0x%x", __func__,
++		  a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate, sampleRate);
++
++  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++  switch (codec_user_config_.sample_rate) {
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
++      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
++        codec_capability_.sample_rate = codec_user_config_.sample_rate;
++        codec_config_.sample_rate = codec_user_config_.sample_rate;
++      }
++      break;
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
++    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
++      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++      break;
++  }
++
++  // Select the sample frequency if there is no user preference
++  do {
++    // Compute the selectable capability
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++      codec_selectable_capability_.sample_rate |=
++          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    }
++
++    //Above Parts: if codec_config is setup successfully(ie., sampleRate in codec_user_config_ is valid), ignore following parts.
++    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
++    	LOG_DEBUG( "%s: setup sample_rate:0x%x from user_config", __func__, codec_config_.sample_rate);
++    	break;
++    }
++    //Below Parts: if codec_config is still not setup successfully, test default sample rate or use the best match
++
++    // Compute the common capability
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++
++    // No user preference - try the codec audio config
++    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
++                                 &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select audio sample rate:(0x%x)", __func__, result_config_cie.sampleRate);
++      break;
++    }
++
++    // No user preference - try the default config
++    if (sink_info_cie.hasFeatureLLAC) {
++      if (select_best_sample_rate(
++              a2dp_lhdc_default_config.llac_sampleRate & sink_info_cie.sampleRate,
++              &result_config_cie, &codec_config_)) {
++    	LOG_DEBUG( "%s: select best sample rate(LLAC default):0x%x", __func__, result_config_cie.sampleRate);
++        break;
++      }
++    } else {
++      if (select_best_sample_rate(
++              a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
++              &result_config_cie, &codec_config_)) {
++        LOG_DEBUG( "%s: select best sample rate(LHDC default):0x%x", __func__, result_config_cie.sampleRate);
++        break;
++      }
++    }
++
++    // No user preference - use the best match
++    if (select_best_sample_rate(sampleRate, &result_config_cie,
++                                &codec_config_)) {
++      LOG_DEBUG( "%s: select best sample rate(best):0x%x", __func__, result_config_cie.sampleRate);
++      break;
++    }
++  } while (false);
++  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
++    LOG_ERROR(
++              "%s: cannot match sample frequency: source caps = 0x%x "
++              "sink info = 0x%x",
++              __func__, a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
++    goto fail;
++  }
++
++  //
++  // Select the bits per sample
++  //
++  // NOTE: this information is NOT included in the LHDC A2DP codec description
++  // that is sent OTA.
++  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
++  LOG_DEBUG( "%s: bits_per_sample src:0x%02x sink:0x%02x matched:0x%02x", __func__,
++		  a2dp_lhdc_source_caps.bits_per_sample, sink_info_cie.bits_per_sample, bits_per_sample);
++  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  switch (codec_user_config_.bits_per_sample) {
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++      }
++      break;
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++      break;
++  }
++
++  // Select the bits per sample if there is no user preference
++  do {
++    // Compute the selectable capability
++      // Compute the selectable capability
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++
++    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE){
++    	LOG_DEBUG( "%s: setup bit_per_sample:0x%02x user_config", __func__, codec_config_.bits_per_sample);
++    	break;
++    }
++
++    // Compute the common capability
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++
++    // No user preference - the the codec audio config
++    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
++                                     &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select audio bits_per_sample:0x%x", __func__, result_config_cie.bits_per_sample);
++      break;
++    }
++
++    // No user preference - try the default config
++    if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
++                                    &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select best bits_per_sample(default):0x%x", __func__, result_config_cie.bits_per_sample);
++      break;
++    }
++
++    // No user preference - use the best match
++    if (select_best_bits_per_sample(bits_per_sample,
++                                    &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select best bits_per_sample(best):0x%x", __func__, result_config_cie.bits_per_sample);
++      break;
++    }
++  } while (false);
++  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
++    LOG_ERROR(
++              "%s: cannot match bits per sample: default = 0x%x "
++              "user preference = 0x%x",
++              __func__, a2dp_lhdc_default_config.bits_per_sample,
++              codec_user_config_.bits_per_sample);
++    goto fail;
++  }
++
++  //
++  // Select the channel mode
++  //
++  LOG_DEBUG( "%s: channelMode = Only supported stereo", __func__);
++  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++  switch (codec_user_config_.channel_mode) {
++    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
++      codec_capability_.channel_mode = codec_user_config_.channel_mode;
++      codec_config_.channel_mode = codec_user_config_.channel_mode;
++      break;
++    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
++    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
++      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++      break;
++  }
++  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
++    LOG_ERROR(
++              "%s: codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_NONE or BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO "
++              , __func__);
++    goto fail;
++  }
++
++  /*******************************************
++   * Update maxTargetBitrate
++   *
++   *******************************************/
++  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
++
++  LOG_DEBUG( "%s: Config Max bitrate result(0x%02x)", __func__, result_config_cie.maxTargetBitrate);
++
++  /*******************************************
++   * Update channelSplitMode
++   *
++   *******************************************/
++  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
++  LOG_DEBUG("%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
++
++
++  /*******************************************
++   * quality mode: magic num check and reconfigure
++   * to specific 1
++   *******************************************/
++  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
++      LOG_DEBUG("%s: use default quality_mode:ABR", __func__);
++  }
++  quality_mode = codec_user_config_.codec_specific_1 & 0xff;
++
++  // filter non-supported quality modes(those supported in LHDCV5 or higher version) for internal use
++  if (quality_mode == A2DP_LHDC_QUALITY_HIGH1) {
++    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
++    quality_mode = A2DP_LHDC_QUALITY_HIGH;
++    LOG_DEBUG("%s: reset non-supported quality_mode to %s", __func__,
++        lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
++  }
++
++  /*******************************************
++   * LHDC features: safety tag check
++   * to specific 3
++   *******************************************/
++  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
++  {
++      LOG_DEBUG( "%s: LHDC feature tag not matched! use old feature settings", __func__);
++
++      /* *
++       * Magic num does not match:
++       * 1. add tag
++       * 2. Re-adjust previous feature(which refers to codec_user_config)'s state(in codec_config_) to codec_user_config_:
++       * 	AR(has UI), Meta(no UI yet), LARC(no UI yet)
++       * */
++      // clean entire specific and set safety tag
++      codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
++
++      // Feature: AR
++      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE) )
++      {
++    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++    	        &allCfgPack,
++				LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
++    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
++    	        true);
++    	    LOG_DEBUG( "%s: restore user_cfg to previous AR status => ON", __func__);
++      }
++      else
++      {
++			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++				&allCfgPack,
++				LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
++				A2DP_LHDC_TO_A2DP_CODEC_USER_,
++				false);
++			LOG_DEBUG( "%s: restore user_cfg to previous AR status => OFF", __func__);
++      }
++      // Feature: META
++      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE) )
++      {
++    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++    	        &allCfgPack,
++				LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
++    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
++    	        true);
++    	    LOG_DEBUG( "%s: restore user_cfg to previous META status => ON", __func__);
++      }
++      else
++      {
++			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++				&allCfgPack,
++				LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
++				A2DP_LHDC_TO_A2DP_CODEC_USER_,
++				false);
++			LOG_DEBUG( "%s: restore user_cfg to previous META status => OFF", __func__);
++      }
++      // Feature: LARC
++      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE) )
++      {
++    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++    	        &allCfgPack,
++				LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
++    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
++    	        true);
++    	    LOG_DEBUG( "%s: restore user_cfg to previous LARC status => ON", __func__);
++      }
++      else
++      {
++			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++				&allCfgPack,
++				LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
++				A2DP_LHDC_TO_A2DP_CODEC_USER_,
++				false);
++			LOG_DEBUG( "%s: restore user_cfg to previous LARC status => OFF", __func__);
++      }
++  }
++  else
++  {
++	  LOG_DEBUG( "%s: LHDC feature tag matched!", __func__);
++  }
++
++
++  /**
++  *LHDC V4 modify
++  */
++
++  /*******************************************
++   * Update Feature/Capabilities: LLAC
++   * to A2DP specifics
++   *******************************************/
++  //result_config_cie.hasFeatureLLAC = sink_info_cie.hasFeatureLLAC;
++  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLLAC & sink_info_cie.hasFeatureLLAC);
++  result_config_cie.hasFeatureLLAC = false;
++
++  /* *
++   * reset bit in A2DP configs
++   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
++   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
++   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_LLAC_ENABLED;
++   * */
++  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++      &allCfgPack,
++      LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
++      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++      false);
++
++  if (hasFeature /*&& 
++      (
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
++      )*/
++     ) {
++    result_config_cie.hasFeatureLLAC = true;
++    //codec_config_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
++    //codec_user_config_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_USER_),
++        true);
++  }
++
++  if(hasFeature)
++  {
++    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
++    //codec_capability_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        true);
++  }
++
++  LOG_DEBUG( "%s: Has LLAC feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                hasFeature,
++                                a2dp_lhdc_source_caps.hasFeatureLLAC,
++                                sink_info_cie.hasFeatureLLAC,
++                                result_config_cie.hasFeatureLLAC);
++  LOG_DEBUG( "%s: LLAC update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                (codec_config_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
++                                (codec_capability_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
++                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
++                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED));
++
++  /*******************************************
++   * Update Feature/Capabilities: LHDCV4
++   * to A2DP specifics
++   *******************************************/
++  //result_config_cie.hasFeatureLHDCV4 = sink_info_cie.hasFeatureLHDCV4;
++  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLHDCV4 & sink_info_cie.hasFeatureLHDCV4);
++  result_config_cie.hasFeatureLHDCV4 = false;
++
++  /* *
++   * reset bit in A2DP configs
++   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
++   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
++   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_V4_ENABLED;
++   * */
++  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++      &allCfgPack,
++      LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
++      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++      false);
++
++  if (hasFeature /*&& 
++      (
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) ||
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
++      )*/
++     ) {
++    result_config_cie.hasFeatureLHDCV4 = true;
++    //codec_config_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
++    //codec_user_config_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_USER_),
++        true);
++  }
++  if (hasFeature) {
++    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
++    //codec_capability_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        true);
++  }
++
++  LOG_DEBUG( "%s: Has V4 feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                hasFeature,
++                                a2dp_lhdc_source_caps.hasFeatureLHDCV4,
++                                sink_info_cie.hasFeatureLHDCV4,
++                                result_config_cie.hasFeatureLHDCV4);
++  LOG_DEBUG( "%s: V4 update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                (codec_config_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
++                                (codec_capability_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
++                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
++                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_V4_ENABLED));
++
++  /*******************************************
++   * Update Feature/Capabilities: JAS
++   * to A2DP specifics
++   *******************************************/
++  {
++    //result_config_cie.hasFeatureJAS = sink_info_cie.hasFeatureJAS;
++    hasFeature = (a2dp_lhdc_source_caps.hasFeatureJAS & sink_info_cie.hasFeatureJAS);
++    result_config_cie.hasFeatureJAS = false;
++
++    /* *
++     * reset bit in A2DP configs
++     *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_JAS_ENABLED;
++     *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_JAS_ENABLED;
++     *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_JAS_ENABLED;
++     * */
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++        false);
++
++    //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED) && hasFeature) {
++    /*  06/02/2021: enable JAS without UI control */
++    //if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE) )
++    if( hasFeature )
++    {
++      result_config_cie.hasFeatureJAS = true;
++      //codec_config_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
++      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++          &allCfgPack,
++          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
++          A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
++          true);
++    }
++
++    if(hasFeature)
++    {
++      //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
++      //codec_capability_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
++      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++          &allCfgPack,
++          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
++          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++          true);
++    }
++    LOG_DEBUG( "%s: Has JAS feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                  hasFeature,
++                                  a2dp_lhdc_source_caps.hasFeatureJAS,
++                                  sink_info_cie.hasFeatureJAS,
++                                  result_config_cie.hasFeatureJAS);
++    LOG_DEBUG( "%s: JAS update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                  (codec_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
++                                  (codec_capability_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
++                                  (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
++                                  (codec_user_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED));
++  }
++
++  /*******************************************
++   * Update Feature/Capabilities: AR
++   * to A2DP specifics
++   *******************************************/
++  //result_config_cie.hasFeatureAR = sink_info_cie.hasFeatureAR;
++  hasFeature = (a2dp_lhdc_source_caps.hasFeatureAR & sink_info_cie.hasFeatureAR);
++  result_config_cie.hasFeatureAR = false;
++
++  /* *
++   * reset bit in A2DP configs
++   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_AR_ENABLED;
++   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_AR_ENABLED;
++   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_AR_ENABLED;
++   * */
++  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++      &allCfgPack,
++      LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
++      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++      false);
++
++  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED) && hasFeature) {
++  if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE) ){
++    result_config_cie.hasFeatureAR = true;
++    //codec_config_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
++        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
++        true);
++    /* 06/02/2021: When AR function is turned ON, downgrade the sample rate to 48KHz if needed.
++     * 	Reason: prevent high CPU loading of AR engine running on higher sample rate(ex:96KHz)
++     */
++    if(codec_user_config_.sample_rate > BTAV_A2DP_CODEC_SAMPLE_RATE_48000)
++    {
++    	LOG_DEBUG( "%s: Limit current sample rate(0x%02X) to 48Khz when AR feature turnned on", __func__,
++    			codec_user_config_.sample_rate);
++		codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++		codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++		result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++    }
++  }
++
++  if (hasFeature) {
++    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
++    //codec_capability_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        true);
++  }
++
++  LOG_DEBUG( "%s: Has AR feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                hasFeature,
++                                a2dp_lhdc_source_caps.hasFeatureAR,
++                                sink_info_cie.hasFeatureAR,
++                                result_config_cie.hasFeatureAR);
++  LOG_DEBUG( "%s: AR update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                (codec_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
++                                (codec_capability_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
++                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
++                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED));
++
++  /*******************************************
++   * Update Feature/Capabilities: META
++   * to A2DP specifics
++   *******************************************/
++  //result_config_cie.hasFeatureMETA = sink_info_cie.hasFeatureMETA;
++  hasFeature = (a2dp_lhdc_source_caps.hasFeatureMETA & sink_info_cie.hasFeatureMETA);
++  result_config_cie.hasFeatureMETA = false;
++
++  /* *
++   * reset bit in A2DP configs
++   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_META_ENABLED;
++   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_META_ENABLED;
++   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_META_ENABLED;
++   * */
++  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++      &allCfgPack,
++      LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
++      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++      false);
++
++  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED) && hasFeature) {
++  if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE) ){
++    result_config_cie.hasFeatureMETA = true;
++    //codec_config_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
++        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
++        true);
++  }
++
++  if (hasFeature) {
++    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
++    //codec_capability_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        true);
++  }
++
++  LOG_DEBUG( "%s: Has META feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                hasFeature,
++                                a2dp_lhdc_source_caps.hasFeatureMETA,
++                                sink_info_cie.hasFeatureMETA,
++                                result_config_cie.hasFeatureMETA);
++  LOG_DEBUG( "%s: META update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                (codec_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
++                                (codec_capability_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
++                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
++                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED));
++
++  /*******************************************
++   * Update Feature/Capabilities: MBR
++   * to A2DP specifics
++   *******************************************/
++  //result_config_cie.hasFeatureMinBitrate = sink_info_cie.hasFeatureMinBitrate;
++  hasFeature = (a2dp_lhdc_source_caps.hasFeatureMinBitrate & sink_info_cie.hasFeatureMinBitrate);
++  result_config_cie.hasFeatureMinBitrate = false;
++
++  /* *
++   * reset bit in A2DP configs
++   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_MBR_ENABLED;
++   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_MBR_ENABLED;
++   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_MBR_ENABLED;
++   * */
++  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++      &allCfgPack,
++      LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
++      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++      false);
++
++  if (hasFeature) {
++    result_config_cie.hasFeatureMinBitrate = true;
++    //codec_config_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
++    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
++    //codec_capability_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        true);
++  }
++
++  LOG_DEBUG( "%s: Has MBR feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                hasFeature,
++                                a2dp_lhdc_source_caps.hasFeatureMinBitrate,
++                                sink_info_cie.hasFeatureMinBitrate,
++                                result_config_cie.hasFeatureMinBitrate);
++  LOG_DEBUG( "%s: MBR update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                (codec_config_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
++                                (codec_capability_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
++                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
++                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED));
++
++
++  /*******************************************
++   * Update Feature/Capabilities: LARC
++   * to A2DP specifics
++   *******************************************/
++  //result_config_cie.hasFeatureLARC = sink_info_cie.hasFeatureLARC;
++  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLARC & sink_info_cie.hasFeatureLARC);
++  result_config_cie.hasFeatureLARC = false;
++
++  /* *
++   * reset bit in A2DP configs
++   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_LARC_ENABLED;
++   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_LARC_ENABLED;
++   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_LARC_ENABLED;
++   * */
++  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++      &allCfgPack,
++      LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
++      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
++      false);
++
++  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED) && hasFeature) {
++  //if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE) ){
++  if( hasFeature ){
++    result_config_cie.hasFeatureLARC = true;
++    //codec_config_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
++        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
++        true);
++  }
++
++  if (hasFeature) {
++    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
++    //codec_capability_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
++        &allCfgPack,
++        LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
++        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        true);
++  }
++
++  LOG_DEBUG( "%s: Has LARC feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
++                                hasFeature,
++                                a2dp_lhdc_source_caps.hasFeatureLARC,
++                                sink_info_cie.hasFeatureLARC,
++                                result_config_cie.hasFeatureLARC);
++  LOG_DEBUG( "%s: LARC update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
++                                (codec_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
++                                (codec_capability_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
++                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
++                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED));
++
++
++  /*******************************************
++   * quality mode: re-adjust according to maxTargetBitrate(smaller one adopted)
++   *******************************************/
++  if ( (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) &&
++	   (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) &&
++	   (quality_mode != A2DP_LHDC_QUALITY_ABR))
++  {
++	  //In this case, max bit rate mechanism is disabled(set to 900k)
++	  result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
++	  LOG_DEBUG("%s: [LLAC + LHDC V4]: set MBR (0x%x)", __func__, result_config_cie.maxTargetBitrate);
++
++	  //dont re-adjust quality mode in this case
++	  LOG_DEBUG("%s: do not adjust quality_mode in this case", __func__);
++  }
++  else
++  {
++	  maxBitRate_Qmode = A2DP_MaxBitRatetoQualityLevelLhdcV3(result_config_cie.maxTargetBitrate);
++	  if(maxBitRate_Qmode < 0xFF) {
++		  if(quality_mode != A2DP_LHDC_QUALITY_ABR && quality_mode > maxBitRate_Qmode){
++			  LOG_DEBUG("%s: adjust quality_mode:0x%x to 0x%x by maxTargetBitrate:0x%x", __func__,
++					  quality_mode, maxBitRate_Qmode, result_config_cie.maxTargetBitrate);
++			  quality_mode = maxBitRate_Qmode;
++			  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | quality_mode;
++		  }
++	  }
++  }
++
++  /*
++   * Final Custom Rules of resolving conflict between capabilities and version
++   */
++  if (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
++    //LHDCV4 + LLAC
++    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
++
++      if (quality_mode == A2DP_LHDC_QUALITY_ABR) {
++		result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++		codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++		codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
++		result_config_cie.hasFeatureLHDCV4 = false;
++		codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
++		LOG_DEBUG("%s: [LLAC + LHDC V4]: LLAC, reset sampleRate (0x%x)", __func__, result_config_cie.sampleRate);
++      } else {
++        result_config_cie.hasFeatureLLAC = false;
++        codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
++        LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC", __func__);
++
++  	    //result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
++  	    //LOG_DEBUG("%s: [LLAC + LHDC V4]: set MBR (0x%x)", __func__, result_config_cie.maxTargetBitrate);
++
++      	if (result_config_cie.hasFeatureMinBitrate) {
++          if (quality_mode < A2DP_LHDC_QUALITY_MID) {
++            codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID;
++            quality_mode = A2DP_LHDC_QUALITY_MID;
++            LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x%x)", __func__, quality_mode);
++          }
++      	} else {
++    	  if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
++		    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++		    quality_mode = A2DP_LHDC_QUALITY_LOW;
++		    LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x%x)", __func__, quality_mode);
++		  }
++      	}
++      }
++    } else if (
++        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
++        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
++       ) {
++      result_config_cie.hasFeatureLLAC = false;
++      codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
++      LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC", __func__);
++    } else if (
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
++       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
++      ) {
++      result_config_cie.hasFeatureLHDCV4 = false;
++      codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
++      LOG_DEBUG("%s: [LLAC + LHDC V4]: LLAC", __func__);
++
++      /* LLAC: prevent quality mode using 64kbps */
++      if (result_config_cie.hasFeatureMinBitrate) {
++    	if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
++    	  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
++    	  quality_mode = A2DP_LHDC_QUALITY_LOW1;
++    	  LOG_DEBUG("%s: [LLAC + LHDC V4]: LLAC, reset Qmode (0x%x)", __func__, quality_mode);
++    	}
++      }
++    } else {
++      LOG_ERROR("%s: [LLAC + LHDC V4]: format incorrect.", __func__);
++      goto fail;
++    }
++
++  } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
++    //LHDC V4 only
++    LOG_DEBUG("%s: [LHDCV4 only]", __func__);
++	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
++		if (result_config_cie.hasFeatureMinBitrate) {
++			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
++				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++				quality_mode = A2DP_LHDC_QUALITY_LOW;
++				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x)", __func__, quality_mode);
++			}
++		}
++	} else {
++		if (result_config_cie.hasFeatureMinBitrate) {
++			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
++				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
++				quality_mode = A2DP_LHDC_QUALITY_LOW4;
++				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x), ", __func__, quality_mode);
++			}
++		}
++	}
++
++  } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
++    //LLAC only
++    LOG_DEBUG("%s: [LLAC only]", __func__);
++    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
++      result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
++      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
++      LOG_DEBUG("%s: [LLAC only]: reset SampleRate (0x%x)", __func__, result_config_cie.sampleRate);
++    }
++
++    if (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR) {
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++      quality_mode = A2DP_LHDC_QUALITY_LOW;
++      LOG_DEBUG("%s: [LLAC only]: reset Qmode (0x%x)", __func__, quality_mode);
++    }
++    
++    /* LLAC: prevent quality mode using 64kbps */
++    if (result_config_cie.hasFeatureMinBitrate) {
++		if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
++		  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
++		  quality_mode = A2DP_LHDC_QUALITY_LOW1;
++		  LOG_DEBUG("%s: [LLAC only]: reset Qmode (0x%x)", __func__, quality_mode);
++		}
++    }
++
++  } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
++    //LHDC V3 only
++    LOG_DEBUG("%s: [LHDCV3 only]", __func__);
++	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
++		if (result_config_cie.hasFeatureMinBitrate) {
++			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
++				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++				quality_mode = A2DP_LHDC_QUALITY_LOW;
++				LOG_DEBUG("%s: [LHDCV3 only]: reset Qmode (0x%x)", __func__, quality_mode);
++			}
++		}
++	} else {
++		if (result_config_cie.hasFeatureMinBitrate) {
++			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
++				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
++				quality_mode = A2DP_LHDC_QUALITY_LOW4;
++				LOG_DEBUG("%s: [LHDCV3 only]: reset Qmode (0x%x), ", __func__, quality_mode);
++			}
++		}
++	}
++  }
++
++  LOG_DEBUG("%s: Final quality_mode = (%d) %s", __func__,
++      quality_mode,
++      lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
++
++  //
++  // Copy the codec-specific fields if they are not zero
++  //
++  if (codec_user_config_.codec_specific_1 != 0)
++    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
++  if (codec_user_config_.codec_specific_2 != 0)
++    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
++  if (codec_user_config_.codec_specific_3 != 0)
++    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
++  if (codec_user_config_.codec_specific_4 != 0)
++    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
++  
++  /* Setup final nego result codec config to peer */
++  if (int ret = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
++                         p_result_codec_config) != A2DP_SUCCESS) {
++    LOG_ERROR("%s: A2DP_BuildInfoLhdcV3 fail(0x%x)", __func__, ret);
++    goto fail;
++  }
++
++
++  // Create a local copy of the peer codec capability, and the
++  // result codec config.
++    LOG_ERROR("%s: is_capability = %d", __func__, is_capability);
++  if (is_capability) {
++    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
++                                ota_codec_peer_capability_);
++  } else {
++    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
++                                ota_codec_peer_config_);
++  }
++  CHECK(status == A2DP_SUCCESS);
++
++  status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
++                              ota_codec_config_);
++  CHECK(status == A2DP_SUCCESS);
++
++  LOG_DEBUG( "%s: Final User_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
++		  (unsigned long long)codec_user_config_.codec_specific_1,
++		  (unsigned long long)codec_user_config_.codec_specific_2,
++		  (unsigned long long)codec_user_config_.codec_specific_3,
++		  (unsigned long long)codec_user_config_.codec_specific_4);
++  LOG_DEBUG( "%s: Final Codec_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
++		  (unsigned long long)(codec_config_.codec_specific_1),
++		  (unsigned long long)(codec_config_.codec_specific_2),
++		  (unsigned long long)(codec_config_.codec_specific_3),
++		  (unsigned long long)(codec_config_.codec_specific_4));
++
++  return true;
++
++fail:
++  // Restore the internal state
++  codec_config_ = saved_codec_config;
++  codec_capability_ = saved_codec_capability;
++  codec_selectable_capability_ = saved_codec_selectable_capability;
++  codec_user_config_ = saved_codec_user_config;
++  codec_audio_config_ = saved_codec_audio_config;
++  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
++  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
++         sizeof(ota_codec_peer_capability_));
++  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
++         sizeof(ota_codec_peer_config_));
++  return false;
++}
++
++
++
++bool A2dpCodecConfigLhdcV3::setPeerCodecCapabilities(
++                                                   const uint8_t* p_peer_codec_capabilities) {
++    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++    tA2DP_LHDC_CIE peer_info_cie;
++    uint8_t sampleRate;
++    uint8_t bits_per_sample;
++
++    // Save the internal state
++    btav_a2dp_codec_config_t saved_codec_selectable_capability =
++    codec_selectable_capability_;
++    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
++    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
++           sizeof(ota_codec_peer_capability_));
++
++    tA2DP_STATUS status =
++    A2DP_ParseInfoLhdcV3(&peer_info_cie, p_peer_codec_capabilities, true);
++    if (status != A2DP_SUCCESS) {
++        LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
++                  __func__, status);
++        goto fail;
++    }
++/*
++    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
++        LOG_ERROR( "%s: can't parse peer's capabilities: Missmatch version(%u:%u)",
++                  __func__, a2dp_lhdc_source_caps.version, peer_info_cie.version);
++        goto fail;
++    }
++*/
++
++    // Compute the selectable capability - bits per sample
++    //codec_selectable_capability_.bits_per_sample =
++    //a2dp_lhdc_source_caps.bits_per_sample;
++    bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    }
++    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    }
++
++
++    // Compute the selectable capability - sample rate
++    sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
++        codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
++        codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    }
++    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
++        codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    }
++
++
++    // Compute the selectable capability - channel mode
++    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++
++    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
++                                ota_codec_peer_capability_);
++    CHECK(status == A2DP_SUCCESS);
++    return true;
++
++fail:
++    // Restore the internal state
++    codec_selectable_capability_ = saved_codec_selectable_capability;
++    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
++           sizeof(ota_codec_peer_capability_));
++    return false;
++}
++
++
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
+new file mode 100644
+index 000000000..894cabd0a
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
+@@ -0,0 +1,747 @@
++/******************************************************************************
++ *
++ *  Copyright 2002-2012 Broadcom Corporation
++ *
++ *  Licensed under the Apache License, Version 2.0 (the "License");
++ *  you may not use this file except in compliance with the License.
++ *  You may obtain a copy of the License at:
++ *
++ *  http://www.apache.org/licenses/LICENSE-2.0
++ *
++ *  Unless required by applicable law or agreed to in writing, software
++ *  distributed under the License is distributed on an "AS IS" BASIS,
++ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ *  See the License for the specific language governing permissions and
++ *  limitations under the License.
++ *
++ ******************************************************************************/
++
++/******************************************************************************
++ *
++ *  Utility functions to help build and parse SBC Codec Information Element
++ *  and Media Payload.
++ *
++ ******************************************************************************/
++
++#define LOG_TAG "a2dp_vendor_lhdcv3_dec"
++
++#include "bt_target.h"
++
++#include "a2dp_vendor_lhdcv3_dec.h"
++
++#include <string.h>
++
++#include <base/logging.h>
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv3_decoder.h"
++#include "bt_utils.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++
++// data type for the LHDC Codec Information Element */
++// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
++typedef struct {
++  uint32_t vendorId;
++  uint16_t codecId;    /* Codec ID for LHDC */
++  uint8_t sampleRate;  /* Sampling Frequency */
++  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
++  uint8_t channelSplitMode;
++  uint8_t version;
++  uint8_t maxTargetBitrate;
++  bool isLLSupported;
++  //uint8_t supportedBitrate;
++  bool hasFeatureJAS;
++  bool hasFeatureAR;
++  bool hasFeatureLLAC;
++  bool hasFeatureMETA;
++  bool hasFeatureMinBitrate;
++  bool hasFeatureLARC;
++  bool hasFeatureLHDCV4;
++} tA2DP_LHDCV3_SINK_CIE;
++
++/* LHDC Sink codec capabilities */
++static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV3_CODEC_ID,   // codecId
++    // sampleRate
++    //(A2DP_LHDC_SAMPLING_FREQ_48000),
++    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
++    // bits_per_sample
++    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
++    //Channel Separation
++    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
++	A2DP_LHDC_CH_SPLIT_NONE,
++    //Version number
++    A2DP_LHDC_VER3,
++    //Target bit Rate
++    A2DP_LHDC_MAX_BIT_RATE_900K,
++    //LL supported ?
++    true,
++
++    /*******************************
++     *  LHDC features/capabilities:
++     *  hasFeatureJAS
++     *  hasFeatureAR
++     *  hasFeatureLLAC
++     *  hasFeatureMETA
++     *  hasFeatureMinBitrate
++     *  hasFeatureLARC
++     *  hasFeatureLHDCV4
++     *******************************/
++    //bool hasFeatureJAS;
++    true,
++
++    //bool hasFeatureAR;
++    true,
++
++    //bool hasFeatureLLAC;
++    true,
++
++    //bool hasFeatureMETA;
++    true,
++
++    //bool hasFeatureMinBitrate;
++    true,
++
++    //bool hasFeatureLARC;
++    false,
++
++    //bool hasFeatureLHDCV4;
++    true,
++};
++
++/* Default LHDC codec configuration */
++static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_default_config = {
++    A2DP_LHDC_VENDOR_ID,                // vendorId
++    A2DP_LHDCV3_CODEC_ID,                 // codecId
++    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
++    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
++    A2DP_LHDC_CH_SPLIT_NONE,
++    A2DP_LHDC_VER3,
++    A2DP_LHDC_MAX_BIT_RATE_900K,
++    false,
++
++    //bool hasFeatureJAS;
++    false,
++
++    //bool hasFeatureAR;
++    false,
++
++    //bool hasFeatureLLAC;
++    true,
++
++    //bool hasFeatureMETA;
++    false,
++
++    //bool hasFeatureMinBitrate;
++    true,
++
++    //bool hasFeatureLARC;
++    false,
++
++    //bool hasFeatureLHDCV4;
++    true,
++};
++
++static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv3 = {
++    a2dp_vendor_lhdcv3_decoder_init,
++    a2dp_vendor_lhdcv3_decoder_cleanup,
++    a2dp_vendor_lhdcv3_decoder_decode_packet,
++    a2dp_vendor_lhdcv3_decoder_start,
++    a2dp_vendor_lhdcv3_decoder_suspend,
++    a2dp_vendor_lhdcv3_decoder_configure,
++};
++
++static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
++    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_capability);
++
++
++// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
++// |p_ie| is a pointer to the LHDC Codec Information Element information.
++// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_BuildInfoLhdcV3Sink(uint8_t media_type,
++                                       const tA2DP_LHDCV3_SINK_CIE* p_ie,
++                                       uint8_t* p_result) {
++
++  const uint8_t* tmpInfo = p_result;
++  if (p_ie == NULL || p_result == NULL) {
++    return A2DP_INVALID_PARAMS;
++  }
++
++  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
++  *p_result++ = (media_type << 4);      //1
++  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
++
++  // Vendor ID and Codec ID
++  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
++  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
++  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
++
++  // Sampling Frequency & Bits per sample
++  uint8_t para = 0;
++
++  // sample rate bit0 ~ bit2
++  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
++
++  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
++      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
++  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
++      para = para | A2DP_LHDC_BIT_FMT_24;
++  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
++      para = para | A2DP_LHDC_BIT_FMT_16;
++  }
++
++  if (p_ie->hasFeatureJAS)
++  {
++    para |= A2DP_LHDC_FEATURE_JAS;
++  }
++
++  if (p_ie->hasFeatureAR)
++  {
++    para |= A2DP_LHDC_FEATURE_AR;
++  }
++
++  // Save octet 9
++  *p_result++ = para;   //9
++
++  para = p_ie->version;
++
++  para |= p_ie->maxTargetBitrate;
++
++  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
++
++  if (p_ie->hasFeatureLLAC)
++  {
++    para |= A2DP_LHDC_FEATURE_LLAC;
++  }
++
++  // Save octet 10
++  *p_result++ = para;   //a
++
++  //Save octet 11
++  para = p_ie->channelSplitMode;
++
++  if (p_ie->hasFeatureMETA)
++  {
++    para |= A2DP_LHDC_FEATURE_META;
++  }
++
++  if (p_ie->hasFeatureMinBitrate)
++  {
++    para |= A2DP_LHDC_FEATURE_MIN_BR;
++  }
++
++  if (p_ie->hasFeatureLARC)
++  {
++    para |= A2DP_LHDC_FEATURE_LARC;
++  }
++
++  if (p_ie->hasFeatureLHDCV4)
++  {
++    para |= A2DP_LHDC_FEATURE_LHDCV4;
++  }
++
++  *p_result++ = para;   //b
++
++  //Save octet 12
++  //para = p_ie->supportedBitrate;
++  //*p_result++ = para;   //c
++
++  LOG_DEBUG("%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
++                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
++     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
++                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
++  return A2DP_SUCCESS;
++}
++
++// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
++// |p_codec_info|. If |is_capability| is true, the byte sequence is
++// codec capabilities, otherwise is codec configuration.
++// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
++// status code.
++static tA2DP_STATUS A2DP_ParseInfoLhdcV3Sink(tA2DP_LHDCV3_SINK_CIE* p_ie,
++                                       const uint8_t* p_codec_info,
++                                       bool is_capability) {
++  uint8_t losc;
++  uint8_t media_type;
++  tA2DP_CODEC_TYPE codec_type;
++  const uint8_t* tmpInfo = p_codec_info;
++  const uint8_t* p_codec_Info_save = p_codec_info;
++
++  //LOG_DEBUG("%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
++  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
++
++  // Check the codec capability length
++  losc = *p_codec_info++;
++
++  if (losc != A2DP_LHDCV3_CODEC_LEN) return A2DP_WRONG_CODEC;
++
++  media_type = (*p_codec_info++) >> 4;
++  codec_type = *p_codec_info++;
++    //LOG_DEBUG("%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
++  /* Check the Media Type and Media Codec Type */
++  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
++      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  // Check the Vendor ID and Codec ID */
++  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
++                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
++                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
++                   (*(p_codec_info + 3) << 24 & 0xFF000000);
++  p_codec_info += 4;
++  p_ie->codecId =
++      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
++  p_codec_info += 2;
++  LOG_DEBUG("%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
++  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
++      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
++  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
++    return A2DP_WRONG_CODEC;
++  }
++
++  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
++    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
++    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++  }
++
++
++  p_codec_info += 1;
++
++  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
++  //p_ie->version = 1;
++
++  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
++  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
++
++  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
++  //p_ie->isLLSupported = false;
++
++  p_codec_info += 1;
++
++  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
++
++  //p_codec_info += 1;
++
++  //p_ie->supportedBitrate = (*p_codec_info);
++
++
++
++
++    LOG_DEBUG("%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
++            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
++                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
++
++  if (is_capability) return A2DP_SUCCESS;
++
++  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
++    return A2DP_BAD_SAMP_FREQ;
++
++  save_codec_info (p_codec_Info_save);
++
++  return A2DP_SUCCESS;
++}
++
++const char* A2DP_VendorCodecNameLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info) {
++  return "LHDC V3";
++}
++
++bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV3_SINK_CIE cfg_cie;
++
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
++         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
++}
++
++
++bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV3_SINK_CIE cfg_cie;
++
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
++         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
++}
++
++
++bool A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
++  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
++                                             false) == A2DP_SUCCESS);
++}
++
++bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
++  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
++                                             true) == A2DP_SUCCESS);
++}
++
++void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info) {
++  LOG_DEBUG("%s: enter", __func__);
++  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_default_config,
++                        p_codec_info) != A2DP_SUCCESS) {
++    LOG_ERROR("%s: A2DP_BuildInfoSbc failed", __func__);
++  }
++}
++
++// Checks whether A2DP SBC codec configuration matches with a device's codec
++// capabilities. |p_cap| is the SBC codec configuration. |p_codec_info| is
++// the device's codec capabilities. |is_capability| is true if
++// |p_codec_info| contains A2DP codec capability.
++// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
++    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_capability) {
++  tA2DP_STATUS status;
++  tA2DP_LHDCV3_SINK_CIE cfg_cie;
++
++  /* parse configuration */
++  status = A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, is_capability);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: parsing failed %d", __func__, status);
++    return status;
++  }
++
++  /* verify that each parameter is in range */
++
++  LOG_DEBUG("%s: FREQ peer: 0x%x, capability 0x%x", __func__,
++            cfg_cie.sampleRate, p_cap->sampleRate);
++
++  LOG_DEBUG("%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
++            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
++
++  /* sampling frequency */
++  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
++
++  /* bit per sample */
++  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
++
++  return A2DP_SUCCESS;
++}
++
++bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
++                                    const uint8_t* p_codec_info_b) {
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status =
++      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
++                                const uint8_t* p_codec_info_b) {
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status =
++      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return false;
++  }
++
++  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
++         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
++         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
++         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
++}
++
++
++int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.sampleRate) {
++    case A2DP_LHDC_SAMPLING_FREQ_44100:
++      return 44100;
++    case A2DP_LHDC_SAMPLING_FREQ_48000:
++      return 48000;
++    case A2DP_LHDC_SAMPLING_FREQ_88200:
++      return 88200;
++    case A2DP_LHDC_SAMPLING_FREQ_96000:
++      return 96000;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++
++  return A2DP_LHDC_CHANNEL_MODE_STEREO;
++}
++
++int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
++
++  // Check whether the codec info contains valid data
++  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
++              a2dp_status);
++    return -1;
++  }
++  return A2DP_LHDC_CHANNEL_MODE_STEREO;
++}
++
++bool A2DP_VendorGetPacketTimestampLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
++                                       const uint8_t* p_data,
++                                       uint32_t* p_timestamp) {
++  // TODO: Is this function really codec-specific?
++  *p_timestamp = *(const uint32_t*)p_data;
++  return true;
++}
++/*
++bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
++                              BT_HDR* p_buf, uint16_t frames_per_packet) {
++  uint8_t* p;
++
++  p_buf->offset -= A2DP_SBC_MPL_HDR_LEN;
++  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
++  p_buf->len += A2DP_SBC_MPL_HDR_LEN;
++  A2DP_BuildMediaPayloadHeaderSbc(p, false, false, false,
++                                  (uint8_t)frames_per_packet);
++
++  return true;
++}
++*/
++std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info) {
++  std::stringstream res;
++  std::string field;
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
++
++  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, true);
++  if (a2dp_status != A2DP_SUCCESS) {
++    res << "A2DP_ParseInfoLhdcV3Sink fail: " << loghex(a2dp_status);
++    return res.str();
++  }
++
++  res << "\tname: LHDC\n";
++
++  // Sample frequency
++  field.clear();
++  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
++              "44100");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
++              "48000");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
++              "88200");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
++              "96000");
++  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
++      << ")\n";
++
++  // Channel mode
++  field.clear();
++  AppendField(&field, 1,
++             "Stereo");
++  res << "\tch_mode: " << field << " (" << "Only support stereo."
++      << ")\n";
++
++  // bits per sample
++  field.clear();
++  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
++              "16");
++  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
++              "24");
++  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
++      << ")\n";
++
++  // Max data rate...
++  field.clear();
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
++              "900Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
++              "500Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
++              "400Kbps");
++  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
++      << ")\n";
++
++  // Version
++  field.clear();
++  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
++              "LHDC V3");
++  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
++      << ")\n";
++
++
++  /*
++  field.clear();
++  AppendField(&field, 0, "NONE");
++  AppendField(&field, 0,
++              "Mono");
++  AppendField(&field, 0,
++              "Dual");
++  AppendField(&field, 1,
++              "Stereo");
++  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
++      << ")\n";
++*/
++  return res.str();
++}
++
++const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
++    const uint8_t* p_codec_info) {
++  if (!A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info)) return NULL;
++
++  return &a2dp_decoder_interface_lhdcv3;
++}
++
++bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info) {
++  tA2DP_LHDCV3_SINK_CIE cfg_cie;
++
++  // Nothing to do: just verify the codec info is valid
++  if (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
++    return false;
++
++  return true;
++}
++
++btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(
++    UNUSED_ATTR const uint8_t* p_codec_info) {
++  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3;
++}
++
++const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void) { return "LHDC V3 SINK"; }
++
++bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg) {
++  LOG_DEBUG("%s: enter", __func__);
++  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_caps,
++                        p_cfg->codec_info) != A2DP_SUCCESS) {
++    return false;
++  }
++
++  return true;
++}
++
++UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV3_SINK_CIE& config_cie,
++                                           btav_a2dp_codec_config_t* result) {
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
++  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++
++  result->bits_per_sample = config_cie.bits_per_sample;
++
++  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++}
++
++
++
++
++
++A2dpCodecConfigLhdcV3Sink::A2dpCodecConfigLhdcV3Sink(
++    btav_a2dp_codec_priority_t codec_priority)
++    : A2dpCodecConfigLhdcV3Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
++                             A2DP_VendorCodecIndexStrLhdcV3Sink(), codec_priority,
++                             false) {}
++
++A2dpCodecConfigLhdcV3Sink::~A2dpCodecConfigLhdcV3Sink() {}
++
++bool A2dpCodecConfigLhdcV3Sink::init() {
++  if (!isValid()) return false;
++
++  // Load the decoder
++  if (!A2DP_VendorLoadDecoderLhdcV3()) {
++    LOG_ERROR("%s: cannot load the decoder", __func__);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2dpCodecConfigLhdcV3Sink::useRtpHeaderMarkerBit() const {
++  // TODO: This method applies only to Source codecs
++  return false;
++}
++
++bool A2dpCodecConfigLhdcV3Sink::updateEncoderUserConfig(
++    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
++    UNUSED_ATTR bool* p_config_updated) {
++  // TODO: This method applies only to Source codecs
++  return false;
++}
++
++uint64_t A2dpCodecConfigLhdcV3Sink::encoderIntervalMs() const {
++  // TODO: This method applies only to Source codecs
++  return 0;
++}
++
++int A2dpCodecConfigLhdcV3Sink::getEffectiveMtu() const {
++  // TODO: This method applies only to Source codecs
++  return 0;
++}
++
++
++bool A2dpCodecConfigLhdcV3Base::setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
++                      uint8_t* p_result_codec_config) {
++  is_source_ = false;
++  return true;
++}
++
++bool A2dpCodecConfigLhdcV3Base::setPeerCodecCapabilities(
++      const uint8_t* p_peer_codec_capabilities) {
++  is_source_ = false;
++  return true;
++}
++
++
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
+new file mode 100644
+index 000000000..4124345eb
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
+@@ -0,0 +1,550 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#define LOG_TAG "a2dp_vendor_lhdcv3_decoder"
++
++#include "a2dp_vendor_lhdcv3_decoder.h"
++
++#include <dlfcn.h>
++#include <inttypes.h>
++#include <stdio.h>
++#include <string.h>
++
++#include <lhdcBT_dec.h>
++
++#include "bt_common.h"
++#include "common/time_util.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++
++
++#define A2DP_LHDC_FUNC_DISABLE		0
++#define A2DP_LHDC_FUNC_ENABLE		1
++
++#define LHDCV3_DEC_MAX_SAMPLES_PER_FRAME  256
++#define LHDCV3_DEC_MAX_CHANNELS           2
++#define LHDCV3_DEC_MAX_BIT_DEPTH          32
++#define LHDCV3_DEC_FRAME_NUM              16
++#define LHDCV3_DEC_BUF_BYTES              (LHDCV3_DEC_FRAME_NUM * LHDCV3_DEC_MAX_SAMPLES_PER_FRAME * LHDCV3_DEC_MAX_CHANNELS * (LHDCV3_DEC_MAX_BIT_DEPTH >> 3))
++#define LHDCV3_DEC_PACKET_NUM             8
++
++#define LHDCV3_DEC_INPUT_BUF_BYTES        1024
++
++#define LHDCV3_DEC_PKT_HDR_BYTES          2
++
++typedef struct {
++  lhdc_ver_t  version;
++  uint32_t    sample_rate;
++  uint8_t     bits_per_sample;
++  uint8_t     func_ch_split;
++  uint8_t     func_ar;
++  uint8_t     func_jas;
++  uint8_t     func_meta;
++
++  uint32_t    timestamp;        // Timestamp for the A2DP frames
++  uint8_t     decode_buf[LHDCV3_DEC_PACKET_NUM][LHDCV3_DEC_BUF_BYTES];
++  uint32_t    dec_buf_idx;
++
++  uint8_t     dec_input_buf[LHDCV3_DEC_INPUT_BUF_BYTES];
++  uint32_t    dec_input_buf_bytes;
++
++  decoded_data_callback_t decode_callback;
++} tA2DP_LHDCV3_DECODER_CB;
++
++static tA2DP_LHDCV3_DECODER_CB a2dp_lhdcv3_decoder_cb;
++
++
++#define _DEC_REC_FILE_
++#if defined(_DEC_REC_FILE_)
++#define RAW_FILE_NAME "/sdcard/Download/lhdcdec.raw"
++#define PCM_FILE_NAME "/sdcard/Download/decoded.pcm"
++static FILE *rawFile = NULL;
++static FILE *pcmFile = NULL;
++#endif
++
++//
++// Decoder for LHDC Sink Codec
++//
++
++//
++// The LHDC decoder shared library, and the functions to use
++//
++static const char* LHDC_DECODER_LIB_NAME = "liblhdcBT_dec.so";
++static void* lhdc_decoder_lib_handle = NULL;
++
++
++static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcBT_dec_init_decoder";
++typedef int (*tLHDCDEC_INIT_DECODER)(tLHDCV3_DEC_CONFIG *config);
++
++static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME = "lhdcBT_dec_check_frame_data_enough";
++typedef int (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
++
++static const char* LHDCDEC_DECODE_NAME = "lhdcBT_dec_decode";
++typedef int (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
++
++static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcBT_dec_deinit_decoder";
++typedef int (*tLHDCDEC_DEINIT_DECODER)(void);
++
++
++static tLHDCDEC_INIT_DECODER lhdcdec_init_decoder;
++static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcdec_check_frame_data_enough;
++static tLHDCDEC_DECODE lhdcdec_decode;
++static tLHDCDEC_DEINIT_DECODER lhdcdec_deinit_decoder;
++
++
++
++
++// LHDC v4 Extend flags
++#define A2DP_LHDC_FLAG_JAS            0x40
++#define A2DP_LHDC_FLAG_AR             0x80
++
++#define A2DP_LHDC_FLAG_LLAC           0x80
++
++#define A2DP_LHDC_FLAG_META           0x10
++#define A2DP_LHDC_FLAG_MBR            0x20
++#define A2DP_LHDC_FLAG_LARC           0x40
++#define A2DP_LHDC_FLAG_V4             0x80
++
++
++
++// offset  0		1B	codec capability length (11 Bytes)
++// offset  1		1B	[7:4] media type
++// offset  2		1B  codec type
++// offset  3		4B	Vendor ID
++// offset  7		2B	Codec ID
++// offset  9		3B 	LHDC specific capability
++#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1	9
++#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2	10
++#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3	11
++
++
++bool save_codec_info (const uint8_t* p_codec_info)
++{
++  if (p_codec_info == NULL)
++  {
++    return false;
++  }
++
++
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
++      A2DP_LHDC_SAMPLING_FREQ_44100)
++  {
++    a2dp_lhdcv3_decoder_cb.sample_rate = 44100;
++  }
++  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
++           A2DP_LHDC_SAMPLING_FREQ_48000)
++  {
++	a2dp_lhdcv3_decoder_cb.sample_rate = 48000;
++  }
++  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
++           A2DP_LHDC_SAMPLING_FREQ_96000)
++  {
++	a2dp_lhdcv3_decoder_cb.sample_rate = 96000;
++  }
++  else
++  {
++    return false;
++  }
++
++
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
++      A2DP_LHDC_BIT_FMT_16)
++  {
++    a2dp_lhdcv3_decoder_cb.bits_per_sample = 16;
++  }
++  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
++           A2DP_LHDC_BIT_FMT_24)
++  {
++	a2dp_lhdcv3_decoder_cb.bits_per_sample = 24;
++  }
++  else
++  {
++    return false;
++  }
++
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2] & A2DP_LHDC_FLAG_LLAC)
++  {
++    //LLAC only 
++    a2dp_lhdcv3_decoder_cb.version = VERSION_LLAC;
++    LOG_DEBUG("%s: LLAC only", __func__);
++  }
++  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_V4) 
++  {
++    //LHDCV4 only 
++    a2dp_lhdcv3_decoder_cb.version = VERSION_4;
++    LOG_DEBUG("%s: LHDC V4 only", __func__);
++  }
++  else
++  {
++    //LHDCV3 only 
++	a2dp_lhdcv3_decoder_cb.version = VERSION_3;
++    LOG_DEBUG("%s: LHDC V3 only", __func__);
++  }
++
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_NONE)
++  {
++    a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_DISABLE;
++  }
++  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_TWS)
++  {
++	a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_ENABLE;
++  }
++  else
++  {
++    return false;
++  }
++
++  // AR
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_AR)
++  {
++	a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
++  }
++  else
++  {
++    a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
++  }
++
++  // JAS
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_JAS)
++  {
++	a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
++  }
++  else
++  {
++    a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
++  }
++
++  // META
++  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_META)
++  {
++	a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
++  }
++  else
++  {
++    a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
++  }
++
++  return true;
++
++}
++
++
++static void* load_func(const char* func_name) {
++
++  void* func_ptr = NULL;
++
++  if ((func_name == NULL) ||
++      (lhdc_decoder_lib_handle == NULL))  {
++
++    return NULL;
++  }
++
++  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
++
++  if (func_ptr == NULL) {
++    LOG_ERROR(
++              "%s: cannot find function '%s' in the encoder library: %s",
++              __func__, func_name, dlerror());
++    A2DP_VendorUnloadDecoderLhdcV3();
++    return NULL;
++  }
++
++  return func_ptr;
++}
++
++
++bool A2DP_VendorLoadDecoderLhdcV3(void) {
++
++  if (lhdc_decoder_lib_handle != NULL) return true;  // Already loaded
++
++  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
++
++  // Open the encoder library
++  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
++  if (lhdc_decoder_lib_handle == NULL) {
++    LOG_ERROR("%s: cannot open LHDC decoder library %s: %s", __func__,
++              LHDC_DECODER_LIB_NAME, dlerror());
++    return false;
++  }
++
++
++  // Load all functions
++  lhdcdec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
++  if (lhdcdec_init_decoder == NULL) return false;
++
++  lhdcdec_check_frame_data_enough = (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
++  if (lhdcdec_check_frame_data_enough == NULL) return false;
++
++  lhdcdec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
++  if (lhdcdec_decode == NULL) return false;
++
++  lhdcdec_deinit_decoder = (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
++  if (lhdcdec_deinit_decoder == NULL) return false;
++
++  return true;
++}
++
++
++void A2DP_VendorUnloadDecoderLhdcV3(void) {
++  a2dp_vendor_lhdcv3_decoder_cleanup();
++}
++
++
++bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback) {
++  LOG_ERROR("%s: A2DP Sink", __func__);
++
++  tLHDCV3_DEC_CONFIG  lhdcdec_config;
++  int  fn_ret;
++
++
++  if ((lhdc_decoder_lib_handle == NULL) ||
++      (lhdcdec_init_decoder == NULL) ||
++	  (lhdcdec_deinit_decoder == NULL)) {
++
++	return false;
++  }
++
++  lhdcdec_deinit_decoder ();
++
++  lhdcdec_config.version = a2dp_lhdcv3_decoder_cb.version;
++  lhdcdec_config.sample_rate = a2dp_lhdcv3_decoder_cb.sample_rate;
++  lhdcdec_config.bits_depth = a2dp_lhdcv3_decoder_cb.bits_per_sample;
++
++  fn_ret = lhdcdec_init_decoder (&lhdcdec_config);
++
++  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
++
++    return false;
++  }
++
++  a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
++  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
++  a2dp_lhdcv3_decoder_cb.decode_callback = decode_callback;
++
++#if defined(_DEC_REC_FILE_)
++  if (rawFile == NULL) {
++    rawFile = fopen(RAW_FILE_NAME,"wb");
++    LOG_DEBUG("%s: Create recode file = %p", __func__, rawFile);
++  }
++  if (pcmFile == NULL) {
++    pcmFile = fopen(PCM_FILE_NAME,"wb");
++    LOG_DEBUG("%s: Create recode file = %p", __func__, pcmFile);
++  }
++#endif
++  return true;
++}
++
++
++void a2dp_vendor_lhdcv3_decoder_cleanup(void) {
++  // Cleanup any LHDC-related state
++
++  LOG_DEBUG("%s: lhdc_decoder_lib_handle = %p", __func__, lhdc_decoder_lib_handle);
++
++  if (lhdc_decoder_lib_handle == NULL) {
++
++	return;
++  }
++
++  if (lhdcdec_deinit_decoder != NULL) {
++
++    lhdcdec_deinit_decoder ();
++  }
++
++  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
++
++  dlclose(lhdc_decoder_lib_handle);
++  lhdc_decoder_lib_handle = NULL;
++
++#if defined(_DEC_REC_FILE_)
++  if (rawFile != NULL) {
++    fclose(rawFile);
++    rawFile = NULL;
++    remove(RAW_FILE_NAME);
++  }
++  if (pcmFile != NULL) {
++    fclose(pcmFile);
++    pcmFile = NULL;
++    remove(PCM_FILE_NAME);
++  }
++#endif
++}
++
++bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf) {
++  uint8_t* data;
++  size_t data_size;
++  uint32_t out_used = 0;
++  int fn_ret;
++  uint32_t dec_buf_idx;
++  uint8_t *ptr_src;
++  uint8_t *ptr_dst;
++  uint32_t packet_bytes;
++  uint32_t i;
++
++
++  if (p_buf == NULL) {
++
++	return false;
++  }
++
++  data = p_buf->data + p_buf->offset;
++  data_size = p_buf->len;
++
++  dec_buf_idx = a2dp_lhdcv3_decoder_cb.dec_buf_idx++;
++  if (a2dp_lhdcv3_decoder_cb.dec_buf_idx >= LHDCV3_DEC_PACKET_NUM)
++  {
++	a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
++  }
++
++
++  if (data_size == 0) {
++    LOG_ERROR("%s: Empty packet", __func__);
++    return false;
++  }
++
++  if ((lhdc_decoder_lib_handle == NULL) ||
++      (lhdcdec_decode == NULL)) {
++
++    LOG_ERROR("%s: Invalid handle!", __func__);
++    return false;
++  }
++
++#if defined(_DEC_REC_FILE_)
++  if (rawFile != NULL && data_size > 0) {
++    fwrite(data + LHDCV3_DEC_PKT_HDR_BYTES, sizeof(uint8_t), data_size - LHDCV3_DEC_PKT_HDR_BYTES, rawFile);
++  }
++#endif
++
++  if ((a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV3_DEC_INPUT_BUF_BYTES)
++  {
++	// the data queued is useless
++	// discard them
++    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
++
++	if (data_size > LHDCV3_DEC_INPUT_BUF_BYTES)
++	{
++	  // input data is too big (more than buffer size)!!
++	  // just ingore it, and do nothing
++	  return true;
++	}
++  }
++
++  memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
++          data, 
++          data_size);
++  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
++
++  packet_bytes = 0;
++  fn_ret = lhdcdec_check_frame_data_enough (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
++                                            a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes,
++											&packet_bytes);
++
++  if (fn_ret == LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH) {
++    LOG_ERROR("%s: Input buffer is NOT enough!, but return true", __func__);
++    return true;
++  }
++  else if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
++
++    LOG_ERROR("%s: fail to check frame data!", __func__);
++
++    // clear the data in the input buffer
++    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
++    return false;
++  }
++
++  if (packet_bytes != (a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes - LHDCV3_DEC_PKT_HDR_BYTES))
++  {
++	// strange!
++	// queued data is NOT exactly equal to one packet!
++	// maybe wrong data in buffer
++	// discard data queued previously, and save input data
++	LOG_ERROR("%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)", __func__, packet_bytes, a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes);
++
++	a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
++	memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
++            data, 
++            data_size);
++    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
++	return true;
++  }
++
++  out_used = sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]);
++  fn_ret = lhdcdec_decode (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
++                           a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes, 
++                           a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx],
++						   &out_used,
++						   a2dp_lhdcv3_decoder_cb.bits_per_sample);
++
++  // finish decoding
++  // clear the data in the input buffer
++  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
++
++  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
++
++    LOG_ERROR("%s: fail to decode lhdc stream!", __func__);
++    return false;
++  }
++
++  if (a2dp_lhdcv3_decoder_cb.bits_per_sample == 24) {
++    ptr_src = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
++	ptr_dst = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
++
++    for (i = 0; i < (out_used >> 2) ; i++) {
++	  *ptr_dst++ = *ptr_src++;
++	  *ptr_dst++ = *ptr_src++;
++	  *ptr_dst++ = *ptr_src++;
++	  ptr_src++;
++    }
++	
++	out_used = (out_used >> 2) * 3;
++  }
++
++#if defined(_DEC_REC_FILE_)
++  if (pcmFile != NULL && out_used > 0 && out_used <= sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx])) {
++    int write_bytes;
++
++    write_bytes = fwrite(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx], sizeof(uint8_t), out_used, pcmFile);
++  }
++#endif
++
++  a2dp_lhdcv3_decoder_cb.decode_callback(
++      reinterpret_cast<uint8_t*>(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]), out_used);
++
++  return true;
++}
++
++void a2dp_vendor_lhdcv3_decoder_start(void) {
++  LOG_INFO("%s", __func__);
++  // do nothing
++}
++
++void a2dp_vendor_lhdcv3_decoder_suspend(void) {
++  LOG_INFO("%s", __func__);
++  // do nothing
++}
++
++void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info) {
++  //int32_t sample_rate;
++  //int32_t bits_per_sample;
++  //int32_t channel_mode;
++
++  if (p_codec_info == NULL) {
++    LOG_ERROR("%s: p_codec_info is NULL", __func__);
++    return;
++  }
++
++  LOG_ERROR("%s", __func__);
++}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
+new file mode 100644
+index 000000000..47877a676
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
+@@ -0,0 +1,1034 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#define LOG_TAG "a2dp_vendor_lhdcv3_encoder"
++#define ATRACE_TAG ATRACE_TAG_AUDIO
++
++#include "a2dp_vendor_lhdcv3_encoder.h"
++
++#ifndef OS_GENERIC
++#include <cutils/trace.h>
++#endif
++#include <dlfcn.h>
++#include <inttypes.h>
++#include <stdio.h>
++#include <string.h>
++
++#include <lhdcBT.h>
++
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv3.h"
++#include "bt_common.h"
++#include "common/time_util.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++//
++// Encoder for LHDC Source Codec
++//
++
++//
++// The LHDC encoder shared library, and the functions to use
++//
++static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
++static void* lhdc_encoder_lib_handle = NULL;
++
++static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
++typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
++
++static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
++typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
++
++static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
++typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
++static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
++typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
++
++static const char* LHDC_INIT_ENCODER_NAME = "lhdcBT_init_encoder";
++typedef int (*tLHDC_INIT_ENCODER)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
++
++static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
++typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
++
++
++static const char* LHDC_ENCODE_NAME = "lhdcBT_encodeV3";
++typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
++
++static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
++typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
++
++static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
++typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
++
++
++static const char* LHDC_SET_EXT_FUNC = "lhdcBT_set_ext_func_state";
++typedef int (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
++
++
++static const char* LHDC_SET_MBR_FUNC = "lhdcBT_set_hasMinBitrateLimit";
++typedef int (*tLHDC_SET_MBR_FUNC)(HANDLE_LHDC_BT handle, bool enabled);
++//int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled )
++//int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len)
++/*leo set_gyro_pos */
++//static const char* LHDC_SET_GYRO_POS_NAME = "lhdcBT_set_gyro_pos";
++//typedef int (*tLHDC_SET_GYRO_POS)(HANDLE_LHDC_BT hLhdcParam, uint32_t world_coordinate_x, uint32_t world_coordinate_y, uint32_t world_coordinate_z);
++
++/**************************************/
++/*   LHDC extend function API Lib     */
++/**************************************/
++static const char* LHDC_GET_USER_EXAPIVER_NAME = "lhdcBT_get_user_exApiver";
++typedef int (*tLHDC_GET_USER_EXAPIVER)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
++
++static const char* LHDC_GET_USER_EXCONFIG_NAME = "lhdcBT_get_user_exconfig";
++typedef int (*tLHDC_GET_USER_EXCONFIG)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
++
++static const char* LHDC_SET_USER_EXCONFIG_NAME = "lhdcBT_set_user_exconfig";
++typedef int (*tLHDC_SET_USER_EXCONFIG)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
++
++static const char* LHDC_SET_USER_EXDATA_NAME = "lhdcBT_set_user_exdata";
++typedef void (*tLHDC_SET_USER_EXDATA)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
++
++static tLHDC_GET_HANDLE lhdc_get_handle;
++static tLHDC_FREE_HANDLE lhdc_free_handle;
++static tLHDC_GET_BITRATE lhdc_get_bitrate;
++static tLHDC_SET_BITRATE lhdc_set_bitrate;
++static tLHDC_INIT_ENCODER lhdc_init_encoder;
++static tLHDC_ENCODE lhdc_encode_func;
++static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
++static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
++static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
++static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
++static tLHDC_SET_MBR_FUNC lhdc_set_mbr_func;
++
++//static tLHDC_SET_GYRO_POS lhdc_set_gyro_pos_func;   /*leo set_gyro_pos */
++
++static tLHDC_GET_USER_EXAPIVER lhdcBT_get_user_exApiVer_func;
++static tLHDC_GET_USER_EXCONFIG lhdcBT_get_user_exconfig_func;
++static tLHDC_SET_USER_EXCONFIG lhdcBT_set_user_exconfig_func;
++static tLHDC_SET_USER_EXDATA lhdcBT_set_user_exdata_func;
++
++// A2DP LHDC encoder interval in milliseconds
++#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
++#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
++
++// offset
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
++#else
++#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
++#endif
++
++//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
++
++typedef struct {
++  uint32_t sample_rate;
++  uint8_t channel_mode;
++  uint8_t bits_per_sample;
++  int quality_mode_index;
++  //int latency_mode_index;
++  int pcm_wlength;
++  LHDCBT_SMPL_FMT_T pcm_fmt;
++  int8_t channelSplitMode;
++  int8_t maxTargetBitrate;
++  bool isLLEnabled;
++} tA2DP_LHDC_ENCODER_PARAMS;
++
++typedef struct {
++  uint32_t counter;
++  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
++  uint64_t last_frame_us;
++} tA2DP_LHDC_FEEDING_STATE;
++
++typedef struct {
++  uint64_t session_start_us;
++
++  size_t media_read_total_expected_packets;
++  size_t media_read_total_expected_reads_count;
++  size_t media_read_total_expected_read_bytes;
++
++  size_t media_read_total_dropped_packets;
++  size_t media_read_total_actual_reads_count;
++  size_t media_read_total_actual_read_bytes;
++} a2dp_lhdc_encoder_stats_t;
++
++typedef struct {
++  a2dp_source_read_callback_t read_callback;
++  a2dp_source_enqueue_callback_t enqueue_callback;
++  uint16_t TxAaMtuSize;
++  size_t TxQueueLength;
++
++  bool use_SCMS_T;
++  bool is_peer_edr;          // True if the peer device supports EDR
++  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
++  uint16_t peer_mtu;         // MTU of the A2DP peer
++  uint32_t timestamp;        // Timestamp for the A2DP frames
++
++  HANDLE_LHDC_BT lhdc_handle;
++  bool has_lhdc_handle;  // True if lhdc_handle is valid
++  uint8_t version;
++
++  tA2DP_FEEDING_PARAMS feeding_params;
++  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
++  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
++
++  a2dp_lhdc_encoder_stats_t stats;
++  uint32_t buf_seq;
++  uint32_t bytes_read;
++} tA2DP_LHDC_ENCODER_CB;
++
++//static bool lhdc_abr_loaded = false;
++
++
++
++typedef struct _lhdc_frame_Info {
++    uint32_t frame_len;
++    uint32_t isSplit;
++    uint32_t isLeft;
++
++} lhdc_frame_Info_t;
++
++
++#define _RECODER_FILE_
++#if defined(_RECODER_FILE_)
++#define ENCODED_FILE_NAME "/sdcard/Download/lhdc.raw"
++#define PCM_FILE_NAME     "/sdcard/Download/source.pcm"
++static FILE  *RecFile = NULL;
++static FILE *pcmFile = NULL;
++#endif
++
++static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
++
++static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
++                                            A2dpCodecConfig* a2dp_codec_config,
++                                            bool* p_restart_input,
++                                            bool* p_restart_output,
++                                            bool* p_config_updated);
++static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
++                                              uint8_t* num_of_frames,
++                                              uint64_t timestamp_us);
++
++static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame);
++static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
++static std::string quality_mode_index_to_name(int quality_mode_index);
++//static std::string latency_mode_index_to_name(int latency_mode_index);
++
++static void* load_func(const char* func_name) {
++  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
++  if (func_ptr == NULL) {
++    LOG_ERROR(
++              "%s: cannot find function '%s' in the encoder library: %s",
++              __func__, func_name, dlerror());
++    A2DP_VendorUnloadEncoderLhdcV3();
++    return NULL;
++  }
++  return func_ptr;
++}
++
++bool A2DP_VendorLoadEncoderLhdcV3(void) {
++  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
++
++  // Initialize the control block
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  // Open the encoder library
++  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
++  if (lhdc_encoder_lib_handle == NULL) {
++    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
++              LHDC_ENCODER_LIB_NAME, dlerror());
++    return false;
++  }
++
++
++  // Load all functions
++  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
++  if (lhdc_get_handle == NULL) return false;
++  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
++  if (lhdc_free_handle == NULL) return false;
++  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
++  if (lhdc_get_bitrate == NULL) return false;
++  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
++  if (lhdc_set_bitrate == NULL) return false;
++  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
++  if (lhdc_init_encoder == NULL) return false;
++  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
++  if (lhdc_encode_func == NULL) return false;
++  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
++  if (lhdc_auto_adjust_bitrate == NULL) return false;
++
++
++  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
++  if (lhdc_set_limit_bitrate == NULL) return false;
++  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
++  if (lhdc_get_block_size == NULL) return false;
++  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
++  if (lhdc_set_ext_func == NULL) return false;
++  lhdc_set_mbr_func = (tLHDC_SET_MBR_FUNC)load_func(LHDC_SET_MBR_FUNC);
++  if (lhdc_set_mbr_func == NULL) return false;
++
++  /*leo set_gyro_pos */
++//  lhdc_set_gyro_pos_func = (tLHDC_SET_GYRO_POS)load_func(LHDC_SET_GYRO_POS_NAME);
++//  if (lhdc_set_gyro_pos_func == NULL) return false;
++
++  lhdcBT_get_user_exApiVer_func = (tLHDC_GET_USER_EXAPIVER)load_func(LHDC_GET_USER_EXAPIVER_NAME);
++  if (lhdcBT_get_user_exApiVer_func == NULL) {
++      LOG_ERROR( "%s:cannot load %s", __func__, LHDC_GET_USER_EXAPIVER_NAME);
++      return false;
++  }
++
++  lhdcBT_get_user_exconfig_func = (tLHDC_GET_USER_EXCONFIG)load_func(LHDC_GET_USER_EXCONFIG_NAME);
++  if (lhdcBT_get_user_exconfig_func == NULL) {
++    LOG_ERROR( "%s:cannot load %s", __func__, LHDC_GET_USER_EXCONFIG_NAME);
++    return false;
++  }
++
++  lhdcBT_set_user_exconfig_func = (tLHDC_SET_USER_EXCONFIG)load_func(LHDC_SET_USER_EXCONFIG_NAME);
++  if (lhdcBT_set_user_exconfig_func == NULL)  {
++    LOG_ERROR( "%s:cannot load %s", __func__, LHDC_SET_USER_EXCONFIG_NAME);
++    return false;
++  }
++
++  lhdcBT_set_user_exdata_func = (tLHDC_SET_USER_EXDATA)load_func(LHDC_SET_USER_EXDATA_NAME);
++  if (lhdcBT_set_user_exdata_func == NULL)  {
++    LOG_ERROR( "%s:cannot load %s", __func__, LHDC_SET_USER_EXDATA_NAME);
++    return false;
++  }
++
++  return true;
++}
++
++void A2DP_VendorUnloadEncoderLhdcV3(void) {
++  // Cleanup any LHDC-related state
++
++    LOG_DEBUG( "%s: a2dp_lhdc_encoder_cb.has_lhdc_handle = %d, lhdc_free_handle = %p",
++              __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle);
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != NULL)
++    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  lhdc_get_handle = NULL;
++  lhdc_free_handle = NULL;
++  lhdc_get_bitrate = NULL;
++  lhdc_set_bitrate = NULL;
++  lhdc_init_encoder = NULL;
++  lhdc_encode_func = NULL;
++  lhdc_auto_adjust_bitrate = NULL;
++  lhdc_set_limit_bitrate = NULL;
++  lhdc_get_block_size = NULL;
++  lhdc_set_ext_func = NULL;
++  lhdc_set_mbr_func = NULL;
++//  lhdc_set_gyro_pos_func = NULL;    /*leo set_gyro_pos */
++
++  lhdcBT_get_user_exApiVer_func = NULL;
++  lhdcBT_get_user_exconfig_func = NULL;
++  lhdcBT_set_user_exconfig_func = NULL;
++  lhdcBT_set_user_exdata_func = NULL;
++
++
++  if (lhdc_encoder_lib_handle != NULL) {
++    dlclose(lhdc_encoder_lib_handle);
++    lhdc_encoder_lib_handle = NULL;
++  }
++}
++
++void a2dp_vendor_lhdcv3_encoder_init(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    A2dpCodecConfig* a2dp_codec_config,
++    a2dp_source_read_callback_t read_callback,
++    a2dp_source_enqueue_callback_t enqueue_callback) {
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
++    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
++
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
++
++  a2dp_lhdc_encoder_cb.read_callback = read_callback;
++  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
++  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
++  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
++  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
++  a2dp_lhdc_encoder_cb.timestamp = 0;
++
++
++  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
++#endif
++
++  // NOTE: Ignore the restart_input / restart_output flags - this initization
++  // happens when the connection is (re)started.
++  bool restart_input = false;
++  bool restart_output = false;
++  bool config_updated = false;
++  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
++                                  a2dp_codec_config, &restart_input,
++                                  &restart_output, &config_updated);
++}
++
++
++int A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(const char* version, const int clen)
++{
++  if(lhdcBT_get_user_exApiVer_func)
++  {
++    //LOG_DEBUG( "%s: get API VERSION, clen:%d", __func__, clen);
++    return lhdcBT_get_user_exApiVer_func(a2dp_lhdc_encoder_cb.lhdc_handle, version, clen);
++  }
++  else
++  {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return BT_STATUS_FAIL;
++  }
++}
++
++int A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
++{
++  if(lhdcBT_get_user_exconfig_func)
++  {
++    //LOG_DEBUG( "%s: get API CONFIG, clen:%d", __func__, clen);
++    return lhdcBT_get_user_exconfig_func(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
++  }
++  else
++  {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return BT_STATUS_FAIL;
++  }
++}
++
++int A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
++{
++  if(lhdcBT_set_user_exconfig_func)
++  {
++    //LOG_DEBUG( "%s: set API CONFIG, clen:%d", __func__, clen);
++    return lhdcBT_set_user_exconfig_func(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
++  }
++  else
++  {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return BT_STATUS_FAIL;
++  }
++}
++
++bool A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(const char* codecData, const int clen)
++{
++  if(lhdcBT_set_user_exdata_func)
++  {
++    //LOG_DEBUG( "%s: set API DATA, clen:%d", __func__, clen);
++    lhdcBT_set_user_exdata_func(a2dp_lhdc_encoder_cb.lhdc_handle, codecData, clen);
++    return true;
++  }
++  else
++  {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return false;
++  }
++}
++
++
++bool A2dpCodecConfigLhdcV3::updateEncoderUserConfig(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
++    bool* p_restart_output, bool* p_config_updated) {
++  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
++  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
++  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
++  a2dp_lhdc_encoder_cb.timestamp = 0;
++
++  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
++    LOG_ERROR(
++              "%s: Cannot update the codec encoder for %s: "
++              "invalid peer MTU",
++              __func__, name().c_str());
++    return false;
++  }
++
++  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
++                                  p_restart_input, p_restart_output,
++                                  p_config_updated);
++  return true;
++}
++
++// Update the A2DP LHDC encoder.
++// |peer_mtu| is the peer MTU.
++// |a2dp_codec_config| is the A2DP codec to use for the update.
++static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
++                                            A2dpCodecConfig* a2dp_codec_config,
++                                            bool* p_restart_input,
++                                            bool* p_restart_output,
++                                            bool* p_config_updated) {
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
++      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  uint8_t codec_info[AVDT_CODEC_SIZE];
++
++  *p_restart_input = false;
++  *p_restart_output = false;
++  *p_config_updated = false;
++
++  //Example for limit bit rate
++  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
++
++
++  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
++    LOG_ERROR(
++              "%s: Cannot update the codec encoder for %s: "
++              "invalid codec config",
++              __func__, a2dp_codec_config->name().c_str());
++    return;
++  }
++  const uint8_t* p_codec_info = codec_info;
++  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
++
++  uint32_t verCode = A2DP_VendorGetVersionLhdcV3(p_codec_info);  //LHDC V3 should 1!
++
++  bool isLLAC = A2DP_VendorHasLLACFlagLhdcV3(p_codec_info);
++
++  bool isLHDCV4 = A2DP_VendorHasV4FlagLhdcV3(p_codec_info);
++
++
++  LOG_DEBUG( "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
++  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
++      int newValue = codec_config.codec_specific_1 & 0xff;
++
++      // adjust non-supported quality modes and wrap to internal library used index
++      if (newValue == A2DP_LHDC_QUALITY_ABR) {
++        newValue = LHDCBT_QUALITY_AUTO; //9->8
++      }
++
++      if (newValue != p_encoder_params->quality_mode_index) {
++        p_encoder_params->quality_mode_index = newValue;
++        LOG_DEBUG( "%s: setting internal quality mode index: %s(%d)", __func__,
++                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
++                      .c_str(), p_encoder_params->quality_mode_index);
++      }
++  }else {
++      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
++      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
++  }
++
++  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++      uint32_t versionSetup = 2;
++      if(isLLAC && !isLHDCV4 && verCode == 1){
++        //LLAC Only
++        versionSetup = 4;
++        LOG_DEBUG( "%s: init to LLAC : %d",__func__, versionSetup);
++      }else if(!isLLAC && isLHDCV4 && verCode == 1) {
++        //LHDCV4 Only
++        versionSetup = 3;
++        LOG_DEBUG( "%s: init to LHDC V4 : %d",__func__, versionSetup);
++      }else if(!isLLAC && !isLHDCV4 && verCode == 1) {
++        //LHDCV3 Only
++        versionSetup = 2;
++        LOG_DEBUG( "%s: init to LHDC V3 : %d",__func__, versionSetup);
++      }else {
++        LOG_DEBUG( "%s: Flags check incorrect. So init to LHDCV3 only : %d",__func__, versionSetup);
++      }
++
++
++      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle(versionSetup);
++      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
++        LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
++        return;  // TODO: Return an error?
++      }
++      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
++  }
++  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV3(p_codec_info);
++
++
++  // The feeding parameters
++  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
++  p_feeding_params->sample_rate =
++      A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
++  p_feeding_params->bits_per_sample =
++      a2dp_codec_config->getAudioBitsPerSample();
++  p_feeding_params->channel_count =
++      A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
++  LOG_DEBUG( "%s:(feeding) sample_rate=%u bits_per_sample=%u channel_count=%u",
++            __func__, p_feeding_params->sample_rate,
++            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
++
++  // The codec parameters
++  p_encoder_params->sample_rate =
++      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
++
++  uint16_t mtu_size =
++      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
++
++  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
++
++  //get separation feature.
++  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV3(p_codec_info);
++  // Set the quality mode index
++  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
++
++  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV3(p_codec_info);
++
++
++  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1ULL) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
++
++
++  p_encoder_params->pcm_wlength =
++      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
++  // Set the Audio format from pcm_wlength
++  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
++  if (p_encoder_params->pcm_wlength == 2)
++    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
++  else if (p_encoder_params->pcm_wlength == 3)
++    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
++ // else if (p_encoder_params->pcm_wlength == 4)
++//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
++
++  LOG_DEBUG( "%s: MTU=%d, peer_mtu=%d", __func__,
++            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
++  LOG_DEBUG(
++            "%s: sample_rate: %d "
++            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
++            __func__, p_encoder_params->sample_rate,
++            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
++            p_encoder_params->pcm_fmt);
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
++#else
++    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
++#endif
++  
++  LOG_DEBUG( "%s:AR Flag = %d", __func__, A2DP_VendorHasARFlagLhdcV3(p_codec_info));
++  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_AR, A2DP_VendorHasARFlagLhdcV3(p_codec_info), NULL, 0);
++  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_JAS, A2DP_VendorHasJASFlagLhdcV3(p_codec_info), NULL, 0);
++  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_LARC, A2DP_VendorHasLARCFlagLhdcV3(p_codec_info), NULL, 0);
++  lhdc_set_mbr_func(a2dp_lhdc_encoder_cb.lhdc_handle, A2DP_VendorHasMinBRFlagLhdcV3(p_codec_info));
++  // Initialize the encoder.
++  // NOTE: MTU in the initialization must include the AVDT media header size.
++  int result = lhdc_init_encoder(
++      a2dp_lhdc_encoder_cb.lhdc_handle,
++      p_encoder_params->sample_rate,
++      p_encoder_params->pcm_fmt,
++      p_encoder_params->quality_mode_index,
++      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
++      0 /* This parameter alaways is 0 in A2DP */ ,
++      max_mtu_len,
++      a2dp_vendor_lhdcv3_get_encoder_interval_ms()
++  );
++  lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
++
++  lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
++
++#if defined(_RECODER_FILE_)
++  if (RecFile == NULL) {
++    RecFile = fopen(ENCODED_FILE_NAME,"wb");
++    LOG_DEBUG( "%s: Create recode file = %p", __func__, RecFile);
++  }
++  if (pcmFile == NULL) {
++    pcmFile = fopen(PCM_FILE_NAME,"wb");
++    LOG_DEBUG( "%s: Create recode file = %p", __func__, pcmFile);
++  }
++#endif
++  if (result != 0) {
++    LOG_ERROR( "%s: error initializing the LHDC encoder: %d", __func__,
++              result);
++  }
++}
++
++void a2dp_vendor_lhdcv3_encoder_cleanup(void) {
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
++    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++#if defined(_RECODER_FILE_)
++  if (RecFile != NULL) {
++    fclose(RecFile);
++    RecFile = NULL;
++    remove(ENCODED_FILE_NAME);
++  }
++  if (pcmFile != NULL) {
++    fclose(pcmFile);
++    pcmFile = NULL;
++    remove(PCM_FILE_NAME);
++  }
++#endif
++}
++
++void a2dp_vendor_lhdcv3_feeding_reset(void) {
++  /* By default, just clear the entire state */
++  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
++         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
++
++  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
++      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
++       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
++       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++       encoder_interval) /
++      1000;
++  a2dp_lhdc_encoder_cb.buf_seq = 0;
++  a2dp_lhdc_encoder_cb.bytes_read = 0;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
++    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++      LOG_DEBUG("%s: reset ABR!", __func__);
++      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
++    }
++  }
++  LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
++            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
++}
++
++void a2dp_vendor_lhdcv3_feeding_flush(void) {
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
++  LOG_DEBUG( "%s", __func__);
++}
++
++uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void) {
++  LOG_DEBUG( "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",
++              __func__, a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
++  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
++      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
++  }else{
++      return A2DP_LHDC_ENCODER_INTERVAL_MS;
++  }
++}
++
++void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us) {
++  uint8_t nb_frame = 0;
++  uint8_t nb_iterations = 0;
++
++  a2dp_lhdcv3_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
++  LOG_DEBUG( "%s: Sending %d frames per iteration, %d iterations",
++              __func__, nb_frame, nb_iterations);
++
++  if (nb_frame == 0) return;
++
++  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
++    // Transcode frame and enqueue
++    a2dp_lhdcV3_encode_frames(nb_frame);
++  }
++}
++
++// Obtains the number of frames to send and number of iterations
++// to be used. |num_of_iterations| and |num_of_frames| parameters
++// are used as output param for returning the respective values.
++static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
++                                              uint8_t* num_of_frames,
++                                              uint64_t timestamp_us) {
++  uint32_t result = 0;
++  uint8_t nof = 0;
++  uint8_t noi = 1;
++
++  *num_of_iterations = 0;
++  *num_of_frames = 0;
++
++  int32_t pcm_bytes_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
++  if (pcm_bytes_per_frame <= 0) {
++    LOG_DEBUG( "%s: lhdc_get_block_size error!", __func__);
++    return;
++  }
++
++  pcm_bytes_per_frame = pcm_bytes_per_frame *
++  a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++  a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++  LOG_DEBUG( "%s: pcm_bytes_per_frame %u", __func__, pcm_bytes_per_frame);
++
++  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
++  uint32_t us_this_tick = encoder_interval * 1000;
++  uint64_t now_us = timestamp_us;
++  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
++    us_this_tick =
++        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
++
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
++      (encoder_interval * 1000);
++
++  result =
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
++      result * pcm_bytes_per_frame;
++  nof = result;
++
++  LOG_DEBUG( "%s: effective num of frames %u, iterations %u", __func__, nof, noi);
++
++  *num_of_frames = nof;
++  *num_of_iterations = noi;
++}
++
++static BT_HDR *bt_buf_new( void) {
++    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
++    if ( p_buf == NULL) {
++        // LeoKu(C): should not happen
++        LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
++        return  NULL;
++    }
++
++    p_buf->offset = A2DP_LHDC_OFFSET;
++    p_buf->len = 0;
++    p_buf->layer_specific = 0;
++    return  p_buf;
++}
++
++static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame){
++  //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
++  //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  int32_t samples_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
++  if (samples_per_frame <= 0) {
++    LOG_ERROR ("%s: lhdc_get_block_size error!", __func__);
++    return;
++  }
++
++  uint32_t pcm_bytes_per_frame = samples_per_frame *
++                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
++#else
++  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
++#endif
++
++  static float mtu_usage = 0;
++  static int mtu_usage_cnt = 0;
++  static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
++  static uint32_t allSendbytes = 0;
++  uint8_t read_buffer[samples_per_frame * 2 * 4];
++  uint8_t latency =0; // p_encoder_params->latency_mode_index;
++  int32_t out_frames = 0, remain_nb_frame = nb_frame;
++  int32_t written = 0;
++  uint32_t bytes_read = 0;
++  uint8_t* packet;
++  BT_HDR * p_buf = NULL;
++
++  while (nb_frame) {
++      if ((p_buf = bt_buf_new()) == NULL) {
++          LOG_ERROR ( "%s: ERROR", __func__);
++          return;
++      }
++    uint32_t written_frame = 0;
++    do {
++      uint32_t temp_bytes_read = 0;
++      if (a2dp_lhdcv3_read_feeding(read_buffer, &temp_bytes_read)) {
++        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
++        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
++
++        //int result =
++
++      #if defined(_RECODER_FILE_)
++        if (pcmFile != NULL) {
++          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
++        }
++      #endif
++        lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, packet, (uint32_t*)&written, (uint32_t*)&out_frames);
++
++        #if defined(_RECODER_FILE_)
++        if (RecFile != NULL && written > 0) {
++            fwrite(packet, sizeof(uint8_t), written, RecFile);
++        }
++        #endif
++
++        p_buf->len += written;
++        allSendbytes += written;
++        nb_frame--;
++        written_frame += out_frames;  // added a frame to the buffer
++        LOG_DEBUG ( "%s: nb_frame:%d, written:%d, out_frames:%d", __func__, nb_frame, written, out_frames);
++
++      }else{
++    	LOG_DEBUG ( "%s: underflow %d", __func__, nb_frame);
++        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
++                        nb_frame * samples_per_frame *
++                        a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++                        a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++
++        // no more pcm to read
++        nb_frame = 0;
++      }
++    } while ((written == 0) && nb_frame);
++
++    if (p_buf->len) {
++      /*
++       * Timestamp of the media packet header represent the TS of the
++       * first frame, i.e the timestamp before including this frame.
++       */
++      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
++      p_buf->layer_specific <<= 8;
++      p_buf->layer_specific |= ( latency | ( written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
++
++      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
++      LOG_DEBUG ( "%s: Timestamp (%d)", __func__, a2dp_lhdc_encoder_cb.timestamp);
++
++      a2dp_lhdc_encoder_cb.timestamp += ( written_frame * samples_per_frame);
++
++      uint8_t done_nb_frame = remain_nb_frame - nb_frame;
++      remain_nb_frame = nb_frame;
++      LOG_DEBUG( "%s: nb_frame:%d, remain_nb_frame:%d, done_nb_frame:%d", __func__, nb_frame, remain_nb_frame, done_nb_frame);
++
++      mtu_usage += ((float)p_buf->len) / max_mtu_len;
++      mtu_usage_cnt++;
++
++      LOG_DEBUG ( "%s: Read bytes(%d)", __func__, a2dp_lhdc_encoder_cb.bytes_read);
++      LOG_DEBUG ( "%s: Send Frame(%d), length(%d)", __func__, written_frame, p_buf->len);
++      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
++      a2dp_lhdc_encoder_cb.bytes_read = 0;
++
++      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
++        return;
++    } else {
++      // NOTE: Unlike the execution path for other codecs, it is normal for
++      // LHDC to NOT write encoded data to the last buffer if there wasn't
++      // enough data to write to. That data is accumulated internally by
++      // the codec and included in the next iteration. Therefore, here we
++      // don't increment the "media_read_total_dropped_packets" counter.
++    	LOG_DEBUG ( "%s: free buffer len(%d)", __func__, p_buf->len);
++      osi_free(p_buf);
++    }
++  }
++  uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
++  if (now_ms - time_prev >= 1000 ) {
++	  LOG_DEBUG ( "%s: Current data rate about %d kbps, packet usage %.2f%%", __func__, (allSendbytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
++      allSendbytes = 0;
++      mtu_usage_cnt = 0;
++      mtu_usage = 0;
++      time_prev = now_ms;
++  }
++}
++
++static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
++    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++  uint32_t read_size = 0;
++  int32_t read_size_tmp = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
++  if (read_size_tmp <= 0) {
++    LOG_ERROR ("%s: lhdc_get_block_size error!", __func__);
++    return false;
++  }
++  read_size = read_size_tmp * bytes_per_sample;
++
++  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
++  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
++
++  /* Read Data from UIPC channel */
++  uint32_t nb_byte_read =
++      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
++  LOG_DEBUG( "%s: want to read size %u, read byte number %u",
++                    __func__, read_size, nb_byte_read);
++  if ((nb_byte_read % bytes_per_sample) != 0) {
++	  LOG_DEBUG( "%s: PCM data not alignment. The audio sample is shfit %d bytes.", __func__,(nb_byte_read % bytes_per_sample));
++  }
++  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
++
++  if (nb_byte_read < read_size) {
++    if (nb_byte_read == 0) return false;
++
++    /* Fill the unfilled part of the read buffer with silence (0) */
++    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
++    nb_byte_read = read_size;
++  }
++  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
++
++    *bytes_read = nb_byte_read;
++
++  return true;
++}
++
++// library index mapping: quality mode index
++static std::string quality_mode_index_to_name(int quality_mode_index) {
++  switch (quality_mode_index) {
++    case LHDCBT_QUALITY_AUTO:
++      return "ABR";
++    case LHDCBT_QUALITY_HIGH:
++      return "HIGH";
++    case LHDCBT_QUALITY_MID:
++      return "MID";
++    case LHDCBT_QUALITY_LOW:
++      return "LOW";
++    case LHDCBT_QUALITY_LOW4:
++      return "LOW_320";
++    case LHDCBT_QUALITY_LOW3:
++      return "LOW_256";
++    case LHDCBT_QUALITY_LOW2:
++      return "LOW_192";
++    case LHDCBT_QUALITY_LOW1:
++      return "LOW_128";
++    case LHDCBT_QUALITY_LOW0:
++      return "LOW_64";
++    default:
++      return "Unknown";
++  }
++}
++
++void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length) {
++  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  LOG_DEBUG( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
++  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
++	  LOG_DEBUG( "%s: Auto Bitrate Enabled!", __func__);
++      if (lhdc_auto_adjust_bitrate != NULL) {
++          lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
++      }
++  }
++}
++
++uint64_t A2dpCodecConfigLhdcV3::encoderIntervalMs() const {
++  return a2dp_vendor_lhdcv3_get_encoder_interval_ms();
++}
++
++int A2dpCodecConfigLhdcV3::getEffectiveMtu() const {
++  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
++}
++
++void A2dpCodecConfigLhdcV3::debug_codec_dump(int fd) {
++  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
++      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++
++  A2dpCodecConfig::debug_codec_dump(fd);
++
++  dprintf(fd,
++          "  Packet counts (expected/dropped)                        : %zu / "
++          "%zu\n",
++          stats->media_read_total_expected_packets,
++          stats->media_read_total_dropped_packets);
++
++  dprintf(fd,
++          "  PCM read counts (expected/actual)                       : %zu / "
++          "%zu\n",
++          stats->media_read_total_expected_reads_count,
++          stats->media_read_total_actual_reads_count);
++
++  dprintf(fd,
++          "  PCM read bytes (expected/actual)                        : %zu / "
++          "%zu\n",
++          stats->media_read_total_expected_read_bytes,
++          stats->media_read_total_actual_read_bytes);
++
++  dprintf(
++      fd, "  LHDC quality mode                                       : %s\n",
++      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
++
++  dprintf(fd,
++          "  LHDC transmission bitrate (Kbps)                        : %d\n",
++          lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle));
++
++  dprintf(fd,
++          "  LHDC saved transmit queue length                        : %zu\n",
++          a2dp_lhdc_encoder_cb.TxQueueLength);
++/*
++  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
++    dprintf(fd,
++            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
++            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
++    dprintf(fd,
++            "  LHDC adaptive bit rate adjustments                      : %zu\n",
++            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
++  }
++  */
++}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
+new file mode 100644
+index 000000000..8b4c1f384
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
+@@ -0,0 +1,2883 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++/******************************************************************************
++ *
++ *  Utility functions to help build and parse the LHDCV5 Codec Information
++ *  Element and Media Payload.
++ *
++ ******************************************************************************/
++
++#define LOG_TAG "a2dp_vendor_lhdcv5"
++
++#include "bt_target.h"
++
++#include "a2dp_vendor_lhdcv5.h"
++
++#include <string.h>
++
++#include <base/logging.h>
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv5_encoder.h"
++#include "a2dp_vendor_lhdcv5_decoder.h"
++#include "bt_utils.h"
++#include "btif_av_co.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++// data type for the LHDC Codec Information Element
++typedef struct {
++  uint32_t vendorId;                                    /* Vendor ID */
++  uint16_t codecId;                                     /* Codec ID */
++  uint8_t sampleRate;                                   /* Sampling Frequency Type */
++  uint8_t bitsPerSample;                                /* Bits Per Sample Type */
++  uint8_t channelMode;                                  /* Channel Mode */
++  uint8_t version;                                      /* Codec SubVersion Number */
++  uint8_t frameLenType;                                 /* Frame Length Type */
++  uint8_t maxTargetBitrate;                             /* Max Target Bit Rate Type */
++  uint8_t minTargetBitrate;                             /* Min Target Bit Rate Type */
++  bool hasFeatureAR;                                    /* FeatureSupported: AR */
++  bool hasFeatureJAS;                                   /* FeatureSupported: JAS */
++  bool hasFeatureMETA;                                  /* FeatureSupported: META */
++  bool hasFeatureLL;                                    /* FeatureSupported: Low Latency */
++  bool hasFeatureLLESS;                                 /* FeatureSupported: Lossless */
++  //for runtime feature switch on/off, not caps
++  bool featureOnAR;                                     /* Feature TurnOn: AR */
++} tA2DP_LHDCV5_CIE;
++
++// source capabilities
++static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV5_CODEC_ID, // codecId
++    // Sampling Frequency
++    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
++    // Bits Per Sample
++    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24),
++    // Channel Mode
++    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
++    // Codec SubVersion Number
++    A2DP_LHDCV5_VER_1,
++    // Encoded Frame Length
++    A2DP_LHDCV5_FRAME_LEN_5MS,
++    // Max Target Bit Rate Type
++    A2DP_LHDCV5_MAX_BIT_RATE_MASK,
++    // Min Target Bit Rate Type
++    A2DP_LHDCV5_MIN_BIT_RATE_MASK,
++    // FeatureSupported: AR
++    true,
++    // FeatureSupported: JAS
++    true,
++    // FeatureSupported: META
++    true,
++    // FeatureSupported: Low Latency
++    true,
++    // FeatureSupported: Lossless
++    true,
++    // Feature On/OFF: AR
++    false,
++};
++
++// default source capabilities for best select
++static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_default_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV5_CODEC_ID, // codecId
++    // Sampling Frequency
++    A2DP_LHDCV5_SAMPLING_FREQ_48000,
++    // Bits Per Sample
++    A2DP_LHDCV5_BIT_FMT_24,
++    // Channel Mode
++    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
++    // Codec Version Number
++    A2DP_LHDCV5_VER_1,
++    // Encoded Frame Length
++    A2DP_LHDCV5_FRAME_LEN_5MS,
++    // Max Target Bit Rate Type
++    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
++    // Min Target Bit Rate Type
++    A2DP_LHDCV5_MIN_BIT_RATE_64K,
++    // FeatureSupported: AR
++    true,
++    // FeatureSupported: JAS
++    true,
++    // FeatureSupported: META
++    true,
++    // FeatureSupported: Low Latency
++    true,
++    // FeatureSupported: Lossless
++    true,
++    // Feature On/OFF: AR
++    false,
++};
++
++// sink capabilities
++static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV5_CODEC_ID, // codecId
++    // Sampling Frequency
++    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
++    // Bits Per Sample
++    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24 | A2DP_LHDCV5_BIT_FMT_32),
++    // Channel Mode
++    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
++    // Codec Version Number
++    A2DP_LHDCV5_VER_1,
++    // Encoded Frame Length
++    A2DP_LHDCV5_FRAME_LEN_5MS,
++    // Max Target Bit Rate Type
++    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
++    // Min Target Bit Rate Type
++    A2DP_LHDCV5_MIN_BIT_RATE_64K,
++    // FeatureSupported: AR
++    true,
++    // FeatureSupported: JAS
++    true,
++    // FeatureSupported: META
++    true,
++    // FeatureSupported: Low Latency
++    true,
++    // FeatureSupported: Lossless
++    true,
++    // Feature On/OFF: AR
++    false,
++};
++
++// default sink capabilities
++UNUSED_ATTR static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_default_caps = {
++    A2DP_LHDC_VENDOR_ID,  // vendorId
++    A2DP_LHDCV5_CODEC_ID, // codecId
++    // Sampling Frequency
++    A2DP_LHDCV5_SAMPLING_FREQ_48000,
++    // Bits Per Sample
++    A2DP_LHDCV5_BIT_FMT_24,
++    // Channel Mode
++    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
++    // Codec Version Number
++    A2DP_LHDCV5_VER_1,
++    // Encoded Frame Length
++    A2DP_LHDCV5_FRAME_LEN_5MS,
++    // Max Target Bit Rate Type
++    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
++    // Min Target Bit Rate Type
++    A2DP_LHDCV5_MIN_BIT_RATE_64K,
++    // FeatureSupported: AR
++    true,
++    // FeatureSupported: JAS
++    true,
++    // FeatureSupported: META
++    true,
++    // FeatureSupported: Low Latency
++    true,
++    // FeatureSupported: Lossless
++    true,
++    // Feature On/OFF: AR
++    false,
++};
++
++//
++// Utilities for LHDC configuration on A2DP specifics - START
++//
++typedef struct {
++  btav_a2dp_codec_config_t *_codec_config_;
++  btav_a2dp_codec_config_t *_codec_capability_;
++  btav_a2dp_codec_config_t *_codec_local_capability_;
++  btav_a2dp_codec_config_t *_codec_selectable_capability_;
++  btav_a2dp_codec_config_t *_codec_user_config_;
++  btav_a2dp_codec_config_t *_codec_audio_config_;
++}tA2DP_CODEC_CONFIGS_PACK;
++
++typedef struct {
++  uint8_t   featureCode;  /* code of LHDC features */
++  uint8_t   inSpecBank;   /* target specific to store the feature flag */
++  uint8_t   bitPos;       /* the bit index(0~63) of the specific(int64_t) that bit store */
++  int64_t   value;        /* real value of the bit position written to the target specific */
++}tA2DP_LHDC_FEATURE_POS;
++
++// default settings of LHDC features configuration on specifics
++// info of feature: JAS
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_JAS = {
++    LHDCV5_FEATURE_CODE_JAS,
++    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
++    LHDCV5_FEATURE_JAS_SPEC_BIT_POS,
++    (0x1ULL << LHDCV5_FEATURE_JAS_SPEC_BIT_POS),
++};
++
++// info of feature: AR
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_AR = {
++    LHDCV5_FEATURE_CODE_AR,
++    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
++    LHDCV5_FEATURE_AR_SPEC_BIT_POS,
++    (0x1ULL << LHDCV5_FEATURE_AR_SPEC_BIT_POS),
++};
++
++// info of feature: META
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_META = {
++    LHDCV5_FEATURE_CODE_META,
++    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
++    LHDCV5_FEATURE_META_SPEC_BIT_POS,
++    (0x1ULL << LHDCV5_FEATURE_META_SPEC_BIT_POS),
++};
++
++// info of feature: Low Latency
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LL = {
++    LHDCV5_FEATURE_CODE_LL,
++    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2,
++    LHDCV5_FEATURE_LL_SPEC_BIT_POS,
++    (0x1ULL << LHDCV5_FEATURE_LL_SPEC_BIT_POS),
++};
++
++// info of feature: LossLess
++static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LLESS = {
++    LHDCV5_FEATURE_CODE_LLESS,
++    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
++    LHDCV5_FEATURE_LLESS_SPEC_BIT_POS,
++    (0x1ULL << LHDCV5_FEATURE_LLESS_SPEC_BIT_POS),
++};
++
++UNUSED_ATTR static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_all[] = {
++    a2dp_lhdcv5_source_spec_JAS,
++    a2dp_lhdcv5_source_spec_AR,
++    a2dp_lhdcv5_source_spec_META,
++    a2dp_lhdcv5_source_spec_LL,
++    a2dp_lhdcv5_source_spec_LLESS,
++};
++
++// to check if target feature bit is set in codec_user_config_
++static bool A2DP_IsFeatureInUserConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
++  bool ret = false;
++
++  if (cfgsPtr == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  switch (featureCode) {
++  case LHDCV5_FEATURE_CODE_JAS:
++  {
++    ret = LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
++        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
++    return ret;
++  } break;
++  case LHDCV5_FEATURE_CODE_AR:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
++        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_META:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
++        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_LL:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
++        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_LLESS:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
++        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
++  } break;
++  default:
++    break;
++  }
++
++  return false;
++}
++
++// to check if target feature bit is set in codec_config_
++static bool A2DP_IsFeatureInCodecConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
++  if (cfgsPtr == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  switch(featureCode) {
++  case LHDCV5_FEATURE_CODE_JAS:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
++        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_AR:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
++        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_META:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
++        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_LL:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
++        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
++  } break;
++  case LHDCV5_FEATURE_CODE_LLESS:
++  {
++    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
++        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
++  } break;
++  default:
++    break;
++  }
++
++  return false;
++}
++
++static void A2DP_UpdateFeatureToSpecLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
++    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value) {
++  if (cfgsPtr == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return;
++  }
++
++  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_) {
++    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
++  }
++  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_) {
++    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
++  }
++  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_) {
++    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
++  }
++  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_) {
++    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
++  }
++  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_) {
++    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
++  }
++  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_) {
++    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
++  }
++}
++
++// to update feature bit value to target codec config's specific
++static void A2DP_UpdateFeatureToA2dpConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
++    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature) {
++  if (cfgsPtr == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return;
++  }
++
++  switch(featureCode) {
++  case LHDCV5_FEATURE_CODE_JAS:
++    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
++    break;
++  case LHDCV5_FEATURE_CODE_AR:
++    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
++    break;
++  case LHDCV5_FEATURE_CODE_META:
++    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
++    break;
++  case LHDCV5_FEATURE_CODE_LL:
++    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
++    break;
++  case LHDCV5_FEATURE_CODE_LLESS:
++    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
++        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
++    break;
++  default:
++    break;
++  }
++}
++//
++// Utilities for LHDC configuration on A2DP specifics - END
++
++static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv5 = {
++    a2dp_vendor_lhdcv5_encoder_init,
++    a2dp_vendor_lhdcv5_encoder_cleanup,
++    a2dp_vendor_lhdcv5_feeding_reset,
++    a2dp_vendor_lhdcv5_feeding_flush,
++    a2dp_vendor_lhdcv5_get_encoder_interval_ms,
++    a2dp_vendor_lhdcv5_send_frames,
++    a2dp_vendor_lhdcv5_set_transmit_queue_length,
++};
++
++static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv5 = {
++    a2dp_vendor_lhdcv5_decoder_init,
++    a2dp_vendor_lhdcv5_decoder_cleanup,
++    a2dp_vendor_lhdcv5_decoder_decode_packet,
++    a2dp_vendor_lhdcv5_decoder_start,
++    a2dp_vendor_lhdcv5_decoder_suspend,
++    a2dp_vendor_lhdcv5_decoder_configure,
++};
++
++UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
++    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info,
++    bool is_capability);
++
++
++// check if target version is supported right now
++static bool is_codec_version_supported(uint8_t version, bool is_source) {
++  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
++      (is_source) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
++
++  if ((version & p_a2dp_lhdcv5_caps->version) != A2DP_LHDCV5_VER_NS) {
++    return true;
++  }
++
++  LOG_DEBUG( "%s: versoin unsupported! peer:%d local:%d",
++      __func__, version, p_a2dp_lhdcv5_caps->version);
++  return false;
++}
++
++// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
++// |p_ie| is a pointer to the LHDC Codec Information Element information.
++// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_BuildInfoLhdcV5(uint8_t media_type,
++    const tA2DP_LHDCV5_CIE* p_ie,
++    uint8_t* p_result) {
++
++  const uint8_t* tmpInfo = p_result;
++  uint8_t para = 0;
++
++  if (p_ie == nullptr || p_result == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return A2DP_INVALID_PARAMS;
++  }
++
++  *p_result++ = A2DP_LHDCV5_CODEC_LEN;  //H0
++  *p_result++ = (media_type << 4);      //H1
++  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //H2
++
++  // Vendor ID(P0-P3) and Codec ID(P4-P5)
++  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
++  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
++  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
++  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
++
++  para = 0;
++  // P6[5:0] Sampling Frequency
++  if ((p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK) != A2DP_LHDCV5_SAMPLING_FREQ_NS) {
++    para |= (p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
++  } else {
++    LOG_ERROR( "%s: invalid sample rate (0x%02X)", __func__, p_ie->sampleRate);
++    return A2DP_INVALID_PARAMS;
++  }
++  // update P6
++  *p_result++ = para; para = 0;
++
++  // P7[2:0] Bit Depth
++  if ((p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK) != A2DP_LHDCV5_BIT_FMT_NS) {
++    para |= (p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK);
++  } else {
++    LOG_ERROR( "%s: invalid bits per sample (0x%02X)", __func__, p_ie->bitsPerSample);
++    return A2DP_INVALID_PARAMS;
++  }
++  // P7[5:4] Max Target Bit Rate
++  para |= (p_ie->maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
++  // P7[7:6] Min Target Bit Rate
++  para |= (p_ie->minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
++  // update P7
++  *p_result++ = para; para = 0;
++
++  // P8[3:0] Codec SubVersion
++  if ((p_ie->version & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_NS) {
++    para = para | (p_ie->version & A2DP_LHDCV5_VERSION_MASK);
++  } else {
++    LOG_ERROR( "%s: invalid codec subversion (0x%02X)", __func__, p_ie->version);
++    return A2DP_INVALID_PARAMS;
++  }
++  // P8[5:4] Frame Length Type
++  if ((p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK) != A2DP_LHDCV5_FRAME_LEN_NS) {
++    para = para | (p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK);
++  } else {
++    LOG_ERROR( "%s: invalid frame length type (0x%02X)", __func__, p_ie->frameLenType);
++    return A2DP_INVALID_PARAMS;
++  }
++  // update P8
++  *p_result++ = para; para = 0;
++
++  // P9[0] HasAR
++  // P9[1] HasJAS
++  // P9[2] HasMeta
++  // P9[6] HasLL
++  // P9[7] HasLossless
++  if (p_ie->hasFeatureAR) {
++    para |= A2DP_LHDCV5_FEATURE_AR;
++  }
++  if (p_ie->hasFeatureJAS) {
++    para |= A2DP_LHDCV5_FEATURE_JAS;
++  }
++  if (p_ie->hasFeatureMETA) {
++    para |= A2DP_LHDCV5_FEATURE_META;
++  }
++  if (p_ie->hasFeatureLL) {
++    para |= A2DP_LHDCV5_FEATURE_LL;
++  }
++  if (p_ie->hasFeatureLLESS) {
++    para |= A2DP_LHDCV5_FEATURE_LLESS;
++  }
++  // update P9
++  *p_result++ = para; para = 0;
++
++  // P10[0] AR ON/OFF
++  if (p_ie->featureOnAR) {
++    para |= A2DP_LHDCV5_AR_ON;
++  }
++  // update P10
++  *p_result++ = para; para = 0;
++
++  LOG_DEBUG( "%s: codec info built = H0-H2{%02X %02X %02X} P0-P3{%02X "
++      "%02X %02X %02X} P4-P5{%02X %02X} P6{%02X} P7{%02X} P8{%02X} P9{%02X} P10{%02X}", __func__,
++      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
++      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
++
++  return A2DP_SUCCESS;
++}
++
++// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
++// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
++// |p_codec_info|. If |is_capability| is true, the byte sequence is
++// codec capabilities, otherwise is codec configuration.
++// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
++// status code.
++static tA2DP_STATUS A2DP_ParseInfoLhdcV5(tA2DP_LHDCV5_CIE* p_ie,
++    const uint8_t* p_codec_info,
++    bool is_capability,
++    bool is_source) {
++  uint8_t losc;
++  uint8_t media_type;
++  tA2DP_CODEC_TYPE codec_type;
++  const uint8_t* tmpInfo = p_codec_info;
++  const uint8_t* p_codec_Info_save = p_codec_info;
++
++  if (p_ie == nullptr || p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return A2DP_INVALID_PARAMS;
++  }
++
++  // Codec capability length
++  losc = *p_codec_info++;
++  if (losc != A2DP_LHDCV5_CODEC_LEN) {
++    LOG_ERROR( "%s: wrong length %u", __func__, losc);
++    return A2DP_WRONG_CODEC;
++  }
++
++  media_type = (*p_codec_info++) >> 4;
++  codec_type = *p_codec_info++;
++
++  // Media Type and Media Codec Type
++  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
++      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
++    LOG_ERROR( "%s: invalid media type 0x%X codec_type 0x%X", __func__, media_type, codec_type);
++    return A2DP_WRONG_CODEC;
++  }
++
++  // Vendor ID(P0-P3) and Codec ID(P4-P5)
++  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
++      (*(p_codec_info + 1) << 8 & 0x0000FF00) |
++      (*(p_codec_info + 2) << 16 & 0x00FF0000) |
++      (*(p_codec_info + 3) << 24 & 0xFF000000);
++  p_codec_info += 4;
++  p_ie->codecId = (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
++  p_codec_info += 2;
++  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
++      p_ie->codecId != A2DP_LHDCV5_CODEC_ID) {
++    LOG_ERROR( "%s: invalid vendorId 0x%X codecId 0x%X", __func__,
++        p_ie->vendorId, p_ie->codecId);
++    return A2DP_WRONG_CODEC;
++  }
++
++  // P6[5:0] Sampling Frequency
++  p_ie->sampleRate = (*p_codec_info & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
++  if (p_ie->sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS) {
++    LOG_ERROR( "%s: invalid sample rate 0x%X", __func__, p_ie->sampleRate);
++    return A2DP_WRONG_CODEC;
++  }
++  p_codec_info += 1;
++
++  // P7[2:0] Bits Per Sample
++  p_ie->bitsPerSample = (*p_codec_info & A2DP_LHDCV5_BIT_FMT_MASK);
++  if (p_ie->bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS) {
++    LOG_ERROR( "%s: invalid bit per sample 0x%X", __func__, p_ie->bitsPerSample);
++    return A2DP_WRONG_CODEC;
++  }
++  // P7[5:4] Max Target Bit Rate
++  p_ie->maxTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
++  // P7[7:6] Min Target Bit Rate
++  p_ie->minTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
++  p_codec_info += 1;
++
++  // Channel Mode: stereo only
++  p_ie->channelMode = A2DP_LHDCV5_CHANNEL_MODE_STEREO;
++
++  // P8[3:0] Codec SubVersion
++  p_ie->version = (*p_codec_info & A2DP_LHDCV5_VERSION_MASK);
++  if (p_ie->version == A2DP_LHDCV5_VER_NS) {
++    LOG_ERROR( "%s: invalid version 0x%X", __func__, p_ie->version);
++    return A2DP_WRONG_CODEC;
++  } else {
++    if (!is_codec_version_supported(p_ie->version, is_source)) {
++      LOG_ERROR( "%s: unsupported version 0x%X", __func__, p_ie->version);
++      return A2DP_WRONG_CODEC;
++    }
++  }
++  // P8[5:4] Frame Length Type
++  p_ie->frameLenType = (*p_codec_info & A2DP_LHDCV5_FRAME_LEN_MASK);
++  if (p_ie->frameLenType == A2DP_LHDCV5_FRAME_LEN_NS) {
++    LOG_ERROR( "%s: invalid frame length mode 0x%X", __func__, p_ie->frameLenType);
++    return A2DP_WRONG_CODEC;
++  }
++  p_codec_info += 1;
++
++  // Features:
++  // P9[0] HasAR
++  // P9[1] HasJAS
++  // P9[2] HasMeta
++  // P9[6] HasLL
++  // P9[7] HasLossless
++  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDCV5_FEATURE_AR) != 0) ? true : false;
++  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_JAS) != 0) ? true : false;
++  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDCV5_FEATURE_META) != 0) ? true : false;
++  p_ie->hasFeatureLL = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LL) != 0) ? true : false;
++  p_ie->hasFeatureLLESS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS) != 0) ? true : false;
++  p_codec_info += 1;
++
++  // P10[0] AR_ON_OFF
++  p_ie->featureOnAR = ((*p_codec_info & A2DP_LHDCV5_AR_ON) != 0) ? true : false;
++
++  LOG_DEBUG( "%s: codec info parsed = H0-H2{%02X %02X %02X} P0-P3{%02X "
++      "%02X %02X %02X} P4-P5{%02X %02X} P6{%02X} P7{%02X} P8{%02X} P9{%02X} P10{%02X}", __func__,
++      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
++      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
++
++  LOG_DEBUG( "%s: %s isCap{%d} SR{%02X} BPS{%02X} Ver{%02X} FL{%02X} "
++      "MBR{%02X} mBR{%02X} Feature{AR(%d) JAS(%d) META(%d) LL(%d) LLESS(%d)} AR_ON{%d}",
++      __func__,
++      (is_source?"SRC":"SNK"),
++      is_capability,
++      p_ie->sampleRate,
++      p_ie->bitsPerSample,
++      p_ie->version,
++      p_ie->frameLenType,
++      p_ie->maxTargetBitrate,
++      p_ie->minTargetBitrate,
++      p_ie->hasFeatureAR,
++      p_ie->hasFeatureJAS,
++      p_ie->hasFeatureMETA,
++      p_ie->hasFeatureLL,
++      p_ie->hasFeatureLLESS,
++      p_ie->featureOnAR);
++
++  //save decoder needed parameters
++#if 1
++  if (!is_source) {
++    if (!a2dp_lhdcv5_decoder_save_codec_info(p_codec_Info_save)) {
++      LOG_DEBUG( "%s: save decoder parameters error", __func__);
++    }
++  }
++#endif
++
++  return A2DP_SUCCESS;
++}
++
++bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE cfg_cie;
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
++      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
++}
++bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE cfg_cie;
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
++      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
++}
++
++bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE cfg_cie;
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
++      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
++}
++bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE cfg_cie;
++  /* Use a liberal check when parsing the codec info */
++  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
++      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
++}
++
++// NOTE: Should be done only for local Sink codec
++bool A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
++  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
++      false) == A2DP_SUCCESS);
++}
++// NOTE: Should be done only for local Sink codec
++bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
++  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
++      true) == A2DP_SUCCESS);
++}
++
++// Checks whether A2DP LHDC codec configuration matches with a device's codec
++// capabilities.
++//  |p_cap| is the LHDC local codec capabilities.
++//  |p_codec_info| is peer's codec capabilities acting as an A2DP source.
++// If |is_capability| is true, the byte sequence is codec capabilities,
++// otherwise is codec configuration.
++// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
++// otherwise the corresponding A2DP error status code.
++static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
++    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info, bool is_capability) {
++  tA2DP_STATUS status;
++  tA2DP_LHDCV5_CIE cfg_cie;
++
++  if (p_cap == nullptr || p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return A2DP_INVALID_PARAMS;
++  }
++
++  // parse configuration
++  status = A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, is_capability, IS_SNK);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: parsing failed %d", __func__, status);
++    return status;
++  }
++
++  // verify that each parameter is in range
++  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
++      cfg_cie.sampleRate, p_cap->sampleRate);
++
++  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
++      cfg_cie.bitsPerSample, p_cap->bitsPerSample);
++
++  // sampling frequency
++  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
++
++  // bits per sample
++  if ((cfg_cie.bitsPerSample & p_cap->bitsPerSample) == 0) return A2DP_NS_BIT_RATE;
++
++  return A2DP_SUCCESS;
++}
++
++bool A2DP_VendorUsesRtpHeaderLhdcV5(UNUSED_ATTR bool content_protection_enabled,
++    UNUSED_ATTR const uint8_t* p_codec_info) {
++  // TODO: Is this correct? The RTP header is always included?
++  return true;
++}
++
++const char* A2DP_VendorCodecNameLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info) {
++  return "LHDC V5";
++}
++
++bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
++    const uint8_t* p_codec_info_b) {
++  tA2DP_LHDCV5_CIE lhdc_cie_a;
++  tA2DP_LHDCV5_CIE lhdc_cie_b;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status =
++      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
++    const uint8_t* p_codec_info_b) {
++  tA2DP_LHDCV5_CIE lhdc_cie_a;
++  tA2DP_LHDCV5_CIE lhdc_cie_b;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status =
++      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information of a: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++  a2dp_status =
++      A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information of b: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++
++  // exam items that require to update codec config with peer if different
++  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
++      (lhdc_cie_a.bitsPerSample == lhdc_cie_b.bitsPerSample) &&
++      (lhdc_cie_a.channelMode == lhdc_cie_b.channelMode) &&
++      (lhdc_cie_a.frameLenType == lhdc_cie_b.frameLenType) &&
++      //(lhdc_cie_a.hasFeatureAR == lhdc_cie_b.hasFeatureAR) &&
++      (lhdc_cie_a.hasFeatureLL == lhdc_cie_b.hasFeatureLL);
++}
++
++int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info) {
++  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
++  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
++
++  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
++      A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
++      case A2DP_LHDCV5_QUALITY_LOW0:
++        return 64000;
++      case A2DP_LHDCV5_QUALITY_LOW1:
++        return 128000;
++      case A2DP_LHDCV5_QUALITY_LOW2:
++        return 192000;
++      case A2DP_LHDCV5_QUALITY_LOW3:
++        return 256000;
++      case A2DP_LHDCV5_QUALITY_LOW4:
++        return 320000;
++      case A2DP_LHDCV5_QUALITY_LOW:
++        return 400000;
++      case A2DP_LHDCV5_QUALITY_MID:
++        return 500000;
++      case A2DP_LHDCV5_QUALITY_HIGH:
++        return 900000;
++      case A2DP_LHDCV5_QUALITY_HIGH1:
++        return 1000000;
++      case A2DP_LHDCV5_QUALITY_ABR:
++        return 9999999;
++      default:
++        return -1;
++    }
++  }
++  return 400000;
++}
++
++int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return -1;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.sampleRate) {
++  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
++    return 44100;
++  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
++    return 48000;
++  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
++    return 96000;
++  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
++    return 192000;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return -1;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.bitsPerSample) {
++  case A2DP_LHDCV5_BIT_FMT_16:
++    return 16;
++  case A2DP_LHDCV5_BIT_FMT_24:
++    return 24;
++  case A2DP_LHDCV5_BIT_FMT_32:
++    return 32;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return -1;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.channelMode) {
++  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
++    return 1;
++  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
++    return 2;
++  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
++    return 2;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return -1;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SNK);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.channelMode) {
++  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
++    return 1;
++  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
++    return 3;
++  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
++    return 3;
++  }
++
++  return -1;
++}
++
++int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return -1;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return -1;
++  }
++
++  switch (lhdc_cie.channelMode) {
++  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
++  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
++  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
++    return lhdc_cie.channelMode;
++  default:
++    break;
++  }
++
++  return -1;
++}
++
++bool A2DP_VendorGetPacketTimestampLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
++    const uint8_t* p_data,
++    uint32_t* p_timestamp) {
++  if (p_codec_info == nullptr || p_data == nullptr || p_timestamp == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // TODO: Is this function really codec-specific?
++  *p_timestamp = *(const uint32_t*)p_data;
++  return true;
++}
++
++bool A2DP_VendorBuildCodecHeaderLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
++    BT_HDR* p_buf,
++    uint16_t frames_per_packet) {
++  uint8_t* p;
++
++  if (p_codec_info == nullptr || p_buf == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
++  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
++  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
++
++  // Not support fragmentation
++  p[0] = ( uint8_t)( frames_per_packet & 0xff);
++  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
++
++  return true;
++}
++
++void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDCV5_CIE lhdc_cie;
++
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV5 fail:%d", __func__, a2dp_status);
++    return;
++  }
++
++  LOG_DEBUG( "\tsamp_freq: 0x%02X ", lhdc_cie.sampleRate);
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++    LOG_DEBUG( "\tsamp_freq: (44100)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++    LOG_DEBUG( "\tsamp_freq: (48000)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++    LOG_DEBUG( "\tsamp_freq: (96000)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++    LOG_DEBUG( "\tsamp_freq: (19200)");
++  }
++
++  LOG_DEBUG( "\tbitsPerSample: 0x%02X ", lhdc_cie.bitsPerSample);
++  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
++    LOG_DEBUG( "\tbit_depth: (16)");
++  }
++  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
++    LOG_DEBUG( "\tbit_depth: (24)");
++  }
++  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
++    LOG_DEBUG( "\tbit_depth: (32)");
++  }
++
++  LOG_DEBUG( "\tchannelMode: 0x%02X ", lhdc_cie.channelMode);
++  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
++    LOG_DEBUG( "\tchannle_mode: (mono)");
++  }
++  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
++    LOG_DEBUG( "\tchannle_mode: (dual)");
++  }
++  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
++    LOG_DEBUG( "\tchannle_mode: (stereo)");
++  }
++}
++
++std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info) {
++  std::stringstream res;
++  std::string field;
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDCV5_CIE lhdc_cie;
++
++  if (p_codec_info == nullptr) {
++    res << "A2DP_VendorCodecInfoStringLhdcV5 nullptr";
++    return res.str();
++  }
++
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    res << "A2DP_ParseInfoLhdcV5 fail: " << loghex(a2dp_status);
++    return res.str();
++  }
++
++  res << "\tname: LHDC V5\n";
++
++  // Sample frequency
++  field.clear();
++  AppendField(&field, (lhdc_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS), "NONE");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100),
++      "44100");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000),
++      "48000");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000),
++      "96000");
++  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000),
++      "192000");
++  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
++                                                                      << ")\n";
++
++  // bits per sample
++  field.clear();
++  AppendField(&field, (lhdc_cie.bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS), "NONE");
++  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16),
++      "16");
++  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24),
++      "24");
++  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32),
++      "24");
++  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bitsPerSample)
++                                                                      << ")\n";
++
++  // Channel mode
++  field.clear();
++  AppendField(&field, (lhdc_cie.channelMode == A2DP_LHDCV5_CHANNEL_MODE_NS), "NONE");
++  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO),
++      "Mono");
++  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL),
++      "Dual");
++  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO),
++      "Stereo");
++  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
++                                                                      << ")\n";
++
++  // Version
++  field.clear();
++  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_NS), "NONE");
++  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_1),
++      "LHDC V5 Ver1");
++  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
++                                                                      << ")\n";
++
++  // Max target bit rate...
++  field.clear();
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_1000K),
++      "1000Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K),
++      "900Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K),
++      "500Kbps");
++  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K),
++      "400Kbps");
++  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK))
++                                                                      << ")\n";
++
++  // Min target bit rate...
++  field.clear();
++  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_400K),
++      "400Kbps");
++  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K),
++      "256Kbps");
++  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K),
++      "128Kbps");
++  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K),
++      "64Kbps");
++  res << "\tMin target-rate: " << field << " (" << loghex((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK))
++                                                                      << ")\n";
++
++  return res.str();
++}
++
++const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
++    const uint8_t* p_codec_info) {
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return NULL;
++  }
++
++  if (!A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info)) return NULL;
++
++  return &a2dp_encoder_interface_lhdcv5;
++}
++
++const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
++    const uint8_t* p_codec_info) {
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return NULL;
++  }
++
++  if (!A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info)) return NULL;
++
++  return &a2dp_decoder_interface_lhdcv5;
++}
++
++bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE cfg_cie;
++  if (p_codec_info == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Nothing to do: just verify the codec info is valid
++  if (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) != A2DP_SUCCESS)
++    return false;
++
++  return true;
++}
++
++btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
++    UNUSED_ATTR const uint8_t* p_codec_info) {
++  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5;
++}
++
++btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(
++    UNUSED_ATTR const uint8_t* p_codec_info) {
++  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5;
++}
++
++const char* A2DP_VendorCodecIndexStrLhdcV5(void) { return "LHDC V5"; }
++
++const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void) { return "LHDC V5 SINK"; }
++
++bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg) {
++  if (p_cfg == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_source_caps,
++      p_cfg->codec_info) != A2DP_SUCCESS) {
++    return false;
++  }
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  /* Content protection info - support SCMS-T */
++  uint8_t* p = p_cfg->protect_info;
++  *p++ = AVDT_CP_LOSC;
++  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
++  p_cfg->num_protect = 1;
++#endif
++
++  return true;
++}
++
++bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg) {
++  if (p_cfg == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_sink_caps,
++      p_cfg->codec_info) != A2DP_SUCCESS) {
++    return false;
++  }
++
++  return true;
++}
++
++UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV5_CIE& config_cie,
++    btav_a2dp_codec_config_t* result) {
++  if (result == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return;
++  }
++
++  // sample rate
++  result->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
++    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++
++  // bits per sample
++  result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
++    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
++    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
++    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++
++  // channel mode
++  result->channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++  if (config_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO)
++    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
++  if (config_cie.channelMode &
++      (A2DP_LHDCV5_CHANNEL_MODE_DUAL | A2DP_LHDCV5_CHANNEL_MODE_STEREO)) {
++    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  }
++}
++
++A2dpCodecConfigLhdcV5Source::A2dpCodecConfigLhdcV5Source(
++    btav_a2dp_codec_priority_t codec_priority)
++: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
++    A2DP_VendorCodecIndexStrLhdcV5(),
++    codec_priority, true) {
++
++  // Compute the local capability
++  codec_local_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  }
++  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  }
++  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++  }
++  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++  }
++
++  codec_local_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
++    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++  }
++  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
++    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++  }
++  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
++    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++  }
++
++  codec_local_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
++  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
++    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
++  }
++  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
++    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  }
++  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
++    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  }
++}
++
++A2dpCodecConfigLhdcV5Source::~A2dpCodecConfigLhdcV5Source() {}
++
++bool A2dpCodecConfigLhdcV5Source::init() {
++  if (!isValid()) return false;
++
++  // Load the encoder
++  if (!A2DP_VendorLoadEncoderLhdcV5()) {
++    LOG_ERROR( "%s: cannot load the encoder", __func__);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2dpCodecConfigLhdcV5Source::useRtpHeaderMarkerBit() const { return false; }
++
++//
++// Selects the best sample rate from |sampleRate|.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_best_sample_rate(uint8_t sampleRate,
++    tA2DP_LHDCV5_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++  if (p_codec_config == nullptr || p_result == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    return true;
++  }
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
++    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++    return true;
++  }
++  return false;
++}
++
++//
++// Selects the audio sample rate from |p_codec_audio_config|.
++// |sampleRate| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_audio_sample_rate(
++    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
++    tA2DP_LHDCV5_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
++  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
++  switch (p_codec_audio_config->sample_rate) {
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
++      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
++      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
++      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
++      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
++    break;
++  }
++  return false;
++}
++
++//
++// Selects the best bits per sample from |bitsPerSample|.
++// |bitsPerSample| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_best_bits_per_sample(
++    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++
++  if (p_result == nullptr || p_codec_config == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // LHDC V5 priority: 24 > 16 > 32
++  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
++    return true;
++  }
++  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
++    return true;
++  }
++  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
++    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
++    return true;
++  }
++  return false;
++}
++
++//
++// Selects the audio bits per sample from |p_codec_audio_config|.
++// |bitsPerSample| contains the capability.
++// The result is stored in |p_result| and |p_codec_config|.
++// Returns true if a selection was made, otherwise false.
++//
++static bool select_audio_bits_per_sample(
++    const btav_a2dp_codec_config_t* p_codec_audio_config,
++    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
++    btav_a2dp_codec_config_t* p_codec_config) {
++
++  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // LHDC V5 priority: 24 > 16 > 32
++  switch (p_codec_audio_config->bits_per_sample) {
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
++      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
++      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
++      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
++      return true;
++    }
++    break;
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++    break;
++  }
++  return false;
++}
++
++static bool A2DP_MaxBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
++  if (mode == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  switch (bitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) {
++  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
++    *mode = A2DP_LHDCV5_QUALITY_HIGH1;
++    return true;
++  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
++    *mode = A2DP_LHDCV5_QUALITY_HIGH;
++    return true;
++  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
++    *mode = A2DP_LHDCV5_QUALITY_MID;
++    return true;
++  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
++    *mode = A2DP_LHDCV5_QUALITY_LOW;
++    return true;
++  }
++  return false;
++}
++
++static bool A2DP_MinBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
++  if (mode == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  switch (bitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) {
++  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
++    *mode = A2DP_LHDCV5_QUALITY_LOW;
++    return true;
++  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
++    *mode = A2DP_LHDCV5_QUALITY_LOW3;
++    return true;
++  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
++    *mode = A2DP_LHDCV5_QUALITY_LOW1;
++    return true;
++  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
++    *mode = A2DP_LHDCV5_QUALITY_LOW0;
++    return true;
++  }
++  return false;
++}
++
++static std::string lhdcV5_sampleRate_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
++    return "44100";
++  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
++    return "48000";
++  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
++    return "96000";
++  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
++    return "192000";
++  default:
++    return "Unknown Sample Rate";
++  }
++}
++
++static std::string lhdcV5_bitPerSample_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDCV5_BIT_FMT_16:
++    return "16";
++  case A2DP_LHDCV5_BIT_FMT_24:
++    return "24";
++  case A2DP_LHDCV5_BIT_FMT_32:
++    return "32";
++  default:
++    return "Unknown Bit Per Sample";
++  }
++}
++
++static std::string lhdcV5_frameLenType_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDCV5_FRAME_LEN_5MS:
++    return "5ms";
++  default:
++    return "Unknown frame length type";
++  }
++}
++
++static std::string lhdcV5_MaxTargetBitRate_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
++    return "900Kbps";
++  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
++    return "500Kbps";
++  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
++    return "400Kbps";
++  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
++    return "1000Kbps";
++  default:
++    return "Unknown Max Bit Rate";
++  }
++}
++
++static std::string lhdcV5_MinTargetBitRate_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
++    return "400Kbps";
++  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
++    return "256Kbps";
++  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
++    return "128Kbps";
++  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
++    return "64Kbps";
++  default:
++    return "Unknown Min Bit Rate";
++  }
++}
++
++static std::string lhdcV5_QualityModeBitRate_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDCV5_QUALITY_ABR:
++    return "ABR";
++  case A2DP_LHDCV5_QUALITY_HIGH1:
++    return "HIGH 1 (1000 Kbps)";
++  case A2DP_LHDCV5_QUALITY_HIGH:
++    return "HIGH (900 Kbps)";
++  case A2DP_LHDCV5_QUALITY_MID:
++    return "MID (500 Kbps)";
++  case A2DP_LHDCV5_QUALITY_LOW:
++    return "LOW (400 Kbps)";
++  case A2DP_LHDCV5_QUALITY_LOW4:
++    return "LOW 4 (320 Kbps)";
++  case A2DP_LHDCV5_QUALITY_LOW3:
++    return "LOW 3 (256 Kbps)";
++  case A2DP_LHDCV5_QUALITY_LOW2:
++    return "LOW 2 (192 Kbps)";
++  case A2DP_LHDCV5_QUALITY_LOW1:
++    return "LOW 1 (128 Kbps)";
++  case A2DP_LHDCV5_QUALITY_LOW0:
++    return "LOW 0 (64 Kbps)";
++  default:
++    return "Unknown Bit Rate Mode";
++  }
++}
++
++
++bool A2dpCodecConfigLhdcV5Base::setCodecConfig(const uint8_t* p_peer_codec_info,
++    bool is_capability,
++    uint8_t* p_result_codec_config) {
++  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++  tA2DP_LHDCV5_CIE sink_info_cie;
++  tA2DP_LHDCV5_CIE result_config_cie;
++  uint8_t sampleRate = 0;
++  uint8_t bitsPerSample = 0;
++  bool hasFeature = false;
++  bool hasUserSet = false;
++  uint8_t qualityMode = 0;
++  uint8_t bitRateQmode = 0;
++  tA2DP_STATUS status;
++
++  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
++      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
++
++  // Save the internal state
++  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
++  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
++  btav_a2dp_codec_config_t saved_codec_selectable_capability =
++      codec_selectable_capability_;
++  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
++  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
++  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
++  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
++  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
++  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
++  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
++      sizeof(ota_codec_peer_capability_));
++  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
++      sizeof(ota_codec_peer_config_));
++
++  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
++  allCfgPack._codec_config_ = &codec_config_;
++  allCfgPack._codec_capability_ = &codec_capability_;
++  allCfgPack._codec_local_capability_ = &codec_local_capability_;
++  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
++  allCfgPack._codec_user_config_ = &codec_user_config_;
++  allCfgPack._codec_audio_config_ = &codec_audio_config_;
++
++  if (p_peer_codec_info == nullptr || p_result_codec_config == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    goto fail;
++  }
++
++  status = A2DP_ParseInfoLhdcV5(&sink_info_cie, p_peer_codec_info, is_capability, IS_SRC);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
++        __func__, status);
++    goto fail;
++  }
++
++  //
++  // Build the preferred configuration
++  //
++  memset(&result_config_cie, 0, sizeof(result_config_cie));
++  result_config_cie.vendorId = p_a2dp_lhdcv5_caps->vendorId;
++  result_config_cie.codecId = p_a2dp_lhdcv5_caps->codecId;
++  result_config_cie.version = sink_info_cie.version;
++
++  //
++  // Select the sample frequency
++  //
++  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & sink_info_cie.sampleRate;
++  LOG_DEBUG( "%s: sampleRate Cap:{peer:0x%02X local:0x%02X result:0x%02X}",
++      __func__, sink_info_cie.sampleRate, p_a2dp_lhdcv5_caps->sampleRate, sampleRate);
++
++  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++  switch (codec_user_config_.sample_rate) {
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
++      codec_capability_.sample_rate = codec_user_config_.sample_rate;
++      codec_config_.sample_rate = codec_user_config_.sample_rate;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
++      codec_capability_.sample_rate = codec_user_config_.sample_rate;
++      codec_config_.sample_rate = codec_user_config_.sample_rate;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
++      codec_capability_.sample_rate = codec_user_config_.sample_rate;
++      codec_config_.sample_rate = codec_user_config_.sample_rate;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
++      codec_capability_.sample_rate = codec_user_config_.sample_rate;
++      codec_config_.sample_rate = codec_user_config_.sample_rate;
++    }
++    break;
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
++  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
++    codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++    codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
++    break;
++  }
++
++  // Select the sample frequency if there is no user preference
++  do {
++    // Compute the selectable capability
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
++      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
++      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
++      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
++      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++
++    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
++      LOG_DEBUG( "%s: sample rate configured successfully 0x%02X",
++          __func__, result_config_cie.sampleRate);
++      break;
++    }
++    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
++
++    // Compute the common capability
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
++      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++
++    // No user preference - try the codec audio config
++    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
++        &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select sample rate from audio: 0x%02X", __func__,
++          result_config_cie.sampleRate);
++      break;
++    }
++
++    // No user preference - try the default config
++    if (select_best_sample_rate(
++        a2dp_lhdcv5_source_default_caps.sampleRate & sink_info_cie.sampleRate,
++        &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select sample rate from default: 0x%02X", __func__,
++          result_config_cie.sampleRate);
++      break;
++    }
++
++    // No user preference - use the best match
++    if (select_best_sample_rate(sampleRate, &result_config_cie,
++        &codec_config_)) {
++      LOG_DEBUG( "%s: select sample rate from best match: 0x%02X", __func__,
++          result_config_cie.sampleRate);
++      break;
++    }
++  } while (false);
++
++  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
++    LOG_ERROR(
++        "%s: cannot match sample frequency: local caps = 0x%02X "
++        "peer info = 0x%02X",
++        __func__, p_a2dp_lhdcv5_caps->sampleRate, sink_info_cie.sampleRate);
++    goto fail;
++  }
++  LOG_DEBUG( "%s: => sample rate(0x%02X) = %s", __func__,
++      result_config_cie.sampleRate,
++      lhdcV5_sampleRate_toString(result_config_cie.sampleRate).c_str());
++
++  //
++  // Select the bits per sample
++  //
++  bitsPerSample = p_a2dp_lhdcv5_caps->bitsPerSample & sink_info_cie.bitsPerSample;
++  LOG_DEBUG( "%s: bitsPerSample:{peer:0x%02X local:0x%02X result:0x%02X}",
++      __func__, sink_info_cie.bitsPerSample, p_a2dp_lhdcv5_caps->bitsPerSample, bitsPerSample);
++
++  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++  switch (codec_user_config_.bits_per_sample) {
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
++      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
++      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++    }
++    break;
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
++      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
++      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++    }
++    break;
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
++      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
++      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
++      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
++    }
++    break;
++  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
++    result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_NS;
++    codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++    codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
++    break;
++  }
++
++  // Select the bits per sample if there is no user preference
++  do {
++    // Compute the selectable capability
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
++      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
++      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
++      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++
++    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
++      LOG_DEBUG( "%s: bit_per_sample configured successfully 0x%02X",
++          __func__, result_config_cie.bitsPerSample);
++      break;
++    }
++    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
++
++    // Compute the common capability
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
++      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++
++    // No user preference - the the codec audio config
++    if (select_audio_bits_per_sample(&codec_audio_config_, bitsPerSample,
++        &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select bit per sample from audio: 0x%02X", __func__,
++          result_config_cie.bitsPerSample);
++      break;
++    }
++
++    // No user preference - try the default config
++    if (select_best_bits_per_sample(
++        a2dp_lhdcv5_source_default_caps.bitsPerSample & sink_info_cie.bitsPerSample,
++        &result_config_cie, &codec_config_)) {
++      LOG_DEBUG( "%s: select bit per sample from default: 0x%02X", __func__,
++          result_config_cie.bitsPerSample);
++      break;
++    }
++
++    // No user preference - use the best match
++    if (select_best_bits_per_sample(bitsPerSample, &result_config_cie,
++        &codec_config_)) {
++      LOG_DEBUG( "%s: select sample rate from best match: 0x%02X", __func__,
++          result_config_cie.bitsPerSample);
++      break;
++    }
++  } while (false);
++
++  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
++    LOG_ERROR(
++        "%s: cannot match bits per sample: local caps = 0x%02X "
++        "peer info = 0x%02X",
++        __func__, p_a2dp_lhdcv5_caps->bitsPerSample,
++        sink_info_cie.bitsPerSample);
++    goto fail;
++  }
++  LOG_DEBUG( "%s: => bit per sample(0x%02X) = %s", __func__,
++      result_config_cie.bitsPerSample,
++      lhdcV5_bitPerSample_toString(result_config_cie.bitsPerSample).c_str());
++
++  // Select the channel mode
++  codec_user_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++  LOG_DEBUG( "%s: channelMode = Only supported stereo", __func__);
++
++  // Update frameLenType
++  result_config_cie.frameLenType = sink_info_cie.frameLenType;
++  LOG_DEBUG( "%s: => frame length type(0x%02X) = %s", __func__,
++      result_config_cie.frameLenType,
++      lhdcV5_frameLenType_toString(result_config_cie.frameLenType).c_str());
++
++  // Update maxTargetBitrate
++  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
++  LOG_DEBUG( "%s: => peer Max Bit Rate(0x%02X) = %s", __func__,
++      result_config_cie.maxTargetBitrate,
++      lhdcV5_MaxTargetBitRate_toString(result_config_cie.maxTargetBitrate).c_str());
++
++  // Update minTargetBitrate
++  result_config_cie.minTargetBitrate = sink_info_cie.minTargetBitrate;
++  LOG_DEBUG( "%s: => peer Min Bit Rate(0x%02X) = %s", __func__,
++      result_config_cie.minTargetBitrate,
++      lhdcV5_MinTargetBitRate_toString(result_config_cie.minTargetBitrate).c_str());
++
++  //
++  // Update Feature/Capabilities to A2DP specifics
++  //
++  /*******************************************
++   * for features that can be enabled by user-control, exam features tag on the specific.
++   * current user-control enabling features:
++   *    Feature: AR
++   *    Feature: LL
++   *******************************************/
++  //features on specific 3
++  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
++  {
++    // reset the specific and apply tag
++    codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
++
++    // get previous status of user-control enabling features from codec_config, then restore to user settings
++    //
++    // Feature: AR
++    hasUserSet = A2DP_IsFeatureInCodecConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
++    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++        &allCfgPack,
++        LHDCV5_FEATURE_CODE_AR,
++        A2DP_LHDC_TO_A2DP_CODEC_USER_,
++        (hasUserSet?true:false));
++    LOG_DEBUG( "%s: LHDC features tag check fail, reset UI status[AR] => %s", __func__, hasUserSet?"true":"false");
++  }
++
++  /*************************************************
++   *  quality mode: caps-control enabling
++   *************************************************/
++  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_ABR;
++    LOG_DEBUG( "%s: tag not match, use default Quality Mode: ABR", __func__);
++  }
++  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDCV5_QUALITY_MASK;
++
++  /*******************************************
++   *  JAS: caps-control enabling
++   *******************************************/
++  {
++    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureJAS & sink_info_cie.hasFeatureJAS);
++    // reset first
++    result_config_cie.hasFeatureJAS = false;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++        &allCfgPack,
++        LHDCV5_FEATURE_CODE_JAS,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ |
++            A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++            false);
++    // update
++    hasUserSet = true;  //caps-control enabling case => always true
++    if (hasFeature && hasUserSet) {
++      result_config_cie.hasFeatureJAS = true;
++      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++          &allCfgPack,
++          LHDCV5_FEATURE_CODE_JAS,
++          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
++              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
++              true);
++    }
++    LOG_DEBUG( "%s: featureJAS: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
++        (result_config_cie.hasFeatureJAS?"Y":"N"),
++        sink_info_cie.hasFeatureJAS,
++        p_a2dp_lhdcv5_caps->hasFeatureJAS,
++        (hasUserSet?"Y":"N"));
++  }
++
++  /*******************************************
++   *  AR: user-control/peer-OTA control enabling
++   *******************************************/
++  {
++    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureAR & sink_info_cie.hasFeatureAR);
++    // reset first
++    result_config_cie.hasFeatureAR = false;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++        &allCfgPack,
++        LHDCV5_FEATURE_CODE_AR,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        false);
++    // update
++    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
++
++    // default AR turning on condition: (customizable)
++    //  1. both sides have the capabilities
++    //  2. (UI on SRC side turns on) || (SNK set AR_ON in codec info)
++    if (hasFeature && (hasUserSet || sink_info_cie.featureOnAR)) {
++      result_config_cie.hasFeatureAR = true;  //decide to turn on feature in encoder
++      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++          &allCfgPack,
++          LHDCV5_FEATURE_CODE_AR,
++          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
++              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
++              true);
++
++      // reconfigure (48KHz sample rate + 24 bits per sample) to run AR
++      if (codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
++        codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++        codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++        codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++        result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
++        LOG_DEBUG( "%s: set 48KHz sample Rate for running AR", __func__);
++      }
++
++      if (codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
++        codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++        result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
++        LOG_DEBUG( "%s: set 24 bits per sample 24 for running AR", __func__);
++      }
++    }
++    LOG_DEBUG( "%s: featureAR: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s AR_ON:%s}", __func__,
++        (result_config_cie.hasFeatureAR?"Y":"N"),
++        sink_info_cie.hasFeatureAR,
++        p_a2dp_lhdcv5_caps->hasFeatureAR,
++        (hasUserSet?"Y":"N"),
++        (sink_info_cie.featureOnAR)?"Y":"N");
++  }
++
++  /*******************************************
++   *  META: caps-control enabling
++   *******************************************/
++  {
++    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureMETA & sink_info_cie.hasFeatureMETA);
++    // reset first
++    result_config_cie.hasFeatureMETA = false;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++        &allCfgPack,
++        LHDCV5_FEATURE_CODE_META,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        false);
++    // update
++    hasUserSet = true;  //caps-control enabling, always true
++    if (hasFeature && hasUserSet) {
++      result_config_cie.hasFeatureMETA = true;
++      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++          &allCfgPack,
++          LHDCV5_FEATURE_CODE_META,
++          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
++              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
++              true);
++    }
++    LOG_DEBUG( "%s: featureMETA: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
++        (result_config_cie.hasFeatureMETA?"Y":"N"),
++        sink_info_cie.hasFeatureMETA,
++        p_a2dp_lhdcv5_caps->hasFeatureMETA,
++        (hasUserSet?"Y":"N"));
++  }
++
++  /*******************************************
++   *  Low Latency: user-control enabling
++   *******************************************/
++  {
++    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLL & sink_info_cie.hasFeatureLL);
++    // reset first
++    result_config_cie.hasFeatureLL = false;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++        &allCfgPack,
++        LHDCV5_FEATURE_CODE_LL,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        false);
++    // update
++    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LL);
++    if (hasFeature && hasUserSet) {
++      result_config_cie.hasFeatureLL = true;
++      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++          &allCfgPack,
++          LHDCV5_FEATURE_CODE_LL,
++          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
++              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
++              true);
++    }
++    LOG_DEBUG( "%s: featureLL: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
++        (result_config_cie.hasFeatureLL?"Y":"N"),
++        sink_info_cie.hasFeatureLL,
++        p_a2dp_lhdcv5_caps->hasFeatureLL,
++        (hasUserSet?"Y":"N"));
++  }
++
++  /*******************************************
++   *  LLESS: caps-control enabling
++   *******************************************/
++  {
++    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLLESS & sink_info_cie.hasFeatureLLESS);
++    // reset first
++    result_config_cie.hasFeatureLLESS = false;
++    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++        &allCfgPack,
++        LHDCV5_FEATURE_CODE_LLESS,
++        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
++        false);
++    // update
++    //hasUserSet = true;  //caps-control enabling, always true
++    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS);  //UI-control
++    if (hasFeature && hasUserSet) {
++      result_config_cie.hasFeatureLLESS = true;
++      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
++          &allCfgPack,
++          LHDCV5_FEATURE_CODE_LLESS,
++          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
++              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
++              true);
++    }
++    LOG_DEBUG( "%s: featureLLESS: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
++        (result_config_cie.hasFeatureLLESS?"Y":"N"),
++        sink_info_cie.hasFeatureLLESS,
++        p_a2dp_lhdcv5_caps->hasFeatureLLESS,
++        (hasUserSet?"Y":"N"));
++  }
++
++
++  //
++  // quality mode re-adjustion in non-ABR cases
++  //
++  if (qualityMode != A2DP_LHDCV5_QUALITY_ABR) {
++    // get corresponding quality mode of the max target bit rate
++    if (!A2DP_MaxBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
++      LOG_ERROR( "%s: get quality mode from maxTargetBitrate error", __func__);
++      goto fail;
++    }
++    // downgrade audio quality according to the max target bit rate
++    if (qualityMode > bitRateQmode) {
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
++      qualityMode = bitRateQmode;
++      LOG_DEBUG( "%s: downgrade quality mode to 0x%02X", __func__, qualityMode);
++    }
++
++    // get corresponding quality mode of the min target bit rate
++    if (!A2DP_MinBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.minTargetBitrate)) {
++      LOG_ERROR( "%s: get quality mode from minTargetBitrate error", __func__);
++      goto fail;
++    }
++    // upgrade audio quality according to the min target bit rate
++    if (qualityMode < bitRateQmode) {
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
++      qualityMode = bitRateQmode;
++      LOG_DEBUG( "%s: upgrade quality mode to 0x%02X", __func__, qualityMode);
++    }
++
++    // specification rule: if sample rate >= 96KHz && qualityMode < 256kbps,
++    //  upgrade qualityMode to 256Kbps(LOW3)
++    if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_96000 ||
++        result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++      if (qualityMode < A2DP_LHDCV5_QUALITY_LOW3) {
++        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_LOW3;
++        qualityMode = A2DP_LHDCV5_QUALITY_LOW3;
++        LOG_DEBUG( "%s: upgrade quality mode to 0x%02X due to higher sample rates", __func__, qualityMode);
++      }
++    }
++
++    // specification rule: if (sample rate == 44.1/48KHz && qualityMode == 1000kbps(HIGH 1)),
++    //  downgrade qualityMode to 900kbps(HIGH)
++    if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_44100 ||
++        result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++      if (qualityMode == A2DP_LHDCV5_QUALITY_HIGH1) {
++        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_HIGH;
++        qualityMode = A2DP_LHDCV5_QUALITY_HIGH;
++        LOG_DEBUG( "%s: downgrade quality mode to 0x%02X due to lower sample rates", __func__, qualityMode);
++      }
++    }
++  }
++
++  LOG_DEBUG( "%s: => final quality mode(0x%02X) = %s", __func__,
++      qualityMode,
++      lhdcV5_QualityModeBitRate_toString(qualityMode).c_str());
++
++  /* Setup final nego result config to peer */
++  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
++      p_result_codec_config) != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: A2DP build info fail", __func__);
++    goto fail;
++  }
++
++  //
++  // Copy the codec-specific fields if they are not zero
++  //
++  if (codec_user_config_.codec_specific_1 != 0)
++    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
++  if (codec_user_config_.codec_specific_2 != 0)
++    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
++  if (codec_user_config_.codec_specific_3 != 0)
++    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
++  if (codec_user_config_.codec_specific_4 != 0)
++    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
++
++  // Create a local copy of the peer codec capability, and the
++  // result codec config.
++  if (is_capability) {
++    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
++        ota_codec_peer_capability_);
++  } else {
++    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
++        ota_codec_peer_config_);
++  }
++  CHECK(status == A2DP_SUCCESS);
++
++  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
++      ota_codec_config_);
++  CHECK(status == A2DP_SUCCESS);
++  return true;
++
++  fail:
++  // Restore the internal state
++  codec_config_ = saved_codec_config;
++  codec_capability_ = saved_codec_capability;
++  codec_selectable_capability_ = saved_codec_selectable_capability;
++  codec_user_config_ = saved_codec_user_config;
++  codec_audio_config_ = saved_codec_audio_config;
++  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
++  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
++      sizeof(ota_codec_peer_capability_));
++  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
++      sizeof(ota_codec_peer_config_));
++  return false;
++}
++
++bool A2dpCodecConfigLhdcV5Base::setPeerCodecCapabilities(
++    const uint8_t* p_peer_codec_capabilities) {
++  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
++  tA2DP_LHDCV5_CIE peer_info_cie;
++  uint8_t sampleRate;
++  uint8_t bits_per_sample;
++  tA2DP_STATUS status;
++  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
++      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
++
++  // Save the internal state
++  btav_a2dp_codec_config_t saved_codec_selectable_capability =
++      codec_selectable_capability_;
++  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
++  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
++      sizeof(ota_codec_peer_capability_));
++
++  if (p_peer_codec_capabilities == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    goto fail;
++  }
++
++  status = A2DP_ParseInfoLhdcV5(&peer_info_cie, p_peer_codec_capabilities, true, IS_SRC);
++  if (status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
++        __func__, status);
++    goto fail;
++  }
++
++  // Compute the selectable capability - sample rate
++  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & peer_info_cie.sampleRate;
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++    codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
++  }
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++    codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
++  }
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++    codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
++  }
++  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++    codec_selectable_capability_.sample_rate |=
++        BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++  }
++
++  // Compute the selectable capability - bits per sample
++  bits_per_sample = p_a2dp_lhdcv5_caps->bitsPerSample & peer_info_cie.bitsPerSample;
++  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_16) {
++    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
++  }
++  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_24) {
++    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
++  }
++  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_32) {
++    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
++  }
++
++  // Compute the selectable capability - channel mode
++  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
++
++  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
++      ota_codec_peer_capability_);
++  CHECK(status == A2DP_SUCCESS);
++  return true;
++
++  fail:
++  // Restore the internal state
++  codec_selectable_capability_ = saved_codec_selectable_capability;
++  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
++      sizeof(ota_codec_peer_capability_));
++  return false;
++}
++
++////////
++// LHDC Extended API Start
++////////
++static bool swapInt64toByteArray(uint8_t *byteArray, int64_t integer64) {
++  if (byteArray == nullptr) {
++    LOG_DEBUG( "%s: null ptr", __func__);
++    return false;
++  }
++
++  byteArray[7] = ((integer64 & 0x00000000000000FF) >> 0);
++  byteArray[6] = ((integer64 & 0x000000000000FF00) >> 8);
++  byteArray[5] = ((integer64 & 0x0000000000FF0000) >> 16);
++  byteArray[4] = ((integer64 & 0x00000000FF000000) >> 24);
++  byteArray[3] = ((integer64 & 0x000000FF00000000) >> 32);
++  byteArray[2] = ((integer64 & 0x0000FF0000000000) >> 40);
++  byteArray[1] = ((integer64 & 0x00FF000000000000) >> 48);
++  byteArray[0] = ((integer64 & 0xFF00000000000000) >> 56);
++
++  return true;
++}
++
++static bool A2DP_LhdcV5GetFeatureInfoV2(uint8_t *featVector) {
++  uint8_t featNum = 0, idx = 0;
++
++  if(featVector == nullptr) {
++    LOG_DEBUG( "%s: null buffer!", __func__);
++    return false;
++  }
++
++  featNum = (sizeof(a2dp_lhdcv5_source_spec_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
++  if (featNum <= 0) {
++    //LOG_DEBUG( "%s: no any features recorded in specifics, nothing to do", __func__);
++    return true;
++  }
++
++  /* 2 bytes per info tuple
++   *  byte0:      featureCode
++   *  byte1[7-6]: inSpecBank
++   *  byte1[5-0]: bitPos in decimal(0~31)
++   */
++  for(int i=0; i<featNum; i++) {
++    featVector[idx] = a2dp_lhdcv5_source_spec_all[i].featureCode;
++    featVector[idx + 1] = (a2dp_lhdcv5_source_spec_all[i].inSpecBank | a2dp_lhdcv5_source_spec_all[i].bitPos);
++    idx += 2;
++  }
++
++  return true;
++}
++
++static bool A2DP_LhdcV5GetA2DPSpecificV2(btav_a2dp_codec_config_t *a2dpCfg,
++    uint8_t *buf, uint32_t len) {
++  if (len < LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2) {
++    LOG_DEBUG( "%s: payload size too small %d ",__func__, len);
++    return false;
++  }
++
++  /* retrieve specifics value */
++  if ( !(
++      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2], a2dpCfg->codec_specific_1) &&
++      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2], a2dpCfg->codec_specific_2) &&
++      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2], a2dpCfg->codec_specific_3) &&
++      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2], a2dpCfg->codec_specific_4)
++  )) {
++    LOG_DEBUG( "%s: copy specifics error",  __func__);
++    return false;
++  }
++
++  /* retrieve bitmap info of LHDCv5 features */
++  if (!A2DP_LhdcV5GetFeatureInfoV2(&buf[LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2])) {
++    LOG_DEBUG( "%s: get feature info error!",  __func__);
++    return false;
++  }
++  return true;
++}
++
++static int A2DP_getEncoderExtendFuncA2DPTypeLhdcV5(A2dpCodecConfig* codecCfg,
++    uint8_t *buf, uint32_t buflen) {
++  btav_a2dp_codec_config_t codec_config_tmp;
++  uint32_t exFuncVer = 0;
++  uint32_t exFuncCode = 0;
++
++  //check buf size
++  if (buflen < (LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE + LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE)) {
++    LOG_DEBUG( "%s: buf len too small %d",  __func__, buflen);
++    return BT_STATUS_FAIL;
++  }
++
++  exFuncVer = (((unsigned int) buf[3]) & ((unsigned int)0xff)) |
++      ((((unsigned int) buf[2]) & ((unsigned int)0xff)) << 8)  |
++      ((((unsigned int) buf[1]) & ((unsigned int)0xff)) << 16) |
++      ((((unsigned int) buf[0]) & ((unsigned int)0xff)) << 24);
++  exFuncCode = (((unsigned int) buf[7]) & ((unsigned int)0xff)) |
++      ((((unsigned int) buf[6]) & ((unsigned int)0xff)) << 8)  |
++      ((((unsigned int) buf[5]) & ((unsigned int)0xff)) << 16) |
++      ((((unsigned int) buf[4]) & ((unsigned int)0xff)) << 24);
++
++  switch (exFuncCode) {
++  case LHDCV5_EXTEND_API_A2DP_SPEC_CODE:
++    switch(buf[LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD]) {
++    case LHDCV5_EXTEND_API_A2DP_SPEC_CFG:
++      codec_config_tmp = codecCfg->getCodecConfig();
++      break;
++    case LHDCV5_EXTEND_API_A2DP_SPEC_CAP:
++      codec_config_tmp = codecCfg->getCodecCapability();
++      break;
++    case LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP:
++      codec_config_tmp = codecCfg->getCodecLocalCapability();
++      break;
++    case LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP:
++      codec_config_tmp = codecCfg->getCodecSelectableCapability();
++      break;
++    case LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG:
++      codec_config_tmp = codecCfg->getCodecUserConfig();
++      break;
++    case LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG:
++      codec_config_tmp = codecCfg->getCodecAudioConfig();
++      break;
++    default:
++      LOG_DEBUG( "%s: unknown a2dp codec config",  __func__);
++      return BT_STATUS_FAIL;
++    }
++    break;
++    default:
++      LOG_DEBUG( "%s: invalid ext API command(0x%X)",  __func__, exFuncCode);
++      return BT_STATUS_FAIL;
++  }
++
++  switch (exFuncVer) {
++  case LHDCV5_EXTEND_API_A2DP_SPEC_VER2:
++    if (!A2DP_LhdcV5GetA2DPSpecificV2(&codec_config_tmp, buf, buflen)) {
++      LOG_DEBUG( "%s: get specifics error",  __func__);
++      return BT_STATUS_FAIL;
++    }
++    break;
++  default:
++    LOG_DEBUG( "%s: invalid ext API version(0x%X)",  __func__, exFuncVer);
++    return BT_STATUS_FAIL;
++  }
++
++  return BT_STATUS_SUCCESS;
++}
++
++int A2dpCodecConfigLhdcV5Base::getLhdcExtendAPIVersion(A2dpCodecConfig* peerCodec,
++    const char* buf, const int clen) {
++  int result = BT_STATUS_FAIL;
++
++  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
++    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
++    return BT_STATUS_FAIL;
++  }
++
++  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
++      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
++
++  if (is_source_) {
++    result = A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(buf, clen);
++  } else {
++    LOG_DEBUG( "%s: sink not supported", __func__);
++    return BT_STATUS_FAIL;
++  }
++
++  return result;
++}
++
++int A2dpCodecConfigLhdcV5Base::getLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec,
++    const char* buf, const int clen) {
++  int result = BT_STATUS_FAIL;
++  uint8_t *pucBuf = (uint8_t *) buf;
++
++  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
++    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
++    return BT_STATUS_FAIL;
++  }
++
++  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
++      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
++
++  if (is_source_) {
++    if (buf[LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD] == LHDCV5_EXTEND_API_CODE_A2DP_TYPE ) {
++      result = A2DP_getEncoderExtendFuncA2DPTypeLhdcV5(peerCodec, pucBuf, (uint32_t)clen);
++    } else if (buf[LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD] == LHDCV5_EXTEND_API_CODE_LIB_TYPE ){
++      result = A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(buf, clen);
++    }
++  } else {
++    LOG_DEBUG( "%s: sink not supported", __func__);
++    return BT_STATUS_FAIL;
++  }
++
++  return result;
++}
++
++int A2dpCodecConfigLhdcV5Base::setLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec,
++    const char* buf, const int clen) {
++  int result = BT_STATUS_FAIL;
++
++  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
++    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
++    return BT_STATUS_FAIL;
++  }
++
++  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
++      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
++
++  if (is_source_) {
++    result = A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(buf, clen);
++  } else {
++    LOG_DEBUG( "%s: sink not supported", __func__);
++    return BT_STATUS_FAIL;
++  }
++
++  return result;
++}
++
++bool A2dpCodecConfigLhdcV5Base::setLhdcExtendAPIData(A2dpCodecConfig* peerCodec,
++    const char* buf, const int clen) {
++
++  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
++    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
++    return BT_STATUS_FAIL;
++  }
++
++  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
++      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
++
++  if (is_source_) {
++    A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(buf, clen);
++    return true;
++  } else {
++    LOG_DEBUG( "%s: sink not supported", __func__);
++    return false;
++  }
++}
++////////
++// LHDC Extended API End
++////////
++
++////////
++//    class implementation for LHDC V5 Sink
++////////
++A2dpCodecConfigLhdcV5Sink::A2dpCodecConfigLhdcV5Sink(
++    btav_a2dp_codec_priority_t codec_priority)
++: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
++    A2DP_VendorCodecIndexStrLhdcV5Sink(),
++    codec_priority, false) {}
++
++A2dpCodecConfigLhdcV5Sink::~A2dpCodecConfigLhdcV5Sink() {}
++
++bool A2dpCodecConfigLhdcV5Sink::init() {
++  if (!isValid()) return false;
++
++  // Load the decoder
++  if (!A2DP_VendorLoadDecoderLhdcV5()) {
++    LOG_ERROR( "%s: cannot load the decoder", __func__);
++    return false;
++  }
++
++  return true;
++}
++
++bool A2dpCodecConfigLhdcV5Sink::useRtpHeaderMarkerBit() const {
++  // TODO: This method applies only to Source codecs
++  return false;
++}
++
++bool A2dpCodecConfigLhdcV5Sink::updateEncoderUserConfig(
++    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
++    UNUSED_ATTR bool* p_config_updated) {
++  // TODO: This method applies only to Source codecs
++  return false;
++}
++
++uint64_t A2dpCodecConfigLhdcV5Sink::encoderIntervalMs() const {
++  // TODO: This method applies only to Source codecs
++  return 0;
++}
++
++int A2dpCodecConfigLhdcV5Sink::getEffectiveMtu() const {
++  // TODO: This method applies only to Source codecs
++  return 0;
++}
++
++////////
++//    APIs for calling from encoder/decoder module - START
++////////
++bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++
++  switch (lhdc_cie.maxTargetBitrate) {
++  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_HIGH1;
++    return true;
++  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_HIGH;
++    return true;
++  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_MID;
++    return true;
++  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW;
++    return true;
++  }
++
++  return false;
++}
++
++bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++
++  switch (lhdc_cie.minTargetBitrate) {
++  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW;
++    return true;
++  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW3;
++    return true;
++  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW1;
++    return true;
++  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
++    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW0;
++    return true;
++  }
++
++  return false;
++}
++
++bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++
++  *retval = (uint32_t)lhdc_cie.version;
++
++  return true;
++}
++
++bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++
++  *retval = (uint32_t)lhdc_cie.bitsPerSample;
++
++  return true;
++}
++
++bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++  *retval = lhdc_cie.hasFeatureJAS ? 1 : 0;
++
++  return true;
++}
++
++bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++  *retval = lhdc_cie.hasFeatureAR ? 1 : 0;
++
++  return true;
++}
++
++bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++  *retval = lhdc_cie.hasFeatureMETA ? 1 : 0;
++
++  return true;
++}
++
++//orig A2DP_VendorGetLowLatencyStateLhdcV5
++bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
++  tA2DP_LHDCV5_CIE lhdc_cie;
++  tA2DP_STATUS a2dp_status;
++
++  if (p_codec_info == nullptr || retval == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  // Check whether the codec info contains valid data
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
++        a2dp_status);
++    return false;
++  }
++  *retval = lhdc_cie.hasFeatureLL ? 1 : 0;
++
++  return true;
++}
++////////
++//    APIs for calling from encoder/decoder module - END
++////////
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
+new file mode 100644
+index 000000000..0202c7773
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
+@@ -0,0 +1,568 @@
++/*
++ * Copyright (C) 2022 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#define LOG_TAG "a2dp_vendor_lhdcv5_decoder"
++
++#include "a2dp_vendor_lhdcv5_decoder.h"
++
++#include <dlfcn.h>
++#include <inttypes.h>
++#include <pthread.h>
++#include <stdio.h>
++#include <string.h>
++
++#include <lhdcv5BT_dec.h>
++
++#include "bt_common.h"
++#include "common/time_util.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++
++
++#define A2DP_LHDC_FUNC_DISABLE		0
++#define A2DP_LHDC_FUNC_ENABLE		1
++
++#define LHDCV5_DEC_MAX_SAMPLES_PER_FRAME  256
++#define LHDCV5_DEC_MAX_CHANNELS           2
++#define LHDCV5_DEC_MAX_BIT_DEPTH          32
++#define LHDCV5_DEC_FRAME_NUM              16
++#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * \
++                                           LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * \
++                                           LHDCV5_DEC_MAX_CHANNELS * \
++                                           (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
++#define LHDCV5_DEC_PACKET_NUM             8
++#define LHDCV5_DEC_INPUT_BUF_BYTES        1024
++#define LHDCV5_DEC_PKT_HDR_BYTES          2
++
++typedef struct {
++  pthread_mutex_t mutex;
++  HANDLE_LHDCV5_BT lhdc_handle;
++  bool has_lhdc_handle;  // True if lhdc_handle is valid
++
++  uint32_t    sample_rate;
++  uint8_t     bits_per_sample;
++  lhdc_ver_t  version;
++  uint8_t     func_ar;
++  uint8_t     func_jas;
++  uint8_t     func_meta;
++
++  uint8_t     decode_buf[LHDCV5_DEC_PACKET_NUM][LHDCV5_DEC_BUF_BYTES];
++  uint32_t    dec_buf_idx;
++
++  uint8_t     dec_input_buf[LHDCV5_DEC_INPUT_BUF_BYTES];
++  uint32_t    dec_input_buf_bytes;
++
++  decoded_data_callback_t decode_callback;
++} tA2DP_LHDCV5_DECODER_CB;
++
++static tA2DP_LHDCV5_DECODER_CB a2dp_lhdcv5_decoder_cb;
++
++
++#define _V5DEC_REC_FILE_
++#if defined(_V5DEC_REC_FILE_)
++#define V5RAW_FILE_NAME "/sdcard/Download/lhdcv5dec.raw"
++#define V5PCM_FILE_NAME "/sdcard/Download/v5decoded.pcm"
++static FILE *rawFile = NULL;
++static FILE *pcmFile = NULL;
++#endif
++
++//
++// The LHDCV5 decoder shared library, and the functions to use
++//
++static const char* LHDC_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
++static void* lhdc_decoder_lib_handle = NULL;
++
++static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcv5BT_dec_init_decoder";
++typedef int32_t (*tLHDCDEC_INIT_DECODER)(HANDLE_LHDCV5_BT *handle,
++    tLHDCV5_DEC_CONFIG *config);
++
++static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME =
++    "lhdcv5BT_dec_check_frame_data_enough";
++typedef int32_t (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData,
++    uint32_t frameBytes, uint32_t *packetBytes);
++
++static const char* LHDCDEC_DECODE_NAME = "lhdcv5BT_dec_decode";
++typedef int32_t (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes,
++    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
++
++static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcv5BT_dec_deinit_decoder";
++typedef int32_t (*tLHDCDEC_DEINIT_DECODER)(HANDLE_LHDCV5_BT handle);
++
++static tLHDCDEC_INIT_DECODER lhdcv5dec_init_decoder;
++static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcv5dec_check_frame_data_enough;
++static tLHDCDEC_DECODE lhdcv5dec_decode;
++static tLHDCDEC_DEINIT_DECODER lhdcv5dec_deinit_decoder;
++
++// LHDC V5 Codec Info:
++//  ----------------------------------------------------------------
++//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
++//  losc | mediaType | codecType | vendorId | codecId | SampRate |
++//  ----------------------------------------------------------------
++//  P7[2:0]   | P7[5:4]    | P7[7:6]       | P8[3:0] | P8[4]       |
++//  bit depth | MaxBitRate | MinBitRate    | Version | FrameLen5ms |
++//  ----------------------------------------------------------------
++//  P9[0] | P9[1]  | P9[2]   | P9[6] | P9[7]       | P10[0]      |
++//  HasAR | HasJAS | HasMeta | HasLL | HasLossless | FeatureOnAR |
++//  ----------------------------------------------------------------
++#define A2DP_LHDCV5_CODEC_INFO_ATTR_1 (3+6)
++#define A2DP_LHDCV5_CODEC_INFO_ATTR_2 (3+7)
++#define A2DP_LHDCV5_CODEC_INFO_ATTR_3 (3+8)
++#define A2DP_LHDCV5_CODEC_INFO_ATTR_4 (3+9)
++
++
++bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info)
++{
++  if (p_codec_info == NULL) {
++    return false;
++  }
++
++  if (lhdc_decoder_lib_handle == NULL) {
++    return false;
++  }
++
++  // Sampling Frequency
++  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
++      A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++    a2dp_lhdcv5_decoder_cb.sample_rate = 44100;
++  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
++      A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++    a2dp_lhdcv5_decoder_cb.sample_rate = 48000;
++  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
++      A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++    a2dp_lhdcv5_decoder_cb.sample_rate = 96000;
++  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
++      A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++    a2dp_lhdcv5_decoder_cb.sample_rate = 192000;
++  } else {
++    return false;
++  }
++
++  // Bit Depth
++  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
++      A2DP_LHDCV5_BIT_FMT_16) {
++    a2dp_lhdcv5_decoder_cb.bits_per_sample = 16;
++  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
++      A2DP_LHDCV5_BIT_FMT_24) {
++    a2dp_lhdcv5_decoder_cb.bits_per_sample = 24;
++  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
++      A2DP_LHDCV5_BIT_FMT_32) {
++    a2dp_lhdcv5_decoder_cb.bits_per_sample = 32;
++  } else {
++    return false;
++  }
++
++  // version
++  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_3] &
++      A2DP_LHDCV5_VER_1) {
++    a2dp_lhdcv5_decoder_cb.version = VERSION_5;
++  } else {
++    return false;
++  }
++
++  // AR
++  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
++      A2DP_LHDCV5_FEATURE_AR) {
++    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
++  } else {
++    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
++  }
++
++  // JAS
++  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
++      A2DP_LHDCV5_FEATURE_JAS) {
++    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
++  } else {
++    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
++  }
++
++  // META
++  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
++      A2DP_LHDCV5_FEATURE_META) {
++    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
++  } else {
++    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
++  }
++
++  return true;
++}
++
++
++static void* load_func(const char* func_name) {
++
++  void* func_ptr = NULL;
++
++  if ((func_name == NULL) ||
++      (lhdc_decoder_lib_handle == NULL)) {
++    LOG_ERROR( "%s: null ptr", __func__);
++    return NULL;
++  }
++
++  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
++
++  if (func_ptr == NULL) {
++    LOG_ERROR(
++        "%s: cannot find function '%s' in the encoder library: %s",
++        __func__, func_name, dlerror());
++    A2DP_VendorUnloadDecoderLhdcV5();
++    return NULL;
++  }
++
++  return func_ptr;
++}
++
++
++bool A2DP_VendorLoadDecoderLhdcV5(void) {
++
++  if (lhdc_decoder_lib_handle != NULL) {
++    return true;  // Already loaded
++  }
++
++  // Initialize the control block
++  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
++
++  pthread_mutex_init(&(a2dp_lhdcv5_decoder_cb.mutex), NULL);
++
++  // Open the encoder library
++  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
++  if (lhdc_decoder_lib_handle == NULL) {
++    LOG_ERROR( "%s: cannot open LHDCV5 decoder library %s", __func__, dlerror());
++    return false;
++  }
++
++  // Load all functions
++  lhdcv5dec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
++  if (lhdcv5dec_init_decoder == NULL) return false;
++
++  lhdcv5dec_check_frame_data_enough =
++      (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
++  if (lhdcv5dec_check_frame_data_enough == NULL) return false;
++
++  lhdcv5dec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
++  if (lhdcv5dec_decode == NULL) return false;
++
++  lhdcv5dec_deinit_decoder =
++      (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
++  if (lhdcv5dec_deinit_decoder == NULL) return false;
++
++  LOG_DEBUG( "%s: LHDCV5 decoder library loaded", __func__);
++  return true;
++}
++
++
++void A2DP_VendorUnloadDecoderLhdcV5(void) {
++
++  a2dp_vendor_lhdcv5_decoder_cleanup();
++
++  pthread_mutex_destroy(&(a2dp_lhdcv5_decoder_cb.mutex));
++  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
++
++  lhdcv5dec_init_decoder = NULL;
++  lhdcv5dec_check_frame_data_enough = NULL;
++  lhdcv5dec_decode = NULL;
++  lhdcv5dec_deinit_decoder = NULL;
++
++  if (lhdc_decoder_lib_handle != NULL) {
++    dlclose(lhdc_decoder_lib_handle);
++    lhdc_decoder_lib_handle = NULL;
++  }
++
++#if defined(_V5DEC_REC_FILE_)
++  if (rawFile != NULL) {
++    fclose(rawFile);
++    rawFile = NULL;
++    remove(V5RAW_FILE_NAME);
++  }
++  if (pcmFile != NULL) {
++    fclose(pcmFile);
++    pcmFile = NULL;
++    remove(V5PCM_FILE_NAME);
++  }
++#endif
++  LOG_DEBUG( "%s: unload LHDC V5 decoder", __func__);
++}
++
++
++bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
++  int32_t api_ret;
++  tLHDCV5_DEC_CONFIG lhdcdec_config;
++
++  if ((lhdc_decoder_lib_handle == NULL) ||
++      (lhdcv5dec_init_decoder == NULL) ||
++      (lhdcv5dec_deinit_decoder == NULL)) {
++    return false;
++  }
++
++  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++
++  LOG_DEBUG( "%s: has_lhdc_handle(%d) handle_base (%p) handle(%p)", __func__,
++      a2dp_lhdcv5_decoder_cb.has_lhdc_handle,
++      &(a2dp_lhdcv5_decoder_cb.lhdc_handle),
++      a2dp_lhdcv5_decoder_cb.lhdc_handle);
++
++  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
++    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
++    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++      LOG_ERROR( "%s: fail to deinit decoder %d", __func__, api_ret);
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++      return false;
++    }
++    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
++    a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
++    LOG_DEBUG( "%s: handle cleaned", __func__);
++  }
++
++  lhdcdec_config.version = a2dp_lhdcv5_decoder_cb.version;
++  lhdcdec_config.sample_rate = a2dp_lhdcv5_decoder_cb.sample_rate;
++  lhdcdec_config.bits_depth = a2dp_lhdcv5_decoder_cb.bits_per_sample;
++  lhdcdec_config.bit_rate = 400000;  //TODO
++
++  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle == false &&
++      a2dp_lhdcv5_decoder_cb.lhdc_handle == NULL) {
++    LOG_DEBUG( "%s: to init decoder...", __func__);
++    api_ret = lhdcv5dec_init_decoder(&(a2dp_lhdcv5_decoder_cb.lhdc_handle), &lhdcdec_config);
++    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++      LOG_ERROR( "%s: falied to init decoder %d", __func__, api_ret);
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++      return false;
++    }
++    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = true;
++  }
++
++  a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
++  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
++  a2dp_lhdcv5_decoder_cb.decode_callback = decode_callback;
++
++#if defined(_V5DEC_REC_FILE_)
++  if (rawFile == NULL) {
++    rawFile = fopen(V5RAW_FILE_NAME,"wb");
++    LOG_DEBUG( "%s: create recode file = %p", __func__, rawFile);
++  }
++  if (pcmFile == NULL) {
++    pcmFile = fopen(V5PCM_FILE_NAME,"wb");
++    LOG_DEBUG( "%s: create recode file = %p", __func__, pcmFile);
++  }
++#endif
++
++  LOG_DEBUG( "%s: init LHDCV5 decoder success", __func__);
++
++  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  return true;
++}
++
++
++void a2dp_vendor_lhdcv5_decoder_cleanup(void) {
++  int32_t api_ret;
++
++  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++
++  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
++    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
++    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++      LOG_ERROR( "%s: fail to deinit LHDCV5 decoder %d", __func__, api_ret);
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++      return;
++    }
++  }
++
++  a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
++  a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
++
++  LOG_DEBUG( "%s: deinit LHDCV5 decoder success", __func__);
++  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++}
++
++
++bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
++  int32_t api_ret;
++  uint8_t *data;
++  size_t data_size;
++  uint32_t out_used = 0;
++  uint32_t dec_buf_idx;
++  uint8_t *ptr_src;
++  uint8_t *ptr_dst;
++  uint32_t packet_bytes;
++  uint32_t i;
++
++  LOG_DEBUG( "%s: enter", __func__);
++
++
++  if ((lhdc_decoder_lib_handle == NULL) ||
++      (lhdcv5dec_decode == NULL)) {
++    LOG_ERROR( "%s: lib not loaded!", __func__);
++    return false;
++  }
++
++  // check handle
++  if (!a2dp_lhdcv5_decoder_cb.has_lhdc_handle || !a2dp_lhdcv5_decoder_cb.lhdc_handle) {
++    LOG_ERROR( "%s: handle not existed!", __func__);
++    return false;
++  }
++
++  if (p_buf == NULL) {
++    return false;
++  }
++
++  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++
++  data = p_buf->data + p_buf->offset;
++  data_size = p_buf->len;
++
++  if (data_size == 0) {
++    LOG_ERROR( "%s: Empty packet", __func__);
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++    return false;
++  }
++
++
++  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
++  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
++    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
++  }
++
++#if defined(_V5DEC_REC_FILE_)
++  if (rawFile != NULL && data_size > 0) {
++    fwrite(data + LHDCV5_DEC_PKT_HDR_BYTES, sizeof(uint8_t),
++        data_size - LHDCV5_DEC_PKT_HDR_BYTES, rawFile);
++  }
++#endif
++
++  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES) {
++    // the data queued is useless
++    // discard them
++    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
++
++    if (data_size > LHDCV5_DEC_INPUT_BUF_BYTES)
++    {
++      // input data is too big (more than buffer size)!!
++      // just ingore it, and do nothing
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++      return true;
++    }
++  }
++
++  memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
++      data, data_size);
++  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
++
++  packet_bytes = 0;
++  api_ret = lhdcv5dec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
++      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
++      &packet_bytes);
++  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++    LOG_ERROR( "%s: fail to check frame data! %d", __func__, api_ret);
++    // clear the data in the input buffer
++    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++    return false;
++  }
++
++  if (packet_bytes != (a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes - LHDCV5_DEC_PKT_HDR_BYTES)) {
++    // strange!
++    // queued data is NOT exactly equal to one packet!
++    // maybe wrong data in buffer
++    // discard data queued previously, and save input data
++    LOG_ERROR( "%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)",
++        __func__, packet_bytes, a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes);
++
++    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
++    memcpy(&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
++        data,
++        data_size);
++    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++    return true;
++  }
++
++  out_used = sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]);
++  api_ret = lhdcv5dec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
++      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
++      a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
++      &out_used,
++      a2dp_lhdcv5_decoder_cb.bits_per_sample);
++
++  // finish decoding
++  // clear the data in the input buffer
++  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
++
++  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++    LOG_ERROR( "%s: fail to decode lhdc stream! %d", __func__, api_ret);
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++    return false;
++  }
++
++  if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 24) { //PCM_24_BIT_PACKCED
++    ptr_src = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
++    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
++
++    for (i = 0; i < (out_used >> 2) ; i++) {
++      *ptr_dst++ = *ptr_src++;
++      *ptr_dst++ = *ptr_src++;
++      *ptr_dst++ = *ptr_src++;
++      ptr_src++;
++    }
++    out_used = (out_used >> 2) * 3;
++  } else if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 32) {
++    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
++
++    for (i = 0; i < (out_used >> 2) ; i++) {
++      ptr_dst[3] = ptr_dst[2];
++      ptr_dst[2] = ptr_dst[1];
++      ptr_dst[1] = ptr_dst[0];
++      ptr_dst[0] = 0;
++      ptr_dst+=4;
++    }
++  }
++
++#if defined(_V5DEC_REC_FILE_)
++  if (pcmFile != NULL && out_used > 0 &&
++      out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
++    int write_bytes;
++    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
++        sizeof(uint8_t), out_used, pcmFile);
++  }
++#endif
++
++  a2dp_lhdcv5_decoder_cb.decode_callback(
++      reinterpret_cast<uint8_t*>(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]), out_used);
++
++  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  return true;
++}
++
++void a2dp_vendor_lhdcv5_decoder_start(void) {
++  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  LOG_DEBUG("%s", __func__);
++  // do nothing
++
++  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++}
++
++void a2dp_vendor_lhdcv5_decoder_suspend(void) {
++  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  LOG_DEBUG("%s", __func__);
++  // do nothing
++}
++
++void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info) {
++  if (p_codec_info == NULL) {
++    LOG_DEBUG("%s: p_codec_info is NULL", __func__);
++    return;
++  }
++  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  LOG_DEBUG("%s", __func__);
++  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
+new file mode 100644
+index 000000000..c21a825f6
+--- /dev/null
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
+@@ -0,0 +1,1260 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++#define LOG_TAG "a2dp_vendor_lhdcv5_encoder"
++#define ATRACE_TAG ATRACE_TAG_AUDIO
++
++#include "a2dp_vendor_lhdcv5_encoder.h"
++
++#ifndef OS_GENERIC
++#include <cutils/trace.h>
++#endif
++#include <dlfcn.h>
++#include <inttypes.h>
++#include <stdio.h>
++#include <string.h>
++
++#include <lhdcv5BT.h>
++
++#include "a2dp_vendor.h"
++#include "a2dp_vendor_lhdcv5.h"
++#include "bt_common.h"
++#include "common/time_util.h"
++#include "osi/include/log.h"
++#include "osi/include/osi.h"
++
++//
++// Encoder for LHDC Source Codec
++//
++
++#define LHDCV5_SRC_EXT_API_ENABLE // LHDC extended API implementation
++
++//
++// The LHDC encoder shared library, and the functions to use
++//
++static const char* LHDC_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
++static void* lhdc_encoder_lib_handle = nullptr;
++
++static const char* LHDC_GET_HANDLE_NAME = "lhdcv5BT_get_handle";
++typedef int32_t (*tLHDC_GET_HANDLE)(uint32_t version, HANDLE_LHDCV5_BT *hLhdcParam);
++
++static const char* LHDC_FREE_HANDLE_NAME = "lhdcv5BT_free_handle";
++typedef int32_t (*tLHDC_FREE_HANDLE)(HANDLE_LHDCV5_BT hLhdcParam);
++
++static const char* LHDC_GET_BITRATE_NAME = "lhdcv5BT_get_bitrate";
++typedef int32_t (*tLHDC_GET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *bitrate);
++
++static const char* LHDC_SET_BITRATE_NAME = "lhdcv5BT_set_bitrate";
++typedef int32_t (*tLHDC_SET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t bitrateInx);
++
++static const char* LHDC_SET_MAX_BITRATE_NAME = "lhdcv5BT_set_max_bitrate";
++typedef int32_t (*tLHDC_SET_MAX_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t maxBitrateInx);
++
++static const char* LHDC_SET_MIN_BITRATE_NAME = "lhdcv5BT_set_min_bitrate";
++typedef int32_t (*tLHDC_SET_MIN_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t minBitrateInx);
++
++static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcv5BT_adjust_bitrate";
++typedef int32_t (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t queueLength);
++
++static const char* LHDC_SET_EXT_FUNC = "lhdcv5BT_set_ext_func_state";
++typedef int32_t (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDCV5_BT hLhdcParam,
++    LHDCV5_EXT_FUNC_T field, bool enabled, void *priv, uint32_t privDataLen);
++
++static const char* LHDC_INIT_ENCODER_NAME = "lhdcv5BT_init_encoder";
++typedef int32_t (*tLHDC_INIT_ENCODER)(HANDLE_LHDCV5_BT hLhdcParam,
++    uint32_t samplingFreq, uint32_t bitsPerSample, uint32_t bitrateInx,
++    uint32_t mtu, uint32_t interval);
++
++static const char* LHDC_GET_BLOCK_SIZE = "lhdcv5BT_get_block_Size";
++typedef int32_t (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *samplesPerFrame);
++
++static const char* LHDC_ENCODE_NAME = "lhdcv5BT_encode";
++typedef int32_t (*tLHDC_ENCODE)(HANDLE_LHDCV5_BT hLhdcParam,
++    void *pInPcm, uint32_t pcmBytes, uint8_t *pOutBuf, uint32_t outBufBytes,
++    uint32_t *pOutByte, uint32_t *pOut_frames);
++
++//
++// LHDC extend function API
++//
++#ifdef LHDCV5_SRC_EXT_API_ENABLE
++static const char* LHDCV5_EXT_SET_CONFIG_NAME = "lhdcv5BT_set_user_exconfig";
++typedef int (*tLHDCV5_EXT_SET_CONFIG)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
++
++static const char* LHDCV5_EXT_GET_CONFIG_NAME = "lhdcv5BT_get_user_exconfig";
++typedef int (*tLHDCV5_EXT_GET_CONFIG)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
++
++static const char* LHDC_EXT_SET_DATA_NAME = "lhdcv5BT_set_user_exdata";
++typedef void (*tLHDCV5_EXT_SET_DATA)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
++
++static const char* LHDCV5_EXT_GET_APIVER_NAME = "lhdcv5BT_get_user_exApiver";
++typedef int (*tLHDCV5_EXT_GET_APIVER)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
++#endif
++
++static tLHDC_GET_HANDLE lhdc_get_handle;
++static tLHDC_FREE_HANDLE lhdc_free_handle;
++static tLHDC_GET_BITRATE lhdc_get_bitrate;
++static tLHDC_SET_BITRATE lhdc_set_bitrate;
++static tLHDC_SET_MAX_BITRATE lhdc_set_max_bitrate;
++static tLHDC_SET_MIN_BITRATE lhdc_set_min_bitrate;
++static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
++static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
++static tLHDC_INIT_ENCODER lhdc_init_encoder;
++static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
++static tLHDC_ENCODE lhdc_encode_func;
++
++//
++// LHDC extend function API
++//
++#ifdef LHDCV5_SRC_EXT_API_ENABLE
++static tLHDCV5_EXT_GET_APIVER lhdcv5_ext_get_ApiVer;
++static tLHDCV5_EXT_GET_CONFIG lhdcv5_ext_get_config;
++static tLHDCV5_EXT_SET_CONFIG lhdcv5_ext_set_config;
++static tLHDCV5_EXT_SET_DATA lhdcv5_ext_set_data;
++#endif
++
++// A2DP LHDC encoder interval in milliseconds
++#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
++#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
++
++// offset
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
++#else
++#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
++#endif
++
++typedef struct {
++  tA2DP_SAMPLE_RATE sample_rate;
++  uint32_t bits_per_sample;
++  uint32_t quality_mode_index;
++  uint32_t pcm_fmt;
++  uint32_t max_target_bitrate;
++  uint32_t min_target_bitrate;
++  uint8_t isLLEnabled;
++} tA2DP_LHDCV5_ENCODER_PARAMS;
++
++typedef struct {
++  uint32_t counter;
++  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
++  uint64_t last_frame_us;
++} tA2DP_LHDCV5_FEEDING_STATE;
++
++typedef struct {
++  uint64_t session_start_us;
++
++  uint32_t media_read_total_expected_packets;
++  uint32_t media_read_total_expected_reads_count;
++  uint32_t media_read_total_expected_read_bytes;
++
++  uint32_t media_read_total_dropped_packets;
++  uint32_t media_read_total_actual_reads_count;
++  uint32_t media_read_total_actual_read_bytes;
++} a2dp_lhdcv5_encoder_stats_t;
++
++typedef struct {
++  a2dp_source_read_callback_t read_callback;
++  a2dp_source_enqueue_callback_t enqueue_callback;
++  uint32_t TxAaMtuSize;
++  uint32_t TxQueueLength;
++
++  bool use_SCMS_T;
++  bool is_peer_edr;          // True if the peer device supports EDR
++  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
++  uint16_t peer_mtu;         // MTU of the A2DP peer
++  uint32_t timestamp;        // Timestamp for the A2DP frames
++
++  HANDLE_LHDCV5_BT lhdc_handle;
++  bool has_lhdc_handle;  // True if lhdc_handle is valid
++
++  tA2DP_FEEDING_PARAMS feeding_params;
++  tA2DP_LHDCV5_ENCODER_PARAMS lhdc_encoder_params;
++  tA2DP_LHDCV5_FEEDING_STATE lhdc_feeding_state;
++
++  a2dp_lhdcv5_encoder_stats_t stats;
++  uint32_t buf_seq;
++  uint32_t bytes_read;
++} tA2DP_LHDCV5_ENCODER_CB;
++
++#define _V5ENC_REC_FILE_
++#if defined(_V5ENC_REC_FILE_)
++#define V5ENC_RAW_NAME "/sdcard/Download/lhdcv5.raw"
++#define V5ENC_PCM_NAME     "/sdcard/Download/sourcev5.pcm"
++static FILE  *recFile = NULL;
++static FILE *pcmFile = NULL;
++#endif
++
++static tA2DP_LHDCV5_ENCODER_CB a2dp_lhdc_encoder_cb;
++
++static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
++    A2dpCodecConfig* a2dp_codec_config,
++    bool* p_restart_input,
++    bool* p_restart_output,
++    bool* p_config_updated);
++
++static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
++    uint8_t* num_of_frames,
++    uint64_t timestamp_us);
++
++static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame);
++
++static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
++
++static std::string quality_mode_index_to_name(uint32_t quality_mode_index);
++
++
++static void* load_func(const char* func_name) {
++  if(!func_name) return NULL;
++
++  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
++  if (func_ptr == NULL) {
++    LOG_ERROR(
++        "%s: cannot find function '%s' in the encoder library: %s",
++        __func__, func_name, dlerror());
++    if (!A2DP_VendorUnloadEncoderLhdcV5()) {
++      LOG_ERROR( "%s: unload encoder error", __func__);
++    }
++    return nullptr;
++  }
++  return func_ptr;
++}
++
++bool A2DP_VendorLoadEncoderLhdcV5(void) {
++  if (lhdc_encoder_lib_handle != nullptr) return true;  // Already loaded
++
++  // Initialize the control block
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  // Open the encoder library
++  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
++  if (lhdc_encoder_lib_handle == nullptr) {
++    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
++        LHDC_ENCODER_LIB_NAME, dlerror());
++    return false;
++  }
++
++  lhdc_get_handle = nullptr;
++  lhdc_free_handle = nullptr;
++  lhdc_get_bitrate = nullptr;
++  lhdc_set_bitrate = nullptr;
++  lhdc_set_max_bitrate = nullptr;
++  lhdc_set_min_bitrate = nullptr;
++  lhdc_auto_adjust_bitrate = nullptr;
++  lhdc_set_ext_func = nullptr;
++  lhdc_init_encoder = nullptr;
++  lhdc_get_block_size =nullptr;
++  lhdc_encode_func = nullptr;
++
++  //
++  // LHDC extend function API
++  //
++#ifdef LHDCV5_SRC_EXT_API_ENABLE
++  lhdcv5_ext_get_ApiVer = nullptr;
++  lhdcv5_ext_get_config = nullptr;
++  lhdcv5_ext_set_config = nullptr;
++  lhdcv5_ext_set_data = nullptr;
++#endif
++
++  // Load all APIs
++  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
++  if (lhdc_get_handle == nullptr) return false;
++  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
++  if (lhdc_free_handle == nullptr) return false;
++  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
++  if (lhdc_get_bitrate == nullptr) return false;
++  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
++  if (lhdc_set_bitrate == nullptr) return false;
++  lhdc_set_max_bitrate = (tLHDC_SET_MAX_BITRATE)load_func(LHDC_SET_MAX_BITRATE_NAME);
++  if (lhdc_set_max_bitrate == nullptr) return false;
++  lhdc_set_min_bitrate = (tLHDC_SET_MIN_BITRATE)load_func(LHDC_SET_MIN_BITRATE_NAME);
++  if (lhdc_set_min_bitrate == nullptr) return false;
++  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
++  if (lhdc_auto_adjust_bitrate == nullptr) return false;
++  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
++  if (lhdc_set_ext_func == nullptr) return false;
++  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
++  if (lhdc_init_encoder == nullptr) return false;
++  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
++  if (lhdc_get_block_size == nullptr) return false;
++  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
++  if (lhdc_encode_func == nullptr) return false;
++
++  //
++  // LHDC extend function API
++  //
++#ifdef LHDCV5_SRC_EXT_API_ENABLE
++  lhdcv5_ext_get_ApiVer = (tLHDCV5_EXT_GET_APIVER)load_func(LHDCV5_EXT_GET_APIVER_NAME);
++  if (lhdcv5_ext_get_ApiVer == nullptr) return false;
++  lhdcv5_ext_get_config = (tLHDCV5_EXT_GET_CONFIG)load_func(LHDCV5_EXT_GET_CONFIG_NAME);
++  if (lhdcv5_ext_get_config == nullptr) return false;
++  lhdcv5_ext_set_config = (tLHDCV5_EXT_SET_CONFIG)load_func(LHDCV5_EXT_SET_CONFIG_NAME);
++  if (lhdcv5_ext_set_config == nullptr) return false;
++  lhdcv5_ext_set_data = (tLHDCV5_EXT_SET_DATA)load_func(LHDC_EXT_SET_DATA_NAME);
++  if (lhdcv5_ext_set_data == nullptr) return false;
++#endif
++
++  return true;
++}
++
++bool A2DP_VendorUnloadEncoderLhdcV5(void) {
++  if (lhdc_encoder_lib_handle == nullptr) return true;  // Already unload
++
++  // Cleanup any LHDC-related state
++  LOG_DEBUG( "%s: has_lhdc_handle %d",
++      __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle);
++
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != nullptr) {
++    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
++    if (ret < 0) {
++      LOG_ERROR( "%s: free handle error %d", __func__, ret);
++      return false;
++    }
++  } else {
++    LOG_ERROR( "%s: unload encoder error", __func__);
++    return false;
++  }
++
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  lhdc_get_handle = nullptr;
++  lhdc_free_handle = nullptr;
++  lhdc_get_bitrate = nullptr;
++  lhdc_set_bitrate = nullptr;
++  lhdc_set_max_bitrate = nullptr;
++  lhdc_set_min_bitrate = nullptr;
++  lhdc_auto_adjust_bitrate = nullptr;
++  lhdc_set_ext_func = nullptr;
++  lhdc_init_encoder = nullptr;
++  lhdc_get_block_size =nullptr;
++  lhdc_encode_func = nullptr;
++
++  //
++  // LHDC extend function API
++  //
++#ifdef LHDCV5_SRC_EXT_API_ENABLE
++  lhdcv5_ext_get_ApiVer = nullptr;
++  lhdcv5_ext_get_config = nullptr;
++  lhdcv5_ext_set_config = nullptr;
++  lhdcv5_ext_set_data = nullptr;
++#endif
++
++  dlclose(lhdc_encoder_lib_handle);
++  lhdc_encoder_lib_handle = nullptr;
++
++  return true;
++}
++
++//tA2DP_ENCODER_INTERFACE::(encoder_init)
++void a2dp_vendor_lhdcv5_encoder_init(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    A2dpCodecConfig* a2dp_codec_config,
++    a2dp_source_read_callback_t read_callback,
++    a2dp_source_enqueue_callback_t enqueue_callback) {
++
++  if (p_peer_params == nullptr || a2dp_codec_config == nullptr ||
++      read_callback == nullptr || enqueue_callback == nullptr) {
++    LOG_ERROR( "%s: null input", __func__);
++    return;
++  }
++
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
++    if (ret < 0) {
++      LOG_ERROR( "%s: free handle error %d", __func__, ret);
++      return;
++    }
++  }
++
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
++
++  a2dp_lhdc_encoder_cb.read_callback = read_callback;
++  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
++  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
++  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
++  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
++  a2dp_lhdc_encoder_cb.timestamp = 0;
++
++
++  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
++#endif
++
++  // NOTE: Ignore the restart_input / restart_output flags - this initization
++  // happens when the connection is (re)started.
++  bool restart_input = false;
++  bool restart_output = false;
++  bool config_updated = false;
++  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
++      a2dp_codec_config, &restart_input,
++      &restart_output, &config_updated);
++}
++
++//
++// LHDC Extended API
++//
++#ifndef LHDCV5_SRC_EXT_API_ENABLE
++int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(const char* version, const int clen) {
++  return BT_STATUS_FAIL;
++}
++int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen) {
++  return BT_STATUS_FAIL;
++}
++int A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen) {
++  return BT_STATUS_FAIL;
++}
++bool A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(const char* codecData, const int clen) {
++  return false;
++}
++#else
++int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(const char* version, const int clen)
++{
++  if (version == nullptr) {
++    return BT_STATUS_FAIL;
++  }
++
++  if(lhdcv5_ext_get_ApiVer != nullptr) {
++    LOG_VERBOSE( "%s: lhdc_ext_API(GetApiVer): clen:%d", __func__, clen);
++    return lhdcv5_ext_get_ApiVer(a2dp_lhdc_encoder_cb.lhdc_handle, version, clen);
++  } else {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return BT_STATUS_FAIL;
++  }
++}
++
++int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
++{
++  if (userConfig == nullptr) {
++    return BT_STATUS_FAIL;
++  }
++
++  if(lhdcv5_ext_get_config != nullptr) {
++    LOG_VERBOSE( "%s: lhdc_ext_API(GetConfig): clen:%d", __func__, clen);
++    return lhdcv5_ext_get_config(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
++  } else {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return BT_STATUS_FAIL;
++  }
++}
++
++int A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
++{
++  if (userConfig == nullptr) {
++    return BT_STATUS_FAIL;
++  }
++
++  if(lhdcv5_ext_set_config != nullptr) {
++    LOG_VERBOSE( "%s: lhdc_ext_API(SetConfig): clen:%d", __func__, clen);
++    return lhdcv5_ext_set_config(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
++  } else {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return BT_STATUS_FAIL;
++  }
++}
++
++bool A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(const char* codecData, const int clen)
++{
++  if (codecData == nullptr) {
++    return BT_STATUS_FAIL;
++  }
++
++  if(lhdcv5_ext_set_data != nullptr) {
++    LOG_VERBOSE( "%s: lhdc_ext_API(SetData): clen:%d", __func__, clen);
++    lhdcv5_ext_set_data(a2dp_lhdc_encoder_cb.lhdc_handle, codecData, clen);
++    return true;
++  } else {
++    LOG_DEBUG( "%s: lib func not found", __func__);
++    return false;
++  }
++}
++#endif  //LHDCV5_SRC_EXT_API_ENABLE
++
++bool A2dpCodecConfigLhdcV5Source::updateEncoderUserConfig(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
++    bool* p_restart_output, bool* p_config_updated) {
++
++  if (p_peer_params == nullptr || p_restart_input == nullptr ||
++      p_restart_output == nullptr || p_config_updated == nullptr) {
++    LOG_ERROR( "%s: null input", __func__);
++    return false;
++  }
++
++  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
++  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
++  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
++  a2dp_lhdc_encoder_cb.timestamp = 0;
++
++  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
++    LOG_ERROR(
++        "%s: Cannot update the codec encoder for %s: "
++        "invalid peer MTU",
++        __func__, name().c_str());
++    return false;
++  }
++
++  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
++      p_restart_input, p_restart_output,
++      p_config_updated);
++  return true;
++}
++
++// wrap index mapping from bt stack to codec library
++static bool a2dp_vendor_lhdcv5_qualitymode_wrapper(uint32_t *out, uint32_t in) {
++  if (!out) return false;
++
++  switch(in) {
++  case A2DP_LHDCV5_QUALITY_ABR:
++    *out = LHDCV5_QUALITY_AUTO;
++    return true;
++  case A2DP_LHDCV5_QUALITY_HIGH1:
++    *out = LHDCV5_QUALITY_HIGH1;
++    return true;
++  case A2DP_LHDCV5_QUALITY_HIGH:
++    *out = LHDCV5_QUALITY_HIGH;
++    return true;
++  case A2DP_LHDCV5_QUALITY_MID:
++    *out = LHDCV5_QUALITY_MID;
++    return true;
++  case A2DP_LHDCV5_QUALITY_LOW:
++    *out = LHDCV5_QUALITY_LOW;
++    return true;
++  case A2DP_LHDCV5_QUALITY_LOW4:
++    *out = LHDCV5_QUALITY_LOW4;
++    return true;
++  case A2DP_LHDCV5_QUALITY_LOW3:
++    *out = LHDCV5_QUALITY_LOW3;
++    return true;
++  case A2DP_LHDCV5_QUALITY_LOW2:
++    *out = LHDCV5_QUALITY_LOW2;
++    return true;
++  case A2DP_LHDCV5_QUALITY_LOW1:
++    *out = LHDCV5_QUALITY_LOW1;
++    return true;
++  case A2DP_LHDCV5_QUALITY_LOW0:
++    *out = LHDCV5_QUALITY_LOW0;
++    return true;
++  }
++
++  return false;
++}
++
++
++// Update the A2DP LHDC encoder.
++// |peer_mtu| is the peer MTU.
++// |a2dp_codec_config| is the A2DP codec to use for the update.
++static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
++    A2dpCodecConfig* a2dp_codec_config,
++    bool* p_restart_input,
++    bool* p_restart_output,
++    bool* p_config_updated) {
++
++  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
++      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  uint8_t codec_info[AVDT_CODEC_SIZE];
++  uint32_t verCode = 0;
++  int32_t lib_ret = 0;
++  uint8_t ret_value8 = 0;
++  uint32_t mtu_size = 0;
++  uint32_t max_mtu_len = 0;
++  uint32_t newValue_bt = 0, newValue_lib = 0;
++  tA2DP_FEEDING_PARAMS* p_feeding_params;
++
++  const uint8_t *p_codec_info;
++
++  *p_restart_input = false;
++  *p_restart_output = false;
++  *p_config_updated = false;
++
++  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
++    LOG_ERROR(
++        "%s: Cannot update the codec encoder for %s: "
++        "invalid codec config",
++        __func__, a2dp_codec_config->name().c_str());
++    return;
++  }
++  p_codec_info = codec_info;
++
++  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
++  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
++
++  // get version
++  if (!A2DP_VendorGetVersionLhdcV5(&verCode, p_codec_info)) {
++    LOG_ERROR( "%s: get version error!", __func__);
++    goto fail;
++  }
++  LOG_DEBUG( "%s: get version: %d" , __func__, verCode);
++
++  // get new handle
++  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++    a2dp_lhdc_encoder_cb.lhdc_handle = nullptr;
++    lib_ret = lhdc_get_handle(verCode, &a2dp_lhdc_encoder_cb.lhdc_handle);
++    if (lib_ret != LHDCV5_FRET_SUCCESS) {
++      LOG_ERROR( "%s: [lib_ret] lhdc_get_handle error %d", __func__, lib_ret);
++      goto fail;
++    }
++
++    if (a2dp_lhdc_encoder_cb.lhdc_handle == nullptr) {
++      LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
++      goto fail;
++    }
++    a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
++  }
++  LOG_DEBUG( "%s: lhdc handle addr = %p", __func__, a2dp_lhdc_encoder_cb.lhdc_handle);
++
++  //
++  // setup feeding parameters for encoder feeding process
++  //
++  p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
++  // sample rate (uint32_t)
++  p_feeding_params->sample_rate = A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
++  if (p_feeding_params->sample_rate < 0) {
++    LOG_ERROR( "%s: get track sample rate error", __func__);
++    goto fail;
++  }
++
++  // bit per sample (uint8_t)
++  p_feeding_params->bits_per_sample = A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
++  if (p_feeding_params->bits_per_sample < 0) {
++    LOG_ERROR( "%s: get bit per sample error", __func__);
++    goto fail;
++  }
++
++  //channel count (uint8_t)
++  p_feeding_params->channel_count = A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
++  if (p_feeding_params->channel_count < 0) {
++    LOG_ERROR( "%s: get channel count error", __func__);
++    goto fail;
++  }
++  LOG_DEBUG( "%s: (feeding param) sample_rate=%u bits_per_sample=%u channel_count=%u",
++      __func__, p_feeding_params->sample_rate,
++      p_feeding_params->bits_per_sample,
++      p_feeding_params->channel_count);
++
++  //
++  // setup encoder parameters for configuring encoder
++  //
++  // sample rate tA2DP_SAMPLE_RATE(uint32_t)
++  p_encoder_params->sample_rate = a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
++
++  // default mtu size (uint32_t)
++  mtu_size = (BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR));
++  // allowed mtu size (uint32_t)
++  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : (uint32_t)peer_mtu;
++  // real mtu size (uint32_t)
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
++#else
++  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
++#endif
++
++  // max target bit rate
++  if (!A2DP_VendorGetMaxBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
++    LOG_ERROR( "%s: get max_target_bitrate error", __func__);
++    goto fail;
++  }
++  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
++    LOG_ERROR( "%s: wrap MBR qualiity mode error", __func__);
++    goto fail;
++  }
++  p_encoder_params->max_target_bitrate = newValue_lib;
++
++  // min target bit rate
++  if (!A2DP_VendorGetMinBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
++    LOG_ERROR( "%s: get min_target_bitrate error", __func__);
++    goto fail;
++  }
++  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
++    LOG_ERROR( "%s: wrap mBR qualiity mode error", __func__);
++    goto fail;
++  }
++  p_encoder_params->min_target_bitrate = newValue_lib;
++
++  // Low latency mode
++  if (!A2DP_VendorHasLLFlagLhdcV5(&(p_encoder_params->isLLEnabled), p_codec_info)){
++    LOG_ERROR( "%s: get Low latency enable error", __func__);
++    goto fail;
++  }
++
++  // bit per sample
++  switch((int)p_feeding_params->bits_per_sample) {
++  case 16:
++    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S16;
++    break;
++  case 24:
++    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S24;
++    break;
++  case 32:
++    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S32;
++    break;
++  }
++
++  // quality mode
++  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    newValue_bt = (codec_config.codec_specific_1 & A2DP_LHDCV5_QUALITY_MASK);
++    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
++      LOG_ERROR( "%s: wrap quality mode error", __func__);
++      goto fail;
++    }
++    if (newValue_lib != p_encoder_params->quality_mode_index) {
++      p_encoder_params->quality_mode_index = newValue_lib;
++    }
++  } else {
++    //default: LOW (400 Kbps)
++    codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_LOW;
++    //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++
++    newValue_bt = A2DP_LHDCV5_QUALITY_LOW;
++    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
++      LOG_ERROR( "%s: (default) wrap quality mode error", __func__);
++      goto fail;
++    }
++    p_encoder_params->quality_mode_index = newValue_lib;
++  }
++
++  LOG_DEBUG( "%s: (encode param) sample_rate=%u pcm_fmt=%d peer_mtu=%d mtu=%d "
++      "maxBitRateIdx=%u minBitRateIdx=%u isLLEnabled=%u quality_mode=%s(%d)", __func__,
++      p_encoder_params->sample_rate,                //44100, 48000, ...
++      p_encoder_params->pcm_fmt,                    //16, 24, 32...
++      peer_mtu, max_mtu_len,                        //number of bytes
++      p_encoder_params->max_target_bitrate,         //index
++      p_encoder_params->min_target_bitrate,         //index
++      p_encoder_params->isLLEnabled,
++      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str(),
++      p_encoder_params->quality_mode_index);
++
++  // setup features to encoder
++  if (A2DP_VendorHasARFlagLhdcV5(&ret_value8, p_codec_info)) {
++    lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_AR, (bool)ret_value8, NULL, 0);
++    if (lib_ret != LHDCV5_FRET_SUCCESS) {
++      LOG_ERROR( "%s: [lib_ret] lhdc_set_ext_func AR(0x%X) %d", __func__, LHDCV5_EXT_FUNC_AR, lib_ret);
++      goto fail;
++    }
++  }
++
++  if (A2DP_VendorHasJASFlagLhdcV5(&ret_value8, p_codec_info)) {
++    lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_JAS, (bool)ret_value8, NULL, 0);
++    if (lib_ret != LHDCV5_FRET_SUCCESS) {
++      LOG_ERROR( "%s: [lib_ret] lhdc_set_ext_func JAS(0x%X) %d", __func__, LHDCV5_EXT_FUNC_JAS, lib_ret);
++      goto fail;
++    }
++  }
++
++  // Initialize the encoder.
++  // NOTE: MTU in the initialization must include the AVDT media header size.
++  lib_ret = lhdc_init_encoder(
++      a2dp_lhdc_encoder_cb.lhdc_handle,
++      p_encoder_params->sample_rate,
++      p_encoder_params->pcm_fmt,
++      p_encoder_params->quality_mode_index,
++      max_mtu_len,
++      (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms());
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_ERROR( "%s: [lib_ret] lhdc_init_encoder %d", __func__, lib_ret);
++    goto fail;
++  }
++
++  // setup after encoder initialized
++  lib_ret = lhdc_set_max_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->max_target_bitrate);
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_ERROR( "%s: [lib_ret] set_max_bitrate %d", __func__, lib_ret);
++    goto fail;
++  }
++  lib_ret = lhdc_set_min_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->min_target_bitrate);
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_ERROR( "%s: [lib_ret] set_min_bitrate %d", __func__, lib_ret);
++    goto fail;
++  }
++  lib_ret = lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_ERROR( "%s: [lib_ret] set_bitrate %d", __func__, lib_ret);
++    goto fail;
++  }
++
++#if defined(_V5ENC_REC_FILE_)
++  if (recFile == NULL) {
++    recFile = fopen(V5ENC_RAW_NAME,"wb");
++    LOG_DEBUG( "%s: create recode file = %p", __func__, recFile);
++  }
++  if (pcmFile == NULL) {
++    pcmFile = fopen(V5ENC_PCM_NAME,"wb");
++    LOG_DEBUG( "%s: create recode file = %p", __func__, pcmFile);
++  }
++#endif
++  return;
++
++  fail:
++  if (a2dp_lhdc_encoder_cb.lhdc_handle) {
++    a2dp_vendor_lhdcv5_encoder_cleanup();
++  }
++}
++
++//tA2DP_ENCODER_INTERFACE::(encoder_cleanup)
++void a2dp_vendor_lhdcv5_encoder_cleanup(void) {
++  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && a2dp_lhdc_encoder_cb.lhdc_handle) {
++    int32_t lib_ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
++    if (lib_ret != LHDCV5_FRET_SUCCESS) {
++      LOG_ERROR( "%s: free handle error %d", __func__, lib_ret);
++      return;
++    }
++  } else {
++    LOG_DEBUG( "%s: nothing to clean", __func__);
++    return;
++  }
++  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
++
++#if defined(_V5ENC_REC_FILE_)
++  if (recFile != NULL) {
++    fclose(recFile);
++    recFile = NULL;
++    remove(V5ENC_RAW_NAME);
++  }
++  if (pcmFile != NULL) {
++    fclose(pcmFile);
++    pcmFile = NULL;
++    remove(V5ENC_PCM_NAME);
++  }
++#endif
++
++  LOG_DEBUG( "%s: encoder cleaned up", __func__);
++}
++
++//tA2DP_ENCODER_INTERFACE::(feeding_reset)
++void a2dp_vendor_lhdcv5_feeding_reset(void) {
++  /* By default, just clear the entire state */
++  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
++      sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
++
++  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
++      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
++          a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
++          a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++          encoder_interval) / 1000;
++  a2dp_lhdc_encoder_cb.buf_seq = 0;
++  a2dp_lhdc_encoder_cb.bytes_read = 0;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
++
++  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
++    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++      LOG_DEBUG("%s: reset ABR!", __func__);
++      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_QUALITY_RESET_AUTO);
++    }
++  }
++
++  LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
++}
++
++//tA2DP_ENCODER_INTERFACE::(feeding_flush)
++void a2dp_vendor_lhdcv5_feeding_flush(void) {
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
++  LOG_DEBUG( "%s", __func__);
++}
++
++//tA2DP_ENCODER_INTERFACE::(get_encoder_interval_ms)
++uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void) {
++  LOG_DEBUG( "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",  __func__,
++      a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
++
++  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
++    return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
++  }else{
++    return A2DP_LHDC_ENCODER_INTERVAL_MS;
++  }
++}
++
++//tA2DP_ENCODER_INTERFACE::(send_frames)
++void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us) {
++  uint8_t nb_frame = 0;
++  uint8_t nb_iterations = 0;
++
++  a2dp_lhdcv5_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
++  LOG_VERBOSE( "%s: Sending %d frames per iteration, %d iterations",
++      __func__, nb_frame, nb_iterations);
++
++  if (nb_frame == 0) return;
++
++  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
++    // Transcode frame and enqueue
++    a2dp_lhdcV5_encode_frames(nb_frame);
++  }
++}
++
++// Obtains the number of frames to send and number of iterations
++// to be used. |num_of_iterations| and |num_of_frames| parameters
++// are used as output param for returning the respective values.
++static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
++    uint8_t* num_of_frames,
++    uint64_t timestamp_us) {
++
++  uint32_t result = 0;
++  uint8_t nof = 0;
++  uint8_t noi = 1;
++  uint32_t pcm_bytes_per_frame = 0;
++  uint32_t samples_per_frame = 0;
++  int32_t lib_ret = 0;
++
++  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_DEBUG( "%s: get block size error %d", __func__, lib_ret);
++    return;
++  }
++
++  pcm_bytes_per_frame = samples_per_frame *
++      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++
++  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
++  uint32_t us_this_tick = encoder_interval * 1000;
++  uint64_t now_us = timestamp_us;
++
++  // not the first time, calculate time offset
++  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0) {
++    us_this_tick = (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
++  }
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
++
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
++      (encoder_interval * 1000);
++
++  result =
++      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
++  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
++      result * pcm_bytes_per_frame;
++  nof = result;
++
++  LOG_DEBUG( "%s: samples_per_frame=%u pcm_bytes_per_frame=%u nb_frame=%u",
++      __func__, samples_per_frame, pcm_bytes_per_frame, nof);
++
++  *num_of_frames = nof;
++  *num_of_iterations = noi;
++}
++
++static BT_HDR *bt_buf_new( void) {
++  BT_HDR *p_buf = ( BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
++  if ( p_buf == NULL) {
++    // LeoKu(C): should not happen
++    LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
++    return NULL;
++  }
++
++  p_buf->offset = A2DP_LHDC_OFFSET;
++  p_buf->len = 0;
++  p_buf->layer_specific = 0;
++  return p_buf;
++}
++
++static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame){
++  static float mtu_usage = 0;
++  static int mtu_usage_cnt = 0;
++  static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
++  static uint32_t all_send_bytes = 0;
++  uint8_t read_buffer[LHDCV5_MAX_SAMPLE_FRAME * 2 * 4];
++  uint32_t samples_per_frame = 0;
++  uint32_t out_frames = 0;
++  uint8_t remain_nb_frame = nb_frame;
++  uint32_t written = 0;
++  uint32_t bytes_read = 0;
++  uint8_t *packet = nullptr;
++  BT_HDR *p_buf = nullptr;
++  int32_t lib_ret = 0;
++  uint32_t pcm_bytes_per_frame = 0;
++  uint32_t max_mtu_len = 0;
++
++  uint32_t written_frame = 0;
++  uint32_t temp_bytes_read = 0;
++
++  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_DEBUG( "%s: [lib_ret] lhdc_get_block_size error %d", __func__, lib_ret);
++    return;
++  }
++  pcm_bytes_per_frame = samples_per_frame *
++      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++
++  if (pcm_bytes_per_frame > sizeof(read_buffer)) {
++    LOG_ERROR( "%s: expected read size error", __func__);
++    return;
++  }
++
++  // check codec handle existed
++  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle || !a2dp_lhdc_encoder_cb.lhdc_handle) {
++    LOG_ERROR( "%s: encoder handle invalid error", __func__);
++    return;
++  }
++
++#if (BTA_AV_CO_CP_SCMS_T == TRUE)
++  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
++#else
++  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
++#endif
++
++  while (nb_frame) {
++    // create a temp output buffer
++    if ((p_buf = bt_buf_new()) == NULL) {
++      LOG_ERROR( "%s: create buf error", __func__);
++      return;
++    }
++
++    written_frame = 0;
++    do {
++      temp_bytes_read = 0;
++      // read from feeding buffer
++      if (a2dp_lhdcv5_read_feeding(read_buffer, &temp_bytes_read)) {
++        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
++        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
++
++#if defined(_V5ENC_REC_FILE_)
++        if (pcmFile != NULL) {
++          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
++        }
++#endif
++
++        LOG_DEBUG( "%s: nb_frame(%d) to encode...", __func__, nb_frame);
++        // to encode
++        lib_ret = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle,
++            read_buffer, temp_bytes_read,
++            packet, (BT_DEFAULT_BUFFER_SIZE-(p_buf->offset + p_buf->len + sizeof(BT_HDR))),
++            &written, &out_frames);
++
++        if (lib_ret != LHDCV5_FRET_SUCCESS) {
++          LOG_ERROR( "%s: [lib_ret] lhdc_encode_func error %d", __func__, lib_ret);
++          a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
++          osi_free(p_buf);
++          return;
++        }
++
++#if defined(_V5ENC_REC_FILE_)
++        if (recFile != NULL && written > 0) {
++          fwrite(packet, sizeof(uint8_t), written, recFile);
++        }
++#endif
++        LOG_DEBUG( "%s: nb_frame(%d) - written:%d, out_frames:%d", __func__,
++            nb_frame, written, out_frames);
++        p_buf->len += written;
++        all_send_bytes += written;
++        nb_frame--;
++        written_frame += out_frames;  // added a frame to the buffer
++      } else {
++        LOG_DEBUG( "%s: nb_frame(%d) - underflow", __func__, nb_frame);
++        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
++            nb_frame * samples_per_frame *
++            a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++            a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++        // no more pcm to read
++        nb_frame = 0;
++      }
++    } while ((written == 0) && nb_frame);
++
++    if (p_buf->len) {
++      /*
++       * Timestamp of the media packet header represent the TS of the
++       * first frame, i.e the timestamp before including this frame.
++       */
++      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
++      p_buf->layer_specific <<= 8;
++      p_buf->layer_specific |= ((written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
++
++      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
++      LOG_VERBOSE( "%s: Timestamp (%d)", __func__, a2dp_lhdc_encoder_cb.timestamp);
++
++      a2dp_lhdc_encoder_cb.timestamp += (written_frame * samples_per_frame);
++
++      remain_nb_frame = nb_frame;
++      LOG_DEBUG( "%s: nb_frame(%d) - remain_nb_frame:%d", __func__, (nb_frame+1), remain_nb_frame);
++
++      mtu_usage += ((float)p_buf->len) / max_mtu_len;
++      mtu_usage_cnt++;
++
++      LOG_DEBUG( "%s: Bytes read for pkt(%d)", __func__, a2dp_lhdc_encoder_cb.bytes_read);
++      LOG_DEBUG( "%s: Output frames(%d) encoded pkt len(%d)", __func__, written_frame, p_buf->len);
++      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
++      a2dp_lhdc_encoder_cb.bytes_read = 0;
++
++      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
++        return;
++    } else {
++      LOG_DEBUG( "%s: free buffer len(%d)", __func__, p_buf->len);
++      a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
++      osi_free(p_buf);
++    }
++  }
++
++  // for statistics
++  uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
++  if (now_ms - time_prev >= 1000 ) {
++    LOG_DEBUG( "%s: current data rate about %d kbps, packet usage %.2f%%", __func__,
++        (all_send_bytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
++    all_send_bytes = 0;
++    mtu_usage_cnt = 0;
++    mtu_usage = 0;
++    time_prev = now_ms;
++  }
++}
++
++static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
++  uint32_t read_size = 0;
++  uint32_t samples_per_frame = 0;
++  uint32_t bytes_per_sample =
++      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
++      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
++  uint32_t nb_byte_read;
++
++  if (read_buffer == nullptr || bytes_read == nullptr) {
++    LOG_ERROR( "%s: null input", __func__);
++    return false;
++  }
++
++  int32_t lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
++  if (lib_ret != LHDCV5_FRET_SUCCESS) {
++    LOG_DEBUG( "%s: [lib_ret] lhdc_get_block_size error %d", __func__, lib_ret);
++    return false;
++  }
++  read_size = samples_per_frame * bytes_per_sample;
++
++  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
++  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
++
++  /* Read Data from UIPC channel */
++  nb_byte_read =
++      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
++  LOG_DEBUG( "%s: expected read bytes %u, actual read bytes %u",
++      __func__, read_size, nb_byte_read);
++
++  //TODO: what to do if not alignment?
++  if ((nb_byte_read % bytes_per_sample) != 0) {
++    LOG_DEBUG( "%s: PCM data not alignment. The audio sample is shfit %d bytes!",
++        __func__, (nb_byte_read % bytes_per_sample));
++  }
++  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
++
++  // if actual read < want to read
++  if (nb_byte_read < read_size) {
++    if (nb_byte_read == 0) return false;
++
++    /* Fill the unfilled part of the read buffer with silence (0) */
++    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
++    nb_byte_read = read_size;
++  }
++  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
++  *bytes_read = nb_byte_read;
++
++  return true;
++}
++
++// library index mapping: quality mode index
++static std::string quality_mode_index_to_name(uint32_t quality_mode_index) {
++  switch (quality_mode_index) {
++  case LHDCV5_QUALITY_HIGH1:
++    return "HIGH1_1000";
++  case LHDCV5_QUALITY_HIGH:
++    return "HIGH_900";
++  case LHDCV5_QUALITY_MID:
++    return "MID_500";
++  case LHDCV5_QUALITY_LOW:
++    return "LOW_400";
++  case LHDCV5_QUALITY_LOW4:
++    return "LOW_320";
++  case LHDCV5_QUALITY_LOW3:
++    return "LOW_256";
++  case LHDCV5_QUALITY_LOW2:
++    return "LOW_192";
++  case LHDCV5_QUALITY_LOW1:
++    return "LOW_128";
++  case LHDCV5_QUALITY_LOW0:
++    return "LOW_64";
++  case LHDCV5_QUALITY_AUTO:
++    return "ABR";
++  default:
++    return "Unknown";
++  }
++}
++
++//tA2DP_ENCODER_INTERFACE::(set_transmit_queue_length)
++void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length) {
++  int32_t lib_ret = 0;
++
++  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
++  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  LOG_VERBOSE( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
++
++  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
++    LOG_VERBOSE( "%s: Auto Bitrate Enabled!", __func__);
++    if (lhdc_auto_adjust_bitrate != NULL) {
++      lib_ret = lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, (uint32_t)transmit_queue_length);
++      if (lib_ret != LHDCV5_FRET_SUCCESS){
++        LOG_ERROR( "%s: [lib_ret] lhdc_auto_adjust_bitrate error %d", __func__, lib_ret);
++      }
++    }
++  }
++}
++
++uint64_t A2dpCodecConfigLhdcV5Source::encoderIntervalMs() const {
++  return a2dp_vendor_lhdcv5_get_encoder_interval_ms();
++}
++
++int A2dpCodecConfigLhdcV5Source::getEffectiveMtu() const {
++  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
++}
++
++void A2dpCodecConfigLhdcV5Source::debug_codec_dump(int fd) {
++  a2dp_lhdcv5_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
++  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
++      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++
++  uint32_t lib_value = 0;
++  int32_t lib_ret = 0;
++
++  A2dpCodecConfig::debug_codec_dump(fd);
++
++  dprintf(fd,
++      "  Packet counts (expected/dropped)                        : %zu / "
++      "%zu\n",
++      (size_t)stats->media_read_total_expected_packets,
++      (size_t)stats->media_read_total_dropped_packets);
++
++  dprintf(fd,
++      "  PCM read counts (expected/actual)                       : %zu / "
++      "%zu\n",
++      (size_t)stats->media_read_total_expected_reads_count,
++      (size_t)stats->media_read_total_actual_reads_count);
++
++  dprintf(fd,
++      "  PCM read bytes (expected/actual)                        : %zu / "
++      "%zu\n",
++      (size_t)stats->media_read_total_expected_read_bytes,
++      (size_t)stats->media_read_total_actual_read_bytes);
++
++  dprintf(fd,
++      "  LHDC quality mode                                       : %s\n",
++      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
++
++  lib_ret = lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, &lib_value);
++  if (lib_ret == LHDCV5_FRET_SUCCESS) {
++    dprintf(fd,
++        "  LHDC transmission bitrate (Kbps)                        : %d\n",
++        lib_value);
++  }
++
++  dprintf(fd,
++      "  LHDC saved transmit queue length                        : %zu\n",
++      (size_t)a2dp_lhdc_encoder_cb.TxQueueLength);
++}
++
+diff --git a/system_bt/stack/include/a2dp_codec_api.h b/system_bt/stack/include/a2dp_codec_api.h
+index 3297c5c78..84c945bac 100644
+--- a/system_bt/stack/include/a2dp_codec_api.h
++++ b/system_bt/stack/include/a2dp_codec_api.h
+@@ -255,6 +255,20 @@ class A2dpCodecConfig {
+   // The information is written in user-friendly form to file descriptor |fd|.
+   virtual void debug_codec_dump(int fd);
+ 
++  // Savitech LHDC EXT API -- START
++  virtual int getLhdcExtendAPIVersion(
++      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
++
++  virtual int getLhdcExtendAPIConfig(
++      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
++
++  virtual int setLhdcExtendAPIConfig(
++      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
++
++  virtual bool setLhdcExtendAPIData(
++      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return true; }
++  // Savitech LHDC EXT API -- END
++
+   std::recursive_mutex codec_mutex_;
+   const btav_a2dp_codec_index_t codec_index_;  // The unique codec index
+   const std::string name_;                     // The codec name
+@@ -454,6 +468,24 @@ class A2dpCodecs {
+   // The information is written in user-friendly form to file descriptor |fd|.
+   void debug_codec_dump(int fd);
+ 
++  // Savitech LHDC EXT API -- START
++  int getLHDCCodecUserApiVer(
++      A2dpCodecConfig* peerCodec,
++      const char* codecConfig, const int clen);
++
++  int getLHDCCodecUserConfig(
++      A2dpCodecConfig* peerCodec,
++      const char* codecConfig, const int clen);
++
++  int setLHDCCodecUserConfig(
++      A2dpCodecConfig* peerCodec,
++      const char* codecConfig, const int clen);
++
++  bool setLHDCCodecUserData(
++      A2dpCodecConfig* peerCodec,
++      const char* codecData, const int clen);
++  // Savitech LHDC EXT API -- END
++
+  private:
+   struct CompareBtBdaddr
+       : public std::binary_function<RawAddress, RawAddress, bool> {
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdc_constants.h b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
+new file mode 100644
+index 000000000..69e3c3bad
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
+@@ -0,0 +1,293 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// A2DP constants for LHDC codec
++//
++
++#ifndef A2DP_VENDOR_LHDC_CONSTANTS_H
++#define A2DP_VENDOR_LHDC_CONSTANTS_H
++#define A2DP_LHDC_SILENCE_LEVEL  1.0f
++#define A2DP_LHDC_VERSION_NUMBER    0x01
++#define A2DP_LHDC_VENDOR_CMD_MASK    0xC000
++#define A2DP_LHDC_VENDOR_FEATURE_MASK    (0xFF000000)
++
++// LHDC Quality Mode Index
++//LHDC not supported auto bit rate now.
++#define A2DP_LHDC_QUALITY_MAGIC_NUM 0x8000
++
++/* LHDC quality supportting new bit rate */
++/* 256kbps, 192kbps, 128kbps, 96kbps, 64kbps */
++#define A2DP_LHDC_QUALITY_MASK   0xFF
++#define A2DP_LHDC_QUALITY_ABR    9   // ABR mode
++#define A2DP_LHDC_QUALITY_HIGH1  8   // 1000kbps (supported in LHDCV5 or higher version)
++#define A2DP_LHDC_QUALITY_HIGH   7   // Equal to LHDCBT_EQMID_HQ 900kbps
++#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500kbps
++#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
++#define A2DP_LHDC_QUALITY_LOW4   4   // 320
++#define A2DP_LHDC_QUALITY_LOW3   3   // 256
++#define A2DP_LHDC_QUALITY_LOW2   2   // 192
++#define A2DP_LHDC_QUALITY_LOW1   1   // 128
++#define A2DP_LHDC_QUALITY_LOW0   0   // 64
++
++#define A2DP_LHDC_LATENCY_MAGIC_NUM 0xC000
++#define A2DP_LHDC_LL_ENABLE	  1	// LL enabled
++#define A2DP_LHDC_LL_DISABLE	0	// LL disabled
++
++#define A2DP_LHDC_LATENCY_LOW	0	// 50-100 ms
++#define A2DP_LHDC_LATENCY_MID	1	// default value, 150-200 ms
++#define A2DP_LHDC_LATENCY_HIGH	2	// 300-500 ms
++
++
++// Length of the LHDC Media Payload header
++#define A2DP_LHDC_MPL_HDR_LEN 2
++
++// LHDC Media Payload Header
++#define A2DP_LHDC_HDR_F_MSK 0x80
++#define A2DP_LHDC_HDR_S_MSK 0x40
++#define A2DP_LHDC_HDR_L_MSK 0x20
++
++#define A2DP_LHDCV3_HDR_NUM_MSK 0x0F
++#define A2DP_LHDCV2_HDR_NUM_MSK 0x7
++#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
++#define A2DP_LHDC_HDR_NUM_SHIFT 2
++#define A2DP_LHDCV3_HDR_NUM_MAX 8
++#define A2DP_LHDCV2_HDR_NUM_MAX 7
++#define A2DP_LHDCV1_HDR_NUM_MAX 7
++
++#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
++#define A2DP_LHDC_HDR_LATENCY_MID   0x01
++#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
++#define A2DP_LHDC_HDR_LATENCY_MSK   0x03
++
++// LHDC codec specific settings
++//#define A2DP_LHDCV3_CODEC_LEN 12
++#define A2DP_LHDCV3_CODEC_LEN 11
++#define A2DP_LHDCV2_CODEC_LEN 11
++#define A2DP_LHDCV1_CODEC_LEN 9
++#define A2DP_LHDC_LL_CODEC_LEN 9
++#define A2DP_LHDCV5_CODEC_LEN 13
++
++// [Octet 0-3] Vendor ID
++#define A2DP_LHDC_VENDOR_ID 0x0000053a
++// [Octet 4-5] Vendor Specific Codec ID
++#define A2DP_LHDCV2_CODEC_ID 0x4C32
++#define A2DP_LHDCV3_CODEC_ID 0x4C33
++#define A2DP_LHDCV1_CODEC_ID 0x484C
++#define A2DP_LHDCV1_LL_CODEC_ID 0x4C4C
++#define A2DP_LHDCV5_CODEC_ID 0x4C35
++
++// [Octet 6], [Bits 0-3] Sampling Frequency
++#define A2DP_LHDC_SAMPLING_FREQ_MASK 0x0F
++#define A2DP_LHDC_SAMPLING_FREQ_44100 0x08
++#define A2DP_LHDC_SAMPLING_FREQ_48000 0x04
++#define A2DP_LHDC_SAMPLING_FREQ_88200 0x02
++#define A2DP_LHDC_SAMPLING_FREQ_96000 0x01
++// [Octet 6], [Bits 3-4] Bit dipth
++#define A2DP_BAD_BITS_PER_SAMPLE    0xff
++#define A2DP_LHDC_BIT_FMT_MASK 	 0x30
++#define A2DP_LHDC_BIT_FMT_24	 0x10
++#define A2DP_LHDC_BIT_FMT_16	 0x20
++
++// [Octet 6], [Bits 6-7] Bit dipth
++#define A2DP_LHDC_FEATURE_AR		0x80
++#define A2DP_LHDC_FEATURE_JAS		0x40
++
++//[Octet 7:bit0..bit3]
++#define A2DP_LHDC_VERSION_MASK 0x0F
++//#define A2DP_LHDC_VERSION_2    0x01
++//#define A2DP_LHDC_VERSION_3    0x02
++//Supported version
++typedef enum {
++    A2DP_LHDC_VER2_BES  = 0,
++    A2DP_LHDC_VER2 = 1,
++    A2DP_LHDC_VER3 = 0x01,
++    A2DP_LHDC_VER4 = 0x02,
++    A2DP_LHDC_VER5 = 0x04,
++    A2DP_LHDC_VER6 = 0x08,
++    A2DP_LHDC_ERROR_VER,
++
++    A2DP_LHDC_LAST_SUPPORTED_VERSION = A2DP_LHDC_VER4,
++} A2DP_LHDC_VERSION;
++
++//[Octet 7:bit4..bit5]
++#define A2DP_LHDC_MAX_BIT_RATE_MASK       0x30
++#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
++#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10		//500~600K
++#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
++//[Octet 7:bit6]
++#define A2DP_LHDC_LL_MASK             0x40
++#define A2DP_LHDC_LL_NONE             0x00
++#define A2DP_LHDC_LL_SUPPORTED        0x40
++
++//[Octet 7:bit7]
++#define A2DP_LHDC_FEATURE_LLAC		0x80
++
++//[Octet 8:bit0..bit3]
++#define A2DP_LHDC_CH_SPLIT_MSK        0x0f
++#define A2DP_LHDC_CH_SPLIT_NONE       0x01
++#define A2DP_LHDC_CH_SPLIT_TWS        0x02
++#define A2DP_LHDC_CH_SPLIT_TWS_PLUS   0x04
++
++//[Octet 8:bit4..bit7]
++#define A2DP_LHDC_FEATURE_META		0x10
++#define A2DP_LHDC_FEATURE_MIN_BR	0x20
++#define A2DP_LHDC_FEATURE_LARC		0x40
++#define A2DP_LHDC_FEATURE_LHDCV4	0x80
++
++//For LL used
++#define A2DP_LHDC_CHANNEL_SEPARATION  0x40
++
++
++//Only supported stereo
++#define A2DP_LHDC_CHANNEL_MODE_STEREO 0x03
++
++#define A2DP_LHDC_BITRATE_900K		0x01
++#define A2DP_LHDC_BITRATE_600K		0x02
++#define A2DP_LHDC_BITRATE_400K		0x04
++#define A2DP_LHDC_BITRATE_320K		0x08
++#define A2DP_LHDC_BITRATE_256K		0x10
++#define A2DP_LHDC_BITRATE_192K		0x20
++#define A2DP_LHDC_BITRATE_128K		0x40
++#define A2DP_LHDC_BITRATE_64K		0x80
++#define A2DP_LHDC_BITRATE_ALL		0xff
++
++
++#define A2DP_LHDC_FEATURE_MAGIC_NUM (0x4C000000)
++//LHDC Features: codec config specific field bitmap definition
++//specific2
++#define A2DP_LHDC_LL_ENABLED		0x1ULL
++//specific3
++#define A2DP_LHDC_JAS_ENABLED		0x1ULL
++#define A2DP_LHDC_AR_ENABLED		0x2ULL
++#define A2DP_LHDC_META_ENABLED		0x4ULL
++#define A2DP_LHDC_LLAC_ENABLED		0x8ULL
++#define A2DP_LHDC_MBR_ENABLED		0x10ULL
++#define A2DP_LHDC_LARC_ENABLED		0x20ULL
++#define A2DP_LHDC_V4_ENABLED		0x40ULL
++/* Define the ?th bit(from least significant bit) in the specific, sync with the bitmap definition
++ *  ex: A2DP_LHDC_AR_ENABLED = (2^A2DP_LHDC_AR_SPEC_BIT_POS)
++ * */
++//default in specific2
++#define A2DP_LHDC_LL_SPEC_BIT_POS        (0x0)
++//default in specific3
++#define A2DP_LHDC_JAS_SPEC_BIT_POS       (0x0)
++#define A2DP_LHDC_AR_SPEC_BIT_POS        (0x01)
++#define A2DP_LHDC_META_SPEC_BIT_POS      (0x02)
++#define A2DP_LHDC_LLAC_SPEC_BIT_POS      (0x03)
++#define A2DP_LHDC_MBR_SPEC_BIT_POS       (0x04)
++#define A2DP_LHDC_LARC_SPEC_BIT_POS      (0x05)
++#define A2DP_LHDC_V4_SPEC_BIT_POS        (0x06)
++
++/* bitmap for A2DP codec config selecting */
++#define A2DP_LHDC_TO_A2DP_CODEC_CONFIG_         0x1ULL      //codec_config_
++#define A2DP_LHDC_TO_A2DP_CODEC_CAP_            0x2ULL      //codec_capability_
++#define A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_      0x4ULL      //codec_local_capability_
++#define A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_     0x8ULL      //codec_selectable_capability_
++#define A2DP_LHDC_TO_A2DP_CODEC_USER_           0x10ULL     //codec_user_config_
++#define A2DP_LHDC_TO_A2DP_CODEC_AUDIO_          0x20ULL     //codec_audio_config_
++
++#define SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
++    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
++    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
++    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
++    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
++} while(0)
++
++#define CHECK_IN_A2DP_SPEC(cfg, spec, value)  do{   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
++    return (cfg->codec_specific_1 & value);   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
++    return (cfg->codec_specific_2 & value);   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
++    return (cfg->codec_specific_3 & value);   \
++  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
++    return (cfg->codec_specific_4 & value);   \
++  return false;   \
++} while(0)
++
++// TODO: return version macro to replace LHDC_CHECK_IN_A2DP_SPEC
++#define LHDCV3_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
++  bool marco_ret = false; \
++  do{   \
++    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
++      marco_ret = (cfg->codec_specific_1 & value);   \
++    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
++      marco_ret = (cfg->codec_specific_2 & value);   \
++    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
++      marco_ret = (cfg->codec_specific_3 & value);   \
++    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
++      marco_ret = (cfg->codec_specific_4 & value);   \
++    } while(0);  \
++  marco_ret;   \
++})
++
++//
++// Savitech - LHDC aDSP configuration
++//
++// Lhdcv5Version: 1 << (below value-1)
++#define A2DP_OFFLOAD_LHDCV2_VER_1                   0x01
++#define A2DP_OFFLOAD_LHDCV3_V3_ONLY                 0x02
++#define A2DP_OFFLOAD_LHDCV3_V4_ONLY                 0x03
++#define A2DP_OFFLOAD_LHDCV3_LLAC                    0x04
++#define A2DP_OFFLOAD_LHDCV5_VER_1                   0x01
++
++// Lhdcv5QualityIndex
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW0            0x01
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW1            0x02
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW2            0x04
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW3            0x08
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW4            0x10
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW             0x20
++#define A2DP_OFFLOAD_LHDC_QUALITY_MID             0x40
++#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH            0x80
++#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH1           0x100
++#define A2DP_OFFLOAD_LHDC_QUALITY_ABR             0x8000
++
++// Lhdcv5FrameDuration
++#define A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US   0x01
++
++// Lhdcv5DataInterval
++#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS      0x01
++#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS      0x02
++
++// Lhdcv5Specific
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR     0x01
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS    0x02
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META   0x04
++
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON   0x01
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT  0x80
++
++// Lhdcv5Parameters
++#define A2DP_OFFLOAD_LHDC_CFG_VER                   6
++#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_L             7
++#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_H             8
++#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L          9
++#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H          10
++#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L          11
++#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H          12
++#define A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR              13
++#define A2DP_OFFLOAD_LHDC_CFG_INTERVAL              14
++#define A2DP_OFFLOAD_LHDC_CFG_SPEC1                 15
++#define A2DP_OFFLOAD_LHDC_CFG_SPEC2                 16
++#define A2DP_OFFLOAD_LHDC_CFG_META                  17
++
++#endif  // A2DP_VENDOR_LHDC_CONSTANTS_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv2.h b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
+new file mode 100644
+index 000000000..5576d12fb
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
+@@ -0,0 +1,183 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// A2DP Codec API for LHDC
++//
++
++#ifndef A2DP_VENDOR_LHDCV2_H
++#define A2DP_VENDOR_LHDCV2_H
++
++#include "a2dp_codec_api.h"
++#include "a2dp_vendor_lhdc_constants.h"
++#include "avdt_api.h"
++
++
++class A2dpCodecConfigLhdcV2 : public A2dpCodecConfig {
++ public:
++  bool copySinkCapability(uint8_t * codec_info);
++  A2dpCodecConfigLhdcV2(btav_a2dp_codec_priority_t codec_priority);
++  virtual ~A2dpCodecConfigLhdcV2();
++
++  bool init() override;
++  uint64_t encoderIntervalMs() const override;
++  int getEffectiveMtu() const override;
++  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
++                      uint8_t* p_result_codec_config) override;
++  bool setPeerCodecCapabilities(
++      const uint8_t* p_peer_codec_capabilities) override;
++
++
++ private:
++  bool useRtpHeaderMarkerBit() const override;
++  bool updateEncoderUserConfig(
++      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++      bool* p_restart_input, bool* p_restart_output,
++      bool* p_config_updated) override;
++  void debug_codec_dump(int fd) override;
++};
++
++bool A2DP_VendorGetLowLatencyEnabledLhdcV2();
++// Checks whether the codec capabilities contain a valid A2DP LHDC Source
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid LHDC
++// codec, otherwise false.
++bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info);
++
++// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid LHDC
++// codec, otherwise false.
++bool A2DP_IsVendorPeerSinkCodecValidLhdcV2(const uint8_t* p_codec_info);
++
++// Checks whether the A2DP data packets should contain RTP header.
++// |content_protection_enabled| is true if Content Protection is
++// enabled. |p_codec_info| contains information about the codec capabilities.
++// Returns true if the A2DP data packets should contain RTP header, otherwise
++// false.
++bool A2DP_VendorUsesRtpHeaderLhdcV2(bool content_protection_enabled,
++                                  const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC codec name for a given |p_codec_info|.
++const char* A2DP_VendorCodecNameLhdcV2(const uint8_t* p_codec_info);
++
++// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
++// have the same type.
++// Returns true if the two codecs have the same type, otherwise false.
++bool A2DP_VendorCodecTypeEqualsLhdcV2(const uint8_t* p_codec_info_a,
++                                    const uint8_t* p_codec_info_b);
++
++// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
++// are exactly the same.
++// Returns true if the two codecs are exactly the same, otherwise false.
++// If the codec type is not LHDC, the return value is false.
++bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
++                                const uint8_t* p_codec_info_b);
++
++// Gets the track sample rate value for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track sample rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info);
++
++// Gets the bits per audio sample for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the bits per audio sample on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info);
++
++// Gets the channel count for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the channel count on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info);
++
++// Gets the channel mode code for the A2DP LHDC codec.
++// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the channel mode code on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetChannelModeCodeLhdcV2(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC audio data timestamp from an audio packet.
++// |p_codec_info| contains the codec information.
++// |p_data| contains the audio data.
++// The timestamp is stored in |p_timestamp|.
++// Returns true on success, otherwise false.
++bool A2DP_VendorGetPacketTimestampLhdcV2(const uint8_t* p_codec_info,
++                                       const uint8_t* p_data,
++                                       uint32_t* p_timestamp);
++
++// Builds A2DP LHDC codec header for audio data.
++// |p_codec_info| contains the codec information.
++// |p_buf| contains the audio data.
++// |frames_per_packet| is the number of frames in this packet.
++// Returns true on success, otherwise false.
++bool A2DP_VendorBuildCodecHeaderLhdcV2(const uint8_t* p_codec_info, BT_HDR* p_buf,
++                                     uint16_t frames_per_packet);
++
++// Decodes A2DP LHDC codec info into a human readable string.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns a string describing the codec information.
++std::string A2DP_VendorCodecInfoStringLhdcV2(const uint8_t* p_codec_info);
++
++// New feature to check codec info is supported Channel Separation.
++int8_t A2DP_VendorGetChannelSplitModeLhdcV2(const uint8_t* p_codec_info);
++
++bool A2DP_VendorGetLowLatencyStateLhdcV2(const uint8_t* p_codec_info);
++int16_t A2DP_VendorGetMaxDatarateLhdcV2(const uint8_t* p_codec_info);
++uint8_t A2DP_VendorGetVersionLhdcV2(const uint8_t* p_codec_info);
++
++// Decodes and displays LHDC codec info (for debugging).
++// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
++void A2DP_VendorDumpCodecInfoLhdcV2(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
++// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
++// |p_codec_info| contains the codec information.
++// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
++// supported, otherwise NULL.
++const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV2(
++    const uint8_t* p_codec_info);
++
++// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
++// specification.
++// |p_codec_info| contains the codec information to adjust.
++// Returns true if |p_codec_info| is valid and supported, otherwise false.
++bool A2DP_VendorAdjustCodecLhdcV2(uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
++// Returns the corresponding |btav_a2dp_codec_index_t| on success,
++// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
++btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV2(
++    const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC Source codec name.
++const char* A2DP_VendorCodecIndexStrLhdcV2(void);
++
++// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
++// configuration entry pointed by |p_cfg|.
++
++bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg);
++// Gets the track bitrate value for the A2DP LHDCV2 codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track bit rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info);
++
++#endif  // A2DP_VENDOR_LHDCV2_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv2_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv2_encoder.h
+new file mode 100644
+index 000000000..0d762cd8a
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv2_encoder.h
+@@ -0,0 +1,63 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// Interface to the A2DP LHDC Encoder
++//
++
++#ifndef A2DP_VENDOR_LHDCV2_ENCODER_H
++#define A2DP_VENDOR_LHDCV2_ENCODER_H
++
++#include "a2dp_codec_api.h"
++
++// Loads the A2DP LHDC encoder.
++// Return true on success, otherwise false.
++bool A2DP_VendorLoadEncoderLhdcV2(void);
++
++// Unloads the A2DP LHDC encoder.
++void A2DP_VendorUnloadEncoderLhdcV2(void);
++
++// Initialize the A2DP LHDC encoder.
++// |p_peer_params| contains the A2DP peer information
++// The current A2DP codec config is in |a2dp_codec_config|.
++// |read_callback| is the callback for reading the input audio data.
++// |enqueue_callback| is the callback for enqueueing the encoded audio data.
++void a2dp_vendor_lhdcv2_encoder_init(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    A2dpCodecConfig* a2dp_codec_config,
++    a2dp_source_read_callback_t read_callback,
++    a2dp_source_enqueue_callback_t enqueue_callback);
++
++// Cleanup the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv2_encoder_cleanup(void);
++
++// Reset the feeding for the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv2_feeding_reset(void);
++
++// Flush the feeding for the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv2_feeding_flush(void);
++
++// Get the A2DP LHDC encoder interval (in milliseconds).
++uint64_t a2dp_vendor_lhdcv2_get_encoder_interval_ms(void);
++
++// Prepare and send A2DP LHDC encoded frames.
++// |timestamp_us| is the current timestamp (in microseconds).
++void a2dp_vendor_lhdcv2_send_frames(uint64_t timestamp_us);
++
++// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
++void a2dp_vendor_lhdcv2_set_transmit_queue_length(size_t transmit_queue_length);
++
++#endif  // A2DP_VENDOR_LHDCV2_ENCODER_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3.h b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
+new file mode 100644
+index 000000000..dd8afaf17
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
+@@ -0,0 +1,328 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// A2DP Codec API for LHDC
++//
++
++#ifndef A2DP_VENDOR_LHDCV3_H
++#define A2DP_VENDOR_LHDCV3_H
++
++#include "a2dp_codec_api.h"
++#include "a2dp_vendor_lhdc_constants.h"
++#include "avdt_api.h"
++
++#ifdef LOG_NDEBUG
++#undef LOG_NDEBUG
++#define LOG_NDEBUG 1	//set 0 to turn on VERBOSE LOG
++#endif
++
++/** Start of LHDC A2DP-Related API definition ***************************************/
++#define EXTEND_FUNC_CODE_GET_SPECIFIC                   ((unsigned int) 0x0A010001)
++#define EXTEND_FUNC_VER_GET_SPECIFIC_V1                 ((unsigned int) 0x01000000)
++#define EXTEND_FUNC_VER_GET_SPECIFIC_V2                 ((unsigned int) 0x02000000)
++#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
++#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
++
++/* ************************************************************************
++ * Version info: EXTEND_FUNC_CODE_GET_SPECIFIC
++ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
++   * API Version:                   (4 bytes)
++   * API Code:                      (4 bytes)
++   * A2DP Codec Config Code:        (1 bytes)
++   * A2dp Specific1:                (8 bytes)
++   * A2dp Specific2:                (8 bytes)
++   * A2dp Specific3:                (8 bytes)
++   * A2dp Specific4:                (8 bytes)
++ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
++   * API Version:                   (4 bytes)
++   * API Code:                      (4 bytes)
++   * A2DP Codec Config Code:        (1 bytes)
++   * Reserved:                      (7 bytes)
++   * A2dp Specific1:                (8 bytes)
++   * A2dp Specific2:                (8 bytes)
++   * A2dp Specific3:                (8 bytes)
++   * A2dp Specific4:                (8 bytes)
++   * Capabilities Metadata sub fields:  (7*2 bytes)
++     * sub[0~1]:    JAS
++     * sub[2~3]:    AR
++     * sub[4~5]:    META
++     * sub[6~7]:    LLAC
++     * sub[8~9]:    MBR
++     * sub[10~11]:  LARC
++     * sub[12~13]:  LHDCV4
++   * Padded:                        (2 bytes)
++ * ************************************************************************/
++#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
++#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
++#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
++#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
++#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
++/* Capabilities metadata fields(2 bytes for each tuple) */
++#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
++#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
++
++/* Total size of buffer */
++#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
++#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
++                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
++/* Head of each field */
++#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
++#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
++#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
++/* Following part in V1 */
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
++/* Following part in V2 */
++#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
++#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
++#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
++
++
++/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
++ * 0x01: codec_config_
++ * 0x02: codec_capability_
++ * 0x03: codec_local_capability_
++ * 0x04: codec_selectable_capability_
++ * 0x05: codec_user_config_
++ * 0x06: codec_audio_config_
++ */
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
++#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
++
++
++/************************
++ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
++   * Capability Code:                   (1 byte)
++   * Saving Position Info:              (1 byte)
++ ************************/
++/* Capabilities's code: */
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
++#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
++
++/* Capabilities's saving position Info:
++ *  1. in which specific                        (represented in leftmost 2-bits)
++ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
++ * */
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
++#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
++/** End of LHDC A2DP-Related API definition ***************************************/
++
++
++class A2dpCodecConfigLhdcV3 : public A2dpCodecConfig {
++ public:
++  bool copySinkCapability(uint8_t * codec_info);
++  A2dpCodecConfigLhdcV3(btav_a2dp_codec_priority_t codec_priority);
++  virtual ~A2dpCodecConfigLhdcV3();
++
++  bool init() override;
++  uint64_t encoderIntervalMs() const override;
++  int getEffectiveMtu() const override;
++  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
++                      uint8_t* p_result_codec_config) override;
++  bool setPeerCodecCapabilities(
++      const uint8_t* p_peer_codec_capabilities) override;
++
++  static int getEncoderExtendFuncUserApiVer(const char* version, const int clen);
++  static int getEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
++  static int setEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
++  static bool setEncoderExtendFuncUserData(const char* userData, const int clen);
++
++ private:
++  bool useRtpHeaderMarkerBit() const override;
++  bool updateEncoderUserConfig(
++      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++      bool* p_restart_input, bool* p_restart_output,
++      bool* p_config_updated) override;
++  void debug_codec_dump(int fd) override;
++};
++
++bool A2DP_VendorGetLowLatencyEnabledLhdcV3();
++// Checks whether the codec capabilities contain a valid A2DP LHDC Source
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid LHDC
++// codec, otherwise false.
++bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
++
++// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid LHDC
++// codec, otherwise false.
++bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
++
++// Checks whether the A2DP data packets should contain RTP header.
++// |content_protection_enabled| is true if Content Protection is
++// enabled. |p_codec_info| contains information about the codec capabilities.
++// Returns true if the A2DP data packets should contain RTP header, otherwise
++// false.
++bool A2DP_VendorUsesRtpHeaderLhdcV3(bool content_protection_enabled,
++                                  const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC codec name for a given |p_codec_info|.
++const char* A2DP_VendorCodecNameLhdcV3(const uint8_t* p_codec_info);
++
++// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
++// have the same type.
++// Returns true if the two codecs have the same type, otherwise false.
++bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
++                                    const uint8_t* p_codec_info_b);
++
++// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
++// are exactly the same.
++// Returns true if the two codecs are exactly the same, otherwise false.
++// If the codec type is not LHDC, the return value is false.
++bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
++                                const uint8_t* p_codec_info_b);
++
++// Gets the track sample rate value for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track sample rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the bits per audio sample for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the bits per audio sample on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the channel count for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the channel count on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the channel mode code for the A2DP LHDC codec.
++// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the channel mode code on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC audio data timestamp from an audio packet.
++// |p_codec_info| contains the codec information.
++// |p_data| contains the audio data.
++// The timestamp is stored in |p_timestamp|.
++// Returns true on success, otherwise false.
++bool A2DP_VendorGetPacketTimestampLhdcV3(const uint8_t* p_codec_info,
++                                       const uint8_t* p_data,
++                                       uint32_t* p_timestamp);
++
++// Builds A2DP LHDC codec header for audio data.
++// |p_codec_info| contains the codec information.
++// |p_buf| contains the audio data.
++// |frames_per_packet| is the number of frames in this packet.
++// Returns true on success, otherwise false.
++bool A2DP_VendorBuildCodecHeaderLhdcV3(const uint8_t* p_codec_info, BT_HDR* p_buf,
++                                     uint16_t frames_per_packet);
++
++// Decodes A2DP LHDC codec info into a human readable string.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns a string describing the codec information.
++std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info);
++
++// New feature to check codec info is supported Channel Separation.
++int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info);
++
++bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info);
++int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info);
++uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info);
++
++bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info);
++bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info);
++
++bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info);
++bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info);
++bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info);
++bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info);
++bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info);
++
++// Decodes and displays LHDC codec info (for debugging).
++// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
++void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
++// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
++// |p_codec_info| contains the codec information.
++// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
++// supported, otherwise NULL.
++const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
++    const uint8_t* p_codec_info);
++
++// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
++// specification.
++// |p_codec_info| contains the codec information to adjust.
++// Returns true if |p_codec_info| is valid and supported, otherwise false.
++bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
++// Returns the corresponding |btav_a2dp_codec_index_t| on success,
++// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
++btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
++    const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC Source codec name.
++const char* A2DP_VendorCodecIndexStrLhdcV3(void);
++
++// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
++// configuration entry pointed by |p_cfg|.
++bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg);
++
++bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t* capVector);
++
++// Gets the track bitrate value for the A2DP LHDCV3 codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track bit rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info);
++
++#endif  // A2DP_VENDOR_LHDCV3_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
+new file mode 100644
+index 000000000..697ca3b69
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
+@@ -0,0 +1,187 @@
++/*
++ * Copyright 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// A2DP Codec API for low complexity subband codec (SBC)
++//
++
++#ifndef A2DP_VENDOR_LHDCV3_DEC_H
++#define A2DP_VENDOR_LHDCV3_DEC_H
++
++#include "a2dp_codec_api.h"
++#include "a2dp_vendor_lhdc_constants.h"
++#include "avdt_api.h"
++
++class A2dpCodecConfigLhdcV3Base : public A2dpCodecConfig {
++ protected:
++  A2dpCodecConfigLhdcV3Base(btav_a2dp_codec_index_t codec_index,
++                         const std::string& name,
++                         btav_a2dp_codec_priority_t codec_priority,
++                         bool is_source)
++      : A2dpCodecConfig(codec_index, name, codec_priority),
++        is_source_(is_source) {}
++  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
++                      uint8_t* p_result_codec_config) override;
++  bool setPeerCodecCapabilities(
++      const uint8_t* p_peer_codec_capabilities) override;
++
++ private:
++  bool is_source_;  // True if local is Source
++};
++
++
++class A2dpCodecConfigLhdcV3Sink : public A2dpCodecConfigLhdcV3Base {
++ public:
++  A2dpCodecConfigLhdcV3Sink(btav_a2dp_codec_priority_t codec_priority);
++  virtual ~A2dpCodecConfigLhdcV3Sink();
++
++  bool init() override;
++  uint64_t encoderIntervalMs() const override;
++  int getEffectiveMtu() const override;
++//  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
++//                      uint8_t* p_result_codec_config) override;
++//  bool setPeerCodecCapabilities(
++//      const uint8_t* p_peer_codec_capabilities) override;
++
++ private:
++  bool useRtpHeaderMarkerBit() const override;
++  bool updateEncoderUserConfig(
++      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++      bool* p_restart_input, bool* p_restart_output,
++      bool* p_config_updated) override;
++};
++
++
++// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid SBC codec,
++// otherwise false.
++bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
++
++// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid SBC codec,
++// otherwise false.
++bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
++
++// Checks whether A2DP SBC Sink codec is supported.
++// |p_codec_info| contains information about the codec capabilities.
++// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
++bool A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info);
++
++// Checks whether an A2DP SBC Source codec for a peer Source device is
++// supported.
++// |p_codec_info| contains information about the codec capabilities of the
++// peer device.
++// Returns true if the A2DP SBC Source codec for a peer Source device is
++// supported, otherwise false.
++bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info);
++
++// Initialize state with the default A2DP SBC codec.
++// The initialized state with the codec capabilities is stored in
++// |p_codec_info|.
++void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info);
++
++// Gets the A2DP SBC codec name for a given |p_codec_info|.
++const char* A2DP_VendorCodecNameLhdcV3Sink(const uint8_t* p_codec_info);
++
++// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
++// have the same type.
++// Returns true if the two codecs have the same type, otherwise false.
++bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
++                             const uint8_t* p_codec_info_b);
++
++// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
++// are exactly the same.
++// Returns true if the two codecs are exactly the same, otherwise false.
++// If the codec type is not SBC, the return value is false.
++bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
++                         const uint8_t* p_codec_info_b);
++
++// Gets the track sample rate value for the A2DP SBC codec.
++// |p_codec_info| is a pointer to the SBC codec_info to decode.
++// Returns the track sample rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info);
++
++// Gets the channel mode code for the A2DP SBC codec.
++// The actual value is codec-specific - see |A2DP_SBC_IE_CH_MD_*|.
++// |p_codec_info| is a pointer to the SBC codec_info to decode.
++// Returns the channel mode code on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info);
++
++// Gets the channel type for the A2DP SBC Sink codec:
++// 1 for mono, or 3 for dual/stereo/joint.
++// |p_codec_info| is a pointer to the SBC codec_info to decode.
++// Returns the channel type on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the A2DP SBC audio data timestamp from an audio packet.
++// |p_codec_info| contains the codec information.
++// |p_data| contains the audio data.
++// The timestamp is stored in |p_timestamp|.
++// Returns true on success, otherwise false.
++bool A2DP_VendorGetPacketTimestampLhdcV3Sink(const uint8_t* p_codec_info,
++                                const uint8_t* p_data, uint32_t* p_timestamp);
++
++// Builds A2DP SBC codec header for audio data.
++// |p_codec_info| contains the codec information.
++// |p_buf| contains the audio data.
++// |frames_per_packet| is the number of frames in this packet.
++// Returns true on success, otherwise false.
++/*bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(const uint8_t* p_codec_info, BT_HDR* p_buf,
++                              uint16_t frames_per_packet);
++*/
++// Decodes A2DP SBC codec info into a human readable string.
++// |p_codec_info| is a pointer to the SBC codec_info to decode.
++// Returns a string describing the codec information.
++std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info);
++
++// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
++// packets - see |tA2DP_DECODER_INTERFACE|.
++// |p_codec_info| contains the codec information.
++// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
++// supported, otherwise NULL.
++const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
++    const uint8_t* p_codec_info);
++
++// Adjusts the A2DP SBC codec, based on local support and Bluetooth
++// specification.
++// |p_codec_info| contains the codec information to adjust.
++// Returns true if |p_codec_info| is valid and supported, otherwise false.
++bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info);
++
++// Gets the A2DP SBC Source codec index for a given |p_codec_info|.
++// Returns the corresponding |btav_a2dp_codec_index_t| on success,
++// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
++btav_a2dp_codec_index_t A2DP_SourceCodecIndexSbc(const uint8_t* p_codec_info);
++
++// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
++// Returns the corresponding |btav_a2dp_codec_index_t| on success,
++// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
++btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC V3 Sink codec name.
++const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void);
++
++// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
++// configuration entry pointed by |p_cfg|.
++bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg);
++
++#endif  // A2DP_VENDOR_LHDCV3_DEC_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_decoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_decoder.h
+new file mode 100644
+index 000000000..58b8f1437
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_decoder.h
+@@ -0,0 +1,59 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// Interface to the A2DP LHDC V3 Decoder
++//
++
++#ifndef A2DP_VENDOR_LHDCV3_DECODER_H
++#define A2DP_VENDOR_LHDCV3_DECODER_H
++
++#include "a2dp_codec_api.h"
++#include "a2dp_vendor_lhdc_constants.h"
++
++
++
++// Save CODEC information
++// Return true on success, otherwise false.
++bool save_codec_info (const uint8_t* p_codec_info);
++
++// Loads the A2DP LHDC V3 decoder.
++// Return true on success, otherwise false.
++bool A2DP_VendorLoadDecoderLhdcV3(void);
++
++// Unloads the A2DP LHDC V3 decoder.
++void A2DP_VendorUnloadDecoderLhdcV3(void);
++
++// Initialize the A2DP LHDC V3 decoder.
++bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback);
++
++// Cleanup the A2DP LHDC V3 decoder.
++void a2dp_vendor_lhdcv3_decoder_cleanup(void);
++
++// Decodes |p_buf|. Calls |decode_callback| passed into |a2dp_lhdcv3_decoder_init|
++// if decoded frames are available.
++bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf);
++
++// Start the A2DP LHDCV3 decoder.
++void a2dp_vendor_lhdcv3_decoder_start(void);
++
++// Suspend the A2DP LHDCV3 decoder.
++void a2dp_vendor_lhdcv3_decoder_suspend(void);
++
++// A2DP LHDCV3 decoder configuration.
++void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info);
++
++#endif  // A2DP_VENDOR_LHDCV3_DECODER_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_encoder.h
+new file mode 100644
+index 000000000..e9ea55f9c
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_encoder.h
+@@ -0,0 +1,74 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// Interface to the A2DP LHDC Encoder
++//
++
++#ifndef A2DP_VENDOR_LHDCV3_ENCODER_H
++#define A2DP_VENDOR_LHDCV3_ENCODER_H
++
++#include "a2dp_codec_api.h"
++
++typedef enum {
++  BTAV_A2DP_CODEC_LHDC_CONFIG_NOTUSED = 0,
++  BTAV_A2DP_CODEC_LHDC_CONFIG_AR,
++  BTAV_A2DP_CODEC_LHDC_CONFIG_META,
++} btav_a2dp_codec_lhdc_ConfigCfg_t;
++
++typedef enum {
++  BTAV_A2DP_CODEC_LHDC_DATA_NOTUSED = 0,
++  BTAV_A2DP_CODEC_LHDC_DATA_GYRO_XY,
++} btav_a2dp_codec_lhdc_DataCfg_t;
++
++// Loads the A2DP LHDC encoder.
++// Return true on success, otherwise false.
++bool A2DP_VendorLoadEncoderLhdcV3(void);
++
++// Unloads the A2DP LHDC encoder.
++void A2DP_VendorUnloadEncoderLhdcV3(void);
++
++// Initialize the A2DP LHDC encoder.
++// |p_peer_params| contains the A2DP peer information
++// The current A2DP codec config is in |a2dp_codec_config|.
++// |read_callback| is the callback for reading the input audio data.
++// |enqueue_callback| is the callback for enqueueing the encoded audio data.
++void a2dp_vendor_lhdcv3_encoder_init(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    A2dpCodecConfig* a2dp_codec_config,
++    a2dp_source_read_callback_t read_callback,
++    a2dp_source_enqueue_callback_t enqueue_callback);
++
++// Cleanup the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv3_encoder_cleanup(void);
++
++// Reset the feeding for the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv3_feeding_reset(void);
++
++// Flush the feeding for the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv3_feeding_flush(void);
++
++// Get the A2DP LHDC encoder interval (in milliseconds).
++uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void);
++
++// Prepare and send A2DP LHDC encoded frames.
++// |timestamp_us| is the current timestamp (in microseconds).
++void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us);
++
++// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
++void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length);
++
++#endif  // A2DP_VENDOR_LHDCV3_ENCODER_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5.h b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
+new file mode 100644
+index 000000000..f579b28cd
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
+@@ -0,0 +1,292 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// A2DP Codec API for LHDCV5
++//
++
++#ifndef A2DP_VENDOR_LHDCV5_H
++#define A2DP_VENDOR_LHDCV5_H
++
++#include "a2dp_codec_api.h"
++#include "a2dp_vendor_lhdc_constants.h"
++#include "a2dp_vendor_lhdcv5_constants.h"
++#include "avdt_api.h"
++
++#define IS_SRC  (true)
++#define IS_SNK  (false)
++
++class A2dpCodecConfigLhdcV5Base : public A2dpCodecConfig {
++ protected:
++  	 A2dpCodecConfigLhdcV5Base(btav_a2dp_codec_index_t codec_index,
++                         const std::string& name,
++                         btav_a2dp_codec_priority_t codec_priority,
++                         bool is_source)
++      : A2dpCodecConfig(codec_index, name, codec_priority),
++        is_source_(is_source) {}
++  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
++                      uint8_t* p_result_codec_config) override;
++  bool setPeerCodecCapabilities(
++      const uint8_t* p_peer_codec_capabilities) override;
++
++  int getLhdcExtendAPIVersion(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
++  int getLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
++  int setLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
++  bool setLhdcExtendAPIData(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
++
++ private:
++  bool is_source_;  // True if local is Source
++};
++
++class A2dpCodecConfigLhdcV5Source : public A2dpCodecConfigLhdcV5Base {
++ public:
++	A2dpCodecConfigLhdcV5Source(btav_a2dp_codec_priority_t codec_priority);
++	virtual ~A2dpCodecConfigLhdcV5Source();
++
++	bool init() override;
++	uint64_t encoderIntervalMs() const override;
++	int getEffectiveMtu() const override;
++
++  static int getEncoderExtendFuncUserApiVer(const char* version, const int clen);
++  static int getEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
++  static int setEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
++  static bool setEncoderExtendFuncUserData(const char* userData, const int clen);
++
++ private:
++	bool useRtpHeaderMarkerBit() const override;
++	bool updateEncoderUserConfig(
++		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++		 bool* p_restart_input, bool* p_restart_output,
++		 bool* p_config_updated) override;
++	void debug_codec_dump(int fd) override;
++};
++
++class A2dpCodecConfigLhdcV5Sink : public A2dpCodecConfigLhdcV5Base {
++public:
++ A2dpCodecConfigLhdcV5Sink(btav_a2dp_codec_priority_t codec_priority);
++ virtual ~A2dpCodecConfigLhdcV5Sink();
++
++ bool init() override;
++ uint64_t encoderIntervalMs() const override;
++ int getEffectiveMtu() const override;
++
++private:
++ bool useRtpHeaderMarkerBit() const override;
++ bool updateEncoderUserConfig(
++		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++		 bool* p_restart_input, bool* p_restart_output,
++		 bool* p_config_updated) override;
++};
++
++bool A2DP_VendorGetLowLatencyEnabledLhdcV5();
++// Checks whether the codec capabilities contain a valid A2DP LHDC Source
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid LHDC
++// codec, otherwise false.
++bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
++
++// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid LHDC
++// codec, otherwise false.
++bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
++
++// Checks whether the A2DP data packets should contain RTP header.
++// |content_protection_enabled| is true if Content Protection is
++// enabled. |p_codec_info| contains information about the codec capabilities.
++// Returns true if the A2DP data packets should contain RTP header, otherwise
++// false.
++bool A2DP_VendorUsesRtpHeaderLhdcV5(bool content_protection_enabled,
++                                  const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC codec name for a given |p_codec_info|.
++const char* A2DP_VendorCodecNameLhdcV5(const uint8_t* p_codec_info);
++
++// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
++// have the same type.
++// Returns true if the two codecs have the same type, otherwise false.
++bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
++                                    const uint8_t* p_codec_info_b);
++
++// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
++// are exactly the same.
++// Returns true if the two codecs are exactly the same, otherwise false.
++// If the codec type is not LHDC, the return value is false.
++bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
++                                const uint8_t* p_codec_info_b);
++
++// Gets the track sample rate value for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track sample rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the bits per audio sample for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the bits per audio sample on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the channel count for the A2DP LHDC codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the channel count on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the channel mode code for the A2DP LHDC codec.
++// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the channel mode code on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC audio data timestamp from an audio packet.
++// |p_codec_info| contains the codec information.
++// |p_data| contains the audio data.
++// The timestamp is stored in |p_timestamp|.
++// Returns true on success, otherwise false.
++bool A2DP_VendorGetPacketTimestampLhdcV5(const uint8_t* p_codec_info,
++                                       const uint8_t* p_data,
++                                       uint32_t* p_timestamp);
++
++// Builds A2DP LHDC codec header for audio data.
++// |p_codec_info| contains the codec information.
++// |p_buf| contains the audio data.
++// |frames_per_packet| is the number of frames in this packet.
++// Returns true on success, otherwise false.
++bool A2DP_VendorBuildCodecHeaderLhdcV5(const uint8_t* p_codec_info, BT_HDR* p_buf,
++                                     uint16_t frames_per_packet);
++
++// Decodes A2DP LHDC codec info into a human readable string.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns a string describing the codec information.
++std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info);
++
++// Parse codec info and get the quality mode of the max target bit rate
++// |p_codec_info_| contains the codec information.
++// the translated quality mode from max target bit rate.
++// Returns true if successfully
++bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
++bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
++
++bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
++bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
++
++bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
++bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
++bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
++bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
++
++// Decodes and displays LHDC codec info (for debugging).
++// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
++void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
++// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
++// |p_codec_info| contains the codec information.
++// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
++// supported, otherwise NULL.
++const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
++    const uint8_t* p_codec_info);
++
++// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
++// specification.
++// |p_codec_info| contains the codec information to adjust.
++// Returns true if |p_codec_info| is valid and supported, otherwise false.
++bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
++// Returns the corresponding |btav_a2dp_codec_index_t| on success,
++// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
++btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
++    const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC Source codec name.
++const char* A2DP_VendorCodecIndexStrLhdcV5(void);
++
++// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
++// configuration entry pointed by |p_cfg|.
++bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg);
++
++bool A2DP_VendorGetSrcCapVectorLhdcV5(uint8_t* capVector);
++
++
++
++// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid SBC codec,
++// otherwise false.
++bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
++
++// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
++// codec.
++// NOTE: only codecs that are implemented are considered valid.
++// Returns true if |p_codec_info| contains information about a valid SBC codec,
++// otherwise false.
++bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
++
++// Checks whether A2DP SBC Sink codec is supported.
++// |p_codec_info| contains information about the codec capabilities.
++// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
++bool A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info);
++
++// Checks whether an A2DP SBC Source codec for a peer Source device is
++// supported.
++// |p_codec_info| contains information about the codec capabilities of the
++// peer device.
++// Returns true if the A2DP SBC Source codec for a peer Source device is
++// supported, otherwise false.
++bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the A2DP SBC codec name for a given |p_codec_info|.
++const char* A2DP_VendorCodecNameLhdcV5Sink(const uint8_t* p_codec_info);
++
++// Gets the channel type for the A2DP SBC Sink codec:
++// 1 for mono, or 3 for dual/stereo/joint.
++// |p_codec_info| is a pointer to the SBC codec_info to decode.
++// Returns the channel type on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
++// packets - see |tA2DP_DECODER_INTERFACE|.
++// |p_codec_info| contains the codec information.
++// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
++// supported, otherwise NULL.
++const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
++    const uint8_t* p_codec_info);
++
++// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
++// Returns the corresponding |btav_a2dp_codec_index_t| on success,
++// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
++btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(const uint8_t* p_codec_info);
++
++// Gets the A2DP LHDC V3 Sink codec name.
++const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void);
++
++// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
++// configuration entry pointed by |p_cfg|.
++bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg);
++
++// Gets the track bitrate value for the A2DP LHDCV5 codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track bit rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info);
++
++#endif  // A2DP_VENDOR_LHDCV5_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
+new file mode 100644
+index 000000000..b405d9225
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
+@@ -0,0 +1,255 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// A2DP constants for LHDC codec
++//
++
++#ifndef A2DP_VENDOR_LHDCV5_CONSTANTS_H
++#define A2DP_VENDOR_LHDCV5_CONSTANTS_H
++
++////////////////////////////////////////////////////////////////////
++// LHDCV5 codec info format:
++// SubVersion: A2DP_LHDCV5_VER1
++// Total Length: A2DP_LHDCV5_CODEC_LEN + 1(losc)
++//  ----------------------------------------------------------------
++//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
++//  losc | mediaType | codecType | vendorId | codecId | SampRate |
++//  ----------------------------------------------------------------
++//  P7[2:0]   | P7[5:4]    | P7[7:6]       | P8[3:0] | P8[4]       |
++//  bit depth | MaxBitRate | MinBitRate    | Version | FrameLen5ms |
++//  ----------------------------------------------------------------
++//  P9[0] | P9[1]  | P9[2]   | P9[6] | P9[7]       | P10[0]      |
++//  HasAR | HasJAS | HasMeta | HasLL | HasLossless | FeatureOnAR |
++//  ----------------------------------------------------------------
++
++// P0-P3 Vendor ID: (0x0000053a)
++// P4-P5 Vendor Specific Codec ID: (0x4C35)
++// P6[5:0] Sampling Frequency
++#define A2DP_LHDCV5_SAMPLING_FREQ_MASK    (0x35)
++#define A2DP_LHDCV5_SAMPLING_FREQ_44100   (0x20)
++#define A2DP_LHDCV5_SAMPLING_FREQ_48000   (0x10)
++#define A2DP_LHDCV5_SAMPLING_FREQ_96000   (0x04)
++#define A2DP_LHDCV5_SAMPLING_FREQ_192000  (0x01)
++#define A2DP_LHDCV5_SAMPLING_FREQ_NS      (0x00)
++
++// P7[2:0] Bit depth
++#define A2DP_LHDCV5_BIT_FMT_MASK  (0x07)
++#define A2DP_LHDCV5_BIT_FMT_16    (0x04)
++#define A2DP_LHDCV5_BIT_FMT_24    (0x02)
++#define A2DP_LHDCV5_BIT_FMT_32    (0x01)
++#define A2DP_LHDCV5_BIT_FMT_NS    (0x00)
++
++// P7[5:4] Max Bit Rate Type
++#define A2DP_LHDCV5_MAX_BIT_RATE_MASK   (0x30)
++#define A2DP_LHDCV5_MAX_BIT_RATE_900K   (0x30)
++#define A2DP_LHDCV5_MAX_BIT_RATE_500K   (0x20)
++#define A2DP_LHDCV5_MAX_BIT_RATE_400K   (0x10)
++#define A2DP_LHDCV5_MAX_BIT_RATE_1000K  (0x00)
++
++// P7[7:6] Min Bit Rate Type
++#define A2DP_LHDCV5_MIN_BIT_RATE_MASK   (0xC0)
++#define A2DP_LHDCV5_MIN_BIT_RATE_400K   (0xC0)
++#define A2DP_LHDCV5_MIN_BIT_RATE_256K   (0x80)
++#define A2DP_LHDCV5_MIN_BIT_RATE_128K   (0x40)
++#define A2DP_LHDCV5_MIN_BIT_RATE_64K    (0x00)
++
++// P8[3:0] Codec SubVersion (bitmap)
++#define A2DP_LHDCV5_VERSION_MASK    (0x0F)
++#define A2DP_LHDCV5_VER_1           (0x01)
++#define A2DP_LHDCV5_VER_NS          (0x00)
++
++// P8[5:4] Frame Length Type
++#define A2DP_LHDCV5_FRAME_LEN_MASK  (0x10)
++#define A2DP_LHDCV5_FRAME_LEN_5MS   (0x10)
++#define A2DP_LHDCV5_FRAME_LEN_NS    (0x00)
++
++// P9[0] HasAR
++// P9[1] HasJAS
++// P9[2] HasMeta
++// P9[6] HasLowLatency
++// P9[7] HasLossless
++#define A2DP_LHDCV5_FEATURE_MASK      (0xC7)
++#define A2DP_LHDCV5_FEATURE_LLESS     (0x80)
++#define A2DP_LHDCV5_FEATURE_LL        (0x40)
++#define A2DP_LHDCV5_FEATURE_META      (0x04)
++#define A2DP_LHDCV5_FEATURE_JAS       (0x02)
++#define A2DP_LHDCV5_FEATURE_AR        (0x01)
++
++// P10[0] AR ON/OFF
++#define A2DP_LHDCV5_AR_ON        (0x01)
++////////////////////////////////////////////////////////////////////
++
++////////////////////////////////////////////////////////////////////
++//  attributes which not in codec info format
++//    channel mode
++//    channel separation mode
++////////////////////////////////////////////////////////////////////
++// channel mode:
++#define A2DP_LHDCV5_CHANNEL_MODE_MASK   (0x07)
++#define A2DP_LHDCV5_CHANNEL_MODE_MONO   (0x04)
++#define A2DP_LHDCV5_CHANNEL_MODE_DUAL   (0x02)
++#define A2DP_LHDCV5_CHANNEL_MODE_STEREO (0x01)
++#define A2DP_LHDCV5_CHANNEL_MODE_NS     (0x00)
++
++// LHDC Quality Mode Index
++#define A2DP_LHDCV5_QUALITY_MASK   (0x0F)
++#define A2DP_LHDCV5_QUALITY_ABR    (0x09)  // Adaptive Bit Rate
++#define A2DP_LHDCV5_QUALITY_HIGH1  (0x08)  // 1000kbps
++#define A2DP_LHDCV5_QUALITY_HIGH   (0x07)  // 900kbps
++#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 500kbps
++#define A2DP_LHDCV5_QUALITY_LOW    (0x05)  // 400kbps
++#define A2DP_LHDCV5_QUALITY_LOW4   (0x04)  // 320kbps
++#define A2DP_LHDCV5_QUALITY_LOW3   (0x03)  // 256kbps
++#define A2DP_LHDCV5_QUALITY_LOW2   (0x02)  // 192kbps
++#define A2DP_LHDCV5_QUALITY_LOW1   (0x01)  // 128kbps
++#define A2DP_LHDCV5_QUALITY_LOW0   (0x00)  // 64kbps
++////////////////////////////////////////////////////////////////////
++
++/************************************************
++ * LHDC Feature Capabilities on A2DP specifics:
++   * feature id:                          (1 byte)
++   * target specific index:               (2 bits)
++   * target bit index on a specific:      (decimal: 0~63)
++************************************************/
++// feature code:
++#define LHDCV5_FEATURE_CODE_MASK     (0xFF)
++#define LHDCV5_FEATURE_CODE_NA       (0x00)
++#define LHDCV5_FEATURE_CODE_JAS      (0x01)
++#define LHDCV5_FEATURE_CODE_AR       (0x02)
++#define LHDCV5_FEATURE_CODE_META     (0x03)
++#define LHDCV5_FEATURE_CODE_LL       (0x08)
++#define LHDCV5_FEATURE_CODE_LLESS    (0x09)
++
++// target specific index:
++#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1    (0x00)     //2-bit:00
++#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2    (0x40)     //2-bit:01
++#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3    (0x80)     //2-bit:10
++#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4    (0xC0)     //2-bit:11
++
++// target bit index on the specific:
++//  specific@1
++#define LHDCV5_FEATURE_QM_SPEC_BIT_POS        (0x00)
++//  specific@2
++#define LHDCV5_FEATURE_LL_SPEC_BIT_POS        (0x00)
++//  specific@3
++#define LHDCV5_FEATURE_JAS_SPEC_BIT_POS       (0x00)
++#define LHDCV5_FEATURE_AR_SPEC_BIT_POS        (0x01)
++#define LHDCV5_FEATURE_META_SPEC_BIT_POS      (0x02)
++#define LHDCV5_FEATURE_LLESS_SPEC_BIT_POS     (0x07)
++// Notice: the highest bit position is limited by A2DP_LHDC_FEATURE_MAGIC_NUM(0x4C000000)
++//  ie., available range in a specific: int64[24:0]
++#define LHDCV5_FEATURE_MAX_SPEC_BIT_POS       (0x19)
++
++#define LHDC_SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
++  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
++    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
++  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
++    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
++  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
++    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
++  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
++    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
++} while(0)
++
++#define LHDCV5_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
++  bool marco_ret = false; \
++  do{   \
++    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
++      marco_ret = (cfg->codec_specific_1 & value);   \
++    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
++      marco_ret = (cfg->codec_specific_2 & value);   \
++    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
++      marco_ret = (cfg->codec_specific_3 & value);   \
++    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
++      marco_ret = (cfg->codec_specific_4 & value);   \
++    } while(0);  \
++  marco_ret;   \
++})
++
++//
++// Savitech - LHDC Extended API Start
++//
++/* LHDC Extend API Category */
++// A2DP Type API: handled in bt stack
++#define LHDCV5_EXTEND_API_CODE_A2DP_TYPE            (0x0A)
++// Lib Type API: handled by codec lib
++#define LHDCV5_EXTEND_API_CODE_LIB_TYPE             (0x0C)
++
++#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD       (4)   /* position of API command code in buffer field */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD         (8)   /* position of codec config id in buffer field */
++
++//
++// A2DP Type API: Get info from A2DP codec config's specifics
++//
++#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE      (0x0A010001)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_VER2      (0x02000000)
++
++/* id for A2DP codec config
++ * 0x01: codec_config_
++ * 0x02: codec_capability_
++ * 0x03: codec_local_capability_
++ * 0x04: codec_selectable_capability_
++ * 0x05: codec_user_config_
++ * 0x06: codec_audio_config_
++ */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_CFG                (0x01)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_CAP                (0x02)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP          (0x03)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP         (0x04)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG           (0x05)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG          (0x06)
++/* ************************************************************************
++ * Fields in buffer for LHDCV5_EXTEND_API_VER_GET_SPECIFIC_V2
++ * total 64 bytes:
++   * API Version:                   (4 bytes)
++   * API Code:                      (4 bytes)
++   * A2DP Codec Config Id:          (1 bytes)
++   * Reserved:                      (7 bytes)
++   * A2dp Specific1:                (8 bytes)
++   * A2dp Specific2:                (8 bytes)
++   * A2dp Specific3:                (8 bytes)
++   * A2dp Specific4:                (8 bytes)
++   * Info fields:                   (5*2 bytes)
++     * [0~1]: AR
++     * [2~3]: JAS
++     * [4~5]: META
++     * [6~7]: Low Latency
++     * [8~9]: Loss Less
++   * Pad:                           (6 bytes)
++ * ************************************************************************/
++#define LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE        4       /* API version */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE       4       /* API index code */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_CFGID_SIZE      1       /* A2DP codec config code */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_RSVD_V2         7       /* Reserved bytes */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_1_SIZE          8       /* Specific 1 */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_2_SIZE          8       /* Specific 2 */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_3_SIZE          8       /* Specific 3 */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_4_SIZE          8       /* Specific 4 */
++#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_SIZE_V2    (5<<1)  /* Info fields */
++// total size of buffer fields (64)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2   (64)
++
++#define LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2        (16)
++#define LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2        (24)
++#define LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2        (32)
++#define LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2        (40)
++#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2    (48)
++
++//
++// Savitech - LHDC Extended API End
++//
++#endif  // A2DP_VENDOR_LHDCV5_CONSTANTS_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
+new file mode 100644
+index 000000000..ba5be9825
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
+@@ -0,0 +1,58 @@
++/*
++ * Copyright (C) 2022 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// Interface to the A2DP LHDC V5 Decoder
++//
++
++#ifndef A2DP_VENDOR_LHDCV5_DECODER_H
++#define A2DP_VENDOR_LHDCV5_DECODER_H
++
++#include "a2dp_codec_api.h"
++#include "a2dp_vendor_lhdc_constants.h"
++#include "a2dp_vendor_lhdcv5_constants.h"
++
++
++// Save CODEC information
++// Return true on success, otherwise false.
++bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info);
++
++// Loads the A2DP LHDC V5 decoder.
++// Return true on success, otherwise false.
++bool A2DP_VendorLoadDecoderLhdcV5(void);
++
++// Unloads the A2DP LHDC V5 decoder.
++void A2DP_VendorUnloadDecoderLhdcV5(void);
++
++// Initialize the A2DP LHDC V5 decoder.
++bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback);
++
++// Cleanup the A2DP LHDC V5 decoder.
++void a2dp_vendor_lhdcv5_decoder_cleanup(void);
++
++// Decode LHDC V5 packet to PCM
++bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf);
++
++// Start the A2DP LHDC V5 decoder.
++void a2dp_vendor_lhdcv5_decoder_start(void);
++
++// Suspend the A2DP LHDC V5 decoder.
++void a2dp_vendor_lhdcv5_decoder_suspend(void);
++
++// A2DP LHDC V5 decoder configuration.
++void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info);
++
++#endif  // A2DP_VENDOR_LHDCV5_DECODER_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_encoder.h
+new file mode 100644
+index 000000000..84b53d276
+--- /dev/null
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_encoder.h
+@@ -0,0 +1,63 @@
++/*
++ * Copyright (C) 2016 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++//
++// Interface to the A2DP LHDC Encoder
++//
++
++#ifndef A2DP_VENDOR_LHDCV5_ENCODER_H
++#define A2DP_VENDOR_LHDCV5_ENCODER_H
++
++#include "a2dp_codec_api.h"
++
++// Loads the A2DP LHDC encoder.
++// Return true on success, otherwise false.
++bool A2DP_VendorLoadEncoderLhdcV5(void);
++
++// Unloads the A2DP LHDC encoder.
++bool A2DP_VendorUnloadEncoderLhdcV5(void);
++
++// Initialize the A2DP LHDC encoder.
++// |p_peer_params| contains the A2DP peer information
++// The current A2DP codec config is in |a2dp_codec_config|.
++// |read_callback| is the callback for reading the input audio data.
++// |enqueue_callback| is the callback for enqueueing the encoded audio data.
++void a2dp_vendor_lhdcv5_encoder_init(
++    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
++    A2dpCodecConfig* a2dp_codec_config,
++    a2dp_source_read_callback_t read_callback,
++    a2dp_source_enqueue_callback_t enqueue_callback);
++
++// Cleanup the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv5_encoder_cleanup(void);
++
++// Reset the feeding for the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv5_feeding_reset(void);
++
++// Flush the feeding for the A2DP LHDC encoder.
++void a2dp_vendor_lhdcv5_feeding_flush(void);
++
++// Get the A2DP LHDC encoder interval (in milliseconds).
++uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void);
++
++// Prepare and send A2DP LHDC encoded frames.
++// |timestamp_us| is the current timestamp (in microseconds).
++void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us);
++
++// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
++void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length);
++
++#endif  // A2DP_VENDOR_LHDCV5_ENCODER_H
+diff --git a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
+index 5b3848abd..8f017bad1 100644
+--- a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
++++ b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
+@@ -28,11 +28,20 @@ static const std::vector<const btav_a2dp_codec_index_t> CODEC_INDEX_ENUM_VALS =
+      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
+      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
+      BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
++     // Savitech Patch - START
++     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
++     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
++     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
++     // Savitech Patch - END
+      BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
+      BTAV_A2DP_CODEC_INDEX_SINK_MIN,
+      BTAV_A2DP_CODEC_INDEX_SINK_SBC,
+      BTAV_A2DP_CODEC_INDEX_SINK_AAC,
+      BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
++     // Savitech Patch - START
++     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
++     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
++     // Savitech Patch - END
+      BTAV_A2DP_CODEC_INDEX_SINK_MAX,
+      BTAV_A2DP_CODEC_INDEX_MIN,
+      BTAV_A2DP_CODEC_INDEX_MAX};
+diff --git a/system_bt/stack/test/stack_a2dp_test.cc b/system_bt/stack/test/stack_a2dp_test.cc
+index 2c1e38739..2cb351a30 100644
+--- a/system_bt/stack/test/stack_a2dp_test.cc
++++ b/system_bt/stack/test/stack_a2dp_test.cc
+@@ -209,6 +209,14 @@ static const char* APTX_ENCODER_LIB_NAME = "libaptX_encoder.so";
+ static const char* APTX_HD_ENCODER_LIB_NAME = "libaptXHD_encoder.so";
+ static const char* LDAC_ENCODER_LIB_NAME = "libldacBT_enc.so";
+ static const char* LDAC_DECODER_LIB_NAME = "libldacBT_dec.so";
++// Savitech Patch - START
++static const char* LHDCV2_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
++static const char* LHDCV3_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
++static const char* LHDCV5_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
++static const char* LHDCV3_DECODER_LIB_NAME = "liblhdcBT_dec.so";
++static const char* LHDCV5_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
++// Savitech Patch - END
++
+ 
+ static bool has_shared_library(const char* name) {
+   void* lib_handle = dlopen(name, RTLD_NOW);
+@@ -253,6 +261,23 @@ class StackA2dpTest : public ::testing::Test {
+           // shared library installed.
+           supported = has_shared_library(LDAC_ENCODER_LIB_NAME);
+           break;
++          // Savitech Patch - START  Offload
++        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV3_ENCODER_LIB_NAME);
++          break;
++        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV2_ENCODER_LIB_NAME);
++          break;
++        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV5_ENCODER_LIB_NAME);
++          break;
++          // Savitech Patch - END
+         case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
+           supported = true;
+           break;
+@@ -264,6 +289,18 @@ class StackA2dpTest : public ::testing::Test {
+           // shared library installed.
+           supported = has_shared_library(LDAC_DECODER_LIB_NAME);
+           break;
++        // Savitech Patch - START  Offload
++        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV3_DECODER_LIB_NAME);
++          break;
++        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV5_DECODER_LIB_NAME);
++          break;
++        // Savitech Patch - END
+         case BTAV_A2DP_CODEC_INDEX_MAX:
+           // Needed to avoid using "default:" case so we can capture when
+           // a new codec is added, and it can be included here.
diff --git a/lhdc_release_diff/LHDC_AOSP12_v506_to_v507_220812.diff b/lhdc_release_diff/LHDC_AOSP12_v506_to_v507_220812.diff
new file mode 100644
index 000000000..3a8f69ea4
--- /dev/null
+++ b/lhdc_release_diff/LHDC_AOSP12_v506_to_v507_220812.diff
@@ -0,0 +1,7146 @@
+diff --git a/external/liblhdc/include/lhdc_api.h b/external/liblhdc/include/lhdc_api.h
+index 6e92a0703..079719cb7 100755
+--- a/external/liblhdc/include/lhdc_api.h
++++ b/external/liblhdc/include/lhdc_api.h
+@@ -26,6 +26,7 @@ typedef enum name {
+     LHDCBT_QUALITY_MID,
+     LHDCBT_QUALITY_HIGH,
+     LHDCBT_QUALITY_AUTO,
++    LHDCBT_QUALITY_RESET_AUTO,
+     LHDCBT_QUALITY_MAX
+ } LHDCBT_QUALITY_T;
+ 
+diff --git a/external/liblhdc/release_note b/external/liblhdc/release_note
+index 11af04258..e8bde81d9 100755
+--- a/external/liblhdc/release_note
++++ b/external/liblhdc/release_note
+@@ -1,7 +1,10 @@
+ Release Note.
+ =========================================================
++2022/07/20
++1. Upgrade LHDCV4 encoder version to V4.0.6
++
+ 2022/04/18
+-1. Upgrade LHDCV4 encoder version to V4.0.4 - 60e474
++1. Upgrade LHDCV4 encoder version to V4.0.4
+ 
+ 2021/11/15
+ 1. Add to print LHDC version and build time.
+diff --git a/external/liblhdc/src/lhdcBT_enc.c b/external/liblhdc/src/lhdcBT_enc.c
+index 87df7aada..5c4e15a31 100755
+--- a/external/liblhdc/src/lhdcBT_enc.c
++++ b/external/liblhdc/src/lhdcBT_enc.c
+@@ -23,6 +23,8 @@
+ 
+ #define LHDC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_lhdc)/sizeof(int))
+ #define LLAC_BITRATE_ELEMENTS_SIZE   (sizeof(auto_bitrate_adjust_table_llac)/sizeof(int))
++#define LHDC_ABR_DEFAULT_BITRATE     (400)
++#define LLAC_ABR_DEFAULT_BITRATE     (400)
+ 
+ #define AR_ALWAYS_ONx  1
+ 
+@@ -162,7 +164,7 @@ static int lhdc_encoder_set_bitrate(lhdc_para_t * handle, int bitrate_inx){
+             if (bitrate_inx != LHDCBT_QUALITY_AUTO) {
+                 handle->lastBitrate = TARGET_BITRATE_LIMIT(lhdc_util_get_bitrate(bitrate_inx), handle->hasMinBitrateLimit ? 320 : 128);
+             }else{
+-                handle->lastBitrate = 400;
++                handle->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
+                 lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, handle);
+                 lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, handle);
+             }
+@@ -649,14 +651,60 @@ int lhdcBT_set_bitrate(HANDLE_LHDC_BT handle, int bitrate_inx){
+     enc_t * enc = &lhdcBT->enc;
+ 
+     switch(lhdcBT->enc_type){
+-        case ENC_TYPE_LHDC:
+-            return lhdc_encoder_set_bitrate(enc->lhdc, bitrate_inx);
++        case ENC_TYPE_LHDC: {
++          lhdc_para_t *lhdc = enc->lhdc;
++          if(lhdc == NULL) {
++            ALOGD("%s: LHDC [Reset BiTrAtE] null ptr!",  __func__);
++            return -1;
++          }
++
++          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
++            if(lhdc->qualityStatus != LHDCBT_QUALITY_AUTO) {
++              ALOGD("%s: LHDC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, lhdc->qualityStatus);
++              return -1;
++            }
++            // change bitrate only, do not update qualityStatus
++            lhdc->lastBitrate = LHDC_ABR_DEFAULT_BITRATE;
++            lhdc_util_reset_up_bitrate(ENC_TYPE_LHDC, lhdc);
++            lhdc_util_reset_down_bitrate(ENC_TYPE_LHDC, lhdc);
++            if (lhdc->version >= 2) {
++              lhdc->updateFramneInfo = true;
++            }
++            LossyEncoderSetTargetByteRate(lhdc->fft_blk, (lhdc->lastBitrate * 1000) / 8);
++            ALOGD("%s: LHDC [Reset BiTrAtE] Reset bitrate to (%d)",  __func__, lhdc->lastBitrate);
++            return 0;
++          } else {
++            // normal case, will update qualityStatus
++            ALOGD("%s: LHDC set bitrate_inx %d", __func__, bitrate_inx);
++            return lhdc_encoder_set_bitrate(lhdc, bitrate_inx);
++          }
++        }
+ 
+         case ENC_TYPE_LLAC: {
++          llac_para_t * llac = enc->llac;
++          if(llac == NULL) {
++            ALOGD("%s: LLAC [Reset BiTrAtE] null ptr!",  __func__);
++            return -1;
++          }
+ 
++          if(bitrate_inx == LHDCBT_QUALITY_RESET_AUTO) {
++            if(llac->qualityStatus != LHDCBT_QUALITY_AUTO) {
++              ALOGD("%s: LLAC [Reset BiTrAtE] only work in ABR! (%d)",  __func__, llac->qualityStatus);
++              return -1;
++            }
++            // change bitrate only, do not update qualityStatus
++            llac->lastBitrate = LLAC_ABR_DEFAULT_BITRATE;
++            ALOGD("%s: LLAC [Reset BiTrAtE] Reset bitrate to (%d)", __func__, llac->lastBitrate);
++            llac_enc_set_bitrate(llac->lastBitrate * 1000, &llac->out_nbytes, &llac->real_bitrate, llac->lh4_enc);
++            llac->updateFramneInfo = true;
++            lhdc_util_reset_up_bitrate(ENC_TYPE_LLAC, llac);
++            lhdc_util_reset_down_bitrate(ENC_TYPE_LLAC, llac);
++            return 0;
++          } else {
+             //return llac_encoder_init(enc->llac, sampling_freq, bitPerSample, bitrate_inx, mtu, interval);
+             ALOGD("%s: LLAC not supported", __func__);
+             return -1;
++          }
+         }
+         default:
+         break;
+diff --git a/external/liblhdcdec/release_note b/external/liblhdcdec/release_note
+index 5776bd2c3..5a42cb9e0 100755
+--- a/external/liblhdcdec/release_note
++++ b/external/liblhdcdec/release_note
+@@ -1,5 +1,8 @@
+ Release Note.
+ =========================================================
++2022/05/11
++1. Upgrade LHDCV4 decoder version to V4.0.2
++
+ 2021/11/22
+-Add LHDC v3/v4 Decoder v4.0.2 - 758f73
++Add LHDC v3/v4 Decoder
+ 
+diff --git a/external/liblhdcv5/CHANGES b/external/liblhdcv5/CHANGES
+index e0373be4a..10de496d1 100755
+--- a/external/liblhdcv5/CHANGES
++++ b/external/liblhdcv5/CHANGES
+@@ -1,4 +1,7 @@
+ Release Note.
+ =========================================================
+-Monday, Feb 21, 2022, by jimmy.chen@savitech.co
+-  Summary for 5.0.4 liblhdcv5 release - cf80fc
++Jul 20, 2022, by jimmy.chen@savitech.co
++  Summary for 5.0.5 liblhdcv5 release  
++  
++Feb 21, 2022, by jimmy.chen@savitech.co
++  Summary for 5.0.1 liblhdcv5 release
+\ No newline at end of file
+diff --git a/external/liblhdcv5/include/lhdcv5_api.h b/external/liblhdcv5/include/lhdcv5_api.h
+index dcc5c7eee..860e4e04b 100755
+--- a/external/liblhdcv5/include/lhdcv5_api.h
++++ b/external/liblhdcv5/include/lhdcv5_api.h
+@@ -62,6 +62,7 @@ typedef enum __LHDCV5_QUALITY__
+   LHDCV5_QUALITY_HIGH,
+   LHDCV5_QUALITY_HIGH1,
+   LHDCV5_QUALITY_AUTO,
++  LHDCV5_QUALITY_RESET_AUTO,
+   LHDCV5_QUALITY_INVALID
+ } LHDCV5_QUALITY_T;
+ 
+diff --git a/external/liblhdcv5/src/lhdcv5BT_enc.c b/external/liblhdcv5/src/lhdcv5BT_enc.c
+index d3ef0243c..7719fbe7c 100755
+--- a/external/liblhdcv5/src/lhdcv5BT_enc.c
++++ b/external/liblhdcv5/src/lhdcv5BT_enc.c
+@@ -31,6 +31,8 @@ static uint32_t auto_bitrate_adjust_table_lhdcv5_192k[] = {256, 320, 400, 400, 4
+ #define LHDCV5_96K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_96k) / sizeof(uint32_t))
+ #define LHDCV5_192K_BITRATE_ELEMENTS_SIZE  (sizeof(auto_bitrate_adjust_table_lhdcv5_192k) / sizeof(uint32_t))
+ 
++#define LHDCV5_ABR_DEFAULT_BITRATE     (LHDCV5_QUALITY_LOW)
++
+ 
+ static const char * rate_to_string
+ (
+@@ -177,7 +179,7 @@ static int lhdcv5_encoder_adjust_bitrate
+ 
+   if (lhdcBT == NULL)
+   {
+-    ALOGW ("%s: Handle is NULL!", __func__);
++    ALOGW ("%s: lhdcBT is NULL!", __func__);
+     return LHDCV5_FRET_INVALID_HANDLE_CB;
+   }
+ 
+@@ -189,7 +191,7 @@ static int lhdcv5_encoder_adjust_bitrate
+ 
+   if (handle->qualityStatus != LHDCV5_QUALITY_AUTO)
+   {
+-    ALOGW ("%s: Not ABR", __func__);
++    ALOGW ("%s: Not ABR (%d)", __func__, handle->qualityStatus);
+     return LHDCV5_FRET_SUCCESS;
+   }
+ 
+@@ -569,21 +571,31 @@ int32_t lhdcv5BT_set_bitrate
+   }
+ 
+   if ((bitrate_inx < LHDCV5_QUALITY_LOW0) ||
+-      (bitrate_inx > LHDCV5_QUALITY_AUTO))
++      (bitrate_inx >= LHDCV5_QUALITY_INVALID))
+   {
+     ALOGW ("%s: Invalid bit rate index (%u)!", __func__, bitrate_inx);
+     return LHDCV5_FRET_INVALID_INPUT_PARAM;
+   }
+ 
+-  func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
++  if (bitrate_inx == LHDCV5_QUALITY_RESET_AUTO) {
++    bitrate_inx_set = LHDCV5_ABR_DEFAULT_BITRATE;
++    ALOGD ("%s: [Reset BiTrAtE] reset to bitrate (%s)", __func__, rate_to_string (bitrate_inx_set));
++    bitrate_inx = LHDCV5_ABR_DEFAULT_BITRATE;
++    // change bitrate only, not update quality index
++    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, false);
++  } else {
++    // also update quality index
++    func_ret = lhdcv5_util_set_target_bitrate_inx (handle, bitrate_inx, &bitrate_inx_set, true);
++  }
+ 
+   if (func_ret != LHDCV5_FRET_SUCCESS)
+   {
+-    ALOGW ("%s: failed to set bit rate (%d)!", __func__, func_ret);
++    ALOGW ("%s: failed to set bitrate (%d)!", __func__, func_ret);
+     return LHDCV5_FRET_ERROR;
+   }
+ 
+-  ALOGD ("%s: Update target bitrate(%s)",  __func__, rate_to_string (bitrate_inx_set));
++  ALOGD ("%s: Update target bitrate(%s)",  __func__,
++      rate_to_string (bitrate_inx_set));
+ 
+   return LHDCV5_FRET_SUCCESS;
+ }
+diff --git a/external/liblhdcv5dec/CHANGES b/external/liblhdcv5dec/CHANGES
+index cf1bb70e4..123e86335 100755
+--- a/external/liblhdcv5dec/CHANGES
++++ b/external/liblhdcv5dec/CHANGES
+@@ -1,4 +1,7 @@
+ Release Note.
+ =========================================================
+-Monday, Feb 21, 2022, by jimmy.chen@savitech.co
+-  Summary for 5.0.1 liblhdcv5dec release - b5900e
++Jun 21, 2022, by jimmy.chen@savitech.co
++  *Update version to 5.0.5
++
++Feb, 21, 2022, by jimmy.chen@savitech.co
++  *Add LHDCV5 Decoder v5.0.1
+diff --git a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
+index 29701bd60..0785b9fe2 100755
+--- a/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
++++ b/external/liblhdcv5dec/inc/lhdcv5BT_dec.h
+@@ -4,7 +4,7 @@
+ extern "C" {
+ #endif
+ 
+-#include "lhdcv5Util.h"
++#include "lhdcv5_util_dec.h"
+ 
+ #define LHDCV5BT_SAMPLE_RATE_44K    (44100)
+ #define LHDCV5BT_SAMPLE_RATE_48K    (48000)
+@@ -15,31 +15,53 @@ extern "C" {
+ #define LHDCV5BT_BIT_DEPTH_24    (24)
+ #define LHDCV5BT_BIT_DEPTH_32    (32)
+ 
++#define LHDCV5BT_BIT_RATE_64K    (64000)
++#define LHDCV5BT_BIT_RATE_128K   (128000)
++#define LHDCV5BT_BIT_RATE_192K   (192000)
++#define LHDCV5BT_BIT_RATE_256K   (256000)
++#define LHDCV5BT_BIT_RATE_320K   (320000)
++#define LHDCV5BT_BIT_RATE_400K   (400000)
++#define LHDCV5BT_BIT_RATE_600K   (600000)
++#define LHDCV5BT_BIT_RATE_900K   (900000)
++#define LHDCV5BT_BIT_RATE_1000K  (1000000)
+ 
+-typedef struct  
++
++
++typedef struct
+ {
+   lhdc_ver_t version;
+-  uint32_t   sample_rate;
+-  uint8_t    bits_depth;
++  uint32_t sample_rate;
++  uint32_t bits_depth;
++  uint32_t bit_rate;
+ } tLHDCV5_DEC_CONFIG;
+ 
+ 
+-
+-int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config);
+-int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+-int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+-int lhdcBT_dec_deinit_decoder(void);
+-
++// lib APIs
++int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config);
++int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
++int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
++int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle);
+ 
+ #define LHDCBT_DEC_NOT_UPD_SEQ_NO			0
+ #define LHDCBT_DEC_UPD_SEQ_NO				1
+ 
++typedef enum __LHDCV5BT_DEC_API_RET__
++{
++  LHDCV5BT_DEC_API_SUCCEED            =  0,
++  LHDCV5BT_DEC_API_FAIL               = -1,
++  LHDCV5BT_DEC_API_INVALID_INPUT      = -2,
++  LHDCV5BT_DEC_API_INVALID_OUTPUT     = -3,
++  LHDCV5BT_DEC_API_INVALID_SEQ_NO     = -4,
++  LHDCV5BT_DEC_API_INIT_DECODER_FAIL  = -5,
++  LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL = -6,
++  LHDCV5BT_DEC_API_FRAME_INFO_FAIL    = -7,
++  LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH   = -8,
++  LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH  = -9,
++  LHDCV5BT_DEC_API_DECODE_FAIL        = -10,
++  LHDCV5BT_DEC_API_ALLOC_MEM_FAIL  = -11,
++
++} LHDCV5BT_DEC_API_RET_T;
+ 
+-#define LHDCBT_DEC_FUNC_SUCCEED             0
+-#define LHDCBT_DEC_FUNC_FAIL                -1
+-#define LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH    -2
+-#define LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH   -3
+-#define LHDCBT_DEC_FUNC_INVALID_SEQ_NO		-4
+ 
+ #ifdef __cplusplus
+ }
+diff --git a/external/liblhdcv5dec/include/lhdcv5Util.h b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
+old mode 100755
+new mode 100644
+similarity index 55%
+rename from external/liblhdcv5dec/include/lhdcv5Util.h
+rename to external/liblhdcv5dec/include/lhdcv5_util_dec.h
+index 733bd5670..576d8c5c2
+--- a/external/liblhdcv5dec/include/lhdcv5Util.h
++++ b/external/liblhdcv5dec/include/lhdcv5_util_dec.h
+@@ -1,12 +1,10 @@
+ /*
+- * lhdcv5Util.h
++ * lhdcv5_util_dec.h
+  *
+- *  Created on: 2022/03/18
+- *      Author: jimmy chen
+  */
+ 
+-#ifndef LHDC_UTIL_H
+-#define LHDC_UTIL_H
++#ifndef LHDCV5_UTIL_DEC_H
++#define LHDCV5_UTIL_DEC_H
+ 
+ #include <stdbool.h>
+ #include <stdint.h>
+@@ -15,6 +13,8 @@
+ extern "C" {
+ #endif
+ 
++typedef void * HANDLE_LHDCV5_BT;
++
+ // Copy definition from external
+ #define BTIF_BD_ADDR_SIZE    6
+ 
+@@ -25,10 +25,6 @@ typedef enum {
+ }LHDC_STRM_TYPE;
+ 
+ typedef enum {
+-  VERSION_2 = 200,
+-  VERSION_3 = 300,
+-  VERSION_4 = 400,
+-  VERSION_LLAC = 500,
+   VERSION_5 = 550
+ }lhdc_ver_t;
+ 
+@@ -76,23 +72,29 @@ typedef int (*LHDC_GET_BT_INFO)(savi_bt_local_info * bt_info);
+ #define A2DP_LHDC_HDR_FRAME_NO_MASK 0xfc
+ 
+ 
+-int32_t lhdcv5_util_init_decoder(uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
+-uint32_t lhdcv5_util_dec_put_data(uint8_t * pInpBuf, uint32_t NumBytes);
+-uint32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t len);
+-bool lhdcv5_util_set_license(uint8_t * licTable, LHDC_GET_BT_INFO pFunc);
+-int32_t lhdcv5_util_set_license_check_period (uint8_t period);
++int32_t lhdcv5_util_init_decoder(uint32_t *ptr, uint32_t bitPerSample, uint32_t sampleRate, uint32_t scaleTo16Bits, lhdc_ver_t version);
++
++int32_t lhdcv5_util_dec_process(uint8_t * pOutBuf, uint8_t * pInput, uint32_t InLen, uint32_t *OutLen);
+ char *lhdcv5_util_dec_get_version();
+ 
+ int32_t lhdcv5_util_dec_destroy();
+ 
+-void lhdc_register_log_cb(print_log_fp cb);
++void lhdcv5_util_dec_register_log_cb(print_log_fp cb);
++
++int32_t lhdcv5_util_dec_get_sample_size (uint32_t *frame_samples);
++int32_t lhdcv5_util_dec_fetch_frame_info(uint8_t *frameData, uint32_t frameDataLen, lhdc_frame_Info_t *frameInfo);
+ 
+-uint32_t lhdcv5_util_dec_get_sample_size (void);
+-bool lhdcv5_util_dec_fetch_frame_info(uint8_t * frameData, lhdc_frame_Info_t * frameInfo);
++int32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
++int32_t lhdcv5_util_dec_get_mem_req(lhdc_ver_t version, uint32_t *mem_req_bytes);
+ 
+-uint32_t lhdcv5_util_dec_channel_selsect(lhdc_channel_t channel_type);
++//Return
++#define LHDCV5_UTIL_DEC_SUCCESS 0
++#define LHDCV5_UTIL_DEC_ERROR_NO_INIT -1
++#define LHDCV5_UTIL_DEC_ERROR_PARAM -2
++#define LHDCV5_UTIL_DEC_ERROR -3
++#define LHDCV5_UTIL_DEC_ERROR_WRONG_DEC -10
+ 
+ #ifdef __cplusplus
+ }
+ #endif
+-#endif /* End of LHDC_UTIL_H */
++#endif /* End of LHDCV5_UTIL_DEC_H */
+diff --git a/external/liblhdcv5dec/src/lhdcv5BT_dec.c b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
+index 43b2d872a..92f1534d7 100755
+--- a/external/liblhdcv5dec/src/lhdcv5BT_dec.c
++++ b/external/liblhdcv5dec/src/lhdcv5BT_dec.c
+@@ -21,7 +21,7 @@ static void print_log_cb(char *msg)
+     return;
+   }
+ 
+-  ALOGD("[LHDCV5] %s", msg);
++  ALOGD("[V5Dec_lib] %s", msg);
+ }
+ 
+ 
+@@ -32,26 +32,28 @@ static void print_log_cb(char *msg)
+ //   input_len: length (bytes) of input buffer pointed by input
+ //   pLout: pointer to pointer to output buffer
+ //   pLlen: length (bytes) of encoded stream in output buffer
++//   upd_seq_no: sequence number type
+ // return:
+ //   > 0: number of frames in current packet
+ //   == 0: No frames in current packet
+ //   < 0: error
+-static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len,
++static int32_t assemble_lhdcv5_packet(uint32_t *frame_num, uint8_t *input, uint32_t input_len,
+     uint8_t **pLout, uint32_t *pLlen, int upd_seq_no)
+ {
+   uint8_t hdr = 0, seqno = 0xff;
+-  int ret = LHDCBT_DEC_FUNC_FAIL;
+   uint32_t status = 0;
+   uint32_t lhdc_total_frame_nb = 0;
+ 
+   if ((input == NULL) ||
+       (pLout == NULL) ||
+       (pLlen == NULL)) {
+-    return LHDCBT_DEC_FUNC_FAIL;
++    ALOGD("%s: null ptr", __func__);
++    return -1;
+   }
+ 
+   if (input_len < 2) {
+-    return LHDCBT_DEC_FUNC_FAIL;
++    ALOGD("%s: input len too small", __func__);
++    return -1;
+   }
+ 
+   hdr = (*input);
+@@ -67,16 +69,17 @@ static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len,
+   status = (hdr & A2DP_LHDC_HDR_FRAME_NO_MASK) >> 2;
+ 
+   if (status <= 0) {
+-    ALOGD("%s: No any frame in packet.", __func__);
++    ALOGD("%s: no any frame in packet.", __func__);
++    *frame_num = 0;
+     return 0;
+   }
+ 
+   lhdc_total_frame_nb = status;
+ 
+   if (seqno != serial_no) {
+-    ALOGD("%s: Packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
++    ALOGD("%s: packet lost! now(%d), expect(%d)", __func__, seqno, serial_no);
+     //serial_no = seqno;
+-    //return LHDCBT_DEC_FUNC_INVALID_SEQ_NO;
++    //return -1;
+   }
+ 
+   if (upd_seq_no == LHDCBT_DEC_UPD_SEQ_NO) {
+@@ -86,34 +89,42 @@ static int assemble_lhdc_packet(uint8_t *input, uint32_t input_len,
+   *pLlen = input_len;
+   *pLout = input;
+ 
+-  ret = (int) lhdc_total_frame_nb;
++  *frame_num = (int) lhdc_total_frame_nb;
+ 
+-  ALOGD("%s: ret total frame number (%d)", __func__, ret);
+-  return ret;
++  ALOGD("%s: total frame number (%d)", __func__, *frame_num);
++  return 0;
+ }
+ 
+ 
+ // description
+-//   init. LHDC v4 decoder 
++//   init. LHDC V5 decoder
+ // Parameter
+-//   config: configuration data for LHDC v4 decoder
++//   handle: codec handle(ptr for heap) from bt stack
++//   config: configuration for LHDC V5 decoder
+ // return:
+ //   == 0: succeed
+-//   < 0: error
+-int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config)
++//   != 0: error code
++int32_t lhdcv5BT_dec_init_decoder(HANDLE_LHDCV5_BT *handle, tLHDCV5_DEC_CONFIG *config)
+ {
+-  if (config == NULL) {
+-    return LHDCBT_DEC_FUNC_FAIL;
++  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
++  uint32_t mem_req_bytes = 0;
++  HANDLE_LHDCV5_BT hLhdcBT = NULL;
++
++  ALOGD("%s: decoder lib version = %s", __func__, lhdcv5_util_dec_get_version());
++
++  if (handle == NULL || config == NULL) {
++    ALOGD("%s: null ptr handle %p config %p", __func__, handle, config);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
+   }
+ 
+-  ALOGD("%s: bits_depth:%d sample_rate=%d version=%d", __func__,
+-      config->bits_depth, config->sample_rate, config->version);
++  ALOGD("%s: bits_depth:%u sample_rate=%u bit_rate=%u version=%d", __func__,
++      config->bits_depth, config->sample_rate, config->bit_rate, config->version);
+ 
+   if ((config->bits_depth != LHDCV5BT_BIT_DEPTH_16) &&
+       (config->bits_depth != LHDCV5BT_BIT_DEPTH_24) &&
+       (config->bits_depth != LHDCV5BT_BIT_DEPTH_32)) {
+     ALOGD("%s: bits_depth %d not supported", __func__, config->bits_depth);
+-    return LHDCBT_DEC_FUNC_FAIL;
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
+   }
+ 
+   if ((config->sample_rate != LHDCV5BT_SAMPLE_RATE_44K) &&
+@@ -121,23 +132,59 @@ int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config)
+       (config->sample_rate != LHDCV5BT_SAMPLE_RATE_96K) &&
+       (config->sample_rate != LHDCV5BT_SAMPLE_RATE_192K)) {
+     ALOGD("%s: sample_rate %d not supported", __func__, config->sample_rate);
+-    return LHDCBT_DEC_FUNC_FAIL;
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  if ((0 > config->bit_rate) || (config->bit_rate > LHDCV5BT_BIT_RATE_1000K)) {
++    ALOGD("%s: bit_rate %d not supported", __func__, config->bit_rate);
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
+   }
+ 
+   if ((config->version != VERSION_5)) {
+     ALOGD("%s: version %d not supported", __func__, config->version);
+-    return LHDCBT_DEC_FUNC_FAIL;
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
++  }
++
++  lhdcv5_util_dec_register_log_cb(&print_log_cb);
++
++  func_ret = lhdcv5_util_dec_get_mem_req(config->version, &mem_req_bytes);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS || mem_req_bytes <= 0) {
++    ALOGW("%s: Fail to get required memory size (%d)!", __func__, func_ret);
++    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
++  }
++
++  hLhdcBT = (HANDLE_LHDCV5_BT)malloc(mem_req_bytes);
++  if (hLhdcBT == NULL) {
++    ALOGW ("%s: Fail to allocate memory!", __func__);
++    return LHDCV5BT_DEC_API_ALLOC_MEM_FAIL;
+   }
+ 
+-  lhdc_register_log_cb(&print_log_cb);
++  ALOGD("%s: init lhdcv5 decoder...", __func__);
++  //TODO: send mem_req_bytes for size check
++  func_ret = lhdcv5_util_init_decoder(hLhdcBT, config->bits_depth,
++      config->sample_rate, config->bit_rate, config->version);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGW ("%s: failed to init decoder (%d)!", __func__, func_ret);
++    free(hLhdcBT);
++    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
++  }
+ 
+-  ALOGD("%s: init lhdcv5 decoder", __func__);
+-  lhdcv5_util_init_decoder(config->bits_depth, config->sample_rate, 400000, config->version);
+-  lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
++  *handle = hLhdcBT;
++  if ((*handle) == NULL) {
++    ALOGW ("%s: handle return NULL!", __func__);
++    return LHDCV5BT_DEC_API_INIT_DECODER_FAIL;
++  }
++
++  func_ret = lhdcv5_util_dec_channel_selsect(LHDC_OUTPUT_STEREO);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGW ("%s: failed to configure channel (%d)!", __func__, func_ret);
++    return LHDCV5BT_DEC_API_CHANNEL_SETUP_FAIL;
++  }
+ 
+   serial_no = 0xff;
+ 
+-  return LHDCBT_DEC_FUNC_SUCCEED;
++  ALOGD("%s: init lhdcv5 decoder success", __func__);
++  return LHDCV5BT_DEC_API_SUCCEED;
+ }
+ 
+ 
+@@ -146,10 +193,11 @@ int lhdcBT_dec_init_decoder(tLHDCV5_DEC_CONFIG *config)
+ // Parameter
+ //   frameData: pointer to input buffer
+ //   frameBytes: length (bytes) of input buffer pointed by frameData
++//   packetBytes: return the final number of queued data in decoder lib (for validation)
+ // return:
+ //   == 0: succeed
+ //   < 0: error
+-int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData,
++int32_t lhdcv5BT_dec_check_frame_data_enough(const uint8_t *frameData,
+     uint32_t frameBytes, uint32_t *packetBytes)
+ {
+   uint8_t *frameDataStart = (uint8_t *)frameData;
+@@ -158,47 +206,45 @@ int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData,
+   uint32_t frame_num = 0;
+   lhdc_frame_Info_t lhdc_frame_Info;
+   uint32_t ptr_offset = 0;
+-  bool fn_ret;
++  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+ 
+   if ((frameData == NULL) || (packetBytes == NULL)) {
+-    return LHDCBT_DEC_FUNC_FAIL;
++    return LHDCV5_UTIL_DEC_ERROR_PARAM;
+   }
+ 
+-  ALOGD("%s: enter, frameBytes (%d)", __func__, (int)frameBytes);
+-
+   *packetBytes = 0;
+ 
+-  frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len,
++  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
+       LHDCBT_DEC_NOT_UPD_SEQ_NO);
++  if (func_ret < 0 || in_buf == NULL) {
++    ALOGE("%s: failed setup input buffer", __func__);
++    return LHDCV5BT_DEC_API_FAIL;
++  }
+ 
+   if (frame_num == 0) {
+-    ALOGD("%s: assemble_lhdc_packet (%d)", __func__, (int)frame_num);
+-    return LHDCBT_DEC_FUNC_SUCCEED;
++    return LHDCV5BT_DEC_API_SUCCEED;
+   }
+ 
+-  ALOGD("%s: in_buf (%p), frameData (%p), in_len (%d), frame_num (%d)", __func__,
+-      in_buf, frameData, (int)in_len, (int) frame_num);
++  ALOGD("%s: incoming frame size(%d), decoding size(%d), total frame num(%d)", __func__,
++      frameBytes, in_len, frame_num);
+ 
+   ptr_offset = 0;
+ 
+   while ((frame_num > 0) && (ptr_offset < in_len))
+   {
+-    fn_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, &lhdc_frame_Info);
+-    if (fn_ret == false) {
+-      ALOGD("%s: fetch frame info fail (%d)", __func__, (int)frame_num);
+-      return LHDCBT_DEC_FUNC_FAIL;
++    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
++    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
++      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+     }
+ 
+-    ALOGD("%s: lhdcFetchFrameInfo  frame_num (%d), ptr_offset (%d), "
+-        "lhdc_frame_Info.frame_len (%d), in_len (%d)", __func__,
+-        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len, (int)in_len);
++    ALOGV("%s: frame_num[%d]: ptr_offset (%d), frame_len (%d)", __func__,
++        (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
+ 
+     if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
+-      ALOGD(" %s: Not Enough... frame_num(%d), ptr_offset(%d), "
+-          "frame_len(%d), in_len (%d)", __func__,
+-          (int)frame_num, (int)ptr_offset,
+-          (int)lhdc_frame_Info.frame_len, (int)in_len);
+-      return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
++      ALOGD(" %s: frame_num[%d]: Not Enough... ptr_offset(%d), frame_len(%d)",
++          __func__, (int)frame_num, (int)ptr_offset, (int)lhdc_frame_Info.frame_len);
++      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
+     }
+ 
+     ptr_offset += lhdc_frame_Info.frame_len;
+@@ -208,42 +254,43 @@ int lhdcBT_dec_check_frame_data_enough(const uint8_t *frameData,
+ 
+   *packetBytes = ptr_offset;
+ 
+-  return LHDCBT_DEC_FUNC_SUCCEED;
++  return LHDCV5BT_DEC_API_SUCCEED;
+ }
+ 
+ 
+ // description
+ //   decode all frames in one packet
+ // Parameter
+-//   frameData: pointer to input buffer
++//   frameData: pointer to input buffer from bt stack
+ //   frameBytes: length (bytes) of input buffer pointed by frameData
+-//   pcmData: pointer to output buffer
++//   pcmData: pointer to output buffer to bt stack
+ //   pcmBytes: length (bytes) of pcm samples in output buffer
++//   bits_depth: bit per sample
+ // return:
+ //   == 0: succeed
+ //   < 0: error
+-int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+-    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth)
++int32_t lhdcv5BT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
++    uint8_t *pcmData, uint32_t *pcmBytes, uint32_t bits_depth)
+ {
+   uint8_t *frameDataStart = (uint8_t *)frameData;
+   uint32_t dec_sum = 0;
+   uint32_t lhdc_out_len = 0;
+-  uint8_t *in_buf = NULL;
++  uint8_t *in_buf = NULL;   //buffer position to input to decode process
+   uint32_t in_len = 0;
+   uint32_t frame_num = 0;
+   lhdc_frame_Info_t lhdc_frame_Info;
+   uint32_t ptr_offset = 0;
+-  bool fn_ret;
+   uint32_t frame_samples;
+   uint32_t frame_bytes;
+   uint32_t pcmSpaceBytes;
++  int32_t func_ret = LHDCV5_UTIL_DEC_SUCCESS;
+ 
+-  ALOGD("%s: enter frameBytes %d", __func__, (int)frameBytes);
++  ALOGV("%s: enter frameBytes %d", __func__, (int)frameBytes);
+ 
+   if ((frameData == NULL) ||
+       (pcmData == NULL) ||
+       (pcmBytes == NULL)) {
+-    return LHDCBT_DEC_FUNC_FAIL;
++    return LHDCV5BT_DEC_API_INVALID_INPUT;
+   }
+ 
+   pcmSpaceBytes = *pcmBytes;
+@@ -261,45 +308,62 @@ int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+   }
+    */
+ 
+-  frame_num = assemble_lhdc_packet(frameDataStart, frameBytes, &in_buf, &in_len,
++  func_ret = assemble_lhdcv5_packet(&frame_num, frameDataStart, frameBytes, &in_buf, &in_len,
+       LHDCBT_DEC_UPD_SEQ_NO);
++  if (func_ret < 0 || in_buf == NULL) {
++    ALOGE("%s: failed setup input buffer", __func__);
++    return LHDCV5BT_DEC_API_FAIL;
++  }
+ 
+   if (frame_num == 0) {
+-    return LHDCBT_DEC_FUNC_SUCCEED;
++    return LHDCV5BT_DEC_API_SUCCEED;
++  }
++
++  func_ret = lhdcv5_util_dec_get_sample_size(&frame_samples);
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGD("%s: fetch frame samples failed (%d)", __func__, func_ret);
++    return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+   }
++  ALOGV("%s: output frame samples %d", __func__, (int)frame_samples);
+ 
+-  frame_samples = lhdcv5_util_dec_get_sample_size();
+-  if (bits_depth == 16) {
++  if (bits_depth == LHDCV5BT_BIT_DEPTH_16) {
+     frame_bytes = frame_samples * 2 * 2;
+   } else {
++    // 24 or 32
+     frame_bytes = frame_samples * 4 * 2;
+   }
+-  ALOGD("%s: frame_samples=%d", __func__, (int)frame_samples);
+ 
+   ptr_offset = 0;
+   dec_sum = 0;
+ 
+   while ((frame_num > 0) && (ptr_offset < in_len))
+   {
+-    fn_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, &lhdc_frame_Info);
+-    if (fn_ret == false) {
+-      ALOGD("%s: fetch frame info fail (%d)", __func__, (int)frame_num);
+-      return LHDCBT_DEC_FUNC_FAIL;
++    func_ret = lhdcv5_util_dec_fetch_frame_info(in_buf + ptr_offset, in_len, &lhdc_frame_Info);
++    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++      ALOGD("%s: fetch frame info fail (%d)", __func__, func_ret);
++      return LHDCV5BT_DEC_API_FRAME_INFO_FAIL;
+     }
+ 
+     if ((ptr_offset + lhdc_frame_Info.frame_len) > in_len) {
+-      return LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH;
++      return LHDCV5BT_DEC_API_INPUT_NOT_ENOUGH;
+     }
+ 
+     if ((dec_sum + frame_bytes) > pcmSpaceBytes) {
+-      return LHDCBT_DEC_FUNC_OUTPUT_NOT_ENOUGH;
++      return LHDCV5BT_DEC_API_OUTPUT_NOT_ENOUGH;
+     }
+ 
+     //ALOGD("%s: get ptr_offset=%d, dec_sum=%d", __func__, ptr_offset, dec_sum);
+-    lhdc_out_len = lhdcv5_util_dec_process(((uint8_t *)pcmData) + dec_sum,
+-        in_buf + ptr_offset, lhdc_frame_Info.frame_len);
++    func_ret = lhdcv5_util_dec_process(
++        ((uint8_t *)pcmData) + dec_sum,
++        in_buf + ptr_offset,
++        lhdc_frame_Info.frame_len,
++        &lhdc_out_len);
++    if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++      ALOGD("%s: decode fail (%d)", __func__, func_ret);
++      return LHDCV5BT_DEC_API_DECODE_FAIL;
++    }
+ 
+-    ALOGD("%s: frm=%d, frame_len=%d out_len=%d..", __func__,
++    ALOGD("%s: frame_num[%d]: input_frame_len %d output_len %d", __func__,
+         (int)frame_num, (int)lhdc_frame_Info.frame_len, (int)lhdc_out_len);
+ 
+     ptr_offset += lhdc_frame_Info.frame_len;
+@@ -310,7 +374,7 @@ int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+ 
+   *pcmBytes = (uint32_t) dec_sum;
+ 
+-  return LHDCBT_DEC_FUNC_SUCCEED;
++  return LHDCV5BT_DEC_API_SUCCEED;
+ }
+ 
+ 
+@@ -320,13 +384,26 @@ int lhdcBT_dec_decode(const uint8_t *frameData, uint32_t frameBytes,
+ //   none
+ // return:
+ //   == 0: success
+-int lhdcBT_dec_deinit_decoder(void)
++int32_t lhdcv5BT_dec_deinit_decoder(HANDLE_LHDCV5_BT handle)
+ {
+-  int32_t ret = 0;
++  int32_t func_ret = 0;
++
++  if(handle == NULL) {
++    ALOGD("%s: empty handle", __func__);
++    return LHDCV5BT_DEC_API_SUCCEED;
++  }
+ 
+-  ret = lhdcv5_util_dec_destroy();
+-  ALOGD("%s: ret %d", __func__, ret);
++  func_ret = lhdcv5_util_dec_destroy();
++  if (func_ret != LHDCV5_UTIL_DEC_SUCCESS) {
++    ALOGD("%s: deinit decoder error (%d)", __func__, func_ret);
++    return LHDCV5BT_DEC_API_FAIL;
++  }
++
++  if(handle) {
++    ALOGD ("%s: free handle %p!", __func__, handle);
++    free(handle);
++  }
+ 
+-  return LHDCBT_DEC_FUNC_SUCCEED;
++  return LHDCV5BT_DEC_API_SUCCEED;
+ }
+ 
+diff --git a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
+index 027a3c8f2..9f4d953fe 100755
+--- a/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
++++ b/frameworks_base/core/java/android/bluetooth/BluetoothCodecConfig.java
+@@ -48,7 +48,6 @@ public final class BluetoothCodecConfig implements Parcelable {
+             SOURCE_CODEC_TYPE_LDAC,
+             SOURCE_CODEC_TYPE_LHDCV3,
+             SOURCE_CODEC_TYPE_LHDCV2,
+-            SOURCE_CODEC_TYPE_LHDCV1,
+             SOURCE_CODEC_TYPE_LHDCV5,
+             SOURCE_CODEC_TYPE_MAX,
+             SOURCE_CODEC_TYPE_INVALID
+@@ -79,14 +78,11 @@ public final class BluetoothCodecConfig implements Parcelable {
+     public static final int SOURCE_CODEC_TYPE_LHDCV2 = 6;
+ 
+     @UnsupportedAppUsage
+-    public static final int SOURCE_CODEC_TYPE_LHDCV1 = 7;
+-
+-    @UnsupportedAppUsage
+-    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 8;
++    public static final int SOURCE_CODEC_TYPE_LHDCV5 = 7;
+     // Savitech LHDC -- END
+ 
+     @UnsupportedAppUsage
+-    public static final int SOURCE_CODEC_TYPE_MAX = 9;
++    public static final int SOURCE_CODEC_TYPE_MAX = 8;
+ 
+     @UnsupportedAppUsage
+     public static final int SOURCE_CODEC_TYPE_INVALID = 1000 * 1000;
+@@ -422,8 +418,6 @@ public final class BluetoothCodecConfig implements Parcelable {
+             case SOURCE_CODEC_TYPE_LDAC:
+                 return "LDAC";
+             // Savitech LHDC -- START
+-            case SOURCE_CODEC_TYPE_LHDCV1:
+-                return "LHDC V1";
+             case SOURCE_CODEC_TYPE_LHDCV2:
+                 return "LHDC V2";
+             case SOURCE_CODEC_TYPE_LHDCV3:
+@@ -684,12 +678,11 @@ public final class BluetoothCodecConfig implements Parcelable {
+                 }
+                 return true;
+             // LHDC: Playback Quality at CodecSpecific1, Low Latency at CodecSpecific2; other feature flags at CodecSpecific3.
+-            case SOURCE_CODEC_TYPE_LHDCV1:
+             case SOURCE_CODEC_TYPE_LHDCV2:
+             case SOURCE_CODEC_TYPE_LHDCV3:
+             case SOURCE_CODEC_TYPE_LHDCV5:
+                 if (mCodecSpecific1 != other.mCodecSpecific1 ||
+-                    mCodecSpecific2 != other.mCodecSpecific2 || 
++                    mCodecSpecific2 != other.mCodecSpecific2 ||
+                     mCodecSpecific3 != other.mCodecSpecific3) {
+                     return false;
+                 }
+diff --git a/frameworks_base/core/java/android/provider/Settings.java b/frameworks_base/core/java/android/provider/Settings.java
+index 93983fdf8..289780712 100755
+--- a/frameworks_base/core/java/android/provider/Settings.java
++++ b/frameworks_base/core/java/android/provider/Settings.java
+@@ -10758,7 +10758,7 @@ public final class Settings {
+ 
+         /**
+          * Savitech Add - A2DP_Source_Sink_Switch
+-         * Whether bluetooth A2DP is initialized as Source or Sink 
++         * Whether bluetooth A2DP is initialized as Source or Sink
+          * @hide
+          */
+         @Readable
+diff --git a/frameworks_base/media/java/android/media/AudioManager.java b/frameworks_base/media/java/android/media/AudioManager.java
+index 38f9607c9..e985855dd 100755
+--- a/frameworks_base/media/java/android/media/AudioManager.java
++++ b/frameworks_base/media/java/android/media/AudioManager.java
+@@ -6844,6 +6844,15 @@ public class AudioManager {
+             int btSourceCodec = AudioSystem.audioFormatToBluetoothSourceCodec(format);
+             if (btSourceCodec
+                     != BluetoothCodecConfig.SOURCE_CODEC_TYPE_INVALID) {
++                // Savitech Patch - START  Offload
++                // Add all LHDC series codecs to offload path
++                /*
++                if (btSourceCodec == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2));
++                    codecConfigList.add(new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3));
++                }
++                */
++                // Savitech Patch - END
+                 codecConfigList.add(new BluetoothCodecConfig(btSourceCodec));
+             }
+         }
+diff --git a/frameworks_base/media/java/android/media/AudioSystem.java b/frameworks_base/media/java/android/media/AudioSystem.java
+index 6ff551a68..dd8ca8181 100755
+--- a/frameworks_base/media/java/android/media/AudioSystem.java
++++ b/frameworks_base/media/java/android/media/AudioSystem.java
+@@ -230,6 +230,12 @@ public class AudioSystem
+     public static final int AUDIO_FORMAT_APTX_HD        = 0x21000000;
+     /** @hide */
+     public static final int AUDIO_FORMAT_LDAC           = 0x23000000;
++    // Savitech Patch - START  Offload
++    /** @hide */
++    //public static final int AUDIO_FORMAT_LHDC           = 0x28000000;
++    /** @hide */
++    //public static final int AUDIO_FORMAT_LHDC_LL        = 0x29000000;
++    // Savitech Patch - END
+ 
+     /** @hide */
+     @IntDef(flag = false, prefix = "AUDIO_FORMAT_", value = {
+@@ -239,7 +245,10 @@ public class AudioSystem
+             AUDIO_FORMAT_SBC,
+             AUDIO_FORMAT_APTX,
+             AUDIO_FORMAT_APTX_HD,
+-            AUDIO_FORMAT_LDAC }
++            AUDIO_FORMAT_LDAC,
++            //AUDIO_FORMAT_LHDC,    // Savitech Patch - START  Offload
++            //AUDIO_FORMAT_LHDC_LL,
++            }
+     )
+     @Retention(RetentionPolicy.SOURCE)
+     public @interface AudioFormatNativeEnumForBtCodec {}
+@@ -256,6 +265,14 @@ public class AudioSystem
+             case AUDIO_FORMAT_APTX: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX;
+             case AUDIO_FORMAT_APTX_HD: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD;
+             case AUDIO_FORMAT_LDAC: return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
++            // Savitech Patch - START  Offload
++            /*
++            case AUDIO_FORMAT_LHDC:
++                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
++            case AUDIO_FORMAT_LHDC_LL:
++                return BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
++            */
++            // Savitech Patch - END
+             default:
+                 Log.e(TAG, "Unknown audio format 0x" + Integer.toHexString(audioFormat)
+                         + " for conversion to BT codec");
+@@ -281,6 +298,16 @@ public class AudioSystem
+                 return AudioSystem.AUDIO_FORMAT_APTX_HD;
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
+                 return AudioSystem.AUDIO_FORMAT_LDAC;
++            // Savitech Patch - START  Offload
++            /*
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
++                return AudioSystem.AUDIO_FORMAT_LHDC;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
++                return AudioSystem.AUDIO_FORMAT_LHDC;
++            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
++                return AudioSystem.AUDIO_FORMAT_LHDC;
++            */
++            // Savitech Patch - END
+             default:
+                 Log.e(TAG, "Unknown BT codec 0x" + Integer.toHexString(btCodec)
+                         + " for conversion to audio format");
+diff --git a/frameworks_base/packages/SettingsLib/res/values/arrays.xml b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
+index 2fabb4ec7..cd7f9d29f 100755
+--- a/frameworks_base/packages/SettingsLib/res/values/arrays.xml
++++ b/frameworks_base/packages/SettingsLib/res/values/arrays.xml
+@@ -154,10 +154,11 @@
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
+         <item>LDAC</item>
+-        <item>Savitech LHDC V1</item>
+-        <item>Savitech LHDC V2</item>
+-        <item>Savitech LHDC V3</item>
+-        <item>Savitech LHDC V5</item>
++        <!-- Savitech Patch - START -->
++        <item>Savitech LHDC V2</item>
++        <item>Savitech LHDC V3/V4</item>
++        <item>Savitech LHDC-V</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Values for Bluetooth Audio Codec selection preference. -->
+@@ -168,10 +169,11 @@
+         <item>2</item>
+         <item>3</item>
+         <item>4</item>
++        <!-- Savitech Patch - START -->
+         <item>5</item>
+         <item>6</item>
+         <item>7</item>
+-        <item>8</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Summaries for Bluetooth Audio Codec selection preference. [CHAR LIMIT=50]-->
+@@ -182,10 +184,11 @@
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx">aptX</xliff:g> audio</item>
+         <item><xliff:g id="qualcomm">Qualcomm</xliff:g> <xliff:g id="aptx_hd">aptX HD</xliff:g> audio</item>
+         <item>LDAC</item>
+-        <item>Savitech LHDC V1</item>
+-        <item>Savitech LHDC V2</item>
+-        <item>Savitech LHDC V3</item>
+-        <item>Savitech LHDC V5</item>
++        <!-- Savitech Patch - START -->
++        <item>Savitech LHDC V2</item>
++        <item>Savitech LHDC V3/V4</item>
++        <item>Savitech LHDC-V</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Titles for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50] -->
+@@ -195,8 +198,10 @@
+         <item>48.0 kHz</item>
+         <item>88.2 kHz</item>
+         <item>96.0 kHz</item>
++        <!-- Savitech Patch - START -->
+         <item>176.4 kHz</item>
+         <item>192.0 kHz</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Values for Bluetooth Audio Codec Sample Rate selection preference. -->
+@@ -206,8 +211,10 @@
+         <item>2</item>
+         <item>4</item>
+         <item>8</item>
++        <!-- Savitech Patch - START -->
+         <item>16</item>
+         <item>32</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Summaries for Bluetooth Audio Codec Sample Rate selection preference. [CHAR LIMIT=50]-->
+@@ -217,8 +224,10 @@
+         <item>48.0 kHz</item>
+         <item>88.2 kHz</item>
+         <item>96.0 kHz</item>
++        <!-- Savitech Patch - START -->
+         <item>176.4 kHz</item>
+         <item>192.0 kHz</item>
++        <!-- Savitech Patch - END -->
+     </string-array>
+ 
+     <!-- Titles for Bluetooth Audio Codec Bits Per Sample selection preference. [CHAR LIMIT=50] -->
+@@ -289,14 +298,14 @@
+         <item>Optimized for Connection Quality</item>
+         <item>Best Effort (Adaptive Bit Rate)</item>
+     </string-array>
+-    
++
+     <!-- Titles for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70] -->
+     <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_titles" translatable="false" >
+-        <item>Low bit rate 00 Quality (64kbps)</item>
+-        <item>Low bit rate 01 Quality (128kbps)</item>
+-        <item>Low bit rate 02 Quality (192kbps)</item>
+-        <item>Low bit rate 03 Quality (256kbps)</item>
+-        <item>Low bit rate 04 Quality (320kbps)</item>
++        <item>Optimized for Connection Quality (64kbps)</item>
++        <item>Optimized for Connection Quality (128kbps)</item>
++        <item>Optimized for Connection Quality (192kbps)</item>
++        <item>Optimized for Connection Quality (256kbps)</item>
++        <item>Optimized for Connection Quality (320kbps)</item>
+         <item>Optimized for Connection Quality (400kbps)</item>
+         <item>Balanced Audio And Connection Quality (500kbps)</item>
+         <item>High Audio Quality (900kbps)</item>
+@@ -317,33 +326,33 @@
+         <item>32776</item>
+         <item>32777</item>
+     </string-array>
+-    
++
+     <!-- Summaries for Bluetooth Audio Codec LHDC Playback Quality selection preference. [CHAR LIMIT=70]-->
+     <string-array name="bluetooth_a2dp_codec_lhdc_playback_quality_summaries" translatable="false" >
+-        <item>Low bit rate 00 Quality</item>
+-        <item>Low bit rate 01 Quality</item>
+-        <item>Low bit rate 02 Quality</item>
+-        <item>Low bit rate 03 Quality</item>
+-        <item>Low bit rate 04 Quality</item>
+-        <item>Optimized for Connection Quality</item>
++        <item>Optimized for Connection Quality (64kbps)</item>
++        <item>Optimized for Connection Quality (128kbps)</item>
++        <item>Optimized for Connection Quality (192kbps)</item>
++        <item>Optimized for Connection Quality (256kbps)</item>
++        <item>Optimized for Connection Quality (320kbps)</item>
++        <item>Optimized for Connection Quality (400kbps)</item>
+         <item>Balanced Audio And Connection Quality</item>
+         <item>High Audio Quality</item>
+         <item>Extremely High Audio Quality</item>
+         <item>Best Effort (Auto Bit Rate)</item>
+     </string-array>
+-    
++
+     <!-- Titles for Bluetooth Audio Codec LHDC Low Latency selection preference. [CHAR LIMIT=70] -->
+     <string-array name="bluetooth_a2dp_codec_lhdc_latency_titles" translatable="false" >
+         <item>Low Latency Mode Disable</item>
+         <item>Low Latency Mode Enable</item>
+     </string-array>
+-    
++
+     <!-- Values for Bluetooth Audio Codec LHDC Latency selection preference. -->
+     <string-array name="bluetooth_a2dp_codec_lhdc_latency_values" translatable="false" >
+         <item>49152</item>
+         <item>49153</item>
+     </string-array>
+-    
++
+     <!-- Summaries for Bluetooth Audio Codec LHDC Latency selection preference. [CHAR LIMIT=70]-->
+     <string-array name="bluetooth_a2dp_codec_lhdc_latency_summaries" translatable="false" >
+         <item>Low Latency OFF</item>
+@@ -355,19 +364,38 @@
+         <item>OFF</item>
+         <item>ON</item>
+     </string-array>
+-    
++
+     <!-- Values for Bluetooth Audio Codec LHDC AR Effect selection preference -->
+     <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" translatable="false" >
+         <item>0</item>
+         <item>2</item>
+     </string-array>
+-    
++
+     <!-- Summaries for Bluetooth Audio Codec LHDC AR Effect selection preference [CHAR LIMIT=70]-->
+     <string-array name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries" translatable="false" >
+         <item>LHDC 3DAR Effect OFF</item>
+         <item>LHDC 3DAR Effect ON</item>
+     </string-array>
+ 
++    <!-- Titles for Bluetooth Audio Codec LHDC Lossless selection preference. [CHAR LIMIT=70] -->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_titles" translatable="false" >
++        <item>OFF</item>
++        <item>ON</item>
++    </string-array>
++
++    <!-- Values for Bluetooth Audio Codec LHDC Lossless selection preference -->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_values" translatable="false" >
++        <item>0</item>
++        <item>2</item>
++    </string-array>
++
++    <!-- Summaries for Bluetooth Audio Codec LHDC Lossless selection preference [CHAR LIMIT=70]-->
++    <string-array name="bluetooth_enable_a2dp_codec_lhdc_lossless_summaries" translatable="false" >
++        <item>LHDC Lossless OFF</item>
++        <item>LHDC Lossless ON</item>
++    </string-array>
++    <!-- Savitech Patch - END -->
++
+     <!-- Summaries for Android Auto Bluetooth Audio Active Device status. [CHAR LIMIT=50]-->
+     <string-array name="bluetooth_audio_active_device_summaries" >
+         <!-- Status message when the device is not Active. -->
+diff --git a/frameworks_base/packages/SettingsLib/res/values/strings.xml b/frameworks_base/packages/SettingsLib/res/values/strings.xml
+index dbdbf49bb..954dcb725 100755
+--- a/frameworks_base/packages/SettingsLib/res/values/strings.xml
++++ b/frameworks_base/packages/SettingsLib/res/values/strings.xml
+@@ -704,6 +704,7 @@
+     <!-- UI debug setting: Select Bluetooth Audio LDAC Codec: LDAC Playback Quality -->
+     <string name="bluetooth_select_a2dp_codec_ldac_playback_quality_dialog_title">Trigger Bluetooth Audio LDAC\u000ACodec Selection: Playback Quality</string>
+ 
++    <!-- Savitech LHDC - START -->
+     <!-- UI debug setting: Select Bluetooth Audio LHDC Playback Quality -->
+     <string name="bluetooth_select_a2dp_codec_lhdc_playback_quality">Bluetooth Audio LHDC Codec: Playback Quality</string>
+     <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
+@@ -711,9 +712,9 @@
+ 
+     <!-- UI debug setting: Select Bluetooth Audio LHDC Low Latency -->
+     <string name="bluetooth_select_a2dp_codec_lhdc_latency">Bluetooth Audio LHDC Codec: Low Latency</string>
+-        <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality -->
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency -->
+     <string name="bluetooth_select_a2dp_codec_lhdc_latency_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALatency</string>
+-    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Playback Quality Summary -->
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Codec: LHDC Low Latency Summary -->
+     <string name="bluetooth_select_a2dp_codec_lhdc_latency_summary">LHDC Codec:\u000ALow Latency</string>
+ 
+     <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect -->
+@@ -721,6 +722,12 @@
+     <!-- UI debug setting: Select Bluetooth Audio LHDC AR effect: LHDC AR Audio -->
+     <string name="bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title">Select Bluetooth Audio LHDC Codec:\u000AAR Audio</string>
+ 
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless -->
++    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless">Enable LHDC Lossless</string>
++    <!-- UI debug setting: Select Bluetooth Audio LHDC Lossless: LHDC Lossless Audio -->
++    <string name="bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title">Select Bluetooth Audio LHDC Codec:\u000ALossless Audio</string>
++    <!-- Savitech LHDC - END -->
++
+     <!-- [CHAR LIMIT=NONE] Label for displaying Bluetooth Audio Codec Parameters while streaming -->
+     <string name="bluetooth_select_a2dp_codec_streaming_label">Streaming: <xliff:g id="streaming_parameter">%1$s</xliff:g></string>
+ 
+diff --git a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+index c87ba3303..391d5574b 100755
+--- a/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
++++ b/frameworks_base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
+@@ -2466,7 +2466,7 @@ class DatabaseHelper extends SQLiteOpenHelper {
+ 
+             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_ON,
+                     R.bool.def_bluetooth_on);
+-            
++
+             // Savitech Add -- A2DP_Source_Sink_Switch
+             loadBooleanSetting(stmt, Settings.Global.BLUETOOTH_A2DP_SINK,
+                     R.bool.def_bluetooth_a2dp_sink);
+diff --git a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
+index a1513b304..b18640f9f 100755
+--- a/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
++++ b/hw_if_bluetooth_audio/BluetoothAudioSupportedCodecsDB.cpp
+@@ -30,6 +30,10 @@ using ::android::hardware::bluetooth::audio::V2_0::AacVariableBitRate;
+ using ::android::hardware::bluetooth::audio::V2_0::AptxParameters;
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+@@ -52,7 +56,12 @@ static const PcmParameters kDefaultSoftwarePcmCapabilities = {
+         static_cast<ChannelMode>(ChannelMode::MONO | ChannelMode::STEREO),
+     .bitsPerSample = static_cast<BitsPerSample>(BitsPerSample::BITS_16 |
+                                                 BitsPerSample::BITS_24 |
+-                                                BitsPerSample::BITS_32)};
++                                                BitsPerSample::BITS_32),
++    // Savitech Patch - Start
++    //   LHDC_Low_Latency(non-offload)
++    //.isLowLatencyEnabled = static_cast<LhdcLowLatencyEn>(LhdcLowLatencyEn::Disabled | LhdcLowLatencyEn::Disabled),
++    // Savitech Patch - End
++};
+ 
+ // Default Supported Codecs
+ // SBC: mSampleRate:(44100), mBitsPerSample:(16), mChannelMode:(MONO|STEREO)
+diff --git a/packages_apps_Bluetooth/res/values/config.xml b/packages_apps_Bluetooth/res/values/config.xml
+index ff04a191d..88152d5d0 100755
+--- a/packages_apps_Bluetooth/res/values/config.xml
++++ b/packages_apps_Bluetooth/res/values/config.xml
+@@ -101,10 +101,9 @@
+     <integer name="a2dp_source_codec_priority_aptx">3001</integer>
+     <integer name="a2dp_source_codec_priority_aptx_hd">4001</integer>
+     <integer name="a2dp_source_codec_priority_ldac">5001</integer>
+-    <integer name="a2dp_source_codec_priority_lhdcv1">6001</integer>
+-    <integer name="a2dp_source_codec_priority_lhdcv2">6002</integer>
+-    <integer name="a2dp_source_codec_priority_lhdcv3">6003</integer>
+-    <integer name="a2dp_source_codec_priority_lhdcv5">6004</integer>
++    <integer name="a2dp_source_codec_priority_lhdcv2">6001</integer>
++    <integer name="a2dp_source_codec_priority_lhdcv3">6002</integer>
++    <integer name="a2dp_source_codec_priority_lhdcv5">6003</integer>
+ 
+     <!-- For enabling the AVRCP Target Cover Artowrk feature-->
+     <bool name="avrcp_target_enable_cover_art">true</bool>
+diff --git a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+index 0d29e2a0d..e6f7c040f 100755
+--- a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
++++ b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+@@ -51,8 +51,6 @@ class A2dpCodecConfig {
+             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+     private @CodecPriority int mA2dpSourceCodecPriorityLdac =
+             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+-    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV1 =
+-            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+     private @CodecPriority int mA2dpSourceCodecPriorityLhdcV2 =
+             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+     private @CodecPriority int mA2dpSourceCodecPriorityLhdcV3 =
+@@ -240,16 +238,6 @@ class A2dpCodecConfig {
+         }
+ 
+         // Savitech LHDC -- START
+-        try {
+-            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv1);
+-        } catch (NotFoundException e) {
+-            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+-        }
+-        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+-                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+-            mA2dpSourceCodecPriorityLhdcV1 = value;
+-        }
+-
+         try {
+             value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv2);
+         } catch (NotFoundException e) {
+@@ -316,30 +304,24 @@ class A2dpCodecConfig {
+         codecConfigArray[4] = codecConfig;
+ 
+         // Savitech LHDC -- START
+-        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1,
+-                mA2dpSourceCodecPriorityLhdcV1, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+-                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+-                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+-                0 /* codecSpecific4 */);
+-        codecConfigArray[5] = codecConfig;
+         codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
+                 mA2dpSourceCodecPriorityLhdcV2, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                 BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                 0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                 0 /* codecSpecific4 */);
+-        codecConfigArray[6] = codecConfig;
++        codecConfigArray[5] = codecConfig;
+         codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
+                 mA2dpSourceCodecPriorityLhdcV3, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                 BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                 0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                 0 /* codecSpecific4 */);
+-        codecConfigArray[7] = codecConfig;
++        codecConfigArray[6] = codecConfig;
+         codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
+                 mA2dpSourceCodecPriorityLhdcV5, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                 BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                 0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                 0 /* codecSpecific4 */);
+-        codecConfigArray[8] = codecConfig;
++        codecConfigArray[7] = codecConfig;
+         // Savitech LHDC -- END
+ 
+         return codecConfigArray;
+@@ -352,32 +334,32 @@ class A2dpCodecConfig {
+                                 byte[] exApiVer) {
+         return mA2dpNativeInterface.getLhdcCodecExtendApiVer(device, exApiVer);
+     }
+-        
++
+     int setLhdcCodecExtendApiConfigAr(BluetoothDevice device,
+                                 byte[] codecConfig) {
+         return mA2dpNativeInterface.setLhdcCodecExtendApiConfigAr(device, codecConfig);
+     }
+-    
++
+     int getLhdcCodecExtendApiConfigAr(BluetoothDevice device,
+                                 byte[] codecConfig) {
+         return mA2dpNativeInterface.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+-    }    
+-    
++    }
++
+     int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+                                 byte[] codecConfig) {
+         return mA2dpNativeInterface.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
+     }
+-    
++
+     int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+                                 byte[] codecConfig) {
+         return mA2dpNativeInterface.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
+-    }    
+-    
++    }
++
+     int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device,
+                                 byte[] codecConfig) {
+         return mA2dpNativeInterface.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
+-    }    
+-    
++    }
++
+     void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device,
+                                 byte[] codecData) {
+         mA2dpNativeInterface.setLhdcCodecExtendApiDataGyro2D(device, codecData);
+diff --git a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+index 272c5cb7d..2137780f2 100755
+--- a/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
++++ b/packages_apps_Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+@@ -1487,9 +1487,9 @@ public class A2dpService extends ProfileService {
+ 
+         /************************************************
+          * Savitech Patch - LHDC Extended API Start
+-         ***********************************************/        
++         ***********************************************/
+         @Override
+-        public int getLhdcCodecExtendApiVer(BluetoothDevice device, 
++        public int getLhdcCodecExtendApiVer(BluetoothDevice device,
+                 byte[] exApiVer) {
+             A2dpService service = getServiceLhdc();
+             if (service == null) {
+@@ -1516,7 +1516,7 @@ public class A2dpService extends ProfileService {
+                 return -1;
+             }
+             return service.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+-        }        
++        }
+ 
+         @Override
+         public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+diff --git a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
+index 033591b30..fba3d580f 100755
+--- a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
++++ b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
+@@ -55,10 +55,6 @@
+                 android:id="@+id/bluetooth_audio_codec_ldac"
+                 layout="@layout/preference_widget_dialog_radiobutton"/>
+ 
+-            <include
+-                android:id="@+id/bluetooth_audio_codec_lhdcv1"
+-                layout="@layout/preference_widget_dialog_radiobutton"/>
+-
+             <include
+                 android:id="@+id/bluetooth_audio_codec_lhdcv2"
+                 layout="@layout/preference_widget_dialog_radiobutton"/>
+diff --git a/packages_apps_Settings/res/xml/development_settings.xml b/packages_apps_Settings/res/xml/development_settings.xml
+index 7dd77f0fe..79d488363 100755
+--- a/packages_apps_Settings/res/xml/development_settings.xml
++++ b/packages_apps_Settings/res/xml/development_settings.xml
+@@ -396,6 +396,13 @@
+             android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title"
+             android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles"
+             android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" />
++            
++        <ListPreference
++            android:key="bluetooth_enable_a2dp_codec_lhdc_lossless"
++            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_lossless"
++            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title"
++            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_titles"
++            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_values" />
+ 
+         <ListPreference
+             android:key="bluetooth_max_connected_audio_devices"
+diff --git a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+index 62fead091..1af1465e4 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
++++ b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+@@ -577,6 +577,8 @@ public class DevelopmentSettingsDashboardFragment extends RestrictedDashboardFra
+                 bluetoothA2dpConfigStore));
+         controllers.add(new BluetoothLHDCAudioArEffectPreferenceController(context, lifecycle,
+                 bluetoothA2dpConfigStore));
++        controllers.add(new BluetoothLHDCAudioLosslessPreferenceController(context, lifecycle,
++                bluetoothA2dpConfigStore));
+         // Savitech LHDC -- END
+         controllers.add(new BluetoothChannelModeDialogPreferenceController(context, lifecycle,
+                 bluetoothA2dpConfigStore));
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
+index 4571ffa2d..2b305debb 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
+@@ -42,7 +42,6 @@ public abstract class AbstractBluetoothDialogPreferenceController extends
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
+-            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD,
+             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX,
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
+index 5cd8af28a..93b4f62bb 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
+@@ -61,8 +61,13 @@ public class BluetoothBitPerSampleDialogPreferenceController extends
+             case 0:
+                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+                 if (currentConfig != null) {
+-                    bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
+-                            currentConfig.getCodecType()));
++                /* Savitech patch: pick default by native decision, not always get the Highest one */
++                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                            bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
++                                currentConfig.getCodecType()));
++                    }
+                 }
+                 break;
+             case 1:
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
+index d156abde6..8603f6b5e 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
+@@ -61,8 +61,13 @@ public class BluetoothChannelModeDialogPreferenceController extends
+             case 0:
+                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+                 if (currentConfig != null) {
+-                    channelModeValue = getHighestChannelMode(getSelectableByCodecType(
+-                            currentConfig.getCodecType()));
++                    /* Savitech patch: pick default by native decision, not always get the Highest one */
++                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                            channelModeValue = getHighestChannelMode(getSelectableByCodecType(
++                                currentConfig.getCodecType()));
++                    }
+                 }
+                 break;
+             case 1:
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
+index 327c1ed9a..d9a2d8f83 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
+@@ -61,7 +61,6 @@ public class BluetoothCodecDialogPreference extends BaseBluetoothDialogPreferenc
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx_hd);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_ldac);
+-        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv1);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv2);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv3);
+         mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv5);
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
+index 2d481981c..a73a0e315 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
+@@ -118,18 +118,14 @@ public class BluetoothCodecDialogPreferenceController extends
+                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                 break;
+             case 6:
+-                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1;
+-                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+-                break;
+-            case 7:
+                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2;
+                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                 break;
+-            case 8:
++            case 7:
+                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3;
+                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                 break;
+-            case 9:
++            case 8:
+                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                 break;
+@@ -144,9 +140,19 @@ public class BluetoothCodecDialogPreferenceController extends
+         if (config == null) {
+             Log.d(TAG, "Selectable config is null. Unable to reset");
+         }
+-        mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
+-        mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
+-        mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
++
++        /* Savitech LHDC patch: use default when codec switching */
++        if (codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
++            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
++            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++            mBluetoothA2dpConfigStore.setSampleRate(BluetoothCodecConfig.SAMPLE_RATE_NONE);
++            mBluetoothA2dpConfigStore.setBitsPerSample(BluetoothCodecConfig.BITS_PER_SAMPLE_NONE);
++            mBluetoothA2dpConfigStore.setChannelMode(BluetoothCodecConfig.CHANNEL_MODE_NONE);
++        } else {
++            mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
++            mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
++            mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
++        }
+     }
+ 
+     @Override
+@@ -190,17 +196,14 @@ public class BluetoothCodecDialogPreferenceController extends
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
+                 index = 5;
+                 break;
+-            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1:
+-                index = 6;
+-                break;
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
+-                index = 7;
++                index = 6;
+                 break;
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
+-                index = 8;
++                index = 7;
+                 break;
+             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
+-                index = 9;
++                index = 8;
+                 break;
+             default:
+                 Log.e(TAG, "Unsupported config:" + config);
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
+new file mode 100644
+index 000000000..4c7d0b3a0
+--- /dev/null
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
+@@ -0,0 +1,96 @@
++/*
++ * Copyright (C) 2022 The Android Open Source Project
++ *
++ * Licensed under the Apache License, Version 2.0 (the "License");
++ * you may not use this file except in compliance with the License.
++ * You may obtain a copy of the License at
++ *
++ *      http://www.apache.org/licenses/LICENSE-2.0
++ *
++ * Unless required by applicable law or agreed to in writing, software
++ * distributed under the License is distributed on an "AS IS" BASIS,
++ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
++ * See the License for the specific language governing permissions and
++ * limitations under the License.
++ */
++
++package com.android.settings.development;
++
++import android.bluetooth.BluetoothCodecConfig;
++import android.content.Context;
++
++import com.android.settings.R;
++import com.android.settingslib.core.lifecycle.Lifecycle;
++import android.util.Log;
++
++/**
++ * Switch preference controller for LHDC Lossless ON/OFF
++ */
++public class BluetoothLHDCAudioLosslessPreferenceController extends
++        AbstractBluetoothA2dpPreferenceController {
++
++    private static final int DEFAULT_INDEX = 0;
++    private static final String BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY =
++            "bluetooth_enable_a2dp_codec_lhdc_lossless";
++
++    private static final int LHDC_FEATURE_MASK = 0xFF000000;
++    private static final int LHDC_FEATURE_TAG = 0x4C000000;
++    private static final int LHDC_LOSSLESS_FEATURE = 0x80;
++
++    public BluetoothLHDCAudioLosslessPreferenceController(Context context, Lifecycle lifecycle,
++            BluetoothA2dpConfigStore store) {
++        super(context, lifecycle, store);
++    }
++
++    @Override
++    public String getPreferenceKey() {
++        return BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY;
++    }
++
++    @Override
++    protected String[] getListValues() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_values);
++    }
++
++    @Override
++    protected String[] getListSummaries() {
++        return mContext.getResources().getStringArray(
++                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_summaries);
++    }
++
++    @Override
++    protected int getDefaultIndex() {
++        return DEFAULT_INDEX;
++    }
++
++    @Override
++    protected void writeConfigurationValues(Object newValue) {
++        final int index = mPreference.findIndexOfValue(newValue.toString());
++        int codecSpecific3Value = 0; // default
++        codecSpecific3Value |= LHDC_FEATURE_TAG;
++        if (index != 0) {
++            codecSpecific3Value |= LHDC_LOSSLESS_FEATURE;
++        }else{
++            codecSpecific3Value &= ~LHDC_LOSSLESS_FEATURE;
++        }
++        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
++    }
++
++    @Override
++    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
++        int ret = 0;
++        int index = (int)config.getCodecSpecific3();
++        int tmp = index & LHDC_FEATURE_MASK;
++        if (tmp == LHDC_FEATURE_TAG) {
++            if ((index & LHDC_LOSSLESS_FEATURE) != 0) {
++                ret = 1;
++            } else {
++                ret = 0;
++            }
++        } else {
++            ret = 0;
++        }
++        return ret;
++    }
++}
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
+index 721c349dc..772ae1eb4 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
+@@ -36,12 +36,17 @@ import java.util.List;
+ public class BluetoothLHDCQualityDialogPreferenceController extends
+         AbstractBluetoothDialogPreferenceController {
+ 
++    // In standard case, low0 is available
++    private static final int index_adjust_offset = 0;
++    // In case of low0 is removed, shift the rest indices
++    //private static final int index_adjust_offset = 1;
++
+     private static final String KEY = "bluetooth_select_a2dp_lhdc_playback_quality";
+     private static final String TAG = "BtLhdcAudioQualityCtr";
+     private static final int DEFAULT_TAG = 0xC000;
+     private static final int DEFAULT_MAGIC = 0x8000;
+-    private static final int DEFAULT_INDEX = 5;
+-    private static final int DEFAULT_MAX_INDEX = 9; //0~9
++    private static final int DEFAULT_INDEX = (5 - index_adjust_offset);
++    private static final int DEFAULT_MAX_INDEX = (9 - index_adjust_offset); //0~9
+ 
+     public BluetoothLHDCQualityDialogPreferenceController(Context context, Lifecycle lifecycle,
+                                                       BluetoothA2dpConfigStore store) {
+@@ -63,7 +68,7 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
+     protected void writeConfigurationValues(final int index) {
+         long codecSpecific1Value = 0;
+         if (index <= DEFAULT_MAX_INDEX) {
+-            codecSpecific1Value = DEFAULT_MAGIC | index;
++            codecSpecific1Value = DEFAULT_MAGIC | (index + index_adjust_offset);
+         }else{
+             codecSpecific1Value = DEFAULT_MAGIC | DEFAULT_INDEX;
+         }
+@@ -81,15 +86,13 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
+     @Override
+     public List<Integer> getSelectableIndex() {
+         List<Integer> selectableIndex = new ArrayList<>();
+-        /*
+         final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+         if (currentConfig != null) {
+-            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1 ||
+-                currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
++            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+                 currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3) {
+-                // except 8(ie., 1000K)
++                // excluding 1000Kbps
+                 for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
+-                    if(i != 8) {
++                    if(i != (8 - index_adjust_offset)) {
+                         selectableIndex.add(i);
+                     }
+                 }
+@@ -101,7 +104,6 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
+                 }
+             }
+         }
+-        */
+ 
+         // All items are available to set from UI but be filtered at native layer.
+         for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
+@@ -113,11 +115,10 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
+     @Override
+     public void updateState(Preference preference) {
+         super.updateState(preference);
+-        // Enable preference when current codec type is LHDCV1/V2/V3/V5. For other cases, disable it.
++        // Enable preference when current codec type is LHDC V2/V3/V5. For other cases, disable it.
+         final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+         if (currentConfig != null
+-                && (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV1 || 
+-                    currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
++                && (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+                     currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
+                     currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5)
+                 ) {
+@@ -142,6 +143,6 @@ public class BluetoothLHDCQualityDialogPreferenceController extends
+         } else {
+             index &= 0xff;
+         }
+-        return index;
++        return (index - index_adjust_offset);
+     }
+ }
+diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
+index 1af84788a..6228a6c64 100755
+--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
++++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
+@@ -61,8 +61,13 @@ public class BluetoothSampleRateDialogPreferenceController extends
+             case 0:
+                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+                 if (currentConfig != null) {
+-                    sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
+-                            currentConfig.getCodecType()));
++                    /* Savitech LHDC patch: use default by LHDC native when selecting system default */
++                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
++                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
++                            sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
++                                currentConfig.getCodecType()));
++                    }
+                 }
+                 break;
+             case 1:
+diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.cc b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
+index afa87426b..19a5c8b4f 100755
+--- a/system_bt/audio_bluetooth_hw/device_port_proxy.cc
++++ b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
+@@ -37,6 +37,10 @@ using ::android::bluetooth::audio::BluetoothAudioSessionControl_2_1;
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::PcmParameters;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using SampleRate = ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+ using SampleRate_2_1 = ::android::hardware::bluetooth::audio::V2_1::SampleRate;
+ using BluetoothAudioStatus =
+@@ -108,6 +112,22 @@ audio_format_t BitsPerSampleToAudioFormat(BitsPerSample bits_per_sample) {
+   }
+ }
+ 
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++/*
++bool isLhdcLowLatencyToAudioFormat(LhdcLowLatencyEn low_latency_enabled) {
++  switch (low_latency_enabled) {
++    case LhdcLowLatencyEn::Enabled:
++      return true;
++    case LhdcLowLatencyEn::Disabled:
++      return false;
++    default:
++      return kBluetoothDefaultAudioFormatLhdcLowLatency;
++  }
++}
++*/
++// Savitech Patch - End
++
+ // The maximum time to wait in std::condition_variable::wait_for()
+ constexpr unsigned int kMaxWaitingTimeMs = 4500;
+ 
+@@ -320,6 +340,10 @@ bool BluetoothAudioPortOut::LoadAudioConfig(audio_config_t* audio_cfg) const {
+            ? AUDIO_CHANNEL_OUT_STEREO
+            : OutputChannelModeToAudioFormat(pcm_cfg.channelMode));
+   audio_cfg->format = BitsPerSampleToAudioFormat(pcm_cfg.bitsPerSample);
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  //_lowLatencyEnabled = isLhdcLowLatencyToAudioFormat(pcm_cfg.isLowLatencyEnabled);
++  // Savitech Patch - End
+   return true;
+ }
+ 
+diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.h b/system_bt/audio_bluetooth_hw/device_port_proxy.h
+index 9e113926f..c8b18893a 100755
+--- a/system_bt/audio_bluetooth_hw/device_port_proxy.h
++++ b/system_bt/audio_bluetooth_hw/device_port_proxy.h
+@@ -54,6 +54,15 @@ class BluetoothAudioPort {
+   // Bluetooth stack
+   virtual bool LoadAudioConfig(audio_config_t* audio_cfg) const = 0;
+ 
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  /*
++  bool isLowLatencyEnabled() const {
++    return _lowLatencyEnabled;
++  }
++  */
++  // Savitech Patch - End
++
+   // WAR to support Mono mode / 16 bits per sample
+   void ForcePcmStereoToMono(bool force) {
+     is_stereo_to_mono_ = force;
+@@ -89,6 +98,11 @@ class BluetoothAudioPort {
+            session_type_ == SessionType_2_1::A2DP_HARDWARE_OFFLOAD_DATAPATH;
+   }
+ 
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  //mutable bool _lowLatencyEnabled = false;
++  // Savitech Patch - End
++
+  protected:
+   uint16_t cookie_;
+   BluetoothStreamState state_;
+diff --git a/system_bt/audio_bluetooth_hw/stream_apis.cc b/system_bt/audio_bluetooth_hw/stream_apis.cc
+index aafe547f7..28e1648fc 100755
+--- a/system_bt/audio_bluetooth_hw/stream_apis.cc
++++ b/system_bt/audio_bluetooth_hw/stream_apis.cc
+@@ -86,8 +86,18 @@ void out_calculate_feeding_delay_ms(const BluetoothStreamOut* out,
+     //   frames_count = buffer_size / frame_size
+     //   latency (sec.) = frames_count / samples_per_second (sample_rate)
+     // Sync from audio_a2dp_hw to add extra delay kExtraAudioSyncMs(+200ms)
++#if 0
++    bool lowLatencySt = false;
++    // Savitech Patch - Start
++    //   LHDC_Low_Latency(non-offload)
++    lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
++    delay_report_ms =
++        out->frames_count_ * 1000 / out->sample_rate_ + (lowLatencySt == true ? 0 : kExtraAudioSyncMs);
++    // Savitech Patch - End
++#else
+     delay_report_ms =
+         out->frames_count_ * 1000 / out->sample_rate_ + kExtraAudioSyncMs;
++#endif
+     if (timestamp != nullptr) {
+       clock_gettime(CLOCK_MONOTONIC, &absorbed_timestamp);
+     }
+@@ -220,6 +230,13 @@ static size_t out_get_buffer_size(const struct audio_stream* stream) {
+   const auto* out = reinterpret_cast<const BluetoothStreamOut*>(stream);
+   size_t buffer_size =
+       out->frames_count_ * audio_stream_out_frame_size(&out->stream_out_);
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  /*
++  bool lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
++  if (lowLatencySt) buffer_size = buffer_size/2;
++  */
++  // Savitech Patch - End
+   LOG(VERBOSE) << __func__ << ": state=" << out->bluetooth_output_.GetState()
+                << ", buffer_size=" << buffer_size;
+   return buffer_size;
+diff --git a/system_bt/audio_bluetooth_hw/stream_apis.h b/system_bt/audio_bluetooth_hw/stream_apis.h
+index 55512d7fb..a1d5daeb3 100755
+--- a/system_bt/audio_bluetooth_hw/stream_apis.h
++++ b/system_bt/audio_bluetooth_hw/stream_apis.h
+@@ -26,6 +26,11 @@ constexpr unsigned int kBluetoothDefaultSampleRate = 44100;
+ constexpr audio_format_t kBluetoothDefaultAudioFormatBitsPerSample =
+     AUDIO_FORMAT_PCM_16_BIT;
+ 
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//constexpr bool kBluetoothDefaultAudioFormatLhdcLowLatency = 0;
++// Savitech Patch - End
++
+ constexpr unsigned int kBluetoothDefaultInputBufferMs = 20;
+ constexpr unsigned int kBluetoothDefaultInputStateTimeoutMs = 20;
+ 
+diff --git a/system_bt/audio_hal_interface/a2dp_encoding.cc b/system_bt/audio_hal_interface/a2dp_encoding.cc
+index f88237be5..761791b8f 100755
+--- a/system_bt/audio_hal_interface/a2dp_encoding.cc
++++ b/system_bt/audio_hal_interface/a2dp_encoding.cc
+@@ -44,7 +44,14 @@ using ::bluetooth::audio::codec::A2dpAptxToHalConfig;
+ using ::bluetooth::audio::codec::A2dpCodecToHalBitsPerSample;
+ using ::bluetooth::audio::codec::A2dpCodecToHalChannelMode;
+ using ::bluetooth::audio::codec::A2dpCodecToHalSampleRate;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::bluetooth::audio::codec::A2dpCodecToHalLhdcLowLatencyMode;
++// Savitech Patch - End
+ using ::bluetooth::audio::codec::A2dpLdacToHalConfig;
++// Savitech Patch - Offload
++//using ::bluetooth::audio::codec::A2dpLhdcv5ToHalConfig;
++// Savitech Patch - End
+ using ::bluetooth::audio::codec::A2dpSbcToHalConfig;
+ using ::bluetooth::audio::codec::CodecConfiguration;
+ 
+@@ -264,15 +271,25 @@ bool a2dp_get_selected_hal_codec_config(CodecConfiguration* codec_config) {
+       }
+       break;
+     }
+-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5: {
+-        return true;
++#if 0
++      // Savitech Patch Offload
++      if (!A2dpLhdcv5ToHalConfig(codec_config, a2dp_config)) {
++        LOG(ERROR) << __func__
++                   << ": Fail to call A2dpLhdcv5ToHalConfig(), codec_type=" << current_codec.codec_type;
++        return false;
+       }
+       break;
++#else
++      // for non-offload only
++      return true;
++#endif
++      // Savitech Patch - End
++    }
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+       [[fallthrough]];
+     default:
+@@ -316,6 +333,18 @@ bool a2dp_get_selected_hal_pcm_config(PcmParameters* pcm_config) {
+   pcm_config->sampleRate = A2dpCodecToHalSampleRate(current_codec);
+   pcm_config->bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
+   pcm_config->channelMode = A2dpCodecToHalChannelMode(current_codec);
++
++  // Savitech Patch - Start
++  //   LHDC_Low_Latency(non-offload)
++  /*
++  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3 ||
++      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2 ||
++      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
++    pcm_config->isLowLatencyEnabled = A2dpCodecToHalLhdcLowLatencyMode(current_codec);
++  }
++  */
++  // Savitech Patch - End
++
+   return (pcm_config->sampleRate != SampleRate::RATE_UNKNOWN &&
+           pcm_config->bitsPerSample != BitsPerSample::BITS_UNKNOWN &&
+           pcm_config->channelMode != ChannelMode::UNKNOWN);
+diff --git a/system_bt/audio_hal_interface/client_interface.h b/system_bt/audio_hal_interface/client_interface.h
+index b9f18b9ed..4cd4de3f8 100755
+--- a/system_bt/audio_hal_interface/client_interface.h
++++ b/system_bt/audio_hal_interface/client_interface.h
+@@ -43,6 +43,10 @@ using AudioConfiguration_2_1 =
+     ::android::hardware::bluetooth::audio::V2_1::AudioConfiguration;
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using IBluetoothAudioProvider =
+     ::android::hardware::bluetooth::audio::V2_0::IBluetoothAudioProvider;
+ using IBluetoothAudioProvider_2_1 =
+@@ -221,7 +225,12 @@ class BluetoothAudioClientInterface {
+   static constexpr PcmParameters kInvalidPcmConfiguration = {
+       .sampleRate = SampleRate::RATE_UNKNOWN,
+       .channelMode = ChannelMode::UNKNOWN,
+-      .bitsPerSample = BitsPerSample::BITS_UNKNOWN};
++      .bitsPerSample = BitsPerSample::BITS_UNKNOWN,
++      // Savitech Patch - Start
++      //   LHDC_Low_Latency(non-offload)
++      //.isLowLatencyEnabled = LhdcLowLatencyEn::Disabled,
++      // Savitech Patch - End
++  };
+ 
+  protected:
+   mutable std::mutex internal_mutex_;
+diff --git a/system_bt/audio_hal_interface/client_interface_unittest.cc b/system_bt/audio_hal_interface/client_interface_unittest.cc
+index 33954c720..996060db5 100755
+--- a/system_bt/audio_hal_interface/client_interface_unittest.cc
++++ b/system_bt/audio_hal_interface/client_interface_unittest.cc
+@@ -32,6 +32,8 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
++// Savitech Patch  Offload
++//using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcChannelMode;
+@@ -121,11 +123,15 @@ constexpr ChannelModePair kChannelModePairs[3] = {
+     {.hal_channel_mode_ = ChannelMode::STEREO,
+      .btav_channel_mode_ = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO}};
+ 
++// Savitech Patch  Offload
+ constexpr btav_a2dp_codec_index_t codec_indexes[] = {
+     BTAV_A2DP_CODEC_INDEX_SOURCE_SBC,  BTAV_A2DP_CODEC_INDEX_SOURCE_AAC,
+     BTAV_A2DP_CODEC_INDEX_SOURCE_APTX, BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
+-    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SINK_SBC,
+-    BTAV_A2DP_CODEC_INDEX_SINK_AAC,    BTAV_A2DP_CODEC_INDEX_SINK_LDAC};
++    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
++    BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
++    BTAV_A2DP_CODEC_INDEX_SINK_SBC,
++    BTAV_A2DP_CODEC_INDEX_SINK_AAC, BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
++    BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3, BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5};
+ constexpr uint16_t kPeerMtus[5] = {660, 663, 883, 1005, 1500};
+ 
+ class TestSinkTransport
+@@ -307,6 +313,24 @@ class BluetoothAudioClientInterfaceTest : public Test {
+              ldac_config.bitsPerSample & ldac_capability.bitsPerSample);
+         return is_codec_config_supported;
+       }
++      // Savitech Patch - START  Offload
++      /*
++      case CodecType::LHDCV3:
++        [[fallthrough]];
++      case CodecType::LHDCV2:
++        [[fallthrough]];
++      case CodecType::LHDCV5: {
++        Lhdcv5Parameters lhdcv5_config = codec_config.config.lhdcv5Config();
++        Lhdcv5Parameters lhdcv5_capability =
++            codec_capability.capabilities.lhdcv5Capabilities();
++        is_codec_config_supported =
++            (lhdcv5_config.sampleRate & lhdcv5_capability.sampleRate &&
++             lhdcv5_config.channelMode & lhdcv5_capability.channelMode &&
++             lhdcv5_config.bitsPerSample & lhdcv5_capability.bitsPerSample);
++        return is_codec_config_supported;
++      }
++      */
++      // Savitech Patch - END
+       case CodecType::APTX:
+         [[fallthrough]];
+       case CodecType::APTX_HD: {
+@@ -649,6 +673,81 @@ TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLdacSession) {
+   }
+ }
+ 
++// Savitech Patch - START  Offload
++/*
++std::vector<CodecConfiguration> Lhdcv5CodecConfigurationsGenerator() {
++  std::vector<CodecConfiguration> lhdcv5_codec_configs;
++  CodecConfiguration codec_config = {};
++  Lhdcv5QualityIndex quality_indexes[10] = {
++      Lhdcv5QualityIndex::QUALITY_LOW4, Lhdcv5QualityIndex::QUALITY_LOW3,
++      Lhdcv5QualityIndex::QUALITY_LOW2, Lhdcv5QualityIndex::QUALITY_LOW1,
++    Lhdcv5QualityIndex::QUALITY_LOW0, Lhdcv5QualityIndex::QUALITY_LOW,
++    Lhdcv5QualityIndex::QUALITY_MID, Lhdcv5QualityIndex::QUALITY_HIGH,
++    Lhdcv5QualityIndex::QUALITY_HIGH1, Lhdcv5QualityIndex::QUALITY_ABR};
++  for (auto sample_rate_pair : kSampleRatePairs) {
++    for (auto bits_per_sample_pair : kBitsPerSamplePairs) {
++      for (auto channel_mode_pair : kChannelModePairs) {
++        for (auto peer_mtu : kPeerMtus) {
++          for (auto quality_index : quality_indexes) {
++            codec_config.codecType = CodecType::LHDCV5;
++            codec_config.peerMtu = peer_mtu;
++            codec_config.isScmstEnabled = false;
++            codec_config.encodedAudioBitrate = 400000;
++            Lhdcv5Parameters lhdc = {
++                .sampleRate = sample_rate_pair.hal_sample_rate_,
++                .channelMode = ChannelMode::STEREO,
++                .qualityIndex = quality_index,
++                .bitsPerSample = bits_per_sample_pair.hal_bits_per_sample_};
++            codec_config.config.lhdcv5Config(lhdc);
++            lhdcv5_codec_configs.push_back(codec_config);
++          }  // LdacQualityIndex
++        }    // peerMtu
++      }      // ChannelMode
++    }        // BitsPerSampple
++  }          // SampleRate
++  return lhdcv5_codec_configs;
++}
++
++TEST_F(BluetoothAudioClientInterfaceTest, A2dpLhdcv5CodecOffloadingState) {
++  test_sink_transport_ =
++      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
++  clientif_sink_ =
++      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
++  auto lhdcv5_codec_configs = Lhdcv5CodecConfigurationsGenerator();
++  for (auto codec_offloading_preference :
++       CodecOffloadingPreferenceGenerator(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
++    UpdateOffloadingCapabilities(codec_offloading_preference.preference_);
++    for (CodecConfiguration codec_config : lhdcv5_codec_configs) {
++      if (IsCodecOffloadingSupported(codec_config) &&
++          codec_offloading_preference.is_target_codec_included_) {
++        ASSERT_TRUE(IsCodecOffloadingEnabled(codec_config));
++      } else {
++        ASSERT_FALSE(IsCodecOffloadingEnabled(codec_config));
++      }
++    }
++  }
++}
++
++TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLhdcv5Session) {
++  test_sink_transport_ =
++      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
++  clientif_sink_ =
++      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
++  AudioConfiguration audio_config = {};
++  for (CodecConfiguration codec_config : Lhdcv5CodecConfigurationsGenerator()) {
++    audio_config.codecConfig(codec_config);
++    clientif_sink_->UpdateAudioConfig(audio_config);
++    if (IsCodecOffloadingSupported(codec_config)) {
++      ASSERT_EQ(clientif_sink_->StartSession(), kClientIfReturnSuccess);
++    } else {
++      ASSERT_NE(clientif_sink_->StartSession(), kClientIfReturnSuccess);
++    }
++    ASSERT_EQ(clientif_sink_->EndSession(), kClientIfReturnSuccess);
++  }
++}
++*/
++// Savitech Patch - END
++
+ std::vector<CodecConfiguration> AptxCodecConfigurationsGenerator(
+     CodecType codec_type) {
+   std::vector<CodecConfiguration> aptx_codec_configs;
+diff --git a/system_bt/audio_hal_interface/codec_status.cc b/system_bt/audio_hal_interface/codec_status.cc
+index cd9d88e05..8ebcdb745 100755
+--- a/system_bt/audio_hal_interface/codec_status.cc
++++ b/system_bt/audio_hal_interface/codec_status.cc
+@@ -24,6 +24,7 @@
+ #include "a2dp_vendor_aptx_constants.h"
+ #include "a2dp_vendor_aptx_hd_constants.h"
+ #include "a2dp_vendor_ldac_constants.h"
++#include "a2dp_vendor_lhdc_constants.h"
+ #include "bta/av/bta_av_int.h"
+ 
+ namespace {
+@@ -39,6 +40,16 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
+ using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
++// Savitech Patch - START Offload
++/*
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5QualityIndex;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5FrameDuration;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5DataInterval;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Version;
++using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Specific;
++*/
++// Savitech Patch - END
+ using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
+ using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
+@@ -148,6 +159,30 @@ bool ldac_offloading_capability_match(const LdacParameters& ldac_capability,
+           << " capability=" << toString(ldac_capability);
+   return true;
+ }
++
++// Savitech Patch - START  Offload
++/*
++bool lhdcv5_offloading_capability_match(const Lhdcv5Parameters& lhdcv5_capability,
++                                        const Lhdcv5Parameters& lhdcv5_config) {
++  if ((static_cast<SampleRate>(lhdcv5_capability.sampleRate &
++                               lhdcv5_config.sampleRate) ==
++       SampleRate::RATE_UNKNOWN) ||
++      (static_cast<ChannelMode>(lhdcv5_capability.channelMode &
++                                    lhdcv5_config.channelMode) ==
++       ChannelMode::UNKNOWN) ||
++      (static_cast<BitsPerSample>(lhdcv5_capability.bitsPerSample &
++                                  lhdcv5_config.bitsPerSample) ==
++       BitsPerSample::BITS_UNKNOWN)) {
++    LOG(WARNING) << __func__ << ": software codec=" << toString(lhdcv5_config)
++                 << " capability=" << toString(lhdcv5_capability);
++    return false;
++  }
++  VLOG(1) << __func__ << ": offloading codec=" << toString(lhdcv5_config)
++          << " capability=" << toString(lhdcv5_capability);
++  return true;
++}
++*/
++// Savitech Patch - END
+ }  // namespace
+ 
+ namespace bluetooth {
+@@ -211,6 +246,26 @@ ChannelMode A2dpCodecToHalChannelMode(
+   }
+ }
+ 
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++/*
++LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
++    const btav_a2dp_codec_config_t& a2dp_codec_config) {
++  switch ((int)(a2dp_codec_config.codec_specific_2 & 0x1)) {
++    case 0:
++      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
++      return LhdcLowLatencyEn::Disabled;
++    case 1:
++      LOG(INFO) << __func__ << ": LHDC low latency Enabled";
++      return LhdcLowLatencyEn::Enabled;
++    default:
++      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
++      return LhdcLowLatencyEn::Disabled;
++  }
++}
++*/
++// Savitech Patch - End
++
+ bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config) {
+   btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
+@@ -470,6 +525,88 @@ bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
+   return true;
+ }
+ 
++// Savitech Patch - START  Offload
++#if 0
++//require definition supported in hardware/interfaces/bluetooth/audio/types.hal
++bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
++                         A2dpCodecConfig* a2dp_config) {
++  btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
++  if ((current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) &&
++      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) &&
++      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
++    codec_config = {};
++    return false;
++  }
++  LOG(INFO) << __func__ << ": enter: codec_type = " << current_codec.codec_type;
++
++  tBT_A2DP_OFFLOAD a2dp_offload;
++  if (false == a2dp_config->getCodecSpecificConfig(&a2dp_offload) ) {
++    LOG(ERROR) << __func__ << ": getCodecSpecificConfig fail";
++    return false;
++  }
++
++  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) {
++    codec_config->codecType = CodecType::LHDCV3;
++  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) {
++    codec_config->codecType = CodecType::LHDCV2;
++  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
++    codec_config->codecType = CodecType::LHDCV5;
++  }
++  codec_config->config.lhdcv5Config({});
++  auto lhdcv5Config = codec_config->config.lhdcv5Config();
++
++  lhdcv5Config.sampleRate = A2dpCodecToHalSampleRate(current_codec);
++  if (lhdcv5Config.sampleRate == SampleRate::RATE_UNKNOWN) {
++    LOG(ERROR) << __func__
++               << ": Unknown LHDC Vn sample_rate=" << current_codec.sample_rate;
++    return false;
++  }
++
++  lhdcv5Config.channelMode = A2dpCodecToHalChannelMode(current_codec);
++  if (lhdcv5Config.channelMode == ChannelMode::UNKNOWN) {
++    LOG(ERROR) << __func__
++               << ": Unknown LHDC Vn channel_mode=" << current_codec.channel_mode;
++    return false;
++  }
++
++  lhdcv5Config.bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
++  if (lhdcv5Config.bitsPerSample == BitsPerSample::BITS_UNKNOWN) {
++    LOG(ERROR) << __func__ << ": Unknown LHDC Vn bits_per_sample="
++               << current_codec.bits_per_sample;
++    return false;
++  }
++
++  lhdcv5Config.codecVersion            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Version) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_VER];
++  lhdcv5Config.qualityIndex            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
++                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L]));
++  lhdcv5Config.maxQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
++                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L]));
++  lhdcv5Config.minQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
++                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]));
++  lhdcv5Config.frameDuration           = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5FrameDuration) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR];
++  lhdcv5Config.dataInterval            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5DataInterval)  a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL];
++  lhdcv5Config.codecSpecific_1         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1];
++  lhdcv5Config.codecSpecific_2         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2];
++  lhdcv5Config.metaData[0]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META];
++  lhdcv5Config.metaData[1]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 1];
++  lhdcv5Config.metaData[2]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 2];
++  lhdcv5Config.metaData[3]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 3];
++  lhdcv5Config.metaData[4]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 4];
++  lhdcv5Config.metaData[5]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 5];
++  lhdcv5Config.metaData[6]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 6];
++  lhdcv5Config.metaData[7]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 7];
++
++  codec_config->config.lhdcv5Config(lhdcv5Config);
++
++  LOG(INFO) << __func__ << ": debug: sampleRate = " << current_codec.sample_rate;
++  LOG(INFO) << __func__ << ": debug: bitsPerSample = " << current_codec.bits_per_sample;
++  LOG(INFO) << __func__ << ": debug: channelMode = " << current_codec.channel_mode;
++
++  return true;
++}
++#endif
++// Savitech Patch - END
++
+ bool UpdateOffloadingCapabilities(
+     const std::vector<btav_a2dp_codec_config_t>& framework_preference) {
+   audio_hal_capabilities = BluetoothAudioClientInterface::GetAudioCapabilities(
+@@ -492,10 +629,38 @@ bool UpdateOffloadingCapabilities(
+       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+         codec_type_masks |= CodecType::LDAC;
+         break;
++      // Savitech Patch - START  Offload
++#if 0
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++        codec_type_masks |= CodecType::LHDCV3;
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++        codec_type_masks |= CodecType::LHDCV2;
++        break;
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++        codec_type_masks |= CodecType::LHDCV5;
++        break;
++#else
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++        [[fallthrough]];
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++        [[fallthrough]];
++      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++        LOG(WARNING) << __func__
++                     << ": Ignore source codec_type=" << preference.codec_type;
++        break;
++#endif
++      // Savitech Patch - END
+       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
+         [[fallthrough]];
+       case BTAV_A2DP_CODEC_INDEX_SINK_AAC:
+         [[fallthrough]];
++      // Savitech Patch - START  Offload
++      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++          [[fallthrough]];
++      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++        [[fallthrough]];
++      // Savitech Patch - END
+       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+         LOG(WARNING) << __func__
+                      << ": Ignore sink codec_type=" << preference.codec_type;
+@@ -554,6 +719,21 @@ bool IsCodecOffloadingEnabled(const CodecConfiguration& codec_config) {
+         auto ldac_config = codec_config.config.ldacConfig();
+         return ldac_offloading_capability_match(ldac_capability, ldac_config);
+       }
++      // Savitech Patch - START  Offload
++      /*
++      case CodecType::LHDCV3:
++        [[fallthrough]];
++      case CodecType::LHDCV2:
++        [[fallthrough]];
++      case CodecType::LHDCV5: {
++        LOG(INFO) << __func__ << ": LHDC aDSP codecType="
++                   << toString(codec_capability.codecType);
++        auto lhdcv5_capability = codec_capability.capabilities.lhdcv5Capabilities();
++        auto lhdcv5_config = codec_config.config.lhdcv5Config();
++        return lhdcv5_offloading_capability_match(lhdcv5_capability, lhdcv5_config);
++      }
++      */
++      // Savitech Patch - END
+       case CodecType::UNKNOWN:
+         [[fallthrough]];
+       default:
+diff --git a/system_bt/audio_hal_interface/codec_status.h b/system_bt/audio_hal_interface/codec_status.h
+index e0e074438..6a476f086 100755
+--- a/system_bt/audio_hal_interface/codec_status.h
++++ b/system_bt/audio_hal_interface/codec_status.h
+@@ -28,6 +28,10 @@ namespace codec {
+ 
+ using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
+ using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
++// Savitech Patch - End
+ using ::android::hardware::bluetooth::audio::V2_0::CodecConfiguration;
+ using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
+ 
+@@ -39,6 +43,13 @@ BitsPerSample A2dpCodecToHalBitsPerSample(
+     const btav_a2dp_codec_config_t& a2dp_codec_config);
+ ChannelMode A2dpCodecToHalChannelMode(
+     const btav_a2dp_codec_config_t& a2dp_codec_config);
++// Savitech Patch - Start
++//   LHDC_Low_Latency(non-offload)
++/*
++LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
++    const btav_a2dp_codec_config_t& a2dp_codec_config);
++    */
++// Savitech Patch - End
+ 
+ bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config);
+@@ -48,7 +59,10 @@ bool A2dpAptxToHalConfig(CodecConfiguration* codec_config,
+                          A2dpCodecConfig* a2dp_config);
+ bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
+                          A2dpCodecConfig* a2dp_config);
+-
++// Savitech Patch - START  Offload
++bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
++                         A2dpCodecConfig* a2dp_config);
++// Savitech Patch - END
+ bool UpdateOffloadingCapabilities(
+     const std::vector<btav_a2dp_codec_config_t>& framework_preference);
+ // Check whether this codec is supported by the audio HAL and is allowed to use
+diff --git a/system_bt/bta/av/bta_av_aact.cc b/system_bt/bta/av/bta_av_aact.cc
+index 33298d649..50d7433c9 100755
+--- a/system_bt/bta/av/bta_av_aact.cc
++++ b/system_bt/bta/av/bta_av_aact.cc
+@@ -3198,6 +3198,17 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+       codec_type = BTA_AV_CODEC_TYPE_LDAC;
+       break;
++    // Savitech Patch - START  Offload
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      codec_type = BTA_AV_CODEC_TYPE_LHDCV3;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      codec_type = BTA_AV_CODEC_TYPE_LHDCV2;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      codec_type = BTA_AV_CODEC_TYPE_LHDCV5;
++      break;
++    // Savitech Patch - END
+     default:
+       APPL_TRACE_ERROR("%s: Unknown Codec type ", __func__);
+       return;
+@@ -3231,6 +3242,14 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
+     case 96000:
+       p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+       break;
++    // Savitech Patch - START  Offload
++    case 176400:
++      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_176400;
++      break;
++    case 192000:
++      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
++      break;
++    // Savitech Patch - END
+   }
+   if (L2CA_GetRemoteCid(p_scb->l2c_cid, &p_a2dp_offload->l2c_rcid) == false) {
+     APPL_TRACE_ERROR("%s: Failed to fetch l2c rcid", __func__);
+diff --git a/system_bt/bta/include/bta_av_api.h b/system_bt/bta/include/bta_av_api.h
+index 4591bbaef..1aacad72c 100755
+--- a/system_bt/bta/include/bta_av_api.h
++++ b/system_bt/bta/include/bta_av_api.h
+@@ -151,7 +151,12 @@ typedef enum {
+   BTA_AV_CODEC_TYPE_AAC = 0x02,
+   BTA_AV_CODEC_TYPE_APTX = 0x04,
+   BTA_AV_CODEC_TYPE_APTXHD = 0x08,
+-  BTA_AV_CODEC_TYPE_LDAC = 0x10
++  BTA_AV_CODEC_TYPE_LDAC = 0x10,
++  // Savitech Patch - START
++  BTA_AV_CODEC_TYPE_LHDCV3 = 0x20,
++  BTA_AV_CODEC_TYPE_LHDCV2 = 0x40,
++  BTA_AV_CODEC_TYPE_LHDCV5 = 0x80,
++  // Savitech Patch - END
+ } tBTA_AV_CODEC_TYPE;
+ 
+ /* Event associated with BTA_AV_ENABLE_EVT */
+diff --git a/system_bt/btif/src/btif_a2dp_audio_interface.cc b/system_bt/btif/src/btif_a2dp_audio_interface.cc
+index 7d7a083a3..2b60cc72f 100755
+--- a/system_bt/btif/src/btif_a2dp_audio_interface.cc
++++ b/system_bt/btif/src/btif_a2dp_audio_interface.cc
+@@ -232,6 +232,23 @@ static void btif_a2dp_get_codec_configuration(
+       p_codec_info->codecSpecific.ldacData.bitrateIndex =
+           a2dp_offload.codec_info[6];
+       break;
++    // Savitech Patch - START  Offload
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      p_codec_info->codecType =
++          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
++          BTA_AV_CODEC_TYPE_LHDCV3;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      p_codec_info->codecType =
++          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
++          BTA_AV_CODEC_TYPE_LHDCV2;
++      break;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      p_codec_info->codecType =
++          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
++          BTA_AV_CODEC_TYPE_LHDCV5;
++      break;
++    // Savitech Patch - END
+     default:
+       APPL_TRACE_ERROR("%s: Unknown Codec type :%d ", __func__,
+                        codec_config.codec_type);
+diff --git a/system_bt/btif/src/btif_a2dp_source.cc b/system_bt/btif/src/btif_a2dp_source.cc
+index 6359d3029..94c5bfd78 100755
+--- a/system_bt/btif/src/btif_a2dp_source.cc
++++ b/system_bt/btif/src/btif_a2dp_source.cc
+@@ -930,7 +930,7 @@ static uint32_t btif_a2dp_source_read_callback(uint8_t* p_buf, uint32_t len) {
+     if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
+       bytes_read = bluetooth::audio::a2dp::read(p_buf + bytes_offset, len_read);
+     } else if (a2dp_uipc != nullptr) {
+-      bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len);
++      bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len_read);
+     }
+ 
+     // Savitech LHDC -- Low Latency Mode
+diff --git a/system_bt/common/metrics.cc b/system_bt/common/metrics.cc
+index 9214dcbde..ada5d0692 100755
+--- a/system_bt/common/metrics.cc
++++ b/system_bt/common/metrics.cc
+@@ -249,6 +249,14 @@ static A2dpSourceCodec get_a2dp_source_codec(int64_t codec_index) {
+       return A2dpSourceCodec::A2DP_SOURCE_CODEC_APTX_HD;
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+       return A2dpSourceCodec::A2DP_SOURCE_CODEC_LDAC;
++    // Savitech Patch - START  Offload
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV3;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV2;
++    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV5;
++    // Savitech Patch - END
+     default:
+       return A2dpSourceCodec::A2DP_SOURCE_CODEC_UNKNOWN;
+   }
+diff --git a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
+index 676798782..31d606fab 100755
+--- a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
++++ b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
+@@ -138,6 +138,11 @@ enum A2dpSourceCodec {
+   A2DP_SOURCE_CODEC_APTX = 3;
+   A2DP_SOURCE_CODEC_APTX_HD = 4;
+   A2DP_SOURCE_CODEC_LDAC = 5;
++  // Savitech Patch - START  Offload
++  A2DP_SOURCE_CODEC_LHDCV3 = 6;
++  A2DP_SOURCE_CODEC_LHDCV2 = 7;
++  A2DP_SOURCE_CODEC_LHDCV5 = 8;
++  // Savitech Patch - END
+ }
+ 
+ // Session information that gets logged for A2DP session.
+diff --git a/system_bt/include/hardware/bt_av.h b/system_bt/include/hardware/bt_av.h
+index e89da167e..432644ae3 100755
+--- a/system_bt/include/hardware/bt_av.h
++++ b/system_bt/include/hardware/bt_av.h
+@@ -56,7 +56,6 @@ typedef enum {
+   BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
+   BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
+   BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+-  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1,
+   BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+ 
+   BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
+@@ -160,9 +159,6 @@ typedef struct {
+       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
+         codec_name_str = "LDAC";
+         break;
+-      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+-        codec_name_str = "LHDC V1";
+-        break;
+       case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+         codec_name_str = "LHDC V2";
+         break;
+diff --git a/system_bt/stack/Android.bp b/system_bt/stack/Android.bp
+index f7803768c..10101e7ab 100755
+--- a/system_bt/stack/Android.bp
++++ b/system_bt/stack/Android.bp
+@@ -96,8 +96,6 @@ cc_library_static {
+         "a2dp/a2dp_vendor_ldac_abr.cc",
+         "a2dp/a2dp_vendor_ldac_decoder.cc",
+         "a2dp/a2dp_vendor_ldac_encoder.cc",
+-        "a2dp/a2dp_vendor_lhdcv1.cc",
+-        "a2dp/a2dp_vendor_lhdcv1_encoder.cc",
+         "a2dp/a2dp_vendor_lhdcv2.cc",
+         "a2dp/a2dp_vendor_lhdcv2_encoder.cc",
+         "a2dp/a2dp_vendor_lhdcv3.cc",
+diff --git a/system_bt/stack/a2dp/a2dp_codec_config.cc b/system_bt/stack/a2dp/a2dp_codec_config.cc
+index 6409bd1f2..0869fad5e 100755
+--- a/system_bt/stack/a2dp/a2dp_codec_config.cc
++++ b/system_bt/stack/a2dp/a2dp_codec_config.cc
+@@ -33,7 +33,6 @@
+ #include "a2dp_vendor_aptx.h"
+ #include "a2dp_vendor_aptx_hd.h"
+ #include "a2dp_vendor_ldac.h"
+-#include "a2dp_vendor_lhdcv1.h"
+ #include "a2dp_vendor_lhdcv2.h"
+ #include "a2dp_vendor_lhdcv3.h"
+ #include "a2dp_vendor_lhdcv3_dec.h"
+@@ -144,9 +143,6 @@ A2dpCodecConfig* A2dpCodecConfig::createCodec(
+     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+       codec_config = new A2dpCodecConfigLdacSink(codec_priority);
+       break;
+-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+-      codec_config = new A2dpCodecConfigLhdcV1(codec_priority);
+-      break;
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+       codec_config = new A2dpCodecConfigLhdcV2(codec_priority);
+       break;
+@@ -271,12 +267,430 @@ bool A2dpCodecConfig::getCodecSpecificConfig(tBT_A2DP_OFFLOAD* p_a2dp_offload) {
+         LOG_VERBOSE("%s: Ldac specific channelmode =%d", __func__,
+                     p_a2dp_offload->codec_info[7]);
+       }
++      // Savitech Patch - START  Offload
++      else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
++        //
++        // LHDC V3
++        //
++        // Main Version
++        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER3 &&
++            (codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER6) {
++          LOG_ERROR("%s: [LHDC V3] Unsupported version 0x%x", __func__,
++              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
++          goto fail;
++        }
++
++        LOG_DEBUG("%s: [LHDC V3] isLLAC=%d isLHDCV4=%d", __func__,
++            (codec_config[10] & A2DP_LHDC_FEATURE_LLAC),
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4));
++        // LHDC/LLAC handle Version
++        if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) != 0 &&
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
++          // LLAC (isLLAC && !isLHDCV4)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_LLAC-1);
++          LOG_DEBUG("%s: [LHDC V3] init to LLAC (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) != 0) {
++          // LHDC V4 Only (!isLLAC && isLHDCV4)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V4_ONLY-1);
++          LOG_DEBUG("%s: [LHDC V3] init to LHDCV4 only (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
++            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
++          // LHDC V3 Only (!isLLAC && !isLHDCV4)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
++          LOG_DEBUG("%s: [LHDC V3] init to LHDCV3 only (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        }else {
++          // LHDC V3 Only - default
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
++          LOG_DEBUG("%s: [LHDC V3] flags check incorrect. So init to LHDCV3 only (0x%02X)", __func__,
++              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++        }
++
++        // bit rate index
++        switch (codec_config_.codec_specific_1 & 0x0F) {
++        case A2DP_LHDC_QUALITY_LOW0:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW2:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW3:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW4:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_MID:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_HIGH:
++        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V3
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_ABR:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        default:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        }
++        LOG_DEBUG("%s: [LHDC V3] Bit Rate = 0x%02X", __func__,
++            (uint8_t)(codec_config_.codec_specific_1 & 0x0F));
++
++        // max bit rate index
++        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V3] Max Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
++
++        // min bit rate index
++        if ((codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR) == A2DP_LHDC_FEATURE_MIN_BR) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++        } else {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V3] Min Bit Rate = 0x%02X", __func__,
++            codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR);
++
++        // frameDuration - not supported
++        // p_a2dp_offload->codec_info[13]
++
++        // data interval
++        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
++          // LL is enabled (10 ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
++          LOG_DEBUG("%s: [LHDC V3] Low Latency mode", __func__);
++        } else {
++          // LL is disabled (20ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
++          LOG_DEBUG("%s: [LHDC V3] Normal Latency mode", __func__);
++        }
++
++        // Codec specific 1
++        if ((codec_config[9] & A2DP_LHDC_FEATURE_AR) != 0) {
++          // AR
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
++          LOG_DEBUG("%s: [LHDC V3] Has feature AR", __func__);
++        }
++        if ((codec_config[9] & A2DP_LHDC_FEATURE_JAS) != 0) {
++          // JAS
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
++          LOG_DEBUG("%s: [LHDC V3] Has feature JAS", __func__);
++        }
++        if ((codec_config[11] & A2DP_LHDC_FEATURE_META) != 0) {
++          // META
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
++          LOG_DEBUG("%s: [LHDC V3] Has feature META", __func__);
++        }
++
++        // Codec specific 2
++        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
++          // split mode disabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
++          LOG_DEBUG("%s: [LHDC V3] No ch split", __func__);
++        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
++          // split mode enabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
++          LOG_DEBUG("%s: [LHDC V3] Has ch split", __func__);
++        } else {
++          LOG_ERROR("%s: [LHDC V3] Unsupported split mode 0x%x", __func__,
++              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
++          goto fail;
++        }
++
++      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++        //
++        // LHDC V2
++        //
++        // Version
++        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) > A2DP_LHDC_VER2) {
++          LOG_ERROR("%s: [LHDC V2] Unsupported version 0x%x", __func__,
++              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
++          goto fail;
++        }
++        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV2_VER_1-1);
++        LOG_DEBUG("%s: [LHDC V2] version (0x%02X)", __func__,
++            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++
++        // bit rate index
++        switch (codec_config_.codec_specific_1 & 0x0F) {
++        case A2DP_LHDC_QUALITY_LOW0:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW2:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW3:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW4:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_LOW:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_MID:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_HIGH:
++        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V2
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDC_QUALITY_ABR:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        default:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        }
++        LOG_DEBUG("%s: [LHDC V2] Bit Rate = 0x%02X", __func__,
++            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
++
++        // max bit rate index
++        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V2] Max Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
++
++        // min bit rate index - not supported
++        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]
++        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]
++
++        // frameDuration - not supported
++        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR]
++
++        // data interval
++        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
++          // LL is enabled (10 ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
++          LOG_DEBUG("%s: [LHDC V2] Low Latency mode", __func__);
++        } else {
++          // LL is disabled (20ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
++          LOG_DEBUG("%s: [LHDC V2] Normal Latency mode", __func__);
++        }
++
++        // Codec specific 1 - not supported
++        // p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1]
++
++        // Codec specific 2
++        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
++          // split mode disabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
++          LOG_DEBUG("%s: [LHDC V2] No ch split", __func__);
++        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
++          // split mode enabled
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
++          LOG_DEBUG("%s: [LHDC V2] Has ch split", __func__);
++        } else {
++          LOG_ERROR("%s: [LHDC V2] Unsupported split mode 0x%x", __func__,
++              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
++          goto fail;
++        }
++      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
++        //
++        // LHDC V5
++        //
++
++        // Version
++        if ((codec_config[11] & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_1) {
++          LOG_ERROR("%s: [LHDC V5] unsupported version 0x%x", __func__,
++              (codec_config[11] & A2DP_LHDCV5_VERSION_MASK));
++          goto fail;
++        }
++        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV5_VER_1-1);
++        LOG_DEBUG("%s: [LHDC V5] version (0x%02X)", __func__,
++            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
++
++        // bit rate index
++        switch (codec_config_.codec_specific_1 & 0xF) {
++        case A2DP_LHDCV5_QUALITY_LOW0:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW2:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW3:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW4:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_LOW:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_MID:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_HIGH:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_HIGH1:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
++          break;
++        case A2DP_LHDCV5_QUALITY_ABR:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        default:
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
++          break;
++        }
++        LOG_DEBUG("%s: [LHDC V5] Bit Rate = 0x%02X", __func__,
++            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
++
++        // max bit rate index
++        if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
++        } else {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V5] Max Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
++
++        // min bit rate index
++        if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
++        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
++        } else {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
++        }
++        LOG_DEBUG("%s: [LHDC V5] Min Bit Rate = 0x%02X", __func__,
++            codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
++
++        // frame duration
++        if ((codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK) != 0) {
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR] = A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US;
++          LOG_DEBUG("%s: [LHDC V5] Frame Duration: 5ms ", __func__);
++        } else {
++          LOG_ERROR("%s: [LHDC V5] unsupported frame duration 0x%x", __func__,
++              codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK);
++          goto fail;
++        }
++
++        // data interval
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_LL) != 0) {
++          // LL is disabled (10 ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
++          LOG_DEBUG("%s: [LHDC V5] Low Latency mode", __func__);
++        } else {
++          // LL is enabled (20ms)
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
++          LOG_DEBUG("%s: [LHDC V5] Normal Latency mode", __func__);
++        }
++
++        // Codec specific 1
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_AR) != 0) {
++          // AR
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
++          LOG_DEBUG("%s: [LHDC V5] Has feature AR", __func__);
++        }
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_JAS) != 0) {
++          // JAS
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
++          LOG_DEBUG("%s: [LHDC V5] Has feature JAS", __func__);
++        }
++        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_META) != 0) {
++          // META
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
++          LOG_DEBUG("%s: [LHDC V5] Has feature META", __func__);
++        }
++
++        // Codec specific 2
++        if ((codec_config[13] & A2DP_LHDCV5_AR_ON) != 0) {
++          // AR_ON
++          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON;
++          LOG_DEBUG("%s: [LHDC V5] AR_ON is set", __func__);
++        }
++      }
++      // Savitech Patch - END
+       break;
+ #endif
+     default:
+       break;
+   }
+   return true;
++
++fail:
++  return false;
+ }
+ 
+ bool A2dpCodecConfig::isValid() const { return true; }
+@@ -625,10 +1039,7 @@ bool A2dpCodecs::init() {
+       } else if (strcmp(tok, "ldac") == 0) {
+         LOG_INFO("%s: LDAC offload supported", __func__);
+         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC] = true;
+-      } else if (strcmp(tok, "lhdcv1") == 0) {  // Savitech LHDC
+-        LOG_INFO("%s: LHDCV1 offload not supported", __func__);
+-        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1] = false;
+-      } else if (strcmp(tok, "lhdcv2") == 0) {
++      } else if (strcmp(tok, "lhdcv2") == 0) {  // Savitech LHDC
+         LOG_INFO("%s: LHDCV2 offload not supported", __func__);
+         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2] = false;
+       } else if (strcmp(tok, "lhdcv3") == 0) {
+@@ -952,7 +1363,6 @@ int A2dpCodecs::getLHDCCodecUserConfig(
+       result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(codecConfig, clen);
+     }
+     break;
+-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+   default:
+     APPL_TRACE_DEBUG("%s: feature not support!", __func__);
+@@ -983,7 +1393,6 @@ int A2dpCodecs::setLHDCCodecUserConfig(
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+     result = A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(codecConfig, clen);
+     break;
+-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+   default:
+     APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+@@ -1011,7 +1420,6 @@ bool A2dpCodecs::setLHDCCodecUserData(
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+     A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(codecData, clen);
+     break;
+-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+   default:
+     APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+@@ -1039,7 +1447,6 @@ int A2dpCodecs::getLHDCCodecUserApiVer(
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+     result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(version, clen);
+     break;
+-  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+   case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+   default:
+     APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+@@ -1726,11 +2133,14 @@ const tA2DP_DECODER_INTERFACE* A2DP_GetDecoderInterface(
+ 
+   switch (codec_type) {
+     case A2DP_MEDIA_CT_SBC:
++      LOG_DEBUG("%s: SBC", __func__);
+       return A2DP_GetDecoderInterfaceSbc(p_codec_info);
+ #if !defined(EXCLUDE_NONSTANDARD_CODECS)
+     case A2DP_MEDIA_CT_AAC:
++      LOG_DEBUG("%s: AAC", __func__);
+       return A2DP_GetDecoderInterfaceAac(p_codec_info);
+     case A2DP_MEDIA_CT_NON_A2DP:
++      LOG_DEBUG("%s: VENDOR CODEC", __func__);
+       return A2DP_VendorGetDecoderInterface(p_codec_info);
+ #endif
+     default:
+diff --git a/system_bt/stack/a2dp/a2dp_vendor.cc b/system_bt/stack/a2dp/a2dp_vendor.cc
+index b32580a78..b9936427f 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor.cc
+@@ -26,7 +26,6 @@
+ #include "a2dp_vendor_ldac.h"
+ #include "a2dp_vendor_lhdcv3.h"
+ #include "a2dp_vendor_lhdcv2.h"
+-#include "a2dp_vendor_lhdcv1.h"
+ #include "a2dp_vendor_lhdcv3_dec.h"
+ #include "a2dp_vendor_lhdcv5.h"
+ #include "bt_target.h"
+@@ -54,11 +53,6 @@ bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorSourceCodecValidLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_IsVendorSourceCodecValidLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info);
+@@ -149,11 +143,6 @@ bool A2DP_IsVendorPeerSinkCodecValid(const uint8_t* p_codec_info) {
+     return A2DP_IsVendorPeerSinkCodecValidLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_IsVendorPeerSinkCodecValidLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_IsVendorPeerSinkCodecValidLhdcV2(p_codec_info);
+@@ -267,12 +256,6 @@ bool A2DP_VendorUsesRtpHeader(bool content_protection_enabled,
+                                         p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorUsesRtpHeaderLhdcV1(content_protection_enabled,
+-                                          p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorUsesRtpHeaderLhdcV2(content_protection_enabled,
+@@ -316,11 +299,6 @@ const char* A2DP_VendorCodecName(const uint8_t* p_codec_info) {
+     return A2DP_VendorCodecNameLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorCodecNameLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorCodecNameLhdcV2(p_codec_info);
+@@ -375,11 +353,6 @@ bool A2DP_VendorCodecTypeEquals(const uint8_t* p_codec_info_a,
+     return A2DP_VendorCodecTypeEqualsLdac(p_codec_info_a, p_codec_info_b);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorCodecTypeEqualsLhdcV1(p_codec_info_a, p_codec_info_b);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorCodecTypeEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
+@@ -435,11 +408,6 @@ bool A2DP_VendorCodecEquals(const uint8_t* p_codec_info_a,
+     return A2DP_VendorCodecEqualsLdac(p_codec_info_a, p_codec_info_b);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorCodecEqualsLhdcV1(p_codec_info_a, p_codec_info_b);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorCodecEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
+@@ -482,9 +450,14 @@ int A2DP_VendorGetBitRate(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetBitRateLdac(p_codec_info);
+   }
+ 
++  // Check for Savitech LHDCV2
++  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
++    return A2DP_VendorGetBitRateLhdcV2(p_codec_info);
++  }
++
+   // Check for Savitech LHDCV3
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+-    return A2DP_VendorGetBitRateLhdcV3Sink(p_codec_info);
++    return A2DP_VendorGetBitRateLhdcV3(p_codec_info);
+   }
+ 
+   // Check for Savitech LHDCV5
+@@ -518,11 +491,6 @@ int A2DP_VendorGetTrackSampleRate(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetTrackSampleRateLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorGetTrackSampleRateLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
+@@ -564,11 +532,6 @@ int A2DP_VendorGetTrackBitsPerSample(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetTrackBitsPerSampleLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorGetTrackBitsPerSampleLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorGetTrackBitsPerSampleLhdcV2(p_codec_info);
+@@ -610,11 +573,6 @@ int A2DP_VendorGetTrackChannelCount(const uint8_t* p_codec_info) {
+     return A2DP_VendorGetTrackChannelCountLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorGetTrackChannelCountLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
+@@ -684,11 +642,6 @@ bool A2DP_VendorGetPacketTimestamp(const uint8_t* p_codec_info,
+     return A2DP_VendorGetPacketTimestampLdac(p_codec_info, p_data, p_timestamp);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorGetPacketTimestampLhdcV1(p_codec_info, p_data, p_timestamp);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorGetPacketTimestampLhdcV2(p_codec_info, p_data, p_timestamp);
+@@ -734,12 +687,6 @@ bool A2DP_VendorBuildCodecHeader(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                            frames_per_packet);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorBuildCodecHeaderLhdcV1(p_codec_info, p_buf,
+-                                               frames_per_packet);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorBuildCodecHeaderLhdcV2(p_codec_info, p_buf,
+@@ -785,11 +732,6 @@ const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterface(
+     return A2DP_VendorGetEncoderInterfaceLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorGetEncoderInterfaceLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorGetEncoderInterfaceLhdcV2(p_codec_info);
+@@ -857,11 +799,6 @@ bool A2DP_VendorAdjustCodec(uint8_t* p_codec_info) {
+     return A2DP_VendorAdjustCodecLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorAdjustCodecLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorAdjustCodecLhdcV2(p_codec_info);
+@@ -904,11 +841,6 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(
+     return A2DP_VendorSourceCodecIndexLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorSourceCodecIndexLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorSourceCodecIndexLhdcV2(p_codec_info);
+@@ -970,8 +902,7 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
+       return A2DP_VendorCodecIndexStrLdac();
+     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+       return A2DP_VendorCodecIndexStrLdacSink();
+-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+-      return A2DP_VendorCodecIndexStrLhdcV1();
++    // Savitech Patch - START
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+       return A2DP_VendorCodecIndexStrLhdcV2();
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+@@ -982,6 +913,7 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
+       return A2DP_VendorCodecIndexStrLhdcV3Sink();
+     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+       return A2DP_VendorCodecIndexStrLhdcV5Sink();
++    // Savitech Patch - END
+     // Add a switch statement for each vendor-specific codec
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+       break;
+@@ -1007,8 +939,7 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
+       return A2DP_VendorInitCodecConfigLdac(p_cfg);
+     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
+       return A2DP_VendorInitCodecConfigLdacSink(p_cfg);
+-    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1:
+-      return A2DP_VendorInitCodecConfigLhdcV1(p_cfg);
++    // Savitech Patch - START
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+       return A2DP_VendorInitCodecConfigLhdcV2(p_cfg);
+     case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+@@ -1019,6 +950,7 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
+       return A2DP_VendorInitCodecConfigLhdcV3Sink(p_cfg);
+     case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+       return A2DP_VendorInitCodecConfigLhdcV5Sink(p_cfg);
++    // Savitech Patch - END
+     // Add a switch statement for each vendor-specific codec
+     case BTAV_A2DP_CODEC_INDEX_MAX:
+       break;
+@@ -1048,11 +980,6 @@ std::string A2DP_VendorCodecInfoString(const uint8_t* p_codec_info) {
+     return A2DP_VendorCodecInfoStringLdac(p_codec_info);
+   }
+ 
+-  // Check for Savitech LHDCV1
+-  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_VendorCodecInfoStringLhdcV1(p_codec_info);
+-  }
+-
+   // Check for Savitech LHDCV2
+   if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+     return A2DP_VendorCodecInfoStringLhdcV2(p_codec_info);
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv1.cc
+deleted file mode 100755
+index 2adb760d7..000000000
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1.cc
++++ /dev/null
+@@ -1,1220 +0,0 @@
+-/*
+- * Copyright (C) 2016 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-/******************************************************************************
+- *
+- *  Utility functions to help build and parse the LHDC Codec Information
+- *  Element and Media Payload.
+- *
+- ******************************************************************************/
+-
+-#define LOG_TAG "a2dp_vendor_lhdcv1"
+-
+-#include "bt_target.h"
+-
+-#include "a2dp_vendor_lhdcv1.h"
+-
+-#include <string.h>
+-
+-#include <base/logging.h>
+-#include "a2dp_vendor.h"
+-#include "a2dp_vendor_lhdcv1_encoder.h"
+-#include "bt_utils.h"
+-#include "osi/include/log.h"
+-#include "osi/include/osi.h"
+-
+-// data type for the LHDC Codec Information Element */
+-// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+-typedef struct {
+-  uint32_t vendorId;
+-  uint16_t codecId;    /* Codec ID for LHDC */
+-  uint8_t sampleRate;  /* Sampling Frequency */
+-  uint8_t channelMode; /* STEREO/DUAL/MONO */
+-  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+-  bool isChannelSeparation;
+-} tA2DP_LHDC_CIE;
+-
+-/* LHDC Source codec capabilities */
+-static const tA2DP_LHDC_CIE a2dp_lhdcV1_caps = {
+-    A2DP_LHDC_VENDOR_ID,  // vendorId
+-    A2DP_LHDCV1_CODEC_ID,   // codecId
+-    // sampleRate
+-    //(A2DP_LHDCV1_SAMPLING_FREQ_48000),
+-    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
+-    // channelMode
+-    (A2DP_LHDC_CHANNEL_MODE_STEREO),
+-    // bits_per_sample
+-    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+-    //Channel Separation
+-    true
+-};
+-    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
+-
+-/* Default LHDC codec configuration */
+-static const tA2DP_LHDC_CIE a2dp_lhdcV1_default_config = {
+-    A2DP_LHDC_VENDOR_ID,                // vendorId
+-    A2DP_LHDCV1_CODEC_ID,                 // codecId
+-    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
+-    A2DP_LHDC_CHANNEL_MODE_STEREO,      // channelMode
+-    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+-    false
+-};
+-
+-static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv1 = {
+-    a2dp_vendor_lhdcV1_encoder_init,
+-    a2dp_vendor_lhdcV1_encoder_cleanup,
+-    a2dp_vendor_lhdcV1_feeding_reset,
+-    a2dp_vendor_lhdcV1_feeding_flush,
+-    a2dp_vendor_lhdcV1_get_encoder_interval_ms,
+-    a2dp_vendor_lhdcV1_send_frames,
+-    a2dp_vendor_lhdcV1_set_transmit_queue_length};
+-
+-UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV1(
+-    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+-    bool is_peer_codec_info);
+-
+-// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+-// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+-// |p_ie| is a pointer to the LHDC Codec Information Element information.
+-// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+-// otherwise the corresponding A2DP error status code.
+-static tA2DP_STATUS A2DP_BuildInfoLhdcV1(uint8_t media_type,
+-                                       const tA2DP_LHDC_CIE* p_ie,
+-                                       uint8_t* p_result) {
+-
+-  const uint8_t* tmpInfo = p_result;
+-  if (p_ie == NULL || p_result == NULL) {
+-    return A2DP_INVALID_PARAMS;
+-  }
+-
+-  *p_result++ = A2DP_LHDCV1_CODEC_LEN;
+-  *p_result++ = (media_type << 4);
+-  *p_result++ = A2DP_MEDIA_CT_NON_A2DP;
+-
+-  // Vendor ID and Codec ID
+-  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
+-  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
+-  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
+-  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
+-  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
+-  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
+-
+-  // Sampling Frequency & Bits per sample
+-  uint8_t para = 0;
+-
+-  // sample rate bit0 ~ bit2
+-  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+-
+-  if(p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+-      para |= A2DP_LHDC_BIT_FMT_24;
+-  if(p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+-      para = para | A2DP_LHDC_BIT_FMT_16;
+-
+-  if (p_ie->isChannelSeparation == true) {
+-      para |= A2DP_LHDCV1_CHANNEL_SEPARATION;   //Force supported Dual channels
+-  }else {
+-      para &= ~A2DP_LHDCV1_CHANNEL_SEPARATION;
+-  }
+-
+-  *p_result = para;
+-  if (*p_result == 0) return A2DP_INVALID_PARAMS;
+-
+-  LOG_DEBUG( "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x",
+-     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9]);
+-  return A2DP_SUCCESS;
+-}
+-
+-// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+-// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+-// |p_codec_info|. If |is_capability| is true, the byte sequence is
+-// codec capabilities, otherwise is codec configuration.
+-// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+-// status code.
+-static tA2DP_STATUS A2DP_ParseInfoLhdcV1(tA2DP_LHDC_CIE* p_ie,
+-                                       const uint8_t* p_codec_info,
+-                                       bool is_capability) {
+-  uint8_t losc;
+-  uint8_t media_type;
+-  tA2DP_CODEC_TYPE codec_type;
+-  const uint8_t* tmpInfo = p_codec_info;
+-
+-  //LOG_DEBUG( "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+-  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+-
+-
+-  LOG_DEBUG( "%s: Parses codec info for capbility = %s", __func__, (is_capability == 1 ? "true" : "false"));
+-  LOG_DEBUG( "%s: Parses codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x",
+-   __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9]);
+-  // Check the codec capability length
+-  losc = *p_codec_info++;
+-    //LOG_DEBUG( "%s: losc = %d, A2DP_LHDCV1_CODEC_LEN = %d", __func__, losc, A2DP_LHDCV1_CODEC_LEN);
+-  if (losc != A2DP_LHDCV1_CODEC_LEN) return A2DP_WRONG_CODEC;
+-
+-  media_type = (*p_codec_info++) >> 4;
+-  codec_type = *p_codec_info++;
+-    //LOG_DEBUG( "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+-  /* Check the Media Type and Media Codec Type */
+-  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+-      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+-    return A2DP_WRONG_CODEC;
+-  }
+-
+-  // Check the Vendor ID and Codec ID */
+-  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+-                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+-                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+-                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+-  p_codec_info += 4;
+-  p_ie->codecId =
+-      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+-  p_codec_info += 2;
+-    //LOG_DEBUG( "%s: p_ie->vendorId = %d, p_ie->codecId = %d", __func__, p_ie->vendorId, p_ie->codecId);
+-  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+-      p_ie->codecId != A2DP_LHDCV1_CODEC_ID) {
+-    return A2DP_WRONG_CODEC;
+-  }
+-
+-  //LOG_DEBUG( "%s: *p_codec_info = 0x%x", __func__, *p_codec_info);
+-
+-  if (*p_codec_info & A2DP_LHDCV1_CHANNEL_SEPARATION){
+-    p_ie->isChannelSeparation = true;
+-  }else{
+-    p_ie->isChannelSeparation = false;
+-  }
+-
+-  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+-
+-  p_ie->channelMode = A2DP_LHDC_CHANNEL_MODE_STEREO;
+-
+-  //p_ie->bits_per_sample = *p_codec_info & A2DP_LHDCV1_BIT_FMT_MASK;
+-
+-  LOG_DEBUG( "%s: *p_codec_info[0x%02x] & A2DP_LHDCV1_BIT_FMT_MASK[0x%02x] = 0x%02x", __func__, *p_codec_info, A2DP_LHDCV1_BIT_FMT_MASK, *p_codec_info & A2DP_LHDCV1_BIT_FMT_MASK);
+-  
+-  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+-    return A2DP_WRONG_CODEC;
+-  }
+-
+-  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+-  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+-    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+-    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-  }
+-
+-
+-  /*
+-  p_ie->sampleRate = *p_codec_info++ & A2DP_LHDC_SAMPLING_FREQ_MASK;
+-  p_ie->channelMode = *p_codec_info++ & A2DP_LHDCV1_CHANNEL_MODE_MASK;
+-
+-*/
+-
+-//LOG_DEBUG( "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x",
+- //__func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6]);
+-
+-  if (is_capability) return A2DP_SUCCESS;
+-
+-  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+-    return A2DP_BAD_SAMP_FREQ;
+-  if (A2DP_BitsSet(p_ie->channelMode) != A2DP_SET_ONE_BIT)
+-    return A2DP_BAD_CH_MODE;
+-
+-  return A2DP_SUCCESS;
+-}
+-
+-// Build the LHDC Media Payload Header.
+-// |p_dst| points to the location where the header should be written to.
+-// If |frag| is true, the media payload frame is fragmented.
+-// |start| is true for the first packet of a fragmented frame.
+-// |last| is true for the last packet of a fragmented frame.
+-// If |frag| is false, |num| is the number of number of frames in the packet,
+-// otherwise is the number of remaining fragments (including this one).
+-/*
+-static void A2DP_BuildMediaPayloadHeaderLhdcV1(uint8_t* p, uint16_t num) {
+-  if (p == NULL) return;
+-  *p = ( uint8_t)( num & 0xff);
+-}
+-*/
+-
+-bool A2DP_IsVendorSourceCodecValidLhdcV1(const uint8_t* p_codec_info) {
+-  tA2DP_LHDC_CIE cfg_cie;
+-
+-  /* Use a liberal check when parsing the codec info */
+-  return (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+-         (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+-}
+-
+-bool A2DP_IsVendorPeerSinkCodecValidLhdcV1(const uint8_t* p_codec_info) {
+-  tA2DP_LHDC_CIE cfg_cie;
+-
+-  /* Use a liberal check when parsing the codec info */
+-  return (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+-         (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+-}
+-
+-// Checks whether A2DP LHDC codec configuration matches with a device's codec
+-// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+-// the device's codec capabilities.
+-// If |is_capability| is true, the byte sequence is codec capabilities,
+-// otherwise is codec configuration.
+-// |p_codec_info| contains the codec capabilities for a peer device that
+-// is acting as an A2DP source.
+-// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+-// otherwise the corresponding A2DP error status code.
+-static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV1(
+-    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+-    bool is_capability) {
+-  tA2DP_STATUS status;
+-  tA2DP_LHDC_CIE cfg_cie;
+-
+-  /* parse configuration */
+-  status = A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, is_capability);
+-  if (status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: parsing failed %d", __func__, status);
+-    return status;
+-  }
+-
+-  /* verify that each parameter is in range */
+-
+-  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+-            cfg_cie.sampleRate, p_cap->sampleRate);
+-  LOG_DEBUG( "%s: CH_MODE peer: 0x%x, capability 0x%x", __func__,
+-            cfg_cie.channelMode, p_cap->channelMode);
+-  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+-            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+-
+-  /* sampling frequency */
+-  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+-
+-  /* channel mode */
+-  //if ((cfg_cie.channelMode & p_cap->channelMode) == 0) return A2DP_NS_CH_MODE;
+-
+-  /* channel mode */
+-  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+-
+-  return A2DP_SUCCESS;
+-}
+-
+-bool A2DP_VendorUsesRtpHeaderLhdcV1(UNUSED_ATTR bool content_protection_enabled,
+-                                  UNUSED_ATTR const uint8_t* p_codec_info) {
+-  // TODO: Is this correct? The RTP header is always included?
+-  return true;
+-}
+-
+-const char* A2DP_VendorCodecNameLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info) {
+-  return "LHDC V1";
+-}
+-
+-bool A2DP_VendorCodecTypeEqualsLhdcV1(const uint8_t* p_codec_info_a,
+-                                    const uint8_t* p_codec_info_b) {
+-  tA2DP_LHDC_CIE lhdcV1_cie_a;
+-  tA2DP_LHDC_CIE lhdcV1_cie_b;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status =
+-      A2DP_ParseInfoLhdcV1(&lhdcV1_cie_a, p_codec_info_a, true);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return false;
+-  }
+-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie_b, p_codec_info_b, true);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return false;
+-  }
+-
+-  return true;
+-}
+-
+-bool A2DP_VendorCodecEqualsLhdcV1(const uint8_t* p_codec_info_a,
+-                                const uint8_t* p_codec_info_b) {
+-  tA2DP_LHDC_CIE lhdcV1_cie_a;
+-  tA2DP_LHDC_CIE lhdcV1_cie_b;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status =
+-      A2DP_ParseInfoLhdcV1(&lhdcV1_cie_a, p_codec_info_a, true);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return false;
+-  }
+-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie_b, p_codec_info_b, true);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return false;
+-  }
+-
+-  return (lhdcV1_cie_a.sampleRate == lhdcV1_cie_b.sampleRate) &&
+-         (lhdcV1_cie_a.bits_per_sample == lhdcV1_cie_b.bits_per_sample);
+-}
+-
+-
+-int A2DP_VendorGetTrackSampleRateLhdcV1(const uint8_t* p_codec_info) {
+-  tA2DP_LHDC_CIE lhdcV1_cie;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return -1;
+-  }
+-
+-  switch (lhdcV1_cie.sampleRate) {
+-    case A2DP_LHDC_SAMPLING_FREQ_44100:
+-      return 44100;
+-    case A2DP_LHDC_SAMPLING_FREQ_48000:
+-      return 48000;
+-    case A2DP_LHDC_SAMPLING_FREQ_88200:
+-      return 88200;
+-    case A2DP_LHDC_SAMPLING_FREQ_96000:
+-      return 96000;
+-  }
+-
+-  return -1;
+-}
+-
+-int A2DP_VendorGetTrackBitsPerSampleLhdcV1(const uint8_t* p_codec_info) {
+-    tA2DP_LHDC_CIE lhdc_cie;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdc_cie, p_codec_info, false);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return -1;
+-  }
+-
+-#if 0
+-  return 32;
+-#else
+-  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
+-
+-  switch (lhdc_cie.bits_per_sample) {
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+-      return 16;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+-      return 24;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+-      return 32;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+-      return -1;
+-  }
+-#endif
+-}
+-
+-int A2DP_VendorGetTrackChannelCountLhdcV1(const uint8_t* p_codec_info) {
+-  tA2DP_LHDC_CIE lhdcV1_cie;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return -1;
+-  }
+-
+-  switch (lhdcV1_cie.channelMode) {
+-    case A2DP_LHDC_CHANNEL_MODE_STEREO:
+-      return 2;
+-  }
+-
+-  return -1;
+-}
+-
+-int A2DP_VendorGetChannelModeCodeLhdcV1(const uint8_t* p_codec_info) {
+-  tA2DP_LHDC_CIE lhdcV1_cie;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return -1;
+-  }
+-
+-  switch (lhdcV1_cie.channelMode) {
+-    case A2DP_LHDC_CHANNEL_MODE_STEREO:
+-      return lhdcV1_cie.channelMode;
+-    default:
+-      break;
+-  }
+-
+-  return -1;
+-}
+-
+-bool A2DP_VendorGetPacketTimestampLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info,
+-                                       const uint8_t* p_data,
+-                                       uint32_t* p_timestamp) {
+-  // TODO: Is this function really codec-specific?
+-  *p_timestamp = *(const uint32_t*)p_data;
+-  return true;
+-}
+-
+-bool A2DP_VendorGetChannelSeparation(const uint8_t* p_codec_info){
+-  tA2DP_LHDC_CIE lhdcV1_cie;
+-
+-  // Check whether the codec info contains valid data
+-  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, false);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+-              a2dp_status);
+-    return false;
+-  }
+-
+-  LOG_ERROR( "%s: isChannelSeparation =%d", __func__, lhdcV1_cie.isChannelSeparation);
+-
+-  return lhdcV1_cie.isChannelSeparation == 0 ? false : true;
+-}
+-
+-bool A2DP_VendorBuildCodecHeaderLhdcV1(UNUSED_ATTR const uint8_t* p_codec_info,
+-                                     BT_HDR* p_buf,
+-                                     uint16_t frames_per_packet) {
+-  uint8_t* p;
+-
+-  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+-  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+-  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+-  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+-  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+-  //A2DP_BuildMediaPayloadHeaderLhdcV1(p, frames_per_packet);
+-  return true;
+-}
+-
+-void A2DP_VendorDumpCodecInfoLhdcV1(const uint8_t* p_codec_info) {
+-  tA2DP_STATUS a2dp_status;
+-  tA2DP_LHDC_CIE lhdcV1_cie;
+-
+-  LOG_DEBUG( "%s", __func__);
+-
+-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, true);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV1 fail:%d", __func__, a2dp_status);
+-    return;
+-  }
+-
+-  LOG_DEBUG( "\tsamp_freq: 0x%x", lhdcV1_cie.sampleRate);
+-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-    LOG_DEBUG( "\tsamp_freq: (44100)");
+-  }
+-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-    LOG_DEBUG( "\tsamp_freq: (48000)");
+-  }
+-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+-    LOG_DEBUG( "\tsamp_freq: (88200)");
+-  }
+-  if (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-    LOG_DEBUG( "\tsamp_freq: (96000)");
+-  }
+-
+-  LOG_DEBUG( "\tch_mode: 0x%x", lhdcV1_cie.channelMode);
+-  if (lhdcV1_cie.channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
+-    LOG_DEBUG( "\tch_mode: (Stereo)");
+-  }
+-}
+-
+-std::string A2DP_VendorCodecInfoStringLhdcV1(const uint8_t* p_codec_info) {
+-  std::stringstream res;
+-  std::string field;
+-  tA2DP_STATUS a2dp_status;
+-  tA2DP_LHDC_CIE lhdcV1_cie;
+-
+-  a2dp_status = A2DP_ParseInfoLhdcV1(&lhdcV1_cie, p_codec_info, true);
+-  if (a2dp_status != A2DP_SUCCESS) {
+-    res << "A2DP_ParseInfoLhdc fail: " << loghex(a2dp_status);
+-    return res.str();
+-  }
+-
+-  res << "\tname: LHDCV1\n";
+-
+-  // Sample frequency
+-  field.clear();
+-  AppendField(&field, (lhdcV1_cie.sampleRate == 0), "NONE");
+-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+-              "44100");
+-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+-              "48000");
+-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+-              "88200");
+-  AppendField(&field, (lhdcV1_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+-              "96000");
+-  res << "\tsamp_freq: " << field << " (" << loghex(lhdcV1_cie.sampleRate)
+-      << ")\n";
+-
+-  // Channel mode
+-  /*
+-  field.clear();
+-  AppendField(&field, 0, "NONE");
+-  AppendField(&field, 0,
+-              "Mono");
+-  AppendField(&field, 0,
+-              "Dual");
+-  AppendField(&field, 1,
+-              "Stereo");
+-  res << "\tch_mode: " << field << " (" << loghex(lhdcV1_cie.channelMode)
+-      << ")\n";
+-*/
+-  return res.str();
+-}
+-
+-const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV1(
+-    const uint8_t* p_codec_info) {
+-  if (!A2DP_IsVendorSourceCodecValidLhdcV1(p_codec_info)) return NULL;
+-
+-  return &a2dp_encoder_interface_lhdcv1;
+-}
+-
+-bool A2DP_VendorAdjustCodecLhdcV1(uint8_t* p_codec_info) {
+-  tA2DP_LHDC_CIE cfg_cie;
+-
+-  // Nothing to do: just verify the codec info is valid
+-  if (A2DP_ParseInfoLhdcV1(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+-    return false;
+-
+-  return true;
+-}
+-
+-btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV1(
+-    UNUSED_ATTR const uint8_t* p_codec_info) {
+-  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1;
+-}
+-
+-const char* A2DP_VendorCodecIndexStrLhdcV1(void) { return "LHDC V1"; }
+-
+-bool A2DP_VendorInitCodecConfigLhdcV1(AvdtpSepConfig* p_cfg) {
+-  if (A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcV1_caps,
+-                         p_cfg->codec_info) != A2DP_SUCCESS) {
+-    return false;
+-  }
+-
+-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+-  /* Content protection info - support SCMS-T */
+-  uint8_t* p = p_cfg->protect_info;
+-  *p++ = AVDT_CP_LOSC;
+-  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+-  p_cfg->num_protect = 1;
+-#endif
+-
+-  return true;
+-}
+-
+-UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+-                                           btav_a2dp_codec_config_t* result) {
+-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+-  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+-    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-
+-  result->bits_per_sample = config_cie.bits_per_sample;
+-
+-  if (config_cie.channelMode &
+-       (A2DP_LHDC_CHANNEL_MODE_STEREO)) {
+-    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+-  }
+-}
+-
+-A2dpCodecConfigLhdcV1::A2dpCodecConfigLhdcV1(
+-    btav_a2dp_codec_priority_t codec_priority)
+-    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV1, "LHDC V1",
+-                      codec_priority) {
+-  // Compute the local capability
+-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-  }
+-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-  }
+-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+-  }
+-  if (a2dp_lhdcV1_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-  }
+-  codec_local_capability_.bits_per_sample = a2dp_lhdcV1_caps.bits_per_sample;
+-  if (a2dp_lhdcV1_caps.channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
+-    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+-  }
+-}
+-
+-A2dpCodecConfigLhdcV1::~A2dpCodecConfigLhdcV1() {}
+-
+-bool A2dpCodecConfigLhdcV1::init() {
+-  if (!isValid()) return false;
+-
+-  // Load the encoder
+-  if (!A2DP_VendorLoadEncoderLhdcV1()) {
+-    LOG_ERROR( "%s: cannot load the encoder", __func__);
+-    return false;
+-  }
+-
+-  return true;
+-}
+-
+-bool A2dpCodecConfigLhdcV1::useRtpHeaderMarkerBit() const { return false; }
+-
+-//
+-// Selects the best sample rate from |sampleRate|.
+-// The result is stored in |p_result| and |p_codec_config|.
+-// Returns true if a selection was made, otherwise false.
+-//
+-static bool select_best_sample_rate(uint8_t sampleRate,
+-                                    tA2DP_LHDC_CIE* p_result,
+-                                    btav_a2dp_codec_config_t* p_codec_config) {
+-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-    return true;
+-  }
+-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+-    return true;
+-  }
+-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-    return true;
+-  }
+-  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+-    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-    return true;
+-  }
+-  return false;
+-}
+-
+-//
+-// Selects the audio sample rate from |p_codec_audio_config|.
+-// |sampleRate| contains the capability.
+-// The result is stored in |p_result| and |p_codec_config|.
+-// Returns true if a selection was made, otherwise false.
+-//
+-static bool select_audio_sample_rate(
+-    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+-    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+-  switch (p_codec_audio_config->sample_rate) {
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-        return true;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-        return true;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+-        return true;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+-        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-        return true;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+-      break;
+-  }
+-  return false;
+-}
+-
+-//
+-// Selects the best bits per sample from |bits_per_sample|.
+-// |bits_per_sample| contains the capability.
+-// The result is stored in |p_result| and |p_codec_config|.
+-// Returns true if a selection was made, otherwise false.
+-//
+-static bool select_best_bits_per_sample(
+-    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+-    btav_a2dp_codec_config_t* p_codec_config) {
+-  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+-    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-    return true;
+-  }
+-  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+-    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-    return true;
+-  }
+-  return false;
+-}
+-
+-//
+-// Selects the audio bits per sample from |p_codec_audio_config|.
+-// |bits_per_sample| contains the capability.
+-// The result is stored in |p_result| and |p_codec_config|.
+-// Returns true if a selection was made, otherwise false.
+-//
+-static bool select_audio_bits_per_sample(
+-    const btav_a2dp_codec_config_t* p_codec_audio_config,
+-    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+-    btav_a2dp_codec_config_t* p_codec_config) {
+-  switch (p_codec_audio_config->bits_per_sample) {
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+-        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-        return true;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+-        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-        return true;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+-      break;
+-  }
+-  return false;
+-}
+-
+-
+-
+-bool A2dpCodecConfigLhdcV1::setCodecConfig(const uint8_t* p_peer_codec_info,
+-                                         bool is_capability,
+-                                         uint8_t* p_result_codec_config) {
+-  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+-  tA2DP_LHDC_CIE sink_info_cie;
+-  tA2DP_LHDC_CIE result_config_cie;
+-  uint8_t channelMode;
+-  uint8_t sampleRate;
+-  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+-
+-  // Save the internal state
+-  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+-  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+-  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+-      codec_selectable_capability_;
+-  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+-  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+-  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+-  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+-  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+-  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+-  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+-         sizeof(ota_codec_peer_capability_));
+-  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+-         sizeof(ota_codec_peer_config_));
+-
+-  tA2DP_STATUS status =
+-      A2DP_ParseInfoLhdcV1(&sink_info_cie, p_peer_codec_info, is_capability);
+-  if (status != A2DP_SUCCESS) {
+-    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
+-              __func__, status);
+-    goto fail;
+-  }
+-
+-    LOG_ERROR(
+-              "%s",
+-              __func__);
+-
+-  //
+-  // Build the preferred configuration
+-  //
+-  memset(&result_config_cie, 0, sizeof(result_config_cie));
+-  result_config_cie.vendorId = a2dp_lhdcV1_caps.vendorId;
+-  result_config_cie.codecId = a2dp_lhdcV1_caps.codecId;
+-
+-  //
+-  // Select the sample frequency
+-  //
+-  sampleRate = a2dp_lhdcV1_caps.sampleRate & sink_info_cie.sampleRate;
+-  LOG_ERROR( "%s: samplrate = 0x%x", __func__, sampleRate);
+-  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+-  switch (codec_user_config_.sample_rate) {
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+-        codec_config_.sample_rate = codec_user_config_.sample_rate;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+-        codec_config_.sample_rate = codec_user_config_.sample_rate;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+-        codec_config_.sample_rate = codec_user_config_.sample_rate;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+-      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+-        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+-        codec_config_.sample_rate = codec_user_config_.sample_rate;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+-    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+-      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+-      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+-      break;
+-  }
+-
+-  // Select the sample frequency if there is no user preference
+-  do {
+-    // Compute the selectable capability
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-      codec_selectable_capability_.sample_rate |=
+-          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-    }
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-      codec_selectable_capability_.sample_rate |=
+-          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-    }
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+-      codec_selectable_capability_.sample_rate |=
+-          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+-    }
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-      codec_selectable_capability_.sample_rate |=
+-          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-    }
+-
+-    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) break;
+-
+-    // Compute the common capability
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+-      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-
+-    // No user preference - try the codec audio config
+-    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+-                                 &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-
+-    // No user preference - try the default config
+-    if (select_best_sample_rate(
+-            a2dp_lhdcV1_default_config.sampleRate & sink_info_cie.sampleRate,
+-            &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-
+-    // No user preference - use the best match
+-    if (select_best_sample_rate(sampleRate, &result_config_cie,
+-                                &codec_config_)) {
+-      break;
+-    }
+-  } while (false);
+-  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+-    LOG_ERROR(
+-              "%s: cannot match sample frequency: source caps = 0x%x "
+-              "sink info = 0x%x",
+-              __func__, a2dp_lhdcV1_caps.sampleRate, sink_info_cie.sampleRate);
+-    goto fail;
+-  }
+-
+-  //
+-  // Select the bits per sample
+-  //
+-  // NOTE: this information is NOT included in the LHDC A2DP codec description
+-  // that is sent OTA.
+-  bits_per_sample = a2dp_lhdcV1_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+-  LOG_ERROR( "%s: a2dp_lhdcV1_caps.bits_per_sample = 0x%02x, sink_info_cie.bits_per_sample = 0x%02x", __func__, a2dp_lhdcV1_caps.bits_per_sample, sink_info_cie.bits_per_sample);
+-  LOG_ERROR( "%s: bits_per_sample = 0x%02x", __func__, bits_per_sample);
+-  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+-  switch (codec_user_config_.bits_per_sample) {
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+-        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+-        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+-        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+-        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+-    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+-      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+-      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+-      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+-      break;
+-  }
+-
+-  // Select the bits per sample if there is no user preference
+-  do {
+-    // Compute the selectable capability
+-      // Compute the selectable capability
+-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-
+-    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) break;
+-
+-    // Compute the common capability
+-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+-      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+-      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-
+-    // No user preference - the the codec audio config
+-    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+-                                     &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-
+-    // No user preference - try the default config
+-    if (select_best_bits_per_sample(a2dp_lhdcV1_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+-                                    &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-
+-    // No user preference - use the best match
+-    if (select_best_bits_per_sample(bits_per_sample,
+-                                    &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-  } while (false);
+-/*
+-  // Select the bits per sample if there is no user preference
+-  do {
+-    // Compute the selectable capability
+-    codec_selectable_capability_.bits_per_sample =
+-        a2dp_lhdcV1_caps.bits_per_sample;
+-
+-    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE)
+-      break;
+-
+-    // Compute the common capability
+-    codec_capability_.bits_per_sample = bits_per_sample;
+-
+-    // No user preference - the the codec audio config
+-    if (select_audio_bits_per_sample(&codec_audio_config_,
+-                                     a2dp_lhdcV1_caps.bits_per_sample,
+-                                     &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-
+-    // No user preference - try the default config
+-    if (select_best_bits_per_sample(a2dp_lhdcV1_default_config.bits_per_sample,
+-                                    &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-
+-    // No user preference - use the best match
+-    if (select_best_bits_per_sample(a2dp_lhdcV1_caps.bits_per_sample,
+-                                    &result_config_cie, &codec_config_)) {
+-      break;
+-    }
+-} while (false);*/
+-  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+-    LOG_ERROR(
+-              "%s: cannot match bits per sample: default = 0x%x "
+-              "user preference = 0x%x",
+-              __func__, a2dp_lhdcV1_default_config.bits_per_sample,
+-              codec_user_config_.bits_per_sample);
+-    goto fail;
+-  }
+-
+-  //
+-  // Select the channel mode
+-  //
+-  channelMode = a2dp_lhdcV1_caps.channelMode & sink_info_cie.channelMode;
+-  LOG_ERROR( "%s: channelMode = 0x%x", __func__, channelMode);
+-  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+-  switch (codec_user_config_.channel_mode) {
+-    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+-      if (channelMode & A2DP_LHDC_CHANNEL_MODE_STEREO) {
+-        result_config_cie.channelMode = A2DP_LHDC_CHANNEL_MODE_STEREO;
+-        codec_capability_.channel_mode = codec_user_config_.channel_mode;
+-        codec_config_.channel_mode = codec_user_config_.channel_mode;
+-        break;
+-      }
+-      break;
+-    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+-    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+-      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+-      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+-      break;
+-  }
+-  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+-  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+-  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+-  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+-    LOG_ERROR(
+-              "%s: cannot match channel mode: source caps = 0x%x "
+-              "sink info = 0x%x",
+-              __func__, a2dp_lhdcV1_caps.channelMode, sink_info_cie.channelMode);
+-    goto fail;
+-  }
+-
+-  if (int ret = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+-                         p_result_codec_config) != A2DP_SUCCESS) {
+-    LOG_ERROR("%s: A2DP_BuildInfoLhdcV1 fail(0x%x)", __func__, ret);
+-    goto fail;
+-  }
+-
+-  //
+-  // Copy the codec-specific fields if they are not zero
+-  //
+-  if (codec_user_config_.codec_specific_1 != 0)
+-    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+-  if (codec_user_config_.codec_specific_2 != 0)
+-    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+-  if (codec_user_config_.codec_specific_3 != 0)
+-    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+-  if (codec_user_config_.codec_specific_4 != 0)
+-    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+-
+-
+-  result_config_cie.isChannelSeparation = sink_info_cie.isChannelSeparation;
+-  LOG_ERROR("%s: isChannelSeparation = %d", __func__, result_config_cie.isChannelSeparation);
+-
+-  // Create a local copy of the peer codec capability, and the
+-  // result codec config.
+-    LOG_ERROR("%s: is_capability = %d", __func__, is_capability);
+-  if (is_capability) {
+-    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+-                                ota_codec_peer_capability_);
+-  } else {
+-    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+-                                ota_codec_peer_config_);
+-  }
+-  CHECK(status == A2DP_SUCCESS);
+-
+-  status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+-                              ota_codec_config_);
+-  CHECK(status == A2DP_SUCCESS);
+-  return true;
+-
+-fail:
+-  // Restore the internal state
+-  codec_config_ = saved_codec_config;
+-  codec_capability_ = saved_codec_capability;
+-  codec_selectable_capability_ = saved_codec_selectable_capability;
+-  codec_user_config_ = saved_codec_user_config;
+-  codec_audio_config_ = saved_codec_audio_config;
+-  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+-  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+-         sizeof(ota_codec_peer_capability_));
+-  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+-         sizeof(ota_codec_peer_config_));
+-  return false;
+-}
+-
+-bool A2dpCodecConfigLhdcV1::setPeerCodecCapabilities(
+-                                                   const uint8_t* p_peer_codec_capabilities) {
+-    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+-    tA2DP_LHDC_CIE peer_info_cie;
+-    uint8_t sampleRate;
+-    uint8_t bits_per_sample;
+-
+-    // Save the internal state
+-    btav_a2dp_codec_config_t saved_codec_selectable_capability =
+-    codec_selectable_capability_;
+-    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+-    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+-           sizeof(ota_codec_peer_capability_));
+-
+-    tA2DP_STATUS status =
+-    A2DP_ParseInfoLhdcV1(&peer_info_cie, p_peer_codec_capabilities, true);
+-    if (status != A2DP_SUCCESS) {
+-        LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
+-                  __func__, status);
+-        goto fail;
+-    }
+-
+-
+-    codec_selectable_capability_.codec_specific_3 = 0;
+-
+-    // Compute the selectable capability - bits per sample
+-    //codec_selectable_capability_.bits_per_sample =
+-    //a2dp_lhdcV1_caps.bits_per_sample;
+-    bits_per_sample = peer_info_cie.bits_per_sample & peer_info_cie.bits_per_sample;
+-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+-    }
+-    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+-        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+-    }
+-
+-
+-    // Compute the selectable capability - sample rate
+-    sampleRate = a2dp_lhdcV1_caps.sampleRate & peer_info_cie.sampleRate;
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+-        codec_selectable_capability_.sample_rate |=
+-        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+-    }
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+-        codec_selectable_capability_.sample_rate |=
+-        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+-    }
+-    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+-        codec_selectable_capability_.sample_rate |=
+-        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+-    }
+-
+-
+-    // Compute the selectable capability - channel mode
+-    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+-
+-    status = A2DP_BuildInfoLhdcV1(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+-                                ota_codec_peer_capability_);
+-    CHECK(status == A2DP_SUCCESS);
+-    return true;
+-
+-fail:
+-    // Restore the internal state
+-    codec_selectable_capability_ = saved_codec_selectable_capability;
+-    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+-           sizeof(ota_codec_peer_capability_));
+-    return false;
+-}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc
+deleted file mode 100755
+index 0a8acb20e..000000000
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv1_encoder.cc
++++ /dev/null
+@@ -1,874 +0,0 @@
+-/*
+- * Copyright (C) 2016 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-#define LOG_TAG "a2dp_vendor_lhdcv1_encoder"
+-#define ATRACE_TAG ATRACE_TAG_AUDIO
+-
+-#include "a2dp_vendor_lhdcv1_encoder.h"
+-
+-#ifndef OS_GENERIC
+-#include <cutils/trace.h>
+-#endif
+-#include <dlfcn.h>
+-#include <inttypes.h>
+-#include <stdio.h>
+-#include <string.h>
+-#include <base/logging.h>
+-
+-#include <lhdcBT.h>
+-
+-#include "a2dp_vendor.h"
+-#include "a2dp_vendor_lhdcv1.h"
+-#include "bt_common.h"
+-#include "common/time_util.h"
+-#include "osi/include/log.h"
+-#include "osi/include/osi.h"
+-
+-//
+-// Encoder for LHDC Source Codec
+-//
+-
+-//
+-// The LHDC encoder shared library, and the functions to use
+-//
+-static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+-static void* lhdcV1_encoder_lib_handle = NULL;
+-
+-static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+-typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+-
+-static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+-typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+-
+-static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+-typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+-static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+-typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+-
+-//static const char* LHDC_GET_SAMPLING_FREQ_NAME = "lhdcBT_get_sampling_freq";
+-//typedef int (*tLHDC_GET_SAMPLING_FREQ)(HANDLE_LHDC_BT hLhdcParam);
+-
+-static const char* LHDC_INIT_HANDLE_ENCODE_NAME = "lhdcBT_init_encoder";
+-typedef int (*tLHDC_INIT_HANDLE_ENCODE)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+-
+-static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+-typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+-
+-
+-static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
+-typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
+-
+-//static const char* LHDC_GET_ERROR_CODE_NAME = "lhdcBT_get_error_code";
+-//typedef int (*tLHDC_GET_ERROR_CODE)(HANDLE_LHDC_BT hLhdcParam);
+-
+-static tLHDC_GET_HANDLE lhdcV1_get_handle_func;
+-static tLHDC_FREE_HANDLE lhdcV1_free_handle_func;
+-//static tLHDC_CLOSE_HANDLE lhdcV1_close_handle_func;
+-//static tLHDC_GET_VERSION lhdcV1_get_version_func;
+-static tLHDC_GET_BITRATE lhdcV1_get_bitrate_func;
+-static tLHDC_SET_BITRATE lhdcV1_set_bitrate_func;
+-//static tLHDC_GET_SAMPLING_FREQ lhdcV1_get_sampling_freq_func;
+-static tLHDC_INIT_HANDLE_ENCODE lhdcV1_init_handle_encode_func;
+-static tLHDC_ENCODE lhdcV1_encode_func;
+-static tLHDC_AUTO_ADJUST_BITRATE lhdcV1_auto_adjust_bitrate_func;
+-//static tLHDC_GET_ERROR_CODE lhdcV1_get_error_code_func;
+-//static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdcV1_set_limit_bitrate_enabled;
+-
+-// A2DP LHDC encoder interval in milliseconds
+-#define A2DP_LHDCV1_ENCODER_INTERVAL_MS 20
+-#define A2DP_LHDCV1_SAMPLES_PER_FRAME 512
+-
+-// offset
+-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+-#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+-#else
+-#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+-#endif
+-
+-//#define A2DP_LHDCV1_OFFSET (AVDT_MEDIA_OFFSET + 0)
+-
+-typedef struct {
+-  uint32_t sample_rate;
+-  uint8_t channel_mode;
+-  uint8_t bits_per_sample;
+-  int quality_mode_index;
+-  int latency_mode_index;
+-  int pcm_wlength;
+-  LHDCBT_SMPL_FMT_T pcm_fmt;
+-  bool isChannelSeparation;
+-} tA2DP_LHDC_ENCODER_PARAMS;
+-
+-typedef struct {
+-  uint32_t counter;
+-  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+-  uint64_t last_frame_us;
+-} tA2DP_LHDC_FEEDING_STATE;
+-
+-typedef struct {
+-  uint64_t session_start_us;
+-
+-  size_t media_read_total_expected_packets;
+-  size_t media_read_total_expected_reads_count;
+-  size_t media_read_total_expected_read_bytes;
+-
+-  size_t media_read_total_dropped_packets;
+-  size_t media_read_total_actual_reads_count;
+-  size_t media_read_total_actual_read_bytes;
+-} a2dp_lhdcV1_encoder_stats_t;
+-
+-typedef struct {
+-  a2dp_source_read_callback_t read_callback;
+-  a2dp_source_enqueue_callback_t enqueue_callback;
+-  uint16_t TxAaMtuSize;
+-  size_t TxQueueLength;
+-
+-  bool use_SCMS_T;
+-  bool is_peer_edr;          // True if the peer device supports EDR
+-  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+-  uint16_t peer_mtu;         // MTU of the A2DP peer
+-  uint32_t timestamp;        // Timestamp for the A2DP frames
+-
+-  HANDLE_LHDC_BT lhdcV1_handle;
+-  bool has_lhdcV1_handle;  // True if lhdcV1_handle is valid
+-/*
+-  HANDLE_LHDC_ABR lhdcV1_abr_handle;
+-  bool has_lhdcV1_abr_handle;
+-  int last_lhdcV1_abr_eqmid;
+-  size_t lhdcV1_abr_adjustments;
+-*/
+-  tA2DP_FEEDING_PARAMS feeding_params;
+-  tA2DP_LHDC_ENCODER_PARAMS lhdcV1_encoder_params;
+-  tA2DP_LHDC_FEEDING_STATE lhdcV1_feeding_state;
+-
+-  a2dp_lhdcV1_encoder_stats_t stats;
+-  uint32_t buf_seq;
+-} tA2DP_LHDC_ENCODER_CB;
+-
+-//static bool lhdcV1_abr_loaded = false;
+-
+-//FILE  *RecFile = NULL;
+-
+-static tA2DP_LHDC_ENCODER_CB a2dp_lhdcV1_encoder_cb;
+-
+-static void a2dp_vendor_lhdcV1_encoder_update(uint16_t peer_mtu,
+-                                            A2dpCodecConfig* a2dp_codec_config,
+-                                            bool* p_restart_input,
+-                                            bool* p_restart_output,
+-                                            bool* p_config_updated);
+-static void a2dp_lhdcV1_get_num_frame_iteration(uint8_t* num_of_iterations,
+-                                              uint8_t* num_of_frames,
+-                                              uint64_t timestamp_us);
+-static void a2dp_lhdcV1_encode_frames(uint8_t nb_frame);
+-static bool a2dp_lhdcV1_read_feeding(uint8_t* read_buffer);
+-static std::string quality_mode_index_to_name(int quality_mode_index);
+-static std::string latency_mode_index_to_name(int latency_mode_index);
+-
+-static void* load_func(const char* func_name) {
+-  void* func_ptr = dlsym(lhdcV1_encoder_lib_handle, func_name);
+-  if (func_ptr == NULL) {
+-    LOG_ERROR(
+-              "%s: cannot find function '%s' in the encoder library: %s",
+-              __func__, func_name, dlerror());
+-    A2DP_VendorUnloadEncoderLhdcV1();
+-    return NULL;
+-  }
+-  return func_ptr;
+-}
+-
+-bool A2DP_VendorLoadEncoderLhdcV1(void) {
+-  if (lhdcV1_encoder_lib_handle != NULL) return true;  // Already loaded
+-
+-  // Initialize the control block
+-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+-
+-  // Open the encoder library
+-  lhdcV1_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+-  if (lhdcV1_encoder_lib_handle == NULL) {
+-    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
+-              LHDC_ENCODER_LIB_NAME, dlerror());
+-    return false;
+-  }
+-
+-  // Load all functions
+-  lhdcV1_get_handle_func = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+-  if (lhdcV1_get_handle_func == NULL) return false;
+-  lhdcV1_free_handle_func = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+-  if (lhdcV1_free_handle_func == NULL) return false;
+-  //lhdcV1_close_handle_func = (tLHDC_CLOSE_HANDLE)load_func(LHDC_CLOSE_HANDLE_NAME);
+-  //if (lhdcV1_close_handle_func == NULL) return false;
+-  //lhdcV1_get_version_func = (tLHDC_GET_VERSION)load_func(LHDC_GET_VERSION_NAME);
+-  //if (lhdcV1_get_version_func == NULL) return false;
+-  lhdcV1_get_bitrate_func = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+-  if (lhdcV1_get_bitrate_func == NULL) return false;
+-  lhdcV1_set_bitrate_func = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+-  if (lhdcV1_set_bitrate_func == NULL) return false;
+-  //lhdcV1_get_sampling_freq_func = (tLHDC_GET_SAMPLING_FREQ)load_func(LHDC_GET_SAMPLING_FREQ_NAME);
+-  //if (lhdcV1_get_sampling_freq_func == NULL) return false;
+-  lhdcV1_init_handle_encode_func =
+-      (tLHDC_INIT_HANDLE_ENCODE)load_func(LHDC_INIT_HANDLE_ENCODE_NAME);
+-  if (lhdcV1_init_handle_encode_func == NULL) return false;
+-  lhdcV1_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+-  if (lhdcV1_encode_func == NULL) return false;
+-  lhdcV1_auto_adjust_bitrate_func = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+-  if (lhdcV1_auto_adjust_bitrate_func == NULL) return false;
+-  //lhdcV1_alter_eqmid_priority_func = (tLHDC_ALTER_EQMID_PRIORITY)load_func(LHDC_ALTER_EQMID_PRIORITY_NAME);
+-  //if (lhdcV1_alter_eqmid_priority_func == NULL) return false;
+-  //lhdcV1_get_eqmid_func = (tLHDC_GET_EQMID)load_func(LHDC_GET_EQMID_NAME);
+-  //if (lhdcV1_get_eqmid_func == NULL) return false;
+-  //lhdcV1_get_error_code_func = (tLHDC_GET_ERROR_CODE)load_func(LHDC_GET_ERROR_CODE_NAME);
+-  //if (lhdcV1_get_error_code_func == NULL) return false;
+-
+-
+-  //lhdcV1_set_limit_bitrate_enabled = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+-  //if (lhdcV1_set_limit_bitrate_enabled == NULL) return false;
+-
+-
+-/*
+-  if (!A2DP_VendorLoadLhdcAbr()) {
+-    LOG_WARN( "%s: cannot load the LHDC ABR library", __func__);
+-    lhdcV1_abr_loaded = false;
+-  } else {
+-    lhdcV1_abr_loaded = true;
+-  }
+-  */
+-  return true;
+-}
+-
+-void A2DP_VendorUnloadEncoderLhdcV1(void) {
+-  // Cleanup any LHDC-related state
+-
+-    LOG_DEBUG( "%s: a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle = %d, lhdcV1_free_handle_func = %p",
+-              __func__, a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle, lhdcV1_free_handle_func);
+-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle && lhdcV1_free_handle_func != NULL)
+-    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
+-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+-
+-  lhdcV1_get_handle_func = NULL;
+-  lhdcV1_free_handle_func = NULL;
+-  lhdcV1_get_bitrate_func = NULL;
+-  lhdcV1_set_bitrate_func = NULL;
+-  //lhdcV1_get_sampling_freq_func = NULL;
+-  lhdcV1_init_handle_encode_func = NULL;
+-  lhdcV1_encode_func = NULL;
+-  lhdcV1_auto_adjust_bitrate_func = NULL;
+-  //lhdcV1_get_error_code_func = NULL;
+-  //lhdcV1_set_limit_bitrate_enabled = NULL;
+-
+-  if (lhdcV1_encoder_lib_handle != NULL) {
+-    dlclose(lhdcV1_encoder_lib_handle);
+-    lhdcV1_encoder_lib_handle = NULL;
+-  }
+-}
+-
+-void a2dp_vendor_lhdcV1_encoder_init(
+-    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+-    A2dpCodecConfig* a2dp_codec_config,
+-    a2dp_source_read_callback_t read_callback,
+-    a2dp_source_enqueue_callback_t enqueue_callback) {
+-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle)
+-    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
+-
+-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+-
+-  a2dp_lhdcV1_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+-
+-  a2dp_lhdcV1_encoder_cb.read_callback = read_callback;
+-  a2dp_lhdcV1_encoder_cb.enqueue_callback = enqueue_callback;
+-  a2dp_lhdcV1_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+-  a2dp_lhdcV1_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+-  a2dp_lhdcV1_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+-  a2dp_lhdcV1_encoder_cb.timestamp = 0;
+-
+-
+-  a2dp_lhdcV1_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+-  a2dp_lhdcV1_encoder_cb.use_SCMS_T = true;
+-#endif
+-
+-  // NOTE: Ignore the restart_input / restart_output flags - this initization
+-  // happens when the connection is (re)started.
+-  bool restart_input = false;
+-  bool restart_output = false;
+-  bool config_updated = false;
+-  a2dp_vendor_lhdcV1_encoder_update(a2dp_lhdcV1_encoder_cb.peer_mtu,
+-                                  a2dp_codec_config, &restart_input,
+-                                  &restart_output, &config_updated);
+-}
+-
+-bool A2dpCodecConfigLhdcV1::updateEncoderUserConfig(
+-    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+-    bool* p_restart_output, bool* p_config_updated) {
+-  a2dp_lhdcV1_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+-  a2dp_lhdcV1_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+-  a2dp_lhdcV1_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+-  a2dp_lhdcV1_encoder_cb.timestamp = 0;
+-
+-  if (a2dp_lhdcV1_encoder_cb.peer_mtu == 0) {
+-    LOG_ERROR(
+-              "%s: Cannot update the codec encoder for %s: "
+-              "invalid peer MTU",
+-              __func__, name().c_str());
+-    return false;
+-  }
+-
+-  a2dp_vendor_lhdcV1_encoder_update(a2dp_lhdcV1_encoder_cb.peer_mtu, this,
+-                                  p_restart_input, p_restart_output,
+-                                  p_config_updated);
+-  return true;
+-}
+-
+-// Update the A2DP LHDC encoder.
+-// |peer_mtu| is the peer MTU.
+-// |a2dp_codec_config| is the A2DP codec to use for the update.
+-static void a2dp_vendor_lhdcV1_encoder_update(uint16_t peer_mtu,
+-                                            A2dpCodecConfig* a2dp_codec_config,
+-                                            bool* p_restart_input,
+-                                            bool* p_restart_output,
+-                                            bool* p_config_updated) {
+-  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+-      &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+-  uint8_t codec_info[AVDT_CODEC_SIZE];
+-
+-  *p_restart_input = false;
+-  *p_restart_output = false;
+-  *p_config_updated = false;
+-
+-  //Example for limit bit rate
+-  //lhdcV1_set_limit_bitrate_enabled(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, 0);
+-
+-
+-  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+-    LOG_ERROR(
+-              "%s: Cannot update the codec encoder for %s: "
+-              "invalid codec config",
+-              __func__, a2dp_codec_config->name().c_str());
+-    return;
+-  }
+-
+-  if (!a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle) {
+-      a2dp_lhdcV1_encoder_cb.lhdcV1_handle = lhdcV1_get_handle_func(0);
+-      if (a2dp_lhdcV1_encoder_cb.lhdcV1_handle == NULL) {
+-          LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
+-          return;  // TODO: Return an error?
+-      }
+-      a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle = true;
+-  }
+-  const uint8_t* p_codec_info = codec_info;
+-  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+-  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+-
+-  // The feeding parameters
+-  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdcV1_encoder_cb.feeding_params;
+-  p_feeding_params->sample_rate =
+-      A2DP_VendorGetTrackSampleRateLhdcV1(p_codec_info);
+-  p_feeding_params->bits_per_sample =
+-      a2dp_codec_config->getAudioBitsPerSample();
+-  p_feeding_params->channel_count =
+-      A2DP_VendorGetTrackChannelCountLhdcV1(p_codec_info);
+-  LOG_DEBUG( "%s: sample_rate=%u bits_per_sample=%u channel_count=%u",
+-            __func__, p_feeding_params->sample_rate,
+-            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+-
+-  // The codec parameters
+-  p_encoder_params->sample_rate =
+-      a2dp_lhdcV1_encoder_cb.feeding_params.sample_rate;
+-  p_encoder_params->channel_mode =
+-      A2DP_VendorGetChannelModeCodeLhdcV1(p_codec_info);
+-
+-  uint16_t mtu_size =
+-      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDCV1_OFFSET - sizeof(BT_HDR);
+-  if (mtu_size < peer_mtu) {
+-    a2dp_lhdcV1_encoder_cb.TxAaMtuSize = mtu_size;
+-  } else {
+-    a2dp_lhdcV1_encoder_cb.TxAaMtuSize = peer_mtu;
+-  }
+-
+-  //get separation feature.
+-  p_encoder_params->isChannelSeparation = A2DP_VendorGetChannelSeparation(p_codec_info);
+-  // Set the quality mode index
+-  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+-  LOG_DEBUG( "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+-  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+-      //int newValue = codec_config.codec_specific_1 & 0xff;
+-      int newValue = codec_config.codec_specific_1 & 0xff;
+-
+-      // adjust non-supported quality modes and wrap to internal library used index
+-      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+-        newValue = LHDCBT_QUALITY_AUTO; //9->8
+-      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
+-        // High1(1000K) does not supported, downgrade to High(900K)
+-        newValue = LHDCBT_QUALITY_HIGH; //8->7
+-        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+-        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+-      }
+-
+-      if (newValue != p_encoder_params->quality_mode_index) {
+-
+-        p_encoder_params->quality_mode_index = newValue;
+-        LOG_DEBUG( "%s: setting internal quality mode to %s(%d)", __func__,
+-                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+-                      .c_str(), p_encoder_params->quality_mode_index);
+-      }
+-  }else {
+-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
+-      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+-      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+-  }
+-  if (p_encoder_params->isChannelSeparation && p_encoder_params->quality_mode_index >= LHDCBT_QUALITY_HIGH) {
+-      /* code */
+-      LOG_DEBUG( "%s: Channel separation enabled, Max bit rate = LHDCBT_QUALITY_MID", __func__);
+-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_MID;
+-  }
+-
+-  //p_encoder_params->latency_mode_index = 1;
+-  if ((codec_config.codec_specific_2 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_LATENCY_MAGIC_NUM) {
+-      int newValue = codec_config.codec_specific_2 & 0xff;
+-      if (newValue != p_encoder_params->latency_mode_index) {
+-          /* code */
+-          p_encoder_params->latency_mode_index = newValue;
+-          LOG_DEBUG( "%s: setting latency value to %s(%d)", __func__,
+-                    latency_mode_index_to_name(p_encoder_params->latency_mode_index).c_str(),
+-                    p_encoder_params->latency_mode_index);
+-      }
+-  }else {
+-      p_encoder_params->latency_mode_index = A2DP_LHDC_LATENCY_MID;
+-  }
+-
+-  p_encoder_params->pcm_wlength =
+-      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample >> 3;
+-  // Set the Audio format from pcm_wlength
+-  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+-  if (p_encoder_params->pcm_wlength == 2)
+-    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+-  else if (p_encoder_params->pcm_wlength == 3)
+-    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+-
+-  LOG_DEBUG( "%s: MTU=%d, peer_mtu=%d", __func__,
+-            a2dp_lhdcV1_encoder_cb.TxAaMtuSize, peer_mtu);
+-  LOG_DEBUG(
+-            "%s: sample_rate: %d channel_mode: %d "
+-            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
+-            __func__, p_encoder_params->sample_rate,
+-            p_encoder_params->channel_mode,
+-            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+-            p_encoder_params->pcm_fmt);
+-/*
+-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+-#else
+-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+-#endif
+-*/
+-  // Initialize the encoder.
+-  // NOTE: MTU in the initialization must include the AVDT media header size.
+-  int result = lhdcV1_init_handle_encode_func(
+-      a2dp_lhdcV1_encoder_cb.lhdcV1_handle,
+-      p_encoder_params->sample_rate,
+-      p_encoder_params->pcm_fmt,
+-      p_encoder_params->quality_mode_index,
+-      p_encoder_params->isChannelSeparation == true ? 1 : 0,
+-      0 /* This parameter alaways is 0 in A2DP */,
+-      0,
+-      a2dp_vendor_lhdcV1_get_encoder_interval_ms()
+-  );
+-  lhdcV1_set_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, p_encoder_params->quality_mode_index);
+-
+-#if defined(RecFile)
+-  if (RecFile == NULL) {
+-      /* code */
+-      RecFile = fopen("/sdcard/Download/lhdc.raw","wb");
+-  }
+-#endif
+-  if (result != 0) {
+-    LOG_ERROR( "%s: error initializing the LHDC encoder: %d", __func__,
+-              result);
+-  }
+-}
+-
+-void a2dp_vendor_lhdcV1_encoder_cleanup(void) {
+-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_handle)
+-    lhdcV1_free_handle_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle);
+-  memset(&a2dp_lhdcV1_encoder_cb, 0, sizeof(a2dp_lhdcV1_encoder_cb));
+-#if defined(RecFile)
+-  if (RecFile != NULL) {
+-      fclose(RecFile);
+-      RecFile = NULL;
+-  }
+-#endif
+-}
+-
+-void a2dp_vendor_lhdcV1_feeding_reset(void) {
+-  /* By default, just clear the entire state */
+-  memset(&a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state, 0,
+-         sizeof(a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state));
+-
+-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick =
+-      (a2dp_lhdcV1_encoder_cb.feeding_params.sample_rate *
+-       a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8 *
+-       a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+-       A2DP_LHDCV1_ENCODER_INTERVAL_MS) /
+-      1000;
+-  a2dp_lhdcV1_encoder_cb.buf_seq = 0;
+-  LOG_DEBUG( "%s: PCM bytes per tick %u", __func__,
+-            a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick);
+-}
+-
+-void a2dp_vendor_lhdcV1_feeding_flush(void) {
+-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter = 0;
+-  LOG_DEBUG( "%s", __func__);
+-}
+-
+-uint64_t a2dp_vendor_lhdcV1_get_encoder_interval_ms(void) {
+-  LOG_DEBUG( "%s: A2DP_LHDCV1_ENCODER_INTERVAL_MS %u",
+-              __func__, A2DP_LHDCV1_ENCODER_INTERVAL_MS);
+-  return A2DP_LHDCV1_ENCODER_INTERVAL_MS;
+-}
+-
+-void a2dp_vendor_lhdcV1_send_frames(uint64_t timestamp_us) {
+-  uint8_t nb_frame = 0;
+-  uint8_t nb_iterations = 0;
+-
+-  a2dp_lhdcV1_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+-  LOG_DEBUG( "%s: Sending %d frames per iteration, %d iterations",
+-              __func__, nb_frame, nb_iterations);
+-  if (nb_frame == 0) return;
+-
+-  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+-    // Transcode frame and enqueue
+-    a2dp_lhdcV1_encode_frames(nb_frame);
+-  }
+-}
+-
+-// Obtains the number of frames to send and number of iterations
+-// to be used. |num_of_iterations| and |num_of_frames| parameters
+-// are used as output param for returning the respective values.
+-static void a2dp_lhdcV1_get_num_frame_iteration(uint8_t* num_of_iterations,
+-                                              uint8_t* num_of_frames,
+-                                              uint64_t timestamp_us) {
+-  uint32_t result = 0;
+-  uint8_t nof = 0;
+-  uint8_t noi = 1;
+-
+-  uint32_t pcm_bytes_per_frame =
+-      A2DP_LHDCV1_SAMPLES_PER_FRAME *
+-      a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+-      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+-  LOG_DEBUG( "%s: pcm_bytes_per_frame %u", __func__,
+-              pcm_bytes_per_frame);
+-
+-  uint32_t us_this_tick = A2DP_LHDCV1_ENCODER_INTERVAL_MS * 1000;
+-  uint64_t now_us = timestamp_us;
+-  if (a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us != 0)
+-    us_this_tick =
+-        (now_us - a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us);
+-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.last_frame_us = now_us;
+-
+-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter +=
+-      a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.bytes_per_tick * us_this_tick /
+-      (A2DP_LHDCV1_ENCODER_INTERVAL_MS * 1000);
+-
+-  result =
+-      a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter / pcm_bytes_per_frame;
+-  a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter -=
+-      result * pcm_bytes_per_frame;
+-  nof = result;
+-
+-  LOG_DEBUG( "%s: effective num of frames %u, iterations %u",
+-              __func__, nof, noi);
+-
+-  *num_of_frames = nof;
+-  *num_of_iterations = noi;
+-}
+-
+-static BT_HDR *bt_buf_new( void) {
+-    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+-    if ( p_buf == NULL) {
+-        // LeoKu(C): should not happen
+-        LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
+-        return  NULL;
+-    }
+-
+-    p_buf->offset = A2DP_LHDCV1_OFFSET;
+-    p_buf->len = 0;
+-    p_buf->layer_specific = 0;
+-    return  p_buf;
+-}
+-
+-#include <vector>
+-using namespace std;
+-static void a2dp_lhdcV1_encode_frames(uint8_t nb_frame) {
+-    BT_HDR * p_buf = NULL;
+-    //BT_HDR * p_btBufs[128];
+-    vector<BT_HDR * > btBufs;
+-    uint8_t nb_frame_org = nb_frame;
+-    tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+-        &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+-    uint32_t pcm_bytes_per_frame = LHDCV1_BT_ENC_BLOCK_SIZE *
+-                                 a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+-                                 a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+-
+-
+-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+-#else
+-    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdcV1_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+-#endif
+-    uint8_t * read_buffer = (uint8_t*)malloc(pcm_bytes_per_frame * 2);
+-    uint8_t * write_buffer = (uint8_t*)&(read_buffer[pcm_bytes_per_frame]);
+-    uint8_t latency = p_encoder_params->latency_mode_index;
+-    int out_offset = 0;
+-    int out_len = 0;
+-    static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+-    static uint32_t allSendbytes = 0;
+-
+-    //if (!p_encoder_params->isChannelSeparation) {
+-        while( nb_frame) {
+-            if ( !a2dp_lhdcV1_read_feeding(read_buffer)) {
+-            LOG_WARN( "%s: underflow %d", __func__, nb_frame);
+-            a2dp_lhdcV1_encoder_cb.lhdcV1_feeding_state.counter +=
+-                      nb_frame * LHDCV1_BT_ENC_BLOCK_SIZE *
+-                      a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+-                      a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+-                break;
+-            }
+-
+-            out_offset = 0;
+-            out_len = lhdcV1_encode_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, read_buffer, write_buffer);
+-    #if defined(RecFile)
+-            if (RecFile != NULL && out_len > 0) {
+-                fwrite(write_buffer, sizeof(uint8_t), out_len, RecFile);
+-            }
+-    #endif
+-
+-            nb_frame--;
+-
+-            while (out_len > 0) {
+-                if (p_buf == NULL) {
+-                    if (NULL == (p_buf = bt_buf_new())) {
+-                        LOG_ERROR ( "%s: ERROR", __func__);
+-                        if (read_buffer) {
+-                            free(read_buffer);
+-                            read_buffer = NULL;
+-                        }
+-                        for(BT_HDR*  p : btBufs) {
+-                            free(p);
+-                        }
+-                        btBufs.clear();
+-                        return;
+-                    }
+-                }
+-
+-                uint8_t *p = ( uint8_t *)( p_buf + 1) + p_buf->offset + p_buf->len;
+-                int space = max_mtu_len - p_buf->len;
+-                int bytes = ( out_len < space)? out_len : space;
+-                memcpy( p, &write_buffer[out_offset], bytes);
+-                out_offset += bytes;
+-                out_len -= bytes;
+-                p_buf->len += bytes;
+-                allSendbytes += bytes;
+-
+-                if ( p_buf->len >= max_mtu_len ) {
+-                    btBufs.push_back(p_buf);
+-                    // allocate new one
+-                    p_buf = NULL;
+-                    if (btBufs.size() >= 64) {
+-                        LOG_ERROR( "%s: Packet buffer usage to big!(%u)", __func__, (uint32_t)btBufs.size());
+-                        break;
+-                    }
+-                }
+-            }
+-        }
+-        uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+-        if (now_ms - time_prev >= 1000 ) {
+-            /* code */
+-            LOG_WARN( "%s: Current data rate about %d kbps", __func__, (allSendbytes * 8) / 1000);
+-            allSendbytes = 0;
+-            time_prev = now_ms;
+-        }
+-
+-        if ( p_buf) {
+-            btBufs.push_back(p_buf);
+-        }
+-
+-        LOG_DEBUG( "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
+-        if ( btBufs.size() == 1) {
+-            p_buf = btBufs[0];
+-
+-            p_buf->layer_specific = a2dp_lhdcV1_encoder_cb.buf_seq++;
+-            p_buf->layer_specific <<= 8;
+-            p_buf->layer_specific |= ( latency | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+-
+-            *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdcV1_encoder_cb.timestamp;
+-
+-            a2dp_lhdcV1_encoder_cb.enqueue_callback( p_buf, 1, p_buf->len);
+-
+-        } else {
+-
+-            uint8_t i;
+-
+-            if (btBufs.size() > 16) {
+-                LOG_DEBUG( "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
+-            }
+-
+-            for( i = 0; i < btBufs.size(); i++) {
+-                p_buf = btBufs[i];
+-
+-                p_buf->layer_specific = a2dp_lhdcV1_encoder_cb.buf_seq++;
+-                p_buf->layer_specific <<= 8;
+-                p_buf->layer_specific |= ( A2DP_LHDC_HDR_F_MSK | latency);
+-
+-                if ( i == 0) {
+-                    p_buf->layer_specific |= ( A2DP_LHDC_HDR_S_MSK | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+-                } else if ( i == ( btBufs.size() - 1)) {
+-                    p_buf->layer_specific |= A2DP_LHDC_HDR_L_MSK;
+-                }
+-
+-                *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdcV1_encoder_cb.timestamp;
+-
+-                a2dp_lhdcV1_encoder_cb.enqueue_callback( p_buf, 1, p_buf->len);
+-            }
+-        }
+-
+-        a2dp_lhdcV1_encoder_cb.timestamp += ( nb_frame_org * LHDCV1_BT_ENC_BLOCK_SIZE);
+-        if (read_buffer) {
+-            free(read_buffer);
+-            read_buffer = NULL;
+-        }
+-        btBufs.clear();
+-}
+-
+-static bool a2dp_lhdcV1_read_feeding(uint8_t* read_buffer) {
+-  uint32_t read_size = LHDCV1_BT_ENC_BLOCK_SIZE *
+-                       a2dp_lhdcV1_encoder_cb.feeding_params.channel_count *
+-                       a2dp_lhdcV1_encoder_cb.feeding_params.bits_per_sample / 8;
+-
+-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_expected_reads_count++;
+-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+-
+-  /* Read Data from UIPC channel */
+-  uint32_t nb_byte_read =
+-      a2dp_lhdcV1_encoder_cb.read_callback(read_buffer, read_size);
+-  LOG_DEBUG( "%s: want to read size %u, read byte number %u",
+-                    __func__, read_size, nb_byte_read);
+-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+-
+-  if (nb_byte_read < read_size) {
+-    if (nb_byte_read == 0) return false;
+-
+-    /* Fill the unfilled part of the read buffer with silence (0) */
+-    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+-    nb_byte_read = read_size;
+-  }
+-  a2dp_lhdcV1_encoder_cb.stats.media_read_total_actual_reads_count++;
+-
+-  return true;
+-}
+-
+-static std::string quality_mode_index_to_name(int quality_mode_index) {
+-  switch (quality_mode_index) {
+-    case LHDCBT_QUALITY_HIGH:
+-      return "HIGH";
+-    case LHDCBT_QUALITY_MID:
+-      return "MID";
+-    case LHDCBT_QUALITY_LOW:
+-      return "LOW";
+-    case LHDCBT_QUALITY_AUTO:
+-      return "ABR";
+-    default:
+-      return "Unknown";
+-  }
+-}
+-
+-static std::string latency_mode_index_to_name(int latency_mode_index){
+-    switch (latency_mode_index) {
+-        case A2DP_LHDC_LATENCY_HIGH:
+-            return "Long Latency";
+-        case A2DP_LHDC_LATENCY_MID:
+-            return "Middle Latency";
+-        case A2DP_LHDC_LATENCY_LOW:
+-            return "Short Latency";
+-        default:
+-            return "Unknown";
+-    }
+-}
+-
+-void a2dp_vendor_lhdcV1_set_transmit_queue_length(size_t transmit_queue_length) {
+-  a2dp_lhdcV1_encoder_cb.TxQueueLength = transmit_queue_length;
+-  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+-  LOG_DEBUG( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+-  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+-      LOG_DEBUG( "%s: Auto Bitrate Enabled!", __func__);
+-      if (lhdcV1_auto_adjust_bitrate_func != NULL) {
+-          lhdcV1_auto_adjust_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle, transmit_queue_length);
+-      }
+-  }
+-}
+-
+-uint64_t A2dpCodecConfigLhdcV1::encoderIntervalMs() const {
+-  return a2dp_vendor_lhdcV1_get_encoder_interval_ms();
+-}
+-
+-int A2dpCodecConfigLhdcV1::getEffectiveMtu() const {
+-  return a2dp_lhdcV1_encoder_cb.TxAaMtuSize;
+-}
+-
+-void A2dpCodecConfigLhdcV1::debug_codec_dump(int fd) {
+-  a2dp_lhdcV1_encoder_stats_t* stats = &a2dp_lhdcV1_encoder_cb.stats;
+-  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+-      &a2dp_lhdcV1_encoder_cb.lhdcV1_encoder_params;
+-
+-  A2dpCodecConfig::debug_codec_dump(fd);
+-
+-  dprintf(fd,
+-          "  Packet counts (expected/dropped)                        : %zu / "
+-          "%zu\n",
+-          stats->media_read_total_expected_packets,
+-          stats->media_read_total_dropped_packets);
+-
+-  dprintf(fd,
+-          "  PCM read counts (expected/actual)                       : %zu / "
+-          "%zu\n",
+-          stats->media_read_total_expected_reads_count,
+-          stats->media_read_total_actual_reads_count);
+-
+-  dprintf(fd,
+-          "  PCM read bytes (expected/actual)                        : %zu / "
+-          "%zu\n",
+-          stats->media_read_total_expected_read_bytes,
+-          stats->media_read_total_actual_read_bytes);
+-
+-  dprintf(
+-      fd, "  LHDC quality mode                                       : %s\n",
+-      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+-
+-  dprintf(fd,
+-          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+-          lhdcV1_get_bitrate_func(a2dp_lhdcV1_encoder_cb.lhdcV1_handle));
+-
+-  dprintf(fd,
+-          "  LHDC saved transmit queue length                        : %zu\n",
+-          a2dp_lhdcV1_encoder_cb.TxQueueLength);
+-/*
+-  if (a2dp_lhdcV1_encoder_cb.has_lhdcV1_abr_handle) {
+-    dprintf(fd,
+-            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+-            a2dp_lhdcV1_encoder_cb.last_lhdcV1_abr_eqmid);
+-    dprintf(fd,
+-            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+-            a2dp_lhdcV1_encoder_cb.lhdcV1_abr_adjustments);
+-  }
+-  */
+-}
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
+index 36d9ee39a..6b0cc11b3 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
+@@ -33,6 +33,7 @@
+ #include "a2dp_vendor.h"
+ #include "a2dp_vendor_lhdcv2_encoder.h"
+ #include "bt_utils.h"
++#include "btif_av_co.h"
+ #include "osi/include/log.h"
+ #include "osi/include/osi.h"
+ 
+@@ -55,14 +56,14 @@ static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+     A2DP_LHDCV2_CODEC_ID,   // codecId
+     // sampleRate
+     //(A2DP_LHDC_SAMPLING_FREQ_48000),
+-    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
++    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+     // bits_per_sample
+     (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+     //Channel Separation
+     A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+     //Version number
+     A2DP_LHDC_VER2,
+-    //Target bit Rate
++    //Max target bit Rate
+     A2DP_LHDC_MAX_BIT_RATE_900K,
+     //LL supported ?
+     false,
+@@ -260,6 +261,54 @@ static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
+ }
+ */
+ 
++static bool A2DP_MaxBitRatetoQualityLevelLhdcV2(uint8_t *mode, uint8_t bitrate) {
++  if (mode == nullptr) {
++    LOG_ERROR( "%s: nullptr input", __func__);
++    return false;
++  }
++
++  switch (bitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
++  case A2DP_LHDC_MAX_BIT_RATE_900K:
++    *mode = A2DP_LHDC_QUALITY_HIGH;
++    return true;
++  case A2DP_LHDC_MAX_BIT_RATE_500K:
++    *mode = A2DP_LHDC_QUALITY_MID;
++    return true;
++  case A2DP_LHDC_MAX_BIT_RATE_400K:
++    *mode = A2DP_LHDC_QUALITY_LOW;
++    return true;
++  }
++  return false;
++}
++
++static std::string lhdcV2_QualityModeBitRate_toString(uint8_t value) {
++  switch((int)value)
++  {
++  case A2DP_LHDC_QUALITY_ABR:
++    return "ABR";
++  case A2DP_LHDC_QUALITY_HIGH1:
++    return "HIGH 1 (1000 Kbps)";
++  case A2DP_LHDC_QUALITY_HIGH:
++    return "HIGH (900 Kbps)";
++  case A2DP_LHDC_QUALITY_MID:
++    return "MID (500 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW:
++    return "LOW (400 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW4:
++    return "LOW 4 (320 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW3:
++    return "LOW 3 (256 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW2:
++    return "LOW 2 (192 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW1:
++    return "LOW 1 (128 Kbps)";
++  case A2DP_LHDC_QUALITY_LOW0:
++    return "LOW 0 (64 Kbps)";
++  default:
++    return "Unknown Bit Rate Mode";
++  }
++}
++
+ bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info) {
+   tA2DP_LHDC_CIE cfg_cie;
+ 
+@@ -372,6 +421,42 @@ bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
+          (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample);
+ }
+ 
++// Savitech Patch - START  Offload
++int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info) {
++
++  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
++  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
++
++  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
++      A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
++      case A2DP_LHDC_QUALITY_LOW0:
++        return 64000;
++      case A2DP_LHDC_QUALITY_LOW1:
++        return 128000;
++      case A2DP_LHDC_QUALITY_LOW2:
++        return 192000;
++      case A2DP_LHDC_QUALITY_LOW3:
++        return 256000;
++      case A2DP_LHDC_QUALITY_LOW4:
++        return 320000;
++      case A2DP_LHDC_QUALITY_LOW:
++        return 400000;
++      case A2DP_LHDC_QUALITY_MID:
++        return 600000;
++      case A2DP_LHDC_QUALITY_HIGH:
++        return 900000;
++      case A2DP_LHDC_QUALITY_ABR:
++        return 9999999;
++      case A2DP_LHDC_QUALITY_HIGH1:
++        [[fallthrough]];
++      default:
++        return -1;
++    }
++  }
++  return 400000;
++}
++// Savitech Patch - END
+ 
+ int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info) {
+   tA2DP_LHDC_CIE lhdc_cie;
+@@ -409,11 +494,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
+     return -1;
+   }
+ 
+-#if 0
+-  return 32;
+-#else
+-  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
+-
+   switch (lhdc_cie.bits_per_sample) {
+     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+       return 16;
+@@ -424,7 +504,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
+     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+       return -1;
+   }
+-#endif
+ }
+ 
+ int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info) {
+@@ -901,6 +980,8 @@ bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
+   tA2DP_LHDC_CIE sink_info_cie;
+   tA2DP_LHDC_CIE result_config_cie;
+   uint8_t sampleRate;
++  uint8_t qualityMode = 0;
++  uint8_t bitRateQmode = 0;
+   bool isLLEnabled;
+   btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+ 
+@@ -1177,12 +1258,48 @@ bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
+ 
+   result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+ 
+-  LOG_DEBUG( "%s: Config bitrate result(0x%02x), prev(0x%02x)", __func__, result_config_cie.maxTargetBitrate, sink_info_cie.maxTargetBitrate);
++  LOG_DEBUG( "%s: max target bitrate: 0x%02x", __func__,
++      result_config_cie.maxTargetBitrate);
+ 
+ 
+   result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+   LOG_ERROR("%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
+ 
++  // quality mode (BitRate) adjust
++  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
++    LOG_DEBUG( "%s: tag not match, use default Mode: ABR", __func__);
++  }
++  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
++
++  //
++  // quality mode adjust when non-ABR
++  //
++  if (qualityMode != A2DP_LHDC_QUALITY_ABR) {
++    // get corresponding quality mode of the max target bit rate
++    if (!A2DP_MaxBitRatetoQualityLevelLhdcV2(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
++      LOG_ERROR( "%s: get quality mode from maxTargetBitrate error", __func__);
++      goto fail;
++    }
++    // downgrade audio quality according to the max target bit rate
++    if (qualityMode > bitRateQmode) {
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
++      qualityMode = bitRateQmode;
++      LOG_DEBUG( "%s: downgrade quality mode to 0x%02X by max target bitrate", __func__, qualityMode);
++    }
++
++    // High1(1000K) does not supported in V2, downgrade to High(900K)
++    if (qualityMode == A2DP_LHDC_QUALITY_HIGH1) {
++      LOG_DEBUG( "%s: reset non-supported quality mode %s to HIGH (900 Kbps)", __func__,
++          lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
++      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
++      qualityMode = A2DP_LHDC_QUALITY_HIGH;
++    }
++  }
++
++  LOG_DEBUG( "%s: => final quality mode(0x%02X) = %s", __func__,
++      qualityMode,
++      lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
+ 
+   if (int ret = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                          p_result_codec_config) != A2DP_SUCCESS) {
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
+index 96a10930d..675125a3d 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
+@@ -363,8 +363,6 @@ static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+   }
+   const uint8_t* p_codec_info = codec_info;
+   btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+-  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+-
+ 
+   if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+       a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle_func(A2DP_VendorGetVersionLhdcV2(p_codec_info) <= A2DP_LHDC_VER2 ? 1 : -1);
+@@ -411,11 +409,6 @@ static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+       // adjust non-supported quality modes and wrap to internal library used index
+       if (newValue == A2DP_LHDC_QUALITY_ABR) {
+         newValue = LHDCBT_QUALITY_AUTO; //9->8
+-      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
+-        // High1(1000K) does not supported, downgrade to High(900K)
+-        newValue = LHDCBT_QUALITY_HIGH; //8->7
+-        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+-        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+       }
+ 
+       if (newValue != p_encoder_params->quality_mode_index) {
+@@ -425,9 +418,8 @@ static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+             .c_str(), p_encoder_params->quality_mode_index);
+       }
+   }else {
+-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
+-      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+-      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
++      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
+   }
+ 
+   //To correcting data to middle.
+@@ -537,6 +529,13 @@ void a2dp_vendor_lhdcv2_feeding_reset(void) {
+       1000;
+   a2dp_lhdc_encoder_cb.buf_seq = 0;
+   a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  LOG_DEBUG("%s: has_lhdc_handle %d (%d)", __func__,
++      a2dp_lhdc_encoder_cb.has_lhdc_handle,p_encoder_params->quality_mode_index);
++  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
++    if(lhdc_set_bitrate_func != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle)
++      lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
++  }
+   LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
+             a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+ }
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
+index 17c1be04f..2269aad67 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
+@@ -33,6 +33,7 @@
+ #include "a2dp_vendor.h"
+ #include "a2dp_vendor_lhdcv3_encoder.h"
+ #include "bt_utils.h"
++#include "btif_av_co.h"
+ #include "osi/include/log.h"
+ #include "osi/include/osi.h"
+ 
+@@ -134,7 +135,7 @@ static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+     A2DP_LHDCV3_CODEC_ID,   // codecId
+     // sampleRate
+     //(A2DP_LHDC_SAMPLING_FREQ_48000),
+-    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
++    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+ 	(A2DP_LHDC_SAMPLING_FREQ_48000),
+     // bits_per_sample
+     (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+@@ -638,6 +639,42 @@ bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+          (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+ }
+ 
++// Savitech Patch - START  Offload
++int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info) {
++
++  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
++  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
++
++  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
++      A2DP_LHDC_QUALITY_MAGIC_NUM) {
++    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
++      case A2DP_LHDC_QUALITY_LOW0:
++        return 64000;
++      case A2DP_LHDC_QUALITY_LOW1:
++        return 128000;
++      case A2DP_LHDC_QUALITY_LOW2:
++        return 192000;
++      case A2DP_LHDC_QUALITY_LOW3:
++        return 256000;
++      case A2DP_LHDC_QUALITY_LOW4:
++        return 320000;
++      case A2DP_LHDC_QUALITY_LOW:
++        return 400000;
++      case A2DP_LHDC_QUALITY_MID:
++        return 600000;
++      case A2DP_LHDC_QUALITY_HIGH:
++        return 900000;
++      case A2DP_LHDC_QUALITY_ABR:
++        return 9999999;
++      case A2DP_LHDC_QUALITY_HIGH1:
++        [[fallthrough]];
++      default:
++        return -1;
++    }
++  }
++  return 400000;
++}
++// Savitech Patch - END
+ 
+ int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info) {
+   tA2DP_LHDC_CIE lhdc_cie;
+@@ -675,11 +712,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
+     return -1;
+   }
+ 
+-#if 0
+-  return 32;
+-#else
+-  // TODO : Implement proc to care about bit per sample in A2DP_ParseInfoLdac()
+-
+   switch (lhdc_cie.bits_per_sample) {
+     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+       return 16;
+@@ -690,7 +722,6 @@ int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
+     case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+       return -1;
+   }
+-#endif
+ }
+ 
+ int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info) {
+@@ -2370,12 +2401,13 @@ bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
+ 
+   } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+     //LHDC V4 only
++    LOG_DEBUG("%s: [LHDCV4 only]", __func__);
+ 	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+ 		if (result_config_cie.hasFeatureMinBitrate) {
+ 			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+ 				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+ 				quality_mode = A2DP_LHDC_QUALITY_LOW;
+-				LOG_DEBUG("%s: [LHDC only]: reset Qmode (0x%x)", __func__, quality_mode);
++				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x)", __func__, quality_mode);
+ 			}
+ 		}
+ 	} else {
+@@ -2383,13 +2415,14 @@ bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
+ 			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+ 				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+ 				quality_mode = A2DP_LHDC_QUALITY_LOW4;
+-				LOG_DEBUG("%s: [LHDC only]: reset Qmode (0x%x), ", __func__, quality_mode);
++				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x), ", __func__, quality_mode);
+ 			}
+ 		}
+ 	}
+ 
+   } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+     //LLAC only
++    LOG_DEBUG("%s: [LLAC only]", __func__);
+     if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+       result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+       codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+@@ -2414,6 +2447,7 @@ bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
+ 
+   } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+     //LHDC V3 only
++    LOG_DEBUG("%s: [LHDCV3 only]", __func__);
+ 	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+ 		if (result_config_cie.hasFeatureMinBitrate) {
+ 			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
+index 2dcead914..894cabd0a 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
+@@ -508,8 +508,6 @@ int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info) {
+   return -1;
+ }
+ 
+-uint32_t A2DP_VendorGetBitRateLhdcV3Sink(const uint8_t* p_codec_info) { return 400; /*a2dp_sbc_get_bitrate();*/ }
+-
+ int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info) {
+   tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+ 
+@@ -661,7 +659,7 @@ btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(
+ const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void) { return "LHDC V3 SINK"; }
+ 
+ bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg) {
+-  LOG_DEBUG("[WL50] %s: enter", __func__);
++  LOG_DEBUG("%s: enter", __func__);
+   if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_caps,
+                         p_cfg->codec_info) != A2DP_SUCCESS) {
+     return false;
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
+index 03e8fa8c6..4124345eb 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
+@@ -20,7 +20,6 @@
+ 
+ #include <dlfcn.h>
+ #include <inttypes.h>
+-#include <pthread.h>
+ #include <stdio.h>
+ #include <string.h>
+ 
+@@ -547,5 +546,5 @@ void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info) {
+     return;
+   }
+ 
+-  LOG_ERROR("JIMM %s: enter", __func__);
++  LOG_ERROR("%s", __func__);
+ }
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
+index 69cb36200..47877a676 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
+@@ -488,7 +488,6 @@ static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+   }
+   const uint8_t* p_codec_info = codec_info;
+   btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+-  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+ 
+   uint32_t verCode = A2DP_VendorGetVersionLhdcV3(p_codec_info);  //LHDC V3 should 1!
+ 
+@@ -504,12 +503,6 @@ static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+       // adjust non-supported quality modes and wrap to internal library used index
+       if (newValue == A2DP_LHDC_QUALITY_ABR) {
+         newValue = LHDCBT_QUALITY_AUTO; //9->8
+-      } else if (newValue == A2DP_LHDC_QUALITY_HIGH1) {
+-        // should not be here normally (re-adjusted in vendor_lhdcv3.cc), but just make a safe.
+-        // High1(1000K) does not supported here, reset to High(900K)
+-        newValue = LHDCBT_QUALITY_HIGH; //8->7
+-        codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+-        //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+       }
+ 
+       if (newValue != p_encoder_params->quality_mode_index) {
+@@ -519,9 +512,8 @@ static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                       .c_str(), p_encoder_params->quality_mode_index);
+       }
+   }else {
+-      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_LOW;
+-      codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+-      //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
++      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
++      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
+   }
+ 
+   if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+@@ -681,6 +673,13 @@ void a2dp_vendor_lhdcv3_feeding_reset(void) {
+   a2dp_lhdc_encoder_cb.buf_seq = 0;
+   a2dp_lhdc_encoder_cb.bytes_read = 0;
+   a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
++  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
++    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++      LOG_DEBUG("%s: reset ABR!", __func__);
++      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
++    }
++  }
+   LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
+             a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+ }
+@@ -885,7 +884,7 @@ static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame){
+         return;
+     } else {
+       // NOTE: Unlike the execution path for other codecs, it is normal for
+-      // LDAC to NOT write encoded data to the last buffer if there wasn't
++      // LHDC to NOT write encoded data to the last buffer if there wasn't
+       // enough data to write to. That data is accumulated internally by
+       // the codec and included in the next iteration. Therefore, here we
+       // don't increment the "media_read_total_dropped_packets" counter.
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
+index 25ad19f35..8b4c1f384 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
+@@ -65,7 +65,7 @@ static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_caps = {
+     // Sampling Frequency
+     (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+     // Bits Per Sample
+-    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24 | A2DP_LHDCV5_BIT_FMT_32),
++    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24),
+     // Channel Mode
+     A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+     // Codec SubVersion Number
+@@ -869,14 +869,15 @@ int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info) {
+         return 500000;
+       case A2DP_LHDCV5_QUALITY_HIGH:
+         return 900000;
+-      case A2DP_LHDCV5_QUALITY_ABR:
+-        return 1000000;
+       case A2DP_LHDCV5_QUALITY_HIGH1:
++        return 1000000;
++      case A2DP_LHDCV5_QUALITY_ABR:
++        return 9999999;
+       default:
+-        return 0;
++        return -1;
+     }
+   }
+-  return 0;
++  return 400000;
+ }
+ 
+ int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info) {
+@@ -1060,6 +1061,53 @@ bool A2DP_VendorBuildCodecHeaderLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+   return true;
+ }
+ 
++void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info) {
++  tA2DP_STATUS a2dp_status;
++  tA2DP_LHDCV5_CIE lhdc_cie;
++
++  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
++  if (a2dp_status != A2DP_SUCCESS) {
++    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV5 fail:%d", __func__, a2dp_status);
++    return;
++  }
++
++  LOG_DEBUG( "\tsamp_freq: 0x%02X ", lhdc_cie.sampleRate);
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
++    LOG_DEBUG( "\tsamp_freq: (44100)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
++    LOG_DEBUG( "\tsamp_freq: (48000)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
++    LOG_DEBUG( "\tsamp_freq: (96000)");
++  }
++  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
++    LOG_DEBUG( "\tsamp_freq: (19200)");
++  }
++
++  LOG_DEBUG( "\tbitsPerSample: 0x%02X ", lhdc_cie.bitsPerSample);
++  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
++    LOG_DEBUG( "\tbit_depth: (16)");
++  }
++  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
++    LOG_DEBUG( "\tbit_depth: (24)");
++  }
++  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
++    LOG_DEBUG( "\tbit_depth: (32)");
++  }
++
++  LOG_DEBUG( "\tchannelMode: 0x%02X ", lhdc_cie.channelMode);
++  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
++    LOG_DEBUG( "\tchannle_mode: (mono)");
++  }
++  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
++    LOG_DEBUG( "\tchannle_mode: (dual)");
++  }
++  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
++    LOG_DEBUG( "\tchannle_mode: (stereo)");
++  }
++}
++
+ std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info) {
+   std::stringstream res;
+   std::string field;
+@@ -2147,7 +2195,8 @@ bool A2dpCodecConfigLhdcV5Base::setCodecConfig(const uint8_t* p_peer_codec_info,
+         (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+         false);
+     // update
+-    hasUserSet = true;  //caps-control enabling, always true
++    //hasUserSet = true;  //caps-control enabling, always true
++    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS);  //UI-control
+     if (hasFeature && hasUserSet) {
+       result_config_cie.hasFeatureLLESS = true;
+       A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
+index ce44032e9..0202c7773 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
+@@ -1,5 +1,5 @@
+ /*
+- * Copyright (C) 2016 The Android Open Source Project
++ * Copyright (C) 2022 The Android Open Source Project
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+@@ -20,6 +20,7 @@
+ 
+ #include <dlfcn.h>
+ #include <inttypes.h>
++#include <pthread.h>
+ #include <stdio.h>
+ #include <string.h>
+ 
+@@ -39,14 +40,19 @@
+ #define LHDCV5_DEC_MAX_CHANNELS           2
+ #define LHDCV5_DEC_MAX_BIT_DEPTH          32
+ #define LHDCV5_DEC_FRAME_NUM              16
+-#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * LHDCV5_DEC_MAX_CHANNELS * (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
++#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * \
++                                           LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * \
++                                           LHDCV5_DEC_MAX_CHANNELS * \
++                                           (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
+ #define LHDCV5_DEC_PACKET_NUM             8
+-
+ #define LHDCV5_DEC_INPUT_BUF_BYTES        1024
+-
+ #define LHDCV5_DEC_PKT_HDR_BYTES          2
+ 
+ typedef struct {
++  pthread_mutex_t mutex;
++  HANDLE_LHDCV5_BT lhdc_handle;
++  bool has_lhdc_handle;  // True if lhdc_handle is valid
++
+   uint32_t    sample_rate;
+   uint8_t     bits_per_sample;
+   lhdc_ver_t  version;
+@@ -80,24 +86,28 @@ static FILE *pcmFile = NULL;
+ static const char* LHDC_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
+ static void* lhdc_decoder_lib_handle = NULL;
+ 
+-static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcBT_dec_init_decoder";
+-typedef int (*tLHDCDEC_INIT_DECODER)(tLHDCV5_DEC_CONFIG *config);
++static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcv5BT_dec_init_decoder";
++typedef int32_t (*tLHDCDEC_INIT_DECODER)(HANDLE_LHDCV5_BT *handle,
++    tLHDCV5_DEC_CONFIG *config);
+ 
+-static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME = "lhdcBT_dec_check_frame_data_enough";
+-typedef int (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
++static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME =
++    "lhdcv5BT_dec_check_frame_data_enough";
++typedef int32_t (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData,
++    uint32_t frameBytes, uint32_t *packetBytes);
+ 
+-static const char* LHDCDEC_DECODE_NAME = "lhdcBT_dec_decode";
+-typedef int (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
++static const char* LHDCDEC_DECODE_NAME = "lhdcv5BT_dec_decode";
++typedef int32_t (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes,
++    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+ 
+-static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcBT_dec_deinit_decoder";
+-typedef int (*tLHDCDEC_DEINIT_DECODER)(void);
+-
+-static tLHDCDEC_INIT_DECODER lhdcdec_init_decoder;
+-static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcdec_check_frame_data_enough;
+-static tLHDCDEC_DECODE lhdcdec_decode;
+-static tLHDCDEC_DEINIT_DECODER lhdcdec_deinit_decoder;
++static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcv5BT_dec_deinit_decoder";
++typedef int32_t (*tLHDCDEC_DEINIT_DECODER)(HANDLE_LHDCV5_BT handle);
+ 
++static tLHDCDEC_INIT_DECODER lhdcv5dec_init_decoder;
++static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcv5dec_check_frame_data_enough;
++static tLHDCDEC_DECODE lhdcv5dec_decode;
++static tLHDCDEC_DEINIT_DECODER lhdcv5dec_deinit_decoder;
+ 
++// LHDC V5 Codec Info:
+ //  ----------------------------------------------------------------
+ //  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
+ //  losc | mediaType | codecType | vendorId | codecId | SampRate |
+@@ -221,6 +231,11 @@ bool A2DP_VendorLoadDecoderLhdcV5(void) {
+     return true;  // Already loaded
+   }
+ 
++  // Initialize the control block
++  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
++
++  pthread_mutex_init(&(a2dp_lhdcv5_decoder_cb.mutex), NULL);
++
+   // Open the encoder library
+   lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+   if (lhdc_decoder_lib_handle == NULL) {
+@@ -229,17 +244,19 @@ bool A2DP_VendorLoadDecoderLhdcV5(void) {
+   }
+ 
+   // Load all functions
+-  lhdcdec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+-  if (lhdcdec_init_decoder == NULL) return false;
++  lhdcv5dec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
++  if (lhdcv5dec_init_decoder == NULL) return false;
+ 
+-  lhdcdec_check_frame_data_enough = (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+-  if (lhdcdec_check_frame_data_enough == NULL) return false;
++  lhdcv5dec_check_frame_data_enough =
++      (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
++  if (lhdcv5dec_check_frame_data_enough == NULL) return false;
+ 
+-  lhdcdec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+-  if (lhdcdec_decode == NULL) return false;
++  lhdcv5dec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
++  if (lhdcv5dec_decode == NULL) return false;
+ 
+-  lhdcdec_deinit_decoder = (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+-  if (lhdcdec_deinit_decoder == NULL) return false;
++  lhdcv5dec_deinit_decoder =
++      (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
++  if (lhdcv5dec_deinit_decoder == NULL) return false;
+ 
+   LOG_DEBUG( "%s: LHDCV5 decoder library loaded", __func__);
+   return true;
+@@ -247,32 +264,82 @@ bool A2DP_VendorLoadDecoderLhdcV5(void) {
+ 
+ 
+ void A2DP_VendorUnloadDecoderLhdcV5(void) {
++
+   a2dp_vendor_lhdcv5_decoder_cleanup();
+-  LOG_DEBUG( "%s: LHDCV5 decoder library unloaded", __func__);
++
++  pthread_mutex_destroy(&(a2dp_lhdcv5_decoder_cb.mutex));
++  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
++
++  lhdcv5dec_init_decoder = NULL;
++  lhdcv5dec_check_frame_data_enough = NULL;
++  lhdcv5dec_decode = NULL;
++  lhdcv5dec_deinit_decoder = NULL;
++
++  if (lhdc_decoder_lib_handle != NULL) {
++    dlclose(lhdc_decoder_lib_handle);
++    lhdc_decoder_lib_handle = NULL;
++  }
++
++#if defined(_V5DEC_REC_FILE_)
++  if (rawFile != NULL) {
++    fclose(rawFile);
++    rawFile = NULL;
++    remove(V5RAW_FILE_NAME);
++  }
++  if (pcmFile != NULL) {
++    fclose(pcmFile);
++    pcmFile = NULL;
++    remove(V5PCM_FILE_NAME);
++  }
++#endif
++  LOG_DEBUG( "%s: unload LHDC V5 decoder", __func__);
+ }
+ 
+ 
+ bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
+-  int  fn_ret;
++  int32_t api_ret;
+   tLHDCV5_DEC_CONFIG lhdcdec_config;
+ 
+   if ((lhdc_decoder_lib_handle == NULL) ||
+-      (lhdcdec_init_decoder == NULL) ||
+-      (lhdcdec_deinit_decoder == NULL)) {
++      (lhdcv5dec_init_decoder == NULL) ||
++      (lhdcv5dec_deinit_decoder == NULL)) {
+     return false;
+   }
+ 
+-  lhdcdec_deinit_decoder();
++  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++
++  LOG_DEBUG( "%s: has_lhdc_handle(%d) handle_base (%p) handle(%p)", __func__,
++      a2dp_lhdcv5_decoder_cb.has_lhdc_handle,
++      &(a2dp_lhdcv5_decoder_cb.lhdc_handle),
++      a2dp_lhdcv5_decoder_cb.lhdc_handle);
++
++  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
++    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
++    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++      LOG_ERROR( "%s: fail to deinit decoder %d", __func__, api_ret);
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++      return false;
++    }
++    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
++    a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
++    LOG_DEBUG( "%s: handle cleaned", __func__);
++  }
+ 
+   lhdcdec_config.version = a2dp_lhdcv5_decoder_cb.version;
+   lhdcdec_config.sample_rate = a2dp_lhdcv5_decoder_cb.sample_rate;
+   lhdcdec_config.bits_depth = a2dp_lhdcv5_decoder_cb.bits_per_sample;
+-
+-  fn_ret = lhdcdec_init_decoder(&lhdcdec_config);
+-
+-  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+-    LOG_ERROR( "%s: LHDCV5 decoder init fail %d", __func__, fn_ret);
+-    return false;
++  lhdcdec_config.bit_rate = 400000;  //TODO
++
++  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle == false &&
++      a2dp_lhdcv5_decoder_cb.lhdc_handle == NULL) {
++    LOG_DEBUG( "%s: to init decoder...", __func__);
++    api_ret = lhdcv5dec_init_decoder(&(a2dp_lhdcv5_decoder_cb.lhdc_handle), &lhdcdec_config);
++    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++      LOG_ERROR( "%s: falied to init decoder %d", __func__, api_ret);
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
++      return false;
++    }
++    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = true;
+   }
+ 
+   a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+@@ -282,56 +349,45 @@ bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
+ #if defined(_V5DEC_REC_FILE_)
+   if (rawFile == NULL) {
+     rawFile = fopen(V5RAW_FILE_NAME,"wb");
+-    LOG_DEBUG( "%s: Create recode file = %p", __func__, rawFile);
++    LOG_DEBUG( "%s: create recode file = %p", __func__, rawFile);
+   }
+   if (pcmFile == NULL) {
+     pcmFile = fopen(V5PCM_FILE_NAME,"wb");
+-    LOG_DEBUG( "%s: Create recode file = %p", __func__, pcmFile);
++    LOG_DEBUG( "%s: create recode file = %p", __func__, pcmFile);
+   }
+ #endif
++
++  LOG_DEBUG( "%s: init LHDCV5 decoder success", __func__);
++
++  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+   return true;
+ }
+ 
+ 
+ void a2dp_vendor_lhdcv5_decoder_cleanup(void) {
+-  int  fn_ret;
++  int32_t api_ret;
+ 
+-  if (lhdc_decoder_lib_handle == NULL) {
+-    return;
+-  }
++  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+ 
+-  if (lhdcdec_deinit_decoder != NULL) {
+-    fn_ret = lhdcdec_deinit_decoder();
+-    if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+-      LOG_ERROR( "%s: LHDCV5 decoder deinit fail %d", __func__, fn_ret);
++  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
++    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
++    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++      LOG_ERROR( "%s: fail to deinit LHDCV5 decoder %d", __func__, api_ret);
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+       return;
+     }
+-  } else {
+-    LOG_ERROR( "%s: Cannot deinit LHDCV5 decoder", __func__);
+-    return;
+   }
+ 
+-  dlclose(lhdc_decoder_lib_handle);
+-  lhdc_decoder_lib_handle = NULL;
++  a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
++  a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+ 
+-#if defined(_V5DEC_REC_FILE_)
+-  if (rawFile != NULL) {
+-    fclose(rawFile);
+-    rawFile = NULL;
+-    remove(V5RAW_FILE_NAME);
+-  }
+-  if (pcmFile != NULL) {
+-    fclose(pcmFile);
+-    pcmFile = NULL;
+-    remove(V5PCM_FILE_NAME);
+-  }
+-#endif
+-  LOG_DEBUG( "%s:  LHDCV5 decoder deinited", __func__);
++  LOG_DEBUG( "%s: deinit LHDCV5 decoder success", __func__);
++  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+ }
+ 
+ 
+ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+-  int fn_ret;
++  int32_t api_ret;
+   uint8_t *data;
+   size_t data_size;
+   uint32_t out_used = 0;
+@@ -341,27 +397,40 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+   uint32_t packet_bytes;
+   uint32_t i;
+ 
++  LOG_DEBUG( "%s: enter", __func__);
++
++
++  if ((lhdc_decoder_lib_handle == NULL) ||
++      (lhdcv5dec_decode == NULL)) {
++    LOG_ERROR( "%s: lib not loaded!", __func__);
++    return false;
++  }
++
++  // check handle
++  if (!a2dp_lhdcv5_decoder_cb.has_lhdc_handle || !a2dp_lhdcv5_decoder_cb.lhdc_handle) {
++    LOG_ERROR( "%s: handle not existed!", __func__);
++    return false;
++  }
++
+   if (p_buf == NULL) {
+     return false;
+   }
+ 
++  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++
+   data = p_buf->data + p_buf->offset;
+   data_size = p_buf->len;
+ 
+-  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
+-  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
+-    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+-  }
+-
+   if (data_size == 0) {
+     LOG_ERROR( "%s: Empty packet", __func__);
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+     return false;
+   }
+ 
+-  if ((lhdc_decoder_lib_handle == NULL) ||
+-      (lhdcdec_decode == NULL)) {
+-    LOG_ERROR( "%s: Invalid handle!", __func__);
+-    return false;
++
++  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
++  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
++    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+   }
+ 
+ #if defined(_V5DEC_REC_FILE_)
+@@ -371,8 +440,7 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+   }
+ #endif
+ 
+-  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES)
+-  {
++  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES) {
+     // the data queued is useless
+     // discard them
+     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+@@ -381,26 +449,24 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+     {
+       // input data is too big (more than buffer size)!!
+       // just ingore it, and do nothing
++      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+       return true;
+     }
+   }
+ 
+   memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+-      data,
+-      data_size);
++      data, data_size);
+   a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+ 
+   packet_bytes = 0;
+-  fn_ret = lhdcdec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
++  api_ret = lhdcv5dec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+       a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+       &packet_bytes);
+-
+-  if (fn_ret == LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH) {
+-    return true;
+-  } else if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+-    LOG_ERROR( "%s: fail to check frame data!", __func__);
++  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++    LOG_ERROR( "%s: fail to check frame data! %d", __func__, api_ret);
+     // clear the data in the input buffer
+     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+     return false;
+   }
+ 
+@@ -413,15 +479,16 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+         __func__, packet_bytes, a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes);
+ 
+     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+-    memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
++    memcpy(&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+         data,
+         data_size);
+     a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+     return true;
+   }
+ 
+   out_used = sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]);
+-  fn_ret = lhdcdec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
++  api_ret = lhdcv5dec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+       a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+       a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+       &out_used,
+@@ -431,8 +498,9 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+   // clear the data in the input buffer
+   a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+ 
+-  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+-    LOG_ERROR( "%s: fail to decode lhdc stream!", __func__);
++  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
++    LOG_ERROR( "%s: fail to decode lhdc stream! %d", __func__, api_ret);
++    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+     return false;
+   }
+ 
+@@ -460,37 +528,41 @@ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+   }
+ 
+ #if defined(_V5DEC_REC_FILE_)
+-  if (pcmFile != NULL && out_used > 0 && out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
++  if (pcmFile != NULL && out_used > 0 &&
++      out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
+     int write_bytes;
+-    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx], sizeof(uint8_t), out_used, pcmFile);
++    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
++        sizeof(uint8_t), out_used, pcmFile);
+   }
+ #endif
+ 
+   a2dp_lhdcv5_decoder_cb.decode_callback(
+       reinterpret_cast<uint8_t*>(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+ 
++  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+   return true;
+ }
+ 
+ void a2dp_vendor_lhdcv5_decoder_start(void) {
+-  LOG_INFO("%s", __func__);
++  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  LOG_DEBUG("%s", __func__);
+   // do nothing
++
++  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+ }
+ 
+ void a2dp_vendor_lhdcv5_decoder_suspend(void) {
+-  LOG_INFO("%s", __func__);
++  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  LOG_DEBUG("%s", __func__);
+   // do nothing
+ }
+ 
+ void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info) {
+-  //int32_t sample_rate;
+-  //int32_t bits_per_sample;
+-  //int32_t channel_mode;
+-
+   if (p_codec_info == NULL) {
+-    LOG_ERROR("%s: p_codec_info is NULL", __func__);
++    LOG_DEBUG("%s: p_codec_info is NULL", __func__);
+     return;
+   }
+-
+-  LOG_ERROR("JIMM %s: enter", __func__);
++  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
++  LOG_DEBUG("%s", __func__);
++  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+ }
+diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
+index bcb4d8845..c21a825f6 100755
+--- a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
++++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
+@@ -848,6 +848,14 @@ void a2dp_vendor_lhdcv5_feeding_reset(void) {
+   a2dp_lhdc_encoder_cb.bytes_read = 0;
+   a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+ 
++  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
++  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
++    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
++      LOG_DEBUG("%s: reset ABR!", __func__);
++      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_QUALITY_RESET_AUTO);
++    }
++  }
++
+   LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
+       a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+ }
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdc_constants.h b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
+index e607b2742..69e3c3bad 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
+@@ -239,4 +239,55 @@ typedef enum {
+   marco_ret;   \
+ })
+ 
++//
++// Savitech - LHDC aDSP configuration
++//
++// Lhdcv5Version: 1 << (below value-1)
++#define A2DP_OFFLOAD_LHDCV2_VER_1                   0x01
++#define A2DP_OFFLOAD_LHDCV3_V3_ONLY                 0x02
++#define A2DP_OFFLOAD_LHDCV3_V4_ONLY                 0x03
++#define A2DP_OFFLOAD_LHDCV3_LLAC                    0x04
++#define A2DP_OFFLOAD_LHDCV5_VER_1                   0x01
++
++// Lhdcv5QualityIndex
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW0            0x01
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW1            0x02
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW2            0x04
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW3            0x08
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW4            0x10
++#define A2DP_OFFLOAD_LHDC_QUALITY_LOW             0x20
++#define A2DP_OFFLOAD_LHDC_QUALITY_MID             0x40
++#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH            0x80
++#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH1           0x100
++#define A2DP_OFFLOAD_LHDC_QUALITY_ABR             0x8000
++
++// Lhdcv5FrameDuration
++#define A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US   0x01
++
++// Lhdcv5DataInterval
++#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS      0x01
++#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS      0x02
++
++// Lhdcv5Specific
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR     0x01
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS    0x02
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META   0x04
++
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON   0x01
++#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT  0x80
++
++// Lhdcv5Parameters
++#define A2DP_OFFLOAD_LHDC_CFG_VER                   6
++#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_L             7
++#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_H             8
++#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L          9
++#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H          10
++#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L          11
++#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H          12
++#define A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR              13
++#define A2DP_OFFLOAD_LHDC_CFG_INTERVAL              14
++#define A2DP_OFFLOAD_LHDC_CFG_SPEC1                 15
++#define A2DP_OFFLOAD_LHDC_CFG_SPEC2                 16
++#define A2DP_OFFLOAD_LHDC_CFG_META                  17
++
+ #endif  // A2DP_VENDOR_LHDC_CONSTANTS_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv1.h b/system_bt/stack/include/a2dp_vendor_lhdcv1.h
+deleted file mode 100755
+index 68dc6eb23..000000000
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv1.h
++++ /dev/null
+@@ -1,171 +0,0 @@
+-/*
+- * Copyright (C) 2016 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-//
+-// A2DP Codec API for LHDC
+-//
+-
+-#ifndef A2DP_VENDOR_LHDCV1_H
+-#define A2DP_VENDOR_LHDCV1_H
+-
+-#include "a2dp_codec_api.h"
+-#include "a2dp_vendor_lhdc_constants.h"
+-#include "a2dp_vendor_lhdcv1_constants.h"
+-#include "avdt_api.h"
+-
+-class A2dpCodecConfigLhdcV1 : public A2dpCodecConfig {
+- public:
+-  A2dpCodecConfigLhdcV1(btav_a2dp_codec_priority_t codec_priority);
+-  virtual ~A2dpCodecConfigLhdcV1();
+-
+-  bool init() override;
+-  uint64_t encoderIntervalMs() const override;
+-  int getEffectiveMtu() const override;
+-  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+-                      uint8_t* p_result_codec_config) override;
+-  bool setPeerCodecCapabilities(
+-      const uint8_t* p_peer_codec_capabilities) override;
+-
+- private:
+-  bool useRtpHeaderMarkerBit() const override;
+-  bool updateEncoderUserConfig(
+-      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+-      bool* p_restart_input, bool* p_restart_output,
+-      bool* p_config_updated) override;
+-  void debug_codec_dump(int fd) override;
+-};
+-
+-// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+-// codec.
+-// NOTE: only codecs that are implemented are considered valid.
+-// Returns true if |p_codec_info| contains information about a valid LHDC
+-// codec, otherwise false.
+-bool A2DP_IsVendorSourceCodecValidLhdcV1(const uint8_t* p_codec_info);
+-
+-// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+-// codec.
+-// NOTE: only codecs that are implemented are considered valid.
+-// Returns true if |p_codec_info| contains information about a valid LHDC
+-// codec, otherwise false.
+-bool A2DP_IsVendorPeerSinkCodecValidLhdcV1(const uint8_t* p_codec_info);
+-
+-// Checks whether the A2DP data packets should contain RTP header.
+-// |content_protection_enabled| is true if Content Protection is
+-// enabled. |p_codec_info| contains information about the codec capabilities.
+-// Returns true if the A2DP data packets should contain RTP header, otherwise
+-// false.
+-bool A2DP_VendorUsesRtpHeaderLhdcV1(bool content_protection_enabled,
+-                                  const uint8_t* p_codec_info);
+-
+-// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+-const char* A2DP_VendorCodecNameLhdcV1(const uint8_t* p_codec_info);
+-
+-// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+-// have the same type.
+-// Returns true if the two codecs have the same type, otherwise false.
+-bool A2DP_VendorCodecTypeEqualsLhdcV1(const uint8_t* p_codec_info_a,
+-                                    const uint8_t* p_codec_info_b);
+-
+-// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+-// are exactly the same.
+-// Returns true if the two codecs are exactly the same, otherwise false.
+-// If the codec type is not LHDC, the return value is false.
+-bool A2DP_VendorCodecEqualsLhdcV1(const uint8_t* p_codec_info_a,
+-                                const uint8_t* p_codec_info_b);
+-
+-// Gets the track sample rate value for the A2DP LHDC codec.
+-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+-// Returns the track sample rate on success, or -1 if |p_codec_info|
+-// contains invalid codec information.
+-int A2DP_VendorGetTrackSampleRateLhdcV1(const uint8_t* p_codec_info);
+-
+-// Gets the bits per audio sample for the A2DP LHDC codec.
+-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+-// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+-// contains invalid codec information.
+-int A2DP_VendorGetTrackBitsPerSampleLhdcV1(const uint8_t* p_codec_info);
+-
+-// Gets the channel count for the A2DP LHDC codec.
+-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+-// Returns the channel count on success, or -1 if |p_codec_info|
+-// contains invalid codec information.
+-int A2DP_VendorGetTrackChannelCountLhdcV1(const uint8_t* p_codec_info);
+-
+-// Gets the channel mode code for the A2DP LHDC codec.
+-// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+-// Returns the channel mode code on success, or -1 if |p_codec_info|
+-// contains invalid codec information.
+-int A2DP_VendorGetChannelModeCodeLhdcV1(const uint8_t* p_codec_info);
+-
+-// Gets the A2DP LHDC audio data timestamp from an audio packet.
+-// |p_codec_info| contains the codec information.
+-// |p_data| contains the audio data.
+-// The timestamp is stored in |p_timestamp|.
+-// Returns true on success, otherwise false.
+-bool A2DP_VendorGetPacketTimestampLhdcV1(const uint8_t* p_codec_info,
+-                                       const uint8_t* p_data,
+-                                       uint32_t* p_timestamp);
+-
+-// Builds A2DP LHDC codec header for audio data.
+-// |p_codec_info| contains the codec information.
+-// |p_buf| contains the audio data.
+-// |frames_per_packet| is the number of frames in this packet.
+-// Returns true on success, otherwise false.
+-bool A2DP_VendorBuildCodecHeaderLhdcV1(const uint8_t* p_codec_info, BT_HDR* p_buf,
+-                                     uint16_t frames_per_packet);
+-
+-
+-// Decodes A2DP LHDC codec info into a human readable string.
+-// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+-// Returns a string describing the codec information.
+-std::string A2DP_VendorCodecInfoStringLhdcV1(const uint8_t* p_codec_info);
+-
+-// New feature to check codec info is supported Channel Separation.
+-bool A2DP_VendorGetChannelSeparation(const uint8_t* p_codec_info);
+-
+-// Decodes and displays LHDC codec info (for debugging).
+-// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+-void A2DP_VendorDumpCodecInfoLhdcV1(const uint8_t* p_codec_info);
+-
+-// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+-// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+-// |p_codec_info| contains the codec information.
+-// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+-// supported, otherwise NULL.
+-const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV1(
+-    const uint8_t* p_codec_info);
+-
+-// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+-// specification.
+-// |p_codec_info| contains the codec information to adjust.
+-// Returns true if |p_codec_info| is valid and supported, otherwise false.
+-bool A2DP_VendorAdjustCodecLhdcV1(uint8_t* p_codec_info);
+-
+-// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+-// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+-// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+-btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV1(
+-    const uint8_t* p_codec_info);
+-
+-// Gets the A2DP LHDC Source codec name.
+-const char* A2DP_VendorCodecIndexStrLhdcV1(void);
+-
+-// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+-// configuration entry pointed by |p_cfg|.
+-bool A2DP_VendorInitCodecConfigLhdcV1(AvdtpSepConfig* p_cfg);
+-
+-#endif  // A2DP_VENDOR_LHDCV1_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv1_constants.h b/system_bt/stack/include/a2dp_vendor_lhdcv1_constants.h
+deleted file mode 100755
+index d9c98493a..000000000
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv1_constants.h
++++ /dev/null
+@@ -1,87 +0,0 @@
+-/*
+- * Copyright (C) 2016 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-//
+-// A2DP constants for LHDC codec
+-//
+-
+-#ifndef A2DP_VENDOR_LHDCV1_CONSTANTS_H
+-#define A2DP_VENDOR_LHDCV1_CONSTANTS_H
+-
+-#define A2DP_LHDCV1_VENDOR_CMD_MASK    0xC000
+-
+-// LHDC Quality Mode Index
+-//LHDC not supported auto bit rate now.
+-//#define A2DP_LHDCV1_QUALITY_MAGIC_NUM 0x8000
+-//#define A2DP_LHDCV1_QUALITY_ABR    8   // ABR mode, range: 990,660,492,396,330(kbps)
+-//#define A2DP_LHDCV1_QUALITY_HIGH   7   // Equal to LHDCBT_EQMID_HQ 900kbps
+-//#define A2DP_LHDCV1_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+-//#define A2DP_LHDCV1_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+-//#define A2DP_LHDCV1_QUALITY_LOW4   4   //
+-//#define A2DP_LHDCV1_QUALITY_LOW3   3
+-//#define A2DP_LHDCV1_QUALITY_LOW2   2
+-//#define A2DP_LHDCV1_QUALITY_LOW1   1
+-//#define A2DP_LHDCV1_QUALITY_LOW0   0
+-
+-#define A2DP_LHDCV1_LATENCY_MAGIC_NUM 0xC000
+-//#define A2DP_LHDCV1_LATENCY_LOW	0	// 50-100 ms
+-//#define A2DP_LHDCV1_LATENCY_MID	1	// default value, 150-200 ms
+-//#define A2DP_LHDCV1_LATENCY_HIGH	2	// 300-500 ms
+-
+-// Length of the LHDC Media Payload header
+-//#define A2DP_LHDCV1_MPL_HDR_LEN 2
+-
+-// LHDC Media Payload Header
+-//#define A2DP_LHDCV1_HDR_F_MSK 0x80
+-//#define A2DP_LHDCV1_HDR_S_MSK 0x40
+-//#define A2DP_LHDCV1_HDR_L_MSK 0x20
+-//#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
+-//#define A2DP_LHDCV1_HDR_NUM_SHIFT 2
+-//#define A2DP_LHDCV1_HDR_NUM_MAX 7
+-
+-//#define A2DP_LHDCV1_HDR_LATENCY_LOW   0x00
+-//#define A2DP_LHDCV1_HDR_LATENCY_MID   0x01
+-//#define A2DP_LHDCV1_HDR_LATENCY_HIGH  0x02
+-//#define A2DP_LHDCV1_HDR_LATENCY_MSK   0x03
+-
+-// LHDC codec specific settings
+-//#define A2DP_LHDCV1_CODEC_LEN 9
+-// [Octet 0-3] Vendor ID
+-//#define A2DP_LHDCV1_VENDOR_ID 0x0000053a
+-// [Octet 4-5] Vendor Specific Codec ID
+-// [Octet 6], [Bits 0-3] Sampling Frequency
+-//#define A2DP_LHDCV1_SAMPLING_FREQ_MASK 0x0F
+-//#define A2DP_LHDCV1_SAMPLING_FREQ_44100 0x08
+-//#define A2DP_LHDCV1_SAMPLING_FREQ_48000 0x04
+-//#define A2DP_LHDCV1_SAMPLING_FREQ_88200 0x02
+-//#define A2DP_LHDCV1_SAMPLING_FREQ_96000 0x01
+-
+-// [Octet 6], [Bits 3-4] Bit dipth
+-#define A2DP_LHDCV1_BIT_FMT_MASK 	 0x30
+-//#define A2DP_LHDCV1_BIT_FMT_24	 0x10
+-//#define A2DP_LHDCV1_BIT_FMT_16	 0x20
+-
+-#define A2DP_LHDCV1_CHANNEL_SEPARATION  0x40
+-
+-
+-
+-//#define A2DP_LHDCV1_CHANNEL_MODE_MASK 0x07
+-//#define A2DP_LHDCV1_CHANNEL_MODE_MONO 0x04
+-//#define A2DP_LHDCV1_CHANNEL_MODE_DUAL 0x02
+-//#define A2DP_LHDCV1_CHANNEL_MODE_STEREO 0x01
+-
+-
+-#endif  // A2DP_VENDOR_LHDCV1_CONSTANTS_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv1_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv1_encoder.h
+deleted file mode 100755
+index 86da05b67..000000000
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv1_encoder.h
++++ /dev/null
+@@ -1,63 +0,0 @@
+-/*
+- * Copyright (C) 2016 The Android Open Source Project
+- *
+- * Licensed under the Apache License, Version 2.0 (the "License");
+- * you may not use this file except in compliance with the License.
+- * You may obtain a copy of the License at
+- *
+- *      http://www.apache.org/licenses/LICENSE-2.0
+- *
+- * Unless required by applicable law or agreed to in writing, software
+- * distributed under the License is distributed on an "AS IS" BASIS,
+- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+- * See the License for the specific language governing permissions and
+- * limitations under the License.
+- */
+-
+-//
+-// Interface to the A2DP LHDC Encoder
+-//
+-
+-#ifndef A2DP_VENDOR_LHDCV1_ENCODER_H
+-#define A2DP_VENDOR_LHDCV1_ENCODER_H
+-
+-#include "a2dp_codec_api.h"
+-
+-// Loads the A2DP LHDC encoder.
+-// Return true on success, otherwise false.
+-bool A2DP_VendorLoadEncoderLhdcV1(void);
+-
+-// Unloads the A2DP LHDC encoder.
+-void A2DP_VendorUnloadEncoderLhdcV1(void);
+-
+-// Initialize the A2DP LHDC encoder.
+-// |p_peer_params| contains the A2DP peer information
+-// The current A2DP codec config is in |a2dp_codec_config|.
+-// |read_callback| is the callback for reading the input audio data.
+-// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+-void a2dp_vendor_lhdcV1_encoder_init(
+-    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+-    A2dpCodecConfig* a2dp_codec_config,
+-    a2dp_source_read_callback_t read_callback,
+-    a2dp_source_enqueue_callback_t enqueue_callback);
+-
+-// Cleanup the A2DP LHDC encoder.
+-void a2dp_vendor_lhdcV1_encoder_cleanup(void);
+-
+-// Reset the feeding for the A2DP LHDC encoder.
+-void a2dp_vendor_lhdcV1_feeding_reset(void);
+-
+-// Flush the feeding for the A2DP LHDC encoder.
+-void a2dp_vendor_lhdcV1_feeding_flush(void);
+-
+-// Get the A2DP LHDC encoder interval (in milliseconds).
+-uint64_t a2dp_vendor_lhdcV1_get_encoder_interval_ms(void);
+-
+-// Prepare and send A2DP LHDC encoded frames.
+-// |timestamp_us| is the current timestamp (in microseconds).
+-void a2dp_vendor_lhdcV1_send_frames(uint64_t timestamp_us);
+-
+-// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+-void a2dp_vendor_lhdcV1_set_transmit_queue_length(size_t transmit_queue_length);
+-
+-#endif  // A2DP_VENDOR_LHDCV1_ENCODER_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv2.h b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
+index 8ea7af782..5576d12fb 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv2.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
+@@ -172,6 +172,12 @@ const char* A2DP_VendorCodecIndexStrLhdcV2(void);
+ 
+ // Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+ // configuration entry pointed by |p_cfg|.
++
+ bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg);
++// Gets the track bitrate value for the A2DP LHDCV2 codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track bit rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info);
+ 
+ #endif  // A2DP_VENDOR_LHDCV2_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3.h b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
+index ce464fbc9..dd8afaf17 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv3.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
+@@ -319,4 +319,10 @@ bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg);
+ 
+ bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t* capVector);
+ 
++// Gets the track bitrate value for the A2DP LHDCV3 codec.
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track bit rate on success, or -1 if |p_codec_info|
++// contains invalid codec information.
++int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info);
++
+ #endif  // A2DP_VENDOR_LHDCV3_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
+index 79280b26a..697ca3b69 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
+@@ -184,8 +184,4 @@ const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void);
+ // configuration entry pointed by |p_cfg|.
+ bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg);
+ 
+-// Get SBC bitrate
+-// Returns |uint32_t| bitrate value in bits per second
+-uint32_t A2DP_VendorGetBitRateLhdcV3Sink(const uint8_t* p_codec_info);
+-
+ #endif  // A2DP_VENDOR_LHDCV3_DEC_H
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5.h b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
+index 75aff4b4b..f579b28cd 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv5.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
+@@ -284,8 +284,8 @@ const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void);
+ bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg);
+ 
+ // Gets the track bitrate value for the A2DP LHDCV5 codec.
+-// |p_codec_info| is a pointer to the LDAC codec_info to decode.
+-// Returns the track sample rate on success, or -1 if |p_codec_info|
++// |p_codec_info| is a pointer to the LHDC codec_info to decode.
++// Returns the track bit rate on success, or -1 if |p_codec_info|
+ // contains invalid codec information.
+ int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info);
+ 
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
+index e7f176c3c..b405d9225 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
+@@ -110,7 +110,7 @@
+ #define A2DP_LHDCV5_QUALITY_ABR    (0x09)  // Adaptive Bit Rate
+ #define A2DP_LHDCV5_QUALITY_HIGH1  (0x08)  // 1000kbps
+ #define A2DP_LHDCV5_QUALITY_HIGH   (0x07)  // 900kbps
+-#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 600kbps
++#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 500kbps
+ #define A2DP_LHDCV5_QUALITY_LOW    (0x05)  // 400kbps
+ #define A2DP_LHDCV5_QUALITY_LOW4   (0x04)  // 320kbps
+ #define A2DP_LHDCV5_QUALITY_LOW3   (0x03)  // 256kbps
+diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
+index 0f2bf36ce..ba5be9825 100755
+--- a/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
++++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
+@@ -1,5 +1,5 @@
+ /*
+- * Copyright (C) 2016 The Android Open Source Project
++ * Copyright (C) 2022 The Android Open Source Project
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+@@ -15,7 +15,7 @@
+  */
+ 
+ //
+-// Interface to the A2DP LHDC V3 Decoder
++// Interface to the A2DP LHDC V5 Decoder
+ //
+ 
+ #ifndef A2DP_VENDOR_LHDCV5_DECODER_H
+@@ -30,30 +30,29 @@
+ // Return true on success, otherwise false.
+ bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info);
+ 
+-// Loads the A2DP LHDC V3 decoder.
++// Loads the A2DP LHDC V5 decoder.
+ // Return true on success, otherwise false.
+ bool A2DP_VendorLoadDecoderLhdcV5(void);
+ 
+-// Unloads the A2DP LHDC V3 decoder.
++// Unloads the A2DP LHDC V5 decoder.
+ void A2DP_VendorUnloadDecoderLhdcV5(void);
+ 
+-// Initialize the A2DP LHDC V3 decoder.
++// Initialize the A2DP LHDC V5 decoder.
+ bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback);
+ 
+-// Cleanup the A2DP LHDC V3 decoder.
++// Cleanup the A2DP LHDC V5 decoder.
+ void a2dp_vendor_lhdcv5_decoder_cleanup(void);
+ 
+-// Decodes |p_buf|. Calls |decode_callback| passed into |a2dp_lhdcv3_decoder_init|
+-// if decoded frames are available.
++// Decode LHDC V5 packet to PCM
+ bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf);
+ 
+-// Start the A2DP LHDCV3 decoder.
++// Start the A2DP LHDC V5 decoder.
+ void a2dp_vendor_lhdcv5_decoder_start(void);
+ 
+-// Suspend the A2DP LHDCV3 decoder.
++// Suspend the A2DP LHDC V5 decoder.
+ void a2dp_vendor_lhdcv5_decoder_suspend(void);
+ 
+-// A2DP LHDCV3 decoder configuration.
++// A2DP LHDC V5 decoder configuration.
+ void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info);
+ 
+ #endif  // A2DP_VENDOR_LHDCV5_DECODER_H
+diff --git a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
+index 5b3848abd..8f017bad1 100755
+--- a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
++++ b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
+@@ -28,11 +28,20 @@ static const std::vector<const btav_a2dp_codec_index_t> CODEC_INDEX_ENUM_VALS =
+      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
+      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
+      BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
++     // Savitech Patch - START
++     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
++     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
++     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
++     // Savitech Patch - END
+      BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
+      BTAV_A2DP_CODEC_INDEX_SINK_MIN,
+      BTAV_A2DP_CODEC_INDEX_SINK_SBC,
+      BTAV_A2DP_CODEC_INDEX_SINK_AAC,
+      BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
++     // Savitech Patch - START
++     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
++     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
++     // Savitech Patch - END
+      BTAV_A2DP_CODEC_INDEX_SINK_MAX,
+      BTAV_A2DP_CODEC_INDEX_MIN,
+      BTAV_A2DP_CODEC_INDEX_MAX};
+diff --git a/system_bt/stack/test/stack_a2dp_test.cc b/system_bt/stack/test/stack_a2dp_test.cc
+index 2c1e38739..2cb351a30 100755
+--- a/system_bt/stack/test/stack_a2dp_test.cc
++++ b/system_bt/stack/test/stack_a2dp_test.cc
+@@ -209,6 +209,14 @@ static const char* APTX_ENCODER_LIB_NAME = "libaptX_encoder.so";
+ static const char* APTX_HD_ENCODER_LIB_NAME = "libaptXHD_encoder.so";
+ static const char* LDAC_ENCODER_LIB_NAME = "libldacBT_enc.so";
+ static const char* LDAC_DECODER_LIB_NAME = "libldacBT_dec.so";
++// Savitech Patch - START
++static const char* LHDCV2_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
++static const char* LHDCV3_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
++static const char* LHDCV5_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
++static const char* LHDCV3_DECODER_LIB_NAME = "liblhdcBT_dec.so";
++static const char* LHDCV5_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
++// Savitech Patch - END
++
+ 
+ static bool has_shared_library(const char* name) {
+   void* lib_handle = dlopen(name, RTLD_NOW);
+@@ -253,6 +261,23 @@ class StackA2dpTest : public ::testing::Test {
+           // shared library installed.
+           supported = has_shared_library(LDAC_ENCODER_LIB_NAME);
+           break;
++          // Savitech Patch - START  Offload
++        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV3_ENCODER_LIB_NAME);
++          break;
++        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV2_ENCODER_LIB_NAME);
++          break;
++        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV5_ENCODER_LIB_NAME);
++          break;
++          // Savitech Patch - END
+         case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
+           supported = true;
+           break;
+@@ -264,6 +289,18 @@ class StackA2dpTest : public ::testing::Test {
+           // shared library installed.
+           supported = has_shared_library(LDAC_DECODER_LIB_NAME);
+           break;
++        // Savitech Patch - START  Offload
++        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV3_DECODER_LIB_NAME);
++          break;
++        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
++          // Codec LDAC is supported only if the device has the corresponding
++          // shared library installed.
++          supported = has_shared_library(LHDCV5_DECODER_LIB_NAME);
++          break;
++        // Savitech Patch - END
+         case BTAV_A2DP_CODEC_INDEX_MAX:
+           // Needed to avoid using "default:" case so we can capture when
+           // a new codec is added, and it can be included here.
diff --git a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
index 963642705..fba3d580f 100644
--- a/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
+++ b/packages_apps_Settings/res/layout/bluetooth_audio_codec_dialog.xml
@@ -54,6 +54,18 @@
             <include
                 android:id="@+id/bluetooth_audio_codec_ldac"
                 layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_audio_codec_lhdcv2"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_audio_codec_lhdcv3"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_audio_codec_lhdcv5"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
         </RadioGroup>
 
         <include
diff --git a/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml
index 03bbe48bd..f2cd2b729 100644
--- a/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml
+++ b/packages_apps_Settings/res/layout/bluetooth_audio_sample_rate_dialog.xml
@@ -50,6 +50,14 @@
             <include
                 android:id="@+id/bluetooth_audio_sample_rate_960"
                 layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_audio_sample_rate_1764"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_audio_sample_rate_1920"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
         </RadioGroup>
 
         <include
diff --git a/packages_apps_Settings/res/layout/bluetooth_lhdc_audio_quality_dialog.xml b/packages_apps_Settings/res/layout/bluetooth_lhdc_audio_quality_dialog.xml
new file mode 100644
index 000000000..0ff2f3fe7
--- /dev/null
+++ b/packages_apps_Settings/res/layout/bluetooth_lhdc_audio_quality_dialog.xml
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (C) 2019 The Android Open Source Project
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+
+<ScrollView
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    android:layout_width="match_parent"
+    android:layout_height="wrap_content">
+
+    <LinearLayout
+        android:layout_width="match_parent"
+        android:layout_height="wrap_content"
+        android:orientation="vertical"
+        android:padding="8dp">
+
+        <RadioGroup
+            android:id="@+id/bluetooth_lhdc_audio_quality_radio_group"
+            android:layout_width="match_parent"
+            android:layout_height="wrap_content"
+            android:layout_marginStart="@dimen/developer_option_dialog_margin_start">
+
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_low0"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_low1"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_low2"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_low3"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+                
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_low4"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+                
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_low"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+                
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_mid"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+                
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_high"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+                
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_high1"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+
+            <include
+                android:id="@+id/bluetooth_lhdc_audio_quality_best_effort"
+                layout="@layout/preference_widget_dialog_radiobutton"/>
+        </RadioGroup>
+
+        <include
+            android:id="@+id/bluetooth_audio_codec_help_info"
+            layout="@layout/preference_widget_dialog_summary"/>
+
+    </LinearLayout>
+
+</ScrollView>
+
diff --git a/packages_apps_Settings/res/xml/development_settings.xml b/packages_apps_Settings/res/xml/development_settings.xml
index 621351681..79d488363 100644
--- a/packages_apps_Settings/res/xml/development_settings.xml
+++ b/packages_apps_Settings/res/xml/development_settings.xml
@@ -375,6 +375,35 @@
             android:positiveButtonText=""
             android:negativeButtonText="@string/dlg_ok"/>
 
+        <com.android.settings.development.bluetooth.BluetoothLHDCQualityDialogPreference
+            android:key="bluetooth_select_a2dp_lhdc_playback_quality"
+            android:title="@string/bluetooth_select_a2dp_codec_lhdc_playback_quality"
+            android:dialogTitle="@string/bluetooth_select_a2dp_codec_lhdc_playback_quality_dialog_title"
+            android:dialogLayout="@layout/bluetooth_lhdc_audio_quality_dialog"
+            android:positiveButtonText=""
+            android:negativeButtonText="@string/dlg_ok"/>
+
+        <ListPreference
+            android:key="bluetooth_select_a2dp_codec_lhdc_latency"
+            android:title="@string/bluetooth_select_a2dp_codec_lhdc_latency"
+            android:dialogTitle="@string/bluetooth_select_a2dp_codec_lhdc_latency_dialog_title"
+            android:entries="@array/bluetooth_a2dp_codec_lhdc_latency_titles"
+            android:entryValues="@array/bluetooth_a2dp_codec_lhdc_latency_values" />
+
+        <ListPreference
+            android:key="bluetooth_enable_a2dp_codec_lhdc_ar_effect"
+            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect"
+            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_ar_effect_dialog_title"
+            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_titles"
+            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_ar_effect_values" />
+            
+        <ListPreference
+            android:key="bluetooth_enable_a2dp_codec_lhdc_lossless"
+            android:title="@string/bluetooth_enable_a2dp_codec_lhdc_lossless"
+            android:dialogTitle="@string/bluetooth_enable_a2dp_codec_lhdc_lossless_dialog_title"
+            android:entries="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_titles"
+            android:entryValues="@array/bluetooth_enable_a2dp_codec_lhdc_lossless_values" />
+
         <ListPreference
             android:key="bluetooth_max_connected_audio_devices"
             android:title="@string/bluetooth_max_connected_audio_devices_string"
diff --git a/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
index 88dda2961..e1fbab4ab 100644
--- a/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/AbstractBluetoothA2dpPreferenceController.java
@@ -106,6 +106,10 @@ public abstract class AbstractBluetoothA2dpPreferenceController extends
 
     @Override
     public void updateState(Preference preference) {
+        if (mBluetoothA2dp == null) {
+            return;
+        }
+
         BluetoothDevice activeDevice = mBluetoothA2dp.getActiveDevice();
         if (activeDevice == null || getCodecConfig(activeDevice) == null || mPreference == null) {
             return;
@@ -191,6 +195,47 @@ public abstract class AbstractBluetoothA2dpPreferenceController extends
         mBluetoothA2dp.setCodecConfigPreference(bluetoothDevice, config);
     }
 
+    /************************************************
+     * Savitech LHDC EXT API -- START
+     ***********************************************/
+    @VisibleForTesting
+    int getLhdcCodecExtendApiVer(BluetoothDevice device, byte[] exApiVer) {
+        return mBluetoothA2dp.getLhdcCodecExtendApiVer(device, exApiVer);
+    }
+
+    @VisibleForTesting
+    int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
+        return mBluetoothA2dp.setLhdcCodecExtendApiConfigAr(device, codecConfig);
+    }
+
+    @VisibleForTesting
+    int getLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
+        return mBluetoothA2dp.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+    }
+
+    @VisibleForTesting
+    int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
+        return mBluetoothA2dp.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
+    }
+
+    @VisibleForTesting
+    int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
+        return mBluetoothA2dp.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
+    }
+
+    @VisibleForTesting
+    int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device, byte[] codecConfig) {
+        return mBluetoothA2dp.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
+    }
+
+    @VisibleForTesting
+    void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device, byte[] codecData) {
+        mBluetoothA2dp.setLhdcCodecExtendApiDataGyro2D(device, codecData);
+    }
+    /************************************************
+     * Savitech LHDC EXT API -- END
+     ***********************************************/
+
     @VisibleForTesting
     BluetoothCodecConfig getCodecConfig(BluetoothDevice device) {
         if (mBluetoothA2dp != null) {
diff --git a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
index fbab1fd12..1af1465e4 100644
--- a/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
+++ b/packages_apps_Settings/src/com/android/settings/development/DevelopmentSettingsDashboardFragment.java
@@ -56,6 +56,7 @@ import com.android.settings.development.bluetooth.BluetoothChannelModeDialogPref
 import com.android.settings.development.bluetooth.BluetoothCodecDialogPreferenceController;
 import com.android.settings.development.bluetooth.BluetoothHDAudioPreferenceController;
 import com.android.settings.development.bluetooth.BluetoothQualityDialogPreferenceController;
+import com.android.settings.development.bluetooth.BluetoothLHDCQualityDialogPreferenceController;
 import com.android.settings.development.bluetooth.BluetoothSampleRateDialogPreferenceController;
 import com.android.settings.development.qstile.DevelopmentTiles;
 import com.android.settings.development.storage.SharedDataPreferenceController;
@@ -569,6 +570,16 @@ public class DevelopmentSettingsDashboardFragment extends RestrictedDashboardFra
                 bluetoothA2dpConfigStore));
         controllers.add(new BluetoothQualityDialogPreferenceController(context, lifecycle,
                 bluetoothA2dpConfigStore));
+        // Savitech LHDC -- START
+        controllers.add(new BluetoothLHDCQualityDialogPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioLatencyPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioArEffectPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        controllers.add(new BluetoothLHDCAudioLosslessPreferenceController(context, lifecycle,
+                bluetoothA2dpConfigStore));
+        // Savitech LHDC -- END
         controllers.add(new BluetoothChannelModeDialogPreferenceController(context, lifecycle,
                 bluetoothA2dpConfigStore));
         controllers.add(new BluetoothHDAudioPreferenceController(context, lifecycle,
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
index d66b8d8dc..2b305debb 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/AbstractBluetoothDialogPreferenceController.java
@@ -38,7 +38,11 @@ public abstract class AbstractBluetoothDialogPreferenceController extends
 
     private static final String TAG = "AbstractBtDlgCtr";
 
-    protected static final int[] CODEC_TYPES = {BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
+    protected static final int[] CODEC_TYPES = {
+            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
+            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
+            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
+            BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX_HD,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_APTX,
             BluetoothCodecConfig.SOURCE_CODEC_TYPE_AAC,
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
index 5cd8af28a..93b4f62bb 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothBitPerSampleDialogPreferenceController.java
@@ -61,8 +61,13 @@ public class BluetoothBitPerSampleDialogPreferenceController extends
             case 0:
                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
                 if (currentConfig != null) {
-                    bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
-                            currentConfig.getCodecType()));
+                /* Savitech patch: pick default by native decision, not always get the Highest one */
+                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                            bitsPerSampleValue = getHighestBitsPerSample(getSelectableByCodecType(
+                                currentConfig.getCodecType()));
+                    }
                 }
                 break;
             case 1:
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
index d156abde6..8603f6b5e 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothChannelModeDialogPreferenceController.java
@@ -61,8 +61,13 @@ public class BluetoothChannelModeDialogPreferenceController extends
             case 0:
                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
                 if (currentConfig != null) {
-                    channelModeValue = getHighestChannelMode(getSelectableByCodecType(
-                            currentConfig.getCodecType()));
+                    /* Savitech patch: pick default by native decision, not always get the Highest one */
+                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                            channelModeValue = getHighestChannelMode(getSelectableByCodecType(
+                                currentConfig.getCodecType()));
+                    }
                 }
                 break;
             case 1:
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
index 6a733f3fb..d9a2d8f83 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreference.java
@@ -61,6 +61,9 @@ public class BluetoothCodecDialogPreference extends BaseBluetoothDialogPreferenc
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_aptx_hd);
         mRadioButtonIds.add(R.id.bluetooth_audio_codec_ldac);
+        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv2);
+        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv3);
+        mRadioButtonIds.add(R.id.bluetooth_audio_codec_lhdcv5);
         String[] stringArray = context.getResources().getStringArray(
                 R.array.bluetooth_a2dp_codec_titles);
         for (int i = 0; i < stringArray.length; i++) {
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
index 6b243c600..a73a0e315 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothCodecDialogPreferenceController.java
@@ -117,6 +117,18 @@ public class BluetoothCodecDialogPreferenceController extends
                 codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC;
                 codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
                 break;
+            case 6:
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
+            case 7:
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
+            case 8:
+                codecTypeValue = BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5;
+                codecPriorityValue = BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST;
+                break;
             default:
                 break;
         }
@@ -128,9 +140,19 @@ public class BluetoothCodecDialogPreferenceController extends
         if (config == null) {
             Log.d(TAG, "Selectable config is null. Unable to reset");
         }
-        mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
-        mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
-        mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
+
+        /* Savitech LHDC patch: use default when codec switching */
+        if (codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
+            codecTypeValue == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+            mBluetoothA2dpConfigStore.setSampleRate(BluetoothCodecConfig.SAMPLE_RATE_NONE);
+            mBluetoothA2dpConfigStore.setBitsPerSample(BluetoothCodecConfig.BITS_PER_SAMPLE_NONE);
+            mBluetoothA2dpConfigStore.setChannelMode(BluetoothCodecConfig.CHANNEL_MODE_NONE);
+        } else {
+            mBluetoothA2dpConfigStore.setSampleRate(getHighestSampleRate(config));
+            mBluetoothA2dpConfigStore.setBitsPerSample(getHighestBitsPerSample(config));
+            mBluetoothA2dpConfigStore.setChannelMode(getHighestChannelMode(config));
+        }
     }
 
     @Override
@@ -174,6 +196,15 @@ public class BluetoothCodecDialogPreferenceController extends
             case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LDAC:
                 index = 5;
                 break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2:
+                index = 6;
+                break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3:
+                index = 7;
+                break;
+            case BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5:
+                index = 8;
+                break;
             default:
                 Log.e(TAG, "Unsupported config:" + config);
                 break;
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioArEffectPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioArEffectPreferenceController.java
new file mode 100644
index 000000000..a17f2ded4
--- /dev/null
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioArEffectPreferenceController.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import android.util.Log;
+
+/**
+ * Switch preference controller for LHDC AR Effect ON/OFF
+ */
+public class BluetoothLHDCAudioArEffectPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 0;
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_AR_EFFECT_KEY =
+            "bluetooth_enable_a2dp_codec_lhdc_ar_effect";
+
+    private static final int LHDC_FEATURE_MASK = 0xFF000000;
+    private static final int LHDC_FEATURE_TAG = 0x4C000000;
+    private static final int LHDC_AR_FEATURE = 0x02;
+
+    public BluetoothLHDCAudioArEffectPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_AR_EFFECT_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_ar_effect_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_ar_effect_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        
+        int codecSpecific3Value = 0; // default
+        codecSpecific3Value |= LHDC_FEATURE_TAG;
+        
+        if (index != 0) {
+            codecSpecific3Value |= LHDC_AR_FEATURE;
+        }else{
+	        codecSpecific3Value &= ~LHDC_AR_FEATURE;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int ret = 0;
+        int index = (int)config.getCodecSpecific3();
+        int tmp = index & LHDC_FEATURE_MASK;
+        if (tmp == LHDC_FEATURE_TAG) {
+            if ((index & LHDC_AR_FEATURE) != 0) {
+                ret = 1;
+            } else {
+                ret = 0;
+            }
+        } else {
+            ret = 0;
+        }
+        return ret;
+    }
+}
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLatencyPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLatencyPreferenceController.java
new file mode 100644
index 000000000..fd9278112
--- /dev/null
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLatencyPreferenceController.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+
+import android.util.Log;
+
+/**
+ * Switch preference controller for LHDC Low Latency Mode
+ */
+public class BluetoothLHDCAudioLatencyPreferenceController extends 
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final String KEY = "bluetooth_select_a2dp_codec_lhdc_latency";
+    private static final String TAG = "BtLhdcLowLatnecyCtr";
+    private static final int DEFAULT_TAG = 0xC000;
+    private static final int DEFAULT_INDEX = 0;
+
+    public BluetoothLHDCAudioLatencyPreferenceController(Context context, Lifecycle lifecycle,
+                                                BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_latency_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_latency_summaries);
+    }
+    
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        int codecSpecific2Value = 0;
+        if (index <= 1) {
+            codecSpecific2Value = DEFAULT_TAG | index;
+        }else{
+            codecSpecific2Value = DEFAULT_TAG | DEFAULT_INDEX;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific2Value(codecSpecific2Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int index = (int)config.getCodecSpecific2();
+        int tmp = index & DEFAULT_TAG;
+        if (tmp == DEFAULT_TAG) {
+            index &= 0x1;
+        } else {
+            index = DEFAULT_INDEX;
+        }
+        return index;
+    }
+}
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
new file mode 100644
index 000000000..4c7d0b3a0
--- /dev/null
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCAudioLosslessPreferenceController.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+
+import com.android.settings.R;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+import android.util.Log;
+
+/**
+ * Switch preference controller for LHDC Lossless ON/OFF
+ */
+public class BluetoothLHDCAudioLosslessPreferenceController extends
+        AbstractBluetoothA2dpPreferenceController {
+
+    private static final int DEFAULT_INDEX = 0;
+    private static final String BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY =
+            "bluetooth_enable_a2dp_codec_lhdc_lossless";
+
+    private static final int LHDC_FEATURE_MASK = 0xFF000000;
+    private static final int LHDC_FEATURE_TAG = 0x4C000000;
+    private static final int LHDC_LOSSLESS_FEATURE = 0x80;
+
+    public BluetoothLHDCAudioLosslessPreferenceController(Context context, Lifecycle lifecycle,
+            BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return BLUETOOTH_SELECT_A2DP_LHDC_LOSSLESS_KEY;
+    }
+
+    @Override
+    protected String[] getListValues() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_values);
+    }
+
+    @Override
+    protected String[] getListSummaries() {
+        return mContext.getResources().getStringArray(
+                R.array.bluetooth_enable_a2dp_codec_lhdc_lossless_summaries);
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return DEFAULT_INDEX;
+    }
+
+    @Override
+    protected void writeConfigurationValues(Object newValue) {
+        final int index = mPreference.findIndexOfValue(newValue.toString());
+        int codecSpecific3Value = 0; // default
+        codecSpecific3Value |= LHDC_FEATURE_TAG;
+        if (index != 0) {
+            codecSpecific3Value |= LHDC_LOSSLESS_FEATURE;
+        }else{
+            codecSpecific3Value &= ~LHDC_LOSSLESS_FEATURE;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific3Value(codecSpecific3Value);
+    }
+
+    @Override
+    protected int getCurrentA2dpSettingIndex(BluetoothCodecConfig config) {
+        int ret = 0;
+        int index = (int)config.getCodecSpecific3();
+        int tmp = index & LHDC_FEATURE_MASK;
+        if (tmp == LHDC_FEATURE_TAG) {
+            if ((index & LHDC_LOSSLESS_FEATURE) != 0) {
+                ret = 1;
+            } else {
+                ret = 0;
+            }
+        } else {
+            ret = 0;
+        }
+        return ret;
+    }
+}
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreference.java
new file mode 100644
index 000000000..6d1610134
--- /dev/null
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreference.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development.bluetooth;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.widget.RadioGroup;
+
+import com.android.settings.R;
+
+/**
+ * Dialog preference to set the Bluetooth A2DP config of LHDC quality
+ */
+public class BluetoothLHDCQualityDialogPreference extends BaseBluetoothDialogPreference implements
+        RadioGroup.OnCheckedChangeListener {
+
+    public BluetoothLHDCQualityDialogPreference(Context context) {
+        super(context);
+        initialize(context);
+    }
+
+    public BluetoothLHDCQualityDialogPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initialize(context);
+    }
+
+    public BluetoothLHDCQualityDialogPreference(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+        initialize(context);
+    }
+
+    public BluetoothLHDCQualityDialogPreference(Context context, AttributeSet attrs, int defStyleAttr,
+                                            int defStyleRes) {
+        super(context, attrs, defStyleAttr, defStyleRes);
+        initialize(context);
+    }
+
+    @Override
+    protected int getRadioButtonGroupId() {
+        return R.id.bluetooth_lhdc_audio_quality_radio_group;
+    }
+
+    @Override
+    protected int getDefaultIndex() {
+        return 9; // Best Effort
+    }
+
+    private void initialize(Context context) {
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low0);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low1);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low2);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low3);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low4);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_low);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_mid);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_high);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_high1);
+        mRadioButtonIds.add(R.id.bluetooth_lhdc_audio_quality_best_effort);
+        String[] stringArray = context.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_playback_quality_titles);
+        for (int i = 0; i < stringArray.length; i++) {
+            mRadioButtonStrings.add(stringArray[i]);
+        }
+        stringArray = context.getResources().getStringArray(
+                R.array.bluetooth_a2dp_codec_lhdc_playback_quality_summaries);
+        for (int i = 0; i < stringArray.length; i++) {
+            mSummaryStrings.add(stringArray[i]);
+        }
+    }
+}
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
new file mode 100644
index 000000000..772ae1eb4
--- /dev/null
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothLHDCQualityDialogPreferenceController.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2019 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.settings.development.bluetooth;
+
+import android.bluetooth.BluetoothCodecConfig;
+import android.content.Context;
+import android.util.Log;
+
+import androidx.annotation.VisibleForTesting;
+import androidx.preference.Preference;
+import androidx.preference.PreferenceScreen;
+
+import com.android.settings.development.BluetoothA2dpConfigStore;
+import com.android.settingslib.core.lifecycle.Lifecycle;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Dialog preference controller to set the Bluetooth A2DP config of LHDC quality
+ */
+public class BluetoothLHDCQualityDialogPreferenceController extends
+        AbstractBluetoothDialogPreferenceController {
+
+    // In standard case, low0 is available
+    private static final int index_adjust_offset = 0;
+    // In case of low0 is removed, shift the rest indices
+    //private static final int index_adjust_offset = 1;
+
+    private static final String KEY = "bluetooth_select_a2dp_lhdc_playback_quality";
+    private static final String TAG = "BtLhdcAudioQualityCtr";
+    private static final int DEFAULT_TAG = 0xC000;
+    private static final int DEFAULT_MAGIC = 0x8000;
+    private static final int DEFAULT_INDEX = (5 - index_adjust_offset);
+    private static final int DEFAULT_MAX_INDEX = (9 - index_adjust_offset); //0~9
+
+    public BluetoothLHDCQualityDialogPreferenceController(Context context, Lifecycle lifecycle,
+                                                      BluetoothA2dpConfigStore store) {
+        super(context, lifecycle, store);
+    }
+
+    @Override
+    public String getPreferenceKey() {
+        return KEY;
+    }
+
+    @Override
+    public void displayPreference(PreferenceScreen screen) {
+        super.displayPreference(screen);
+        ((BaseBluetoothDialogPreference) mPreference).setCallback(this);
+    }
+
+    @Override
+    protected void writeConfigurationValues(final int index) {
+        long codecSpecific1Value = 0;
+        if (index <= DEFAULT_MAX_INDEX) {
+            codecSpecific1Value = DEFAULT_MAGIC | (index + index_adjust_offset);
+        }else{
+            codecSpecific1Value = DEFAULT_MAGIC | DEFAULT_INDEX;
+        }
+        mBluetoothA2dpConfigStore.setCodecSpecific1Value(codecSpecific1Value);
+    }
+
+    @Override
+    protected int getCurrentIndexByConfig(BluetoothCodecConfig config) {
+        if (config == null) {
+            Log.e(TAG, "Unable to get current config index. Config is null.");
+        }
+        return convertCfgToBtnIndex((int) config.getCodecSpecific1());
+    }
+
+    @Override
+    public List<Integer> getSelectableIndex() {
+        List<Integer> selectableIndex = new ArrayList<>();
+        final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+        if (currentConfig != null) {
+            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+                currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3) {
+                // excluding 1000Kbps
+                for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
+                    if(i != (8 - index_adjust_offset)) {
+                        selectableIndex.add(i);
+                    }
+                }
+            }
+            if (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                // All items of LHDCV5 are available.
+                for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
+                    selectableIndex.add(i);
+                }
+            }
+        }
+
+        // All items are available to set from UI but be filtered at native layer.
+        for (int i = 0; i <= DEFAULT_MAX_INDEX; i++) {
+            selectableIndex.add(i);
+        }
+        return selectableIndex;
+    }
+
+    @Override
+    public void updateState(Preference preference) {
+        super.updateState(preference);
+        // Enable preference when current codec type is LHDC V2/V3/V5. For other cases, disable it.
+        final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
+        if (currentConfig != null
+                && (currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 ||
+                    currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 ||
+                    currentConfig.getCodecType() == BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5)
+                ) {
+            preference.setEnabled(true);
+        } else {
+            preference.setEnabled(false);
+            preference.setSummary("");
+        }
+    }
+
+    @Override
+    public void onHDAudioEnabled(boolean enabled) {
+        mPreference.setEnabled(false);
+    }
+
+    @VisibleForTesting
+    int convertCfgToBtnIndex(int config) {
+        int index = config;
+        int tmp = config & DEFAULT_TAG;  //0xC000
+        if (tmp != DEFAULT_MAGIC) {  //0x8000
+            index = getDefaultIndex();
+        } else {
+            index &= 0xff;
+        }
+        return (index - index_adjust_offset);
+    }
+}
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java
index 622c47ae5..2abd2d24e 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreference.java
@@ -61,6 +61,8 @@ public class BluetoothSampleRateDialogPreference extends BaseBluetoothDialogPref
         mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_480);
         mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_882);
         mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_960);
+        mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_1764);
+        mRadioButtonIds.add(R.id.bluetooth_audio_sample_rate_1920);
         String[] stringArray = context.getResources().getStringArray(
                 R.array.bluetooth_a2dp_codec_sample_rate_titles);
         for (int i = 0; i < stringArray.length; i++) {
diff --git a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
index 9e4b99ef8..6228a6c64 100644
--- a/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
+++ b/packages_apps_Settings/src/com/android/settings/development/bluetooth/BluetoothSampleRateDialogPreferenceController.java
@@ -61,8 +61,13 @@ public class BluetoothSampleRateDialogPreferenceController extends
             case 0:
                 final BluetoothCodecConfig currentConfig = getCurrentCodecConfig();
                 if (currentConfig != null) {
-                    sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
-                            currentConfig.getCodecType()));
+                    /* Savitech LHDC patch: use default by LHDC native when selecting system default */
+                    if (currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3 &&
+                        currentConfig.getCodecType() != BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5) {
+                            sampleRateValue = getHighestSampleRate(getSelectableByCodecType(
+                                currentConfig.getCodecType()));
+                    }
                 }
                 break;
             case 1:
@@ -77,6 +82,12 @@ public class BluetoothSampleRateDialogPreferenceController extends
             case 4:
                 sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_96000;
                 break;
+            case 5:
+                sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_176400;
+                break;
+            case 6:
+                sampleRateValue = BluetoothCodecConfig.SAMPLE_RATE_192000;
+                break;
             default:
                 break;
         }
@@ -124,6 +135,12 @@ public class BluetoothSampleRateDialogPreferenceController extends
             case BluetoothCodecConfig.SAMPLE_RATE_96000:
                 index = 4;
                 break;
+            case BluetoothCodecConfig.SAMPLE_RATE_176400:
+                index = 5;
+                break;
+            case BluetoothCodecConfig.SAMPLE_RATE_192000:
+                index = 6;
+                break;
             default:
                 Log.e(TAG, "Unsupported config:" + config);
                 break;
diff --git a/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp b/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp
index a94990437..f41361962 100644
--- a/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp
+++ b/packages_apps_bluetooth/jni/com_android_bluetooth_a2dp.cpp
@@ -505,6 +505,182 @@ static jboolean setCodecConfigPreferenceNative(JNIEnv* env, jobject object,
   return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
 }
 
+/************************************************
+ * Savitech LHDC EXT API -- START
+ ***********************************************/
+static char *jByteArrayToChar(JNIEnv *env, jbyteArray buf) {
+    char *chars = NULL;
+    jbyte *bytes;
+    bytes = env->GetByteArrayElements(buf, 0);
+    if (!bytes) {
+      jniThrowIOException(env, EINVAL);
+      return JNI_FALSE;
+    }
+    int chars_len = env->GetArrayLength(buf);
+    chars = new char[chars_len + 1];
+    memset(chars, 0, chars_len + 1);
+    memcpy(chars, bytes, chars_len);
+    chars[chars_len] = 0;
+    env->ReleaseByteArrayElements(buf, bytes, 0);
+    return chars;
+}
+
+static jint getLhdcCodecExtendApiVerNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecConfig){
+
+  int status = BT_STATUS_FAIL;
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return status;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return status;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecConfig);
+  chars = jByteArrayToChar(env, codecConfig);
+  if(!chars)
+  {
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return status;
+  }
+
+  status =
+      sBluetoothA2dpInterface->getApiVer_lhdc(bd_addr, chars, chars_len);
+
+  if (status != BT_STATUS_SUCCESS) {
+    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
+  }
+  else {
+    env->SetByteArrayRegion(codecConfig, 0, chars_len, reinterpret_cast<jbyte *>(chars));
+  }
+
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+
+  return status;
+}
+
+static jint getLhdcCodecExtendApiConfigNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecConfig){
+
+  int status = BT_STATUS_FAIL;
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return status;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return status;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecConfig);
+  chars = jByteArrayToChar(env, codecConfig);
+  if(!chars)
+  {
+    env->ReleaseByteArrayElements(address, addr, 0);
+    return status;
+  }
+
+  status =
+      sBluetoothA2dpInterface->getApiCfg_lhdc(bd_addr, chars, chars_len);
+
+  if (status != BT_STATUS_SUCCESS) {
+    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
+  }
+  else {
+    env->SetByteArrayRegion(codecConfig, 0, chars_len, reinterpret_cast<jbyte *>(chars));
+  }
+
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+
+  return status;
+}
+
+static jint setLhdcCodecExtendApiConfigNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecConfig){
+
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return JNI_FALSE;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return JNI_FALSE;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecConfig);
+  chars = jByteArrayToChar(env, codecConfig);
+
+  int status =
+      sBluetoothA2dpInterface->setApiCfg_lhdc(bd_addr, chars, chars_len);
+
+  if (status != BT_STATUS_SUCCESS) {
+    ALOGE("%s: Failed codec configuration, status: %d", __func__, status);
+    return status;
+  }
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+
+  return status;
+}
+
+static void setLhdcCodecExtendApiDataNative(JNIEnv* env, jobject object,
+                                           jbyteArray address,
+                                           jbyteArray codecData){
+
+  std::shared_lock<std::shared_timed_mutex> lock(interface_mutex);
+  if (!sBluetoothA2dpInterface) {
+    ALOGE("%s: Failed to get the Bluetooth A2DP Interface", __func__);
+    return;
+  }
+
+  jbyte* addr = env->GetByteArrayElements(address, nullptr);
+  if (!addr) {
+    jniThrowIOException(env, EINVAL);
+    return;
+  }
+
+  RawAddress bd_addr;
+  bd_addr.FromOctets(reinterpret_cast<const uint8_t*>(addr));
+
+  char *chars = NULL;
+  int chars_len = env->GetArrayLength(codecData);
+  chars = jByteArrayToChar(env, codecData);
+
+  sBluetoothA2dpInterface->setAPiData_lhdc(bd_addr, chars, chars_len);
+
+  env->ReleaseByteArrayElements(address, addr, 0);
+  delete[] chars;
+}
+//Savitech LHDC EXT API -- END
+
 static JNINativeMethod sMethods[] = {
     {"classInitNative", "()V", (void*)classInitNative},
     {"initNative",
@@ -518,6 +694,20 @@ static JNINativeMethod sMethods[] = {
     {"setCodecConfigPreferenceNative",
      "([B[Landroid/bluetooth/BluetoothCodecConfig;)Z",
      (void*)setCodecConfigPreferenceNative},
+    // Savitech LHDC EXT API -- START
+    {"getLhdcCodecExtendApiVerNative",
+     "([B[B)I",
+     (void*)getLhdcCodecExtendApiVerNative},
+    {"getLhdcCodecExtendApiConfigNative",
+     "([B[B)I",
+     (void*)getLhdcCodecExtendApiConfigNative},
+    {"setLhdcCodecExtendApiConfigNative",
+     "([B[B)I",
+     (void*)setLhdcCodecExtendApiConfigNative},
+    {"setLhdcCodecExtendApiDataNative",
+     "([B[B)V",
+     (void*)setLhdcCodecExtendApiDataNative},
+    // Savitech LHDC EXT API -- END
 };
 
 int register_com_android_bluetooth_a2dp(JNIEnv* env) {
diff --git a/packages_apps_bluetooth/res/values/config.xml b/packages_apps_bluetooth/res/values/config.xml
index 0fc3fdc4f..88152d5d0 100644
--- a/packages_apps_bluetooth/res/values/config.xml
+++ b/packages_apps_bluetooth/res/values/config.xml
@@ -101,6 +101,9 @@
     <integer name="a2dp_source_codec_priority_aptx">3001</integer>
     <integer name="a2dp_source_codec_priority_aptx_hd">4001</integer>
     <integer name="a2dp_source_codec_priority_ldac">5001</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv2">6001</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv3">6002</integer>
+    <integer name="a2dp_source_codec_priority_lhdcv5">6003</integer>
 
     <!-- For enabling the AVRCP Target Cover Artowrk feature-->
     <bool name="avrcp_target_enable_cover_art">true</bool>
diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
index 6e0b1c022..e6f7c040f 100644
--- a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
+++ b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpCodecConfig.java
@@ -51,6 +51,12 @@ class A2dpCodecConfig {
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
     private @CodecPriority int mA2dpSourceCodecPriorityLdac =
             BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV2 =
+            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV3 =
+            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+    private @CodecPriority int mA2dpSourceCodecPriorityLhdcV5 =
+            BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
 
     private BluetoothCodecConfig[] mCodecConfigOffloading = new BluetoothCodecConfig[0];
 
@@ -231,6 +237,38 @@ class A2dpCodecConfig {
             mA2dpSourceCodecPriorityLdac = value;
         }
 
+        // Savitech LHDC -- START
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv2);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV2 = value;
+        }
+
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv3);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV3 = value;
+        }
+
+        try {
+            value = resources.getInteger(R.integer.a2dp_source_codec_priority_lhdcv5);
+        } catch (NotFoundException e) {
+            value = BluetoothCodecConfig.CODEC_PRIORITY_DEFAULT;
+        }
+        if ((value >= BluetoothCodecConfig.CODEC_PRIORITY_DISABLED) && (value
+                < BluetoothCodecConfig.CODEC_PRIORITY_HIGHEST)) {
+            mA2dpSourceCodecPriorityLhdcV5 = value;
+        }
+        // Savitech LHDC -- END
+
         BluetoothCodecConfig codecConfig;
         BluetoothCodecConfig[] codecConfigArray =
                 new BluetoothCodecConfig[BluetoothCodecConfig.SOURCE_CODEC_TYPE_MAX];
@@ -265,7 +303,69 @@ class A2dpCodecConfig {
                 0 /* codecSpecific2 */, 0 /* codecSpecific3 */, 0 /* codecSpecific4 */);
         codecConfigArray[4] = codecConfig;
 
+        // Savitech LHDC -- START
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV2,
+                mA2dpSourceCodecPriorityLhdcV2, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[5] = codecConfig;
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV3,
+                mA2dpSourceCodecPriorityLhdcV3, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[6] = codecConfig;
+        codecConfig = new BluetoothCodecConfig(BluetoothCodecConfig.SOURCE_CODEC_TYPE_LHDCV5,
+                mA2dpSourceCodecPriorityLhdcV5, BluetoothCodecConfig.SAMPLE_RATE_NONE,
+                BluetoothCodecConfig.BITS_PER_SAMPLE_NONE, BluetoothCodecConfig.CHANNEL_MODE_NONE,
+                0 /* codecSpecific1 */, 0 /* codecSpecific2 */, 0 /* codecSpecific3 */,
+                0 /* codecSpecific4 */);
+        codecConfigArray[7] = codecConfig;
+        // Savitech LHDC -- END
+
         return codecConfigArray;
     }
+
+    /************************************************
+     * Savitech LHDC EXT API -- START
+     ***********************************************/
+    int getLhdcCodecExtendApiVer(BluetoothDevice device,
+                                byte[] exApiVer) {
+        return mA2dpNativeInterface.getLhdcCodecExtendApiVer(device, exApiVer);
+    }
+
+    int setLhdcCodecExtendApiConfigAr(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.setLhdcCodecExtendApiConfigAr(device, codecConfig);
+    }
+
+    int getLhdcCodecExtendApiConfigAr(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+    }
+
+    int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
+    }
+
+    int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
+    }
+
+    int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device,
+                                byte[] codecConfig) {
+        return mA2dpNativeInterface.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
+    }
+
+    void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device,
+                                byte[] codecData) {
+        mA2dpNativeInterface.setLhdcCodecExtendApiDataGyro2D(device, codecData);
+    }
+    /************************************************
+     * Savitech LHDC EXT API -- END
+     ***********************************************/
 }
 
diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
index 2530f82a8..340c801e9 100644
--- a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
+++ b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpNativeInterface.java
@@ -220,6 +220,34 @@ public class A2dpNativeInterface {
         }
     }
 
+    /************************************************
+     * Savitech LHDC EXT API -- START
+     ***********************************************/
+    public int getLhdcCodecExtendApiVer(BluetoothDevice device, byte[] exApiVer) {
+        return getLhdcCodecExtendApiVerNative(getByteAddress(device), exApiVer);
+    }
+    public int getLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
+        return getLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
+    }
+    public int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
+        return setLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
+    }
+    public int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
+        return getLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
+    }
+    public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device, byte[] codecConfig) {
+        return getLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
+    }
+    public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
+        return setLhdcCodecExtendApiConfigNative(getByteAddress(device), codecConfig);
+    }
+    public void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device, byte[] codecData) {
+    	setLhdcCodecExtendApiDataNative(getByteAddress(device), codecData);
+    }
+    /************************************************
+     * Savitech LHDC EXT API -- END
+     ***********************************************/
+
     // Native methods that call into the JNI interface
     private static native void classInitNative();
     private native void initNative(int maxConnectedAudioDevices,
@@ -232,4 +260,10 @@ public class A2dpNativeInterface {
     private native boolean setActiveDeviceNative(byte[] address);
     private native boolean setCodecConfigPreferenceNative(byte[] address,
                 BluetoothCodecConfig[] codecConfigArray);
+    // Savitech LHDC EXT API
+    private native int getLhdcCodecExtendApiVerNative(byte[] address, byte[] exApiVer);
+    private native int setLhdcCodecExtendApiConfigNative(byte[] address, byte[] codecConfig);
+    private native int getLhdcCodecExtendApiConfigNative(byte[] address, byte[] codecConfig);
+    private native int getLhdcCodecExtendApiA2dpCodecConfigNative(byte[] address, byte[] codecConfig);
+    private native void setLhdcCodecExtendApiDataNative(byte[] address, byte[] codecData);
 }
diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
index c6b17594a..2137780f2 100644
--- a/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/packages_apps_bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -751,6 +751,68 @@ public class A2dpService extends ProfileService {
         mA2dpCodecConfig.setCodecConfigPreference(device, codecStatus, codecConfig);
     }
 
+    /************************************************
+     * Savitech LHDC EXT API -- START
+     ***********************************************/
+    public int getLhdcCodecExtendApiVer(BluetoothDevice device, byte[] exApiVer) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+        return mA2dpCodecConfig.getLhdcCodecExtendApiVer(device, exApiVer);
+    }
+
+    public int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+        return mA2dpCodecConfig.setLhdcCodecExtendApiConfigAr(device, codecConfig);
+    }
+
+    public int getLhdcCodecExtendApiConfigAr(BluetoothDevice device, byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+        return mA2dpCodecConfig.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+    }
+
+    public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+        return mA2dpCodecConfig.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
+    }
+
+    public int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device, byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+        return mA2dpCodecConfig.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
+    }
+
+    public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device, byte[] codecConfig) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return -1;
+        }
+        return mA2dpCodecConfig.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
+    }
+
+    public void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device, byte[] codecData) {
+        if (device == null) {
+            Log.e(TAG, "Cannot set codec config preference: no active A2DP device");
+            return;
+        }
+        mA2dpCodecConfig.setLhdcCodecExtendApiDataGyro2D(device, codecData);
+    }
+    /************************************************
+     * Savitech LHDC EXT API -- END
+     ***********************************************/
+
     /**
      * Enables the optional codecs.
      *
@@ -1226,6 +1288,20 @@ public class A2dpService extends ProfileService {
             return mService;
         }
 
+        // Savitech - comaptible to API before Android 12.0 
+        private A2dpService getServiceLhdc() {
+            if (!Utils.checkCallerIsSystemOrActiveUser()
+                    || !Utils.checkServiceAvailable(mService, TAG)) {
+                Log.w(TAG, "A2DP call not allowed for non-active user");
+                return null;
+            }
+
+            if (mService != null && mService.isAvailable()) {
+                return mService;
+            }
+            return null;
+        }
+
         BluetoothA2dpBinder(A2dpService svc) {
             mService = svc;
         }
@@ -1409,6 +1485,82 @@ public class A2dpService extends ProfileService {
             service.setCodecConfigPreference(device, codecConfig);
         }
 
+        /************************************************
+         * Savitech Patch - LHDC Extended API Start
+         ***********************************************/
+        @Override
+        public int getLhdcCodecExtendApiVer(BluetoothDevice device,
+                byte[] exApiVer) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendApiVer(device, exApiVer);
+        }
+
+        @Override
+        public int setLhdcCodecExtendApiConfigAr(BluetoothDevice device, 
+                byte[] codecConfig) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return -1;
+            }
+            return service.setLhdcCodecExtendApiConfigAr(device, codecConfig);
+        }
+
+        @Override
+        public int getLhdcCodecExtendApiConfigAr(BluetoothDevice device,
+                byte[] codecConfig) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendApiConfigAr(device, codecConfig);
+        }
+
+        @Override
+        public int setLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+                byte[] codecConfig) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return -1;
+            }
+            return service.setLhdcCodecExtendApiConfigMeta(device, codecConfig);
+        }
+
+        @Override
+        public int getLhdcCodecExtendApiConfigMeta(BluetoothDevice device,
+                byte[] codecConfig) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendApiConfigMeta(device, codecConfig);
+        }
+
+        @Override
+        public int getLhdcCodecExtendApiConfigA2dpCodecSpecific(BluetoothDevice device,
+                byte[] codecConfig) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return -1;
+            }
+            return service.getLhdcCodecExtendApiConfigA2dpCodecSpecific(device, codecConfig);
+        }
+
+        @Override
+        public void setLhdcCodecExtendApiDataGyro2D(BluetoothDevice device,
+                byte[] codecData) {
+            A2dpService service = getServiceLhdc();
+            if (service == null) {
+                return;
+            }
+            service.setLhdcCodecExtendApiDataGyro2D(device, codecData);
+        }
+        /************************************************
+         * Savitech Patch - LHDC Extended API End
+         ***********************************************/
+
         @Override
         public void enableOptionalCodecs(BluetoothDevice device, AttributionSource source) {
             Attributable.setAttributionSource(device, source);
diff --git a/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java b/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java
index 41535377a..7b9a960c4 100644
--- a/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java
+++ b/packages_apps_bluetooth/src/com/android/bluetooth/btservice/Config.java
@@ -111,6 +111,13 @@ public class Config {
 
     private static Class[] sSupportedProfiles = new Class[0];
 
+    // Savitech Add -- A2DP_Source_Sink_Switch
+    private static boolean isBluetoothPersistedA2DPSinkOn(Context context) {
+        final ContentResolver resolver = context.getContentResolver();
+        int state = Settings.Global.getInt(resolver, Settings.Global.BLUETOOTH_A2DP_SINK, 0);
+        return (state != 0);
+    }
+
     private static boolean sIsGdEnabledUptoScanningLayer = false;
 
     static void init(Context ctx) {
@@ -139,6 +146,21 @@ public class Config {
                         + " by components configuration");
             }
 
+            /* Savitech Add -- A2DP_Source_Sink_Switch
+             * 	check a2dp sink persist settings to load A2DP sink or not
+             * */
+            /*
+            if (supported == true && config.mClass == A2dpSinkService.class) {
+                if (isBluetoothPersistedA2DPSinkOn(ctx)) {
+                    Log.d(TAG, "A2DP sink service load");
+                    supported = true;
+                } else {
+                    Log.d(TAG, "A2DP sink service not load");
+                    supported = false;
+                }
+            }
+            */
+
             if (supported && !isProfileDisabled(ctx, config.mMask)) {
                 Log.v(TAG, "Adding " + config.mClass.getSimpleName());
                 profiles.add(config.mClass);
diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.cc b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
index afa87426b..19a5c8b4f 100644
--- a/system_bt/audio_bluetooth_hw/device_port_proxy.cc
+++ b/system_bt/audio_bluetooth_hw/device_port_proxy.cc
@@ -37,6 +37,10 @@ using ::android::bluetooth::audio::BluetoothAudioSessionControl_2_1;
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::PcmParameters;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::android::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using SampleRate = ::android::hardware::bluetooth::audio::V2_0::SampleRate;
 using SampleRate_2_1 = ::android::hardware::bluetooth::audio::V2_1::SampleRate;
 using BluetoothAudioStatus =
@@ -108,6 +112,22 @@ audio_format_t BitsPerSampleToAudioFormat(BitsPerSample bits_per_sample) {
   }
 }
 
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+/*
+bool isLhdcLowLatencyToAudioFormat(LhdcLowLatencyEn low_latency_enabled) {
+  switch (low_latency_enabled) {
+    case LhdcLowLatencyEn::Enabled:
+      return true;
+    case LhdcLowLatencyEn::Disabled:
+      return false;
+    default:
+      return kBluetoothDefaultAudioFormatLhdcLowLatency;
+  }
+}
+*/
+// Savitech Patch - End
+
 // The maximum time to wait in std::condition_variable::wait_for()
 constexpr unsigned int kMaxWaitingTimeMs = 4500;
 
@@ -320,6 +340,10 @@ bool BluetoothAudioPortOut::LoadAudioConfig(audio_config_t* audio_cfg) const {
            ? AUDIO_CHANNEL_OUT_STEREO
            : OutputChannelModeToAudioFormat(pcm_cfg.channelMode));
   audio_cfg->format = BitsPerSampleToAudioFormat(pcm_cfg.bitsPerSample);
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  //_lowLatencyEnabled = isLhdcLowLatencyToAudioFormat(pcm_cfg.isLowLatencyEnabled);
+  // Savitech Patch - End
   return true;
 }
 
diff --git a/system_bt/audio_bluetooth_hw/device_port_proxy.h b/system_bt/audio_bluetooth_hw/device_port_proxy.h
index 9e113926f..c8b18893a 100644
--- a/system_bt/audio_bluetooth_hw/device_port_proxy.h
+++ b/system_bt/audio_bluetooth_hw/device_port_proxy.h
@@ -54,6 +54,15 @@ class BluetoothAudioPort {
   // Bluetooth stack
   virtual bool LoadAudioConfig(audio_config_t* audio_cfg) const = 0;
 
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  /*
+  bool isLowLatencyEnabled() const {
+    return _lowLatencyEnabled;
+  }
+  */
+  // Savitech Patch - End
+
   // WAR to support Mono mode / 16 bits per sample
   void ForcePcmStereoToMono(bool force) {
     is_stereo_to_mono_ = force;
@@ -89,6 +98,11 @@ class BluetoothAudioPort {
            session_type_ == SessionType_2_1::A2DP_HARDWARE_OFFLOAD_DATAPATH;
   }
 
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  //mutable bool _lowLatencyEnabled = false;
+  // Savitech Patch - End
+
  protected:
   uint16_t cookie_;
   BluetoothStreamState state_;
diff --git a/system_bt/audio_bluetooth_hw/stream_apis.cc b/system_bt/audio_bluetooth_hw/stream_apis.cc
index aafe547f7..28e1648fc 100644
--- a/system_bt/audio_bluetooth_hw/stream_apis.cc
+++ b/system_bt/audio_bluetooth_hw/stream_apis.cc
@@ -86,8 +86,18 @@ void out_calculate_feeding_delay_ms(const BluetoothStreamOut* out,
     //   frames_count = buffer_size / frame_size
     //   latency (sec.) = frames_count / samples_per_second (sample_rate)
     // Sync from audio_a2dp_hw to add extra delay kExtraAudioSyncMs(+200ms)
+#if 0
+    bool lowLatencySt = false;
+    // Savitech Patch - Start
+    //   LHDC_Low_Latency(non-offload)
+    lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
+    delay_report_ms =
+        out->frames_count_ * 1000 / out->sample_rate_ + (lowLatencySt == true ? 0 : kExtraAudioSyncMs);
+    // Savitech Patch - End
+#else
     delay_report_ms =
         out->frames_count_ * 1000 / out->sample_rate_ + kExtraAudioSyncMs;
+#endif
     if (timestamp != nullptr) {
       clock_gettime(CLOCK_MONOTONIC, &absorbed_timestamp);
     }
@@ -220,6 +230,13 @@ static size_t out_get_buffer_size(const struct audio_stream* stream) {
   const auto* out = reinterpret_cast<const BluetoothStreamOut*>(stream);
   size_t buffer_size =
       out->frames_count_ * audio_stream_out_frame_size(&out->stream_out_);
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  /*
+  bool lowLatencySt = out->bluetooth_output_.isLowLatencyEnabled();
+  if (lowLatencySt) buffer_size = buffer_size/2;
+  */
+  // Savitech Patch - End
   LOG(VERBOSE) << __func__ << ": state=" << out->bluetooth_output_.GetState()
                << ", buffer_size=" << buffer_size;
   return buffer_size;
diff --git a/system_bt/audio_bluetooth_hw/stream_apis.h b/system_bt/audio_bluetooth_hw/stream_apis.h
index 55512d7fb..a1d5daeb3 100644
--- a/system_bt/audio_bluetooth_hw/stream_apis.h
+++ b/system_bt/audio_bluetooth_hw/stream_apis.h
@@ -26,6 +26,11 @@ constexpr unsigned int kBluetoothDefaultSampleRate = 44100;
 constexpr audio_format_t kBluetoothDefaultAudioFormatBitsPerSample =
     AUDIO_FORMAT_PCM_16_BIT;
 
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//constexpr bool kBluetoothDefaultAudioFormatLhdcLowLatency = 0;
+// Savitech Patch - End
+
 constexpr unsigned int kBluetoothDefaultInputBufferMs = 20;
 constexpr unsigned int kBluetoothDefaultInputStateTimeoutMs = 20;
 
diff --git a/system_bt/audio_hal_interface/a2dp_encoding.cc b/system_bt/audio_hal_interface/a2dp_encoding.cc
index 44a4828fc..761791b8f 100644
--- a/system_bt/audio_hal_interface/a2dp_encoding.cc
+++ b/system_bt/audio_hal_interface/a2dp_encoding.cc
@@ -44,7 +44,14 @@ using ::bluetooth::audio::codec::A2dpAptxToHalConfig;
 using ::bluetooth::audio::codec::A2dpCodecToHalBitsPerSample;
 using ::bluetooth::audio::codec::A2dpCodecToHalChannelMode;
 using ::bluetooth::audio::codec::A2dpCodecToHalSampleRate;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::bluetooth::audio::codec::A2dpCodecToHalLhdcLowLatencyMode;
+// Savitech Patch - End
 using ::bluetooth::audio::codec::A2dpLdacToHalConfig;
+// Savitech Patch - Offload
+//using ::bluetooth::audio::codec::A2dpLhdcv5ToHalConfig;
+// Savitech Patch - End
 using ::bluetooth::audio::codec::A2dpSbcToHalConfig;
 using ::bluetooth::audio::codec::CodecConfiguration;
 
@@ -264,6 +271,25 @@ bool a2dp_get_selected_hal_codec_config(CodecConfiguration* codec_config) {
       }
       break;
     }
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5: {
+#if 0
+      // Savitech Patch Offload
+      if (!A2dpLhdcv5ToHalConfig(codec_config, a2dp_config)) {
+        LOG(ERROR) << __func__
+                   << ": Fail to call A2dpLhdcv5ToHalConfig(), codec_type=" << current_codec.codec_type;
+        return false;
+      }
+      break;
+#else
+      // for non-offload only
+      return true;
+#endif
+      // Savitech Patch - End
+    }
     case BTAV_A2DP_CODEC_INDEX_MAX:
       [[fallthrough]];
     default:
@@ -307,6 +333,18 @@ bool a2dp_get_selected_hal_pcm_config(PcmParameters* pcm_config) {
   pcm_config->sampleRate = A2dpCodecToHalSampleRate(current_codec);
   pcm_config->bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
   pcm_config->channelMode = A2dpCodecToHalChannelMode(current_codec);
+
+  // Savitech Patch - Start
+  //   LHDC_Low_Latency(non-offload)
+  /*
+  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3 ||
+      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2 ||
+      current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
+    pcm_config->isLowLatencyEnabled = A2dpCodecToHalLhdcLowLatencyMode(current_codec);
+  }
+  */
+  // Savitech Patch - End
+
   return (pcm_config->sampleRate != SampleRate::RATE_UNKNOWN &&
           pcm_config->bitsPerSample != BitsPerSample::BITS_UNKNOWN &&
           pcm_config->channelMode != ChannelMode::UNKNOWN);
diff --git a/system_bt/audio_hal_interface/client_interface.h b/system_bt/audio_hal_interface/client_interface.h
index b9f18b9ed..4cd4de3f8 100644
--- a/system_bt/audio_hal_interface/client_interface.h
+++ b/system_bt/audio_hal_interface/client_interface.h
@@ -43,6 +43,10 @@ using AudioConfiguration_2_1 =
     ::android::hardware::bluetooth::audio::V2_1::AudioConfiguration;
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using IBluetoothAudioProvider =
     ::android::hardware::bluetooth::audio::V2_0::IBluetoothAudioProvider;
 using IBluetoothAudioProvider_2_1 =
@@ -221,7 +225,12 @@ class BluetoothAudioClientInterface {
   static constexpr PcmParameters kInvalidPcmConfiguration = {
       .sampleRate = SampleRate::RATE_UNKNOWN,
       .channelMode = ChannelMode::UNKNOWN,
-      .bitsPerSample = BitsPerSample::BITS_UNKNOWN};
+      .bitsPerSample = BitsPerSample::BITS_UNKNOWN,
+      // Savitech Patch - Start
+      //   LHDC_Low_Latency(non-offload)
+      //.isLowLatencyEnabled = LhdcLowLatencyEn::Disabled,
+      // Savitech Patch - End
+  };
 
  protected:
   mutable std::mutex internal_mutex_;
diff --git a/system_bt/audio_hal_interface/client_interface_unittest.cc b/system_bt/audio_hal_interface/client_interface_unittest.cc
index 33954c720..996060db5 100644
--- a/system_bt/audio_hal_interface/client_interface_unittest.cc
+++ b/system_bt/audio_hal_interface/client_interface_unittest.cc
@@ -32,6 +32,8 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
 using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
 using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
+// Savitech Patch  Offload
+//using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
 using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
 using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
 using ::android::hardware::bluetooth::audio::V2_0::SbcChannelMode;
@@ -121,11 +123,15 @@ constexpr ChannelModePair kChannelModePairs[3] = {
     {.hal_channel_mode_ = ChannelMode::STEREO,
      .btav_channel_mode_ = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO}};
 
+// Savitech Patch  Offload
 constexpr btav_a2dp_codec_index_t codec_indexes[] = {
     BTAV_A2DP_CODEC_INDEX_SOURCE_SBC,  BTAV_A2DP_CODEC_INDEX_SOURCE_AAC,
     BTAV_A2DP_CODEC_INDEX_SOURCE_APTX, BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
-    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SINK_SBC,
-    BTAV_A2DP_CODEC_INDEX_SINK_AAC,    BTAV_A2DP_CODEC_INDEX_SINK_LDAC};
+    BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+    BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+    BTAV_A2DP_CODEC_INDEX_SINK_SBC,
+    BTAV_A2DP_CODEC_INDEX_SINK_AAC, BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
+    BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3, BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5};
 constexpr uint16_t kPeerMtus[5] = {660, 663, 883, 1005, 1500};
 
 class TestSinkTransport
@@ -307,6 +313,24 @@ class BluetoothAudioClientInterfaceTest : public Test {
              ldac_config.bitsPerSample & ldac_capability.bitsPerSample);
         return is_codec_config_supported;
       }
+      // Savitech Patch - START  Offload
+      /*
+      case CodecType::LHDCV3:
+        [[fallthrough]];
+      case CodecType::LHDCV2:
+        [[fallthrough]];
+      case CodecType::LHDCV5: {
+        Lhdcv5Parameters lhdcv5_config = codec_config.config.lhdcv5Config();
+        Lhdcv5Parameters lhdcv5_capability =
+            codec_capability.capabilities.lhdcv5Capabilities();
+        is_codec_config_supported =
+            (lhdcv5_config.sampleRate & lhdcv5_capability.sampleRate &&
+             lhdcv5_config.channelMode & lhdcv5_capability.channelMode &&
+             lhdcv5_config.bitsPerSample & lhdcv5_capability.bitsPerSample);
+        return is_codec_config_supported;
+      }
+      */
+      // Savitech Patch - END
       case CodecType::APTX:
         [[fallthrough]];
       case CodecType::APTX_HD: {
@@ -649,6 +673,81 @@ TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLdacSession) {
   }
 }
 
+// Savitech Patch - START  Offload
+/*
+std::vector<CodecConfiguration> Lhdcv5CodecConfigurationsGenerator() {
+  std::vector<CodecConfiguration> lhdcv5_codec_configs;
+  CodecConfiguration codec_config = {};
+  Lhdcv5QualityIndex quality_indexes[10] = {
+      Lhdcv5QualityIndex::QUALITY_LOW4, Lhdcv5QualityIndex::QUALITY_LOW3,
+      Lhdcv5QualityIndex::QUALITY_LOW2, Lhdcv5QualityIndex::QUALITY_LOW1,
+    Lhdcv5QualityIndex::QUALITY_LOW0, Lhdcv5QualityIndex::QUALITY_LOW,
+    Lhdcv5QualityIndex::QUALITY_MID, Lhdcv5QualityIndex::QUALITY_HIGH,
+    Lhdcv5QualityIndex::QUALITY_HIGH1, Lhdcv5QualityIndex::QUALITY_ABR};
+  for (auto sample_rate_pair : kSampleRatePairs) {
+    for (auto bits_per_sample_pair : kBitsPerSamplePairs) {
+      for (auto channel_mode_pair : kChannelModePairs) {
+        for (auto peer_mtu : kPeerMtus) {
+          for (auto quality_index : quality_indexes) {
+            codec_config.codecType = CodecType::LHDCV5;
+            codec_config.peerMtu = peer_mtu;
+            codec_config.isScmstEnabled = false;
+            codec_config.encodedAudioBitrate = 400000;
+            Lhdcv5Parameters lhdc = {
+                .sampleRate = sample_rate_pair.hal_sample_rate_,
+                .channelMode = ChannelMode::STEREO,
+                .qualityIndex = quality_index,
+                .bitsPerSample = bits_per_sample_pair.hal_bits_per_sample_};
+            codec_config.config.lhdcv5Config(lhdc);
+            lhdcv5_codec_configs.push_back(codec_config);
+          }  // LdacQualityIndex
+        }    // peerMtu
+      }      // ChannelMode
+    }        // BitsPerSampple
+  }          // SampleRate
+  return lhdcv5_codec_configs;
+}
+
+TEST_F(BluetoothAudioClientInterfaceTest, A2dpLhdcv5CodecOffloadingState) {
+  test_sink_transport_ =
+      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
+  clientif_sink_ =
+      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
+  auto lhdcv5_codec_configs = Lhdcv5CodecConfigurationsGenerator();
+  for (auto codec_offloading_preference :
+       CodecOffloadingPreferenceGenerator(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
+    UpdateOffloadingCapabilities(codec_offloading_preference.preference_);
+    for (CodecConfiguration codec_config : lhdcv5_codec_configs) {
+      if (IsCodecOffloadingSupported(codec_config) &&
+          codec_offloading_preference.is_target_codec_included_) {
+        ASSERT_TRUE(IsCodecOffloadingEnabled(codec_config));
+      } else {
+        ASSERT_FALSE(IsCodecOffloadingEnabled(codec_config));
+      }
+    }
+  }
+}
+
+TEST_F(BluetoothAudioClientInterfaceTest, StartAndEndA2dpOffloadLhdcv5Session) {
+  test_sink_transport_ =
+      new TestSinkTransport(SessionType::A2DP_HARDWARE_OFFLOAD_DATAPATH);
+  clientif_sink_ =
+      new BluetoothAudioSinkClientInterface(test_sink_transport_, nullptr);
+  AudioConfiguration audio_config = {};
+  for (CodecConfiguration codec_config : Lhdcv5CodecConfigurationsGenerator()) {
+    audio_config.codecConfig(codec_config);
+    clientif_sink_->UpdateAudioConfig(audio_config);
+    if (IsCodecOffloadingSupported(codec_config)) {
+      ASSERT_EQ(clientif_sink_->StartSession(), kClientIfReturnSuccess);
+    } else {
+      ASSERT_NE(clientif_sink_->StartSession(), kClientIfReturnSuccess);
+    }
+    ASSERT_EQ(clientif_sink_->EndSession(), kClientIfReturnSuccess);
+  }
+}
+*/
+// Savitech Patch - END
+
 std::vector<CodecConfiguration> AptxCodecConfigurationsGenerator(
     CodecType codec_type) {
   std::vector<CodecConfiguration> aptx_codec_configs;
diff --git a/system_bt/audio_hal_interface/codec_status.cc b/system_bt/audio_hal_interface/codec_status.cc
index cd9d88e05..8ebcdb745 100644
--- a/system_bt/audio_hal_interface/codec_status.cc
+++ b/system_bt/audio_hal_interface/codec_status.cc
@@ -24,6 +24,7 @@
 #include "a2dp_vendor_aptx_constants.h"
 #include "a2dp_vendor_aptx_hd_constants.h"
 #include "a2dp_vendor_ldac_constants.h"
+#include "a2dp_vendor_lhdc_constants.h"
 #include "bta/av/bta_av_int.h"
 
 namespace {
@@ -39,6 +40,16 @@ using ::android::hardware::bluetooth::audio::V2_0::CodecType;
 using ::android::hardware::bluetooth::audio::V2_0::LdacChannelMode;
 using ::android::hardware::bluetooth::audio::V2_0::LdacParameters;
 using ::android::hardware::bluetooth::audio::V2_0::LdacQualityIndex;
+// Savitech Patch - START Offload
+/*
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Parameters;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5QualityIndex;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5FrameDuration;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5DataInterval;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Version;
+using ::android::hardware::bluetooth::audio::V2_0::Lhdcv5Specific;
+*/
+// Savitech Patch - END
 using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
 using ::android::hardware::bluetooth::audio::V2_0::SbcAllocMethod;
 using ::android::hardware::bluetooth::audio::V2_0::SbcBlockLength;
@@ -148,6 +159,30 @@ bool ldac_offloading_capability_match(const LdacParameters& ldac_capability,
           << " capability=" << toString(ldac_capability);
   return true;
 }
+
+// Savitech Patch - START  Offload
+/*
+bool lhdcv5_offloading_capability_match(const Lhdcv5Parameters& lhdcv5_capability,
+                                        const Lhdcv5Parameters& lhdcv5_config) {
+  if ((static_cast<SampleRate>(lhdcv5_capability.sampleRate &
+                               lhdcv5_config.sampleRate) ==
+       SampleRate::RATE_UNKNOWN) ||
+      (static_cast<ChannelMode>(lhdcv5_capability.channelMode &
+                                    lhdcv5_config.channelMode) ==
+       ChannelMode::UNKNOWN) ||
+      (static_cast<BitsPerSample>(lhdcv5_capability.bitsPerSample &
+                                  lhdcv5_config.bitsPerSample) ==
+       BitsPerSample::BITS_UNKNOWN)) {
+    LOG(WARNING) << __func__ << ": software codec=" << toString(lhdcv5_config)
+                 << " capability=" << toString(lhdcv5_capability);
+    return false;
+  }
+  VLOG(1) << __func__ << ": offloading codec=" << toString(lhdcv5_config)
+          << " capability=" << toString(lhdcv5_capability);
+  return true;
+}
+*/
+// Savitech Patch - END
 }  // namespace
 
 namespace bluetooth {
@@ -211,6 +246,26 @@ ChannelMode A2dpCodecToHalChannelMode(
   }
 }
 
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+/*
+LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
+    const btav_a2dp_codec_config_t& a2dp_codec_config) {
+  switch ((int)(a2dp_codec_config.codec_specific_2 & 0x1)) {
+    case 0:
+      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
+      return LhdcLowLatencyEn::Disabled;
+    case 1:
+      LOG(INFO) << __func__ << ": LHDC low latency Enabled";
+      return LhdcLowLatencyEn::Enabled;
+    default:
+      LOG(INFO) << __func__ << ": LHDC low latency Disabled";
+      return LhdcLowLatencyEn::Disabled;
+  }
+}
+*/
+// Savitech Patch - End
+
 bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
                         A2dpCodecConfig* a2dp_config) {
   btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
@@ -470,6 +525,88 @@ bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
   return true;
 }
 
+// Savitech Patch - START  Offload
+#if 0
+//require definition supported in hardware/interfaces/bluetooth/audio/types.hal
+bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config) {
+  btav_a2dp_codec_config_t current_codec = a2dp_config->getCodecConfig();
+  if ((current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) &&
+      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) &&
+      (current_codec.codec_type != BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5)) {
+    codec_config = {};
+    return false;
+  }
+  LOG(INFO) << __func__ << ": enter: codec_type = " << current_codec.codec_type;
+
+  tBT_A2DP_OFFLOAD a2dp_offload;
+  if (false == a2dp_config->getCodecSpecificConfig(&a2dp_offload) ) {
+    LOG(ERROR) << __func__ << ": getCodecSpecificConfig fail";
+    return false;
+  }
+
+  if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3) {
+    codec_config->codecType = CodecType::LHDCV3;
+  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2) {
+    codec_config->codecType = CodecType::LHDCV2;
+  } else if (current_codec.codec_type == BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5) {
+    codec_config->codecType = CodecType::LHDCV5;
+  }
+  codec_config->config.lhdcv5Config({});
+  auto lhdcv5Config = codec_config->config.lhdcv5Config();
+
+  lhdcv5Config.sampleRate = A2dpCodecToHalSampleRate(current_codec);
+  if (lhdcv5Config.sampleRate == SampleRate::RATE_UNKNOWN) {
+    LOG(ERROR) << __func__
+               << ": Unknown LHDC Vn sample_rate=" << current_codec.sample_rate;
+    return false;
+  }
+
+  lhdcv5Config.channelMode = A2dpCodecToHalChannelMode(current_codec);
+  if (lhdcv5Config.channelMode == ChannelMode::UNKNOWN) {
+    LOG(ERROR) << __func__
+               << ": Unknown LHDC Vn channel_mode=" << current_codec.channel_mode;
+    return false;
+  }
+
+  lhdcv5Config.bitsPerSample = A2dpCodecToHalBitsPerSample(current_codec);
+  if (lhdcv5Config.bitsPerSample == BitsPerSample::BITS_UNKNOWN) {
+    LOG(ERROR) << __func__ << ": Unknown LHDC Vn bits_per_sample="
+               << current_codec.bits_per_sample;
+    return false;
+  }
+
+  lhdcv5Config.codecVersion            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Version) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_VER];
+  lhdcv5Config.qualityIndex            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
+                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L]));
+  lhdcv5Config.maxQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
+                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L]));
+  lhdcv5Config.minQualityIndex         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5QualityIndex)
+                                         ((((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]) << 8) | ((unsigned short) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]));
+  lhdcv5Config.frameDuration           = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5FrameDuration) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR];
+  lhdcv5Config.dataInterval            = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5DataInterval)  a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL];
+  lhdcv5Config.codecSpecific_1         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1];
+  lhdcv5Config.codecSpecific_2         = (::vendor::mediatek::hardware::bluetooth::audio::V2_1::Lhdcv5Specific)      a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2];
+  lhdcv5Config.metaData[0]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META];
+  lhdcv5Config.metaData[1]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 1];
+  lhdcv5Config.metaData[2]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 2];
+  lhdcv5Config.metaData[3]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 3];
+  lhdcv5Config.metaData[4]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 4];
+  lhdcv5Config.metaData[5]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 5];
+  lhdcv5Config.metaData[6]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 6];
+  lhdcv5Config.metaData[7]             = (unsigned char) a2dp_offload.codec_info[A2DP_OFFLOAD_LHDC_CFG_META + 7];
+
+  codec_config->config.lhdcv5Config(lhdcv5Config);
+
+  LOG(INFO) << __func__ << ": debug: sampleRate = " << current_codec.sample_rate;
+  LOG(INFO) << __func__ << ": debug: bitsPerSample = " << current_codec.bits_per_sample;
+  LOG(INFO) << __func__ << ": debug: channelMode = " << current_codec.channel_mode;
+
+  return true;
+}
+#endif
+// Savitech Patch - END
+
 bool UpdateOffloadingCapabilities(
     const std::vector<btav_a2dp_codec_config_t>& framework_preference) {
   audio_hal_capabilities = BluetoothAudioClientInterface::GetAudioCapabilities(
@@ -492,10 +629,38 @@ bool UpdateOffloadingCapabilities(
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         codec_type_masks |= CodecType::LDAC;
         break;
+      // Savitech Patch - START  Offload
+#if 0
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        codec_type_masks |= CodecType::LHDCV3;
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+        codec_type_masks |= CodecType::LHDCV2;
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        codec_type_masks |= CodecType::LHDCV5;
+        break;
+#else
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        [[fallthrough]];
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+        [[fallthrough]];
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        LOG(WARNING) << __func__
+                     << ": Ignore source codec_type=" << preference.codec_type;
+        break;
+#endif
+      // Savitech Patch - END
       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
         [[fallthrough]];
       case BTAV_A2DP_CODEC_INDEX_SINK_AAC:
         [[fallthrough]];
+      // Savitech Patch - START  Offload
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+          [[fallthrough]];
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+        [[fallthrough]];
+      // Savitech Patch - END
       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
         LOG(WARNING) << __func__
                      << ": Ignore sink codec_type=" << preference.codec_type;
@@ -554,6 +719,21 @@ bool IsCodecOffloadingEnabled(const CodecConfiguration& codec_config) {
         auto ldac_config = codec_config.config.ldacConfig();
         return ldac_offloading_capability_match(ldac_capability, ldac_config);
       }
+      // Savitech Patch - START  Offload
+      /*
+      case CodecType::LHDCV3:
+        [[fallthrough]];
+      case CodecType::LHDCV2:
+        [[fallthrough]];
+      case CodecType::LHDCV5: {
+        LOG(INFO) << __func__ << ": LHDC aDSP codecType="
+                   << toString(codec_capability.codecType);
+        auto lhdcv5_capability = codec_capability.capabilities.lhdcv5Capabilities();
+        auto lhdcv5_config = codec_config.config.lhdcv5Config();
+        return lhdcv5_offloading_capability_match(lhdcv5_capability, lhdcv5_config);
+      }
+      */
+      // Savitech Patch - END
       case CodecType::UNKNOWN:
         [[fallthrough]];
       default:
diff --git a/system_bt/audio_hal_interface/codec_status.h b/system_bt/audio_hal_interface/codec_status.h
index e0e074438..6a476f086 100644
--- a/system_bt/audio_hal_interface/codec_status.h
+++ b/system_bt/audio_hal_interface/codec_status.h
@@ -28,6 +28,10 @@ namespace codec {
 
 using ::android::hardware::bluetooth::audio::V2_0::BitsPerSample;
 using ::android::hardware::bluetooth::audio::V2_0::ChannelMode;
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+//using ::vendor::mediatek::hardware::bluetooth::audio::V2_0::LhdcLowLatencyEn;
+// Savitech Patch - End
 using ::android::hardware::bluetooth::audio::V2_0::CodecConfiguration;
 using ::android::hardware::bluetooth::audio::V2_0::SampleRate;
 
@@ -39,6 +43,13 @@ BitsPerSample A2dpCodecToHalBitsPerSample(
     const btav_a2dp_codec_config_t& a2dp_codec_config);
 ChannelMode A2dpCodecToHalChannelMode(
     const btav_a2dp_codec_config_t& a2dp_codec_config);
+// Savitech Patch - Start
+//   LHDC_Low_Latency(non-offload)
+/*
+LhdcLowLatencyEn A2dpCodecToHalLhdcLowLatencyMode(
+    const btav_a2dp_codec_config_t& a2dp_codec_config);
+    */
+// Savitech Patch - End
 
 bool A2dpSbcToHalConfig(CodecConfiguration* codec_config,
                         A2dpCodecConfig* a2dp_config);
@@ -48,7 +59,10 @@ bool A2dpAptxToHalConfig(CodecConfiguration* codec_config,
                          A2dpCodecConfig* a2dp_config);
 bool A2dpLdacToHalConfig(CodecConfiguration* codec_config,
                          A2dpCodecConfig* a2dp_config);
-
+// Savitech Patch - START  Offload
+bool A2dpLhdcv5ToHalConfig(CodecConfiguration* codec_config,
+                         A2dpCodecConfig* a2dp_config);
+// Savitech Patch - END
 bool UpdateOffloadingCapabilities(
     const std::vector<btav_a2dp_codec_config_t>& framework_preference);
 // Check whether this codec is supported by the audio HAL and is allowed to use
diff --git a/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl b/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl
index 94379af56..3d06096cd 100644
--- a/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl
+++ b/system_bt/binder/android/bluetooth/IBluetoothA2dp.aidl
@@ -90,4 +90,17 @@ interface IBluetoothA2dp {
     boolean setBufferLengthMillis(int codec, int size, in AttributionSource attributionSource);
     @JavaPassthrough(annotation="@android.annotation.RequiresPermission(android.Manifest.permission.BLUETOOTH_CONNECT)")
     int getPriority(in BluetoothDevice device, in AttributionSource attributionSource);
+
+    //Savitech LHDC EXT API -- START
+    //  get revision of the API
+    int getLhdcCodecExtendApiVer(in BluetoothDevice device, inout byte[] exApiVer);
+    //  get/set config-type APIs
+    int setLhdcCodecExtendApiConfigAr(in BluetoothDevice device, in byte[] codecConfig);
+    int getLhdcCodecExtendApiConfigAr(in BluetoothDevice device, inout byte[] codecConfig);
+    int setLhdcCodecExtendApiConfigMeta(in BluetoothDevice device, in byte[] codecConfig);
+    int getLhdcCodecExtendApiConfigMeta(in BluetoothDevice device, inout byte[] codecConfig);
+    int getLhdcCodecExtendApiConfigA2dpCodecSpecific(in BluetoothDevice device, inout byte[] codecConfig);
+    //  set data-type APIs
+    oneway void setLhdcCodecExtendApiDataGyro2D(in BluetoothDevice device, in byte[] codecData);
+    //Savitech LHDC EXT API -- END
 }
diff --git a/system_bt/bta/av/bta_av_aact.cc b/system_bt/bta/av/bta_av_aact.cc
index 33298d649..50d7433c9 100644
--- a/system_bt/bta/av/bta_av_aact.cc
+++ b/system_bt/bta/av/bta_av_aact.cc
@@ -3198,6 +3198,17 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
       codec_type = BTA_AV_CODEC_TYPE_LDAC;
       break;
+    // Savitech Patch - START  Offload
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      codec_type = BTA_AV_CODEC_TYPE_LHDCV3;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      codec_type = BTA_AV_CODEC_TYPE_LHDCV2;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      codec_type = BTA_AV_CODEC_TYPE_LHDCV5;
+      break;
+    // Savitech Patch - END
     default:
       APPL_TRACE_ERROR("%s: Unknown Codec type ", __func__);
       return;
@@ -3231,6 +3242,14 @@ static void bta_av_offload_codec_builder(tBTA_AV_SCB* p_scb,
     case 96000:
       p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
       break;
+    // Savitech Patch - START  Offload
+    case 176400:
+      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_176400;
+      break;
+    case 192000:
+      p_a2dp_offload->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+      break;
+    // Savitech Patch - END
   }
   if (L2CA_GetRemoteCid(p_scb->l2c_cid, &p_a2dp_offload->l2c_rcid) == false) {
     APPL_TRACE_ERROR("%s: Failed to fetch l2c rcid", __func__);
diff --git a/system_bt/bta/include/bta_av_api.h b/system_bt/bta/include/bta_av_api.h
index 4591bbaef..1aacad72c 100644
--- a/system_bt/bta/include/bta_av_api.h
+++ b/system_bt/bta/include/bta_av_api.h
@@ -151,7 +151,12 @@ typedef enum {
   BTA_AV_CODEC_TYPE_AAC = 0x02,
   BTA_AV_CODEC_TYPE_APTX = 0x04,
   BTA_AV_CODEC_TYPE_APTXHD = 0x08,
-  BTA_AV_CODEC_TYPE_LDAC = 0x10
+  BTA_AV_CODEC_TYPE_LDAC = 0x10,
+  // Savitech Patch - START
+  BTA_AV_CODEC_TYPE_LHDCV3 = 0x20,
+  BTA_AV_CODEC_TYPE_LHDCV2 = 0x40,
+  BTA_AV_CODEC_TYPE_LHDCV5 = 0x80,
+  // Savitech Patch - END
 } tBTA_AV_CODEC_TYPE;
 
 /* Event associated with BTA_AV_ENABLE_EVT */
diff --git a/system_bt/btif/co/bta_av_co.cc b/system_bt/btif/co/bta_av_co.cc
index 463612011..889f2ceaa 100644
--- a/system_bt/btif/co/bta_av_co.cc
+++ b/system_bt/btif/co/bta_av_co.cc
@@ -959,7 +959,7 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(
   // Select the Source codec
   const BtaAvCoSep* p_sink = nullptr;
   if (p_peer->acceptor) {
-    UpdateAllSelectableSourceCodecs(p_peer);
+    size_t updated_codecs = UpdateAllSelectableSourceCodecs(p_peer);
     if (p_peer->p_sink == nullptr) {
       // Update the selected codec
       p_peer->p_sink =
@@ -971,6 +971,10 @@ tA2DP_STATUS BtaAvCo::ProcessSourceGetConfig(
                        __func__, p_peer->addr.ToString().c_str());
       return A2DP_FAIL;
     }
+    /* Savitech Patch: Dispatch the event to make sure the recent UPDATED info is reported. */
+    if (updated_codecs > 0) {
+      ReportSourceCodecState(p_peer);
+    }
   } else {
     if (btif_av_peer_prefers_mandatory_codec(p_peer->addr)) {
       // Apply user preferred codec directly before first codec selected.
@@ -2217,3 +2221,139 @@ btav_a2dp_scmst_info_t bta_av_co_get_scmst_info(
 }
 
 void btif_a2dp_codec_debug_dump(int fd) { bta_av_co_cb.DebugDump(fd); }
+
+/************************************************
+ * Savitech LHDC EXT API -- START
+ ***********************************************/
+// LHDC Extended API: get target API version
+int bta_av_co_get_codec_LHDC_user_ApiVer(
+    const RawAddress& peer_address,
+    const char *version, const int clen) {
+
+  int success = BT_STATUS_SUCCESS;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    success = p_peer->GetCodecs()->getLHDCCodecUserApiVer(peerCodec, version, clen);
+    goto done;
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+done:
+  return success;
+}
+
+// LHDC extended API: get user config
+int bta_av_co_get_codec_LHDC_user_config(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  int success = BT_STATUS_SUCCESS;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    success = p_peer->GetCodecs()->getLHDCCodecUserConfig(peerCodec, config, clen);
+    goto done;
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+done:
+  return success;
+}
+
+// LHDC extended API: set user config
+int bta_av_co_set_codec_LHDC_user_config(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  int success = BT_STATUS_SUCCESS;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    success = p_peer->GetCodecs()->setLHDCCodecUserConfig(peerCodec, config, clen);
+    goto done;
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = BT_STATUS_NOT_READY;
+    goto done;
+  }
+
+done:
+  return success;
+}
+
+// LHDC extended API: set user data
+bool bta_av_co_set_codec_LHDC_user_data(
+    const RawAddress& peer_address,
+    const char *data, const int clen) {
+
+  bool success = true;
+  A2dpCodecConfig* peerCodec = NULL;
+
+  BtaAvCoPeer* p_peer = bta_av_co_cb.FindPeer(peer_address);
+  if (p_peer == nullptr) {
+    APPL_TRACE_ERROR("%s: cannot find peer %s to configure", __func__,
+        peer_address.ToString().c_str());
+    success = false;
+    goto done;
+  }
+
+  peerCodec = p_peer->GetCodecs()->getCurrentCodecConfig();
+  if (peerCodec) {
+    APPL_TRACE_DEBUG("%s: peerCodec: name=%s, codecIndex=%d", __func__,
+        peerCodec->name().c_str(), peerCodec->codecIndex());
+    if (!p_peer->GetCodecs()->setLHDCCodecUserData(peerCodec, data, clen)) {
+      success = false;
+      goto done;
+    }
+  } else {
+    APPL_TRACE_WARNING("%s: Fail to get current codec of peer!", __func__);
+    success = false;
+    goto done;
+  }
+
+done:
+  return success;
+}
+/************************************************
+ * Savitech LHDC EXT API -- END
+ ***********************************************/
diff --git a/system_bt/btif/include/btif_a2dp_source.h b/system_bt/btif/include/btif_a2dp_source.h
index 60e5e0d3d..01e32a743 100644
--- a/system_bt/btif/include/btif_a2dp_source.h
+++ b/system_bt/btif/include/btif_a2dp_source.h
@@ -133,4 +133,23 @@ void btif_a2dp_source_debug_dump(int fd);
 void btif_a2dp_source_set_dynamic_audio_buffer_size(
     uint8_t dynamic_audio_buffer_size);
 
+//
+// Savitech LHDC EXT API -- START
+//
+int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int btif_a2dp_source_encoder_LHDC_user_config_update_req(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+void btif_a2dp_source_encoder_LHDC_user_data_update_req(
+    uint16_t event, char* p_param);
+// Savitech LHDC EXT API -- END
+
 #endif /* BTIF_A2DP_SOURCE_H */
diff --git a/system_bt/btif/include/btif_av_co.h b/system_bt/btif/include/btif_av_co.h
index 01b3b2fd0..5a8943557 100644
--- a/system_bt/btif/include/btif_av_co.h
+++ b/system_bt/btif/include/btif_av_co.h
@@ -86,4 +86,24 @@ A2dpCodecConfig* bta_av_get_a2dp_peer_current_codec(
 // information.
 void btif_a2dp_codec_debug_dump(int fd);
 
+//
+// Savitech LHDC EXT API -- START
+//
+int bta_av_co_get_codec_LHDC_user_ApiVer(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int bta_av_co_get_codec_LHDC_user_config(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+int bta_av_co_set_codec_LHDC_user_config(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+
+bool bta_av_co_set_codec_LHDC_user_data(
+    const RawAddress& peer_addr,
+    const char *config, const int clen);
+// Savitech LHDC EXT API -- END
+
 #endif  // BTIF_AV_CO_H
diff --git a/system_bt/btif/src/btif_a2dp_audio_interface.cc b/system_bt/btif/src/btif_a2dp_audio_interface.cc
index 7d7a083a3..2b60cc72f 100644
--- a/system_bt/btif/src/btif_a2dp_audio_interface.cc
+++ b/system_bt/btif/src/btif_a2dp_audio_interface.cc
@@ -232,6 +232,23 @@ static void btif_a2dp_get_codec_configuration(
       p_codec_info->codecSpecific.ldacData.bitrateIndex =
           a2dp_offload.codec_info[6];
       break;
+    // Savitech Patch - START  Offload
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      p_codec_info->codecType =
+          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
+          BTA_AV_CODEC_TYPE_LHDCV3;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      p_codec_info->codecType =
+          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
+          BTA_AV_CODEC_TYPE_LHDCV2;
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      p_codec_info->codecType =
+          (::android::hardware::bluetooth::a2dp::V1_0::CodecType)
+          BTA_AV_CODEC_TYPE_LHDCV5;
+      break;
+    // Savitech Patch - END
     default:
       APPL_TRACE_ERROR("%s: Unknown Codec type :%d ", __func__,
                        codec_config.codec_type);
diff --git a/system_bt/btif/src/btif_a2dp_sink.cc b/system_bt/btif/src/btif_a2dp_sink.cc
index fa02a8682..2d905b616 100644
--- a/system_bt/btif/src/btif_a2dp_sink.cc
+++ b/system_bt/btif/src/btif_a2dp_sink.cc
@@ -90,6 +90,7 @@ class BtifA2dpSinkControlBlock {
         sample_rate(0),
         channel_count(0),
         rx_focus_state(BTIF_A2DP_SINK_FOCUS_NOT_GRANTED),
+        //rx_focus_state(BTIF_A2DP_SINK_FOCUS_GRANTED),   //Savitech -- Enable A2DP Sink
         audio_track(nullptr),
         decoder_interface(nullptr) {}
 
@@ -105,6 +106,7 @@ class BtifA2dpSinkControlBlock {
     decode_alarm = nullptr;
     rx_flush = false;
     rx_focus_state = BTIF_A2DP_SINK_FOCUS_NOT_GRANTED;
+    //rx_focus_state = BTIF_A2DP_SINK_FOCUS_GRANTED;  //Savitech -- Enable A2DP Sink
     sample_rate = 0;
     channel_count = 0;
     decoder_interface = nullptr;
diff --git a/system_bt/btif/src/btif_a2dp_source.cc b/system_bt/btif/src/btif_a2dp_source.cc
index 19bf998ab..94c5bfd78 100644
--- a/system_bt/btif/src/btif_a2dp_source.cc
+++ b/system_bt/btif/src/btif_a2dp_source.cc
@@ -271,6 +271,24 @@ static void btm_read_rssi_cb(void* data);
 static void btm_read_failed_contact_counter_cb(void* data);
 static void btm_read_tx_power_cb(void* data);
 
+// Savitech LHDC EXT API -- START
+static int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(
+    const RawAddress& peer_address,
+    const char *version, const int clen);
+
+static int btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen);
+
+static int btif_a2dp_source_encoder_LHDC_user_config_update_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen);
+
+static void btif_a2dp_source_encoder_LHDC_user_data_update_event(
+    const RawAddress& peer_address,
+    const char *data, const int clen);
+// Savitech LHDC EXT API -- END
+
 void btif_a2dp_source_accumulate_scheduling_stats(SchedulingStats* src,
                                                   SchedulingStats* dst) {
   dst->total_updates += src->total_updates;
@@ -904,10 +922,26 @@ static uint32_t btif_a2dp_source_read_callback(uint8_t* p_buf, uint32_t len) {
   uint16_t event;
   uint32_t bytes_read = 0;
 
-  if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
-    bytes_read = bluetooth::audio::a2dp::read(p_buf, len);
-  } else if (a2dp_uipc != nullptr) {
-    bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf, len);
+  uint32_t bytes_offset = 0;
+  uint32_t len_read = len;
+  uint32_t timeout_cnt = 0;
+
+  while (true) {
+    if (bluetooth::audio::a2dp::is_hal_2_0_enabled()) {
+      bytes_read = bluetooth::audio::a2dp::read(p_buf + bytes_offset, len_read);
+    } else if (a2dp_uipc != nullptr) {
+      bytes_read = UIPC_Read(*a2dp_uipc, UIPC_CH_ID_AV_AUDIO, &event, p_buf + bytes_offset, len_read);
+    }
+
+    // Savitech LHDC -- Low Latency Mode
+    bytes_offset += bytes_read;
+    len_read -= bytes_read;
+    timeout_cnt++;
+    if (len_read <= 0 || timeout_cnt >= 5) {
+        bytes_read = bytes_offset;
+        break;
+    }
+    usleep(1000);
   }
 
   if (bytes_read < len) {
@@ -1383,3 +1417,71 @@ static void btm_read_tx_power_cb(void* data) {
   LOG_WARN("%s: device: %s, Tx Power: %d", __func__,
            result->rem_bda.ToString().c_str(), result->tx_power);
 }
+
+//
+// Savitech LHDC EXT API -- START
+//
+// LHDC extended API: get API revision
+int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(
+    const RawAddress& peer_address,
+    const char *version, const int clen) {
+
+  return btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(peer_address, version, clen);
+}
+static int btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_event(
+    const RawAddress& peer_address,
+    const char *version, const int clen) {
+
+  return bta_av_co_get_codec_LHDC_user_ApiVer(peer_address, version, clen);
+}
+
+// LHDC extended API: get config
+int btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(peer_address, config, clen);
+}
+static int btif_a2dp_source_encoder_LHDC_user_config_retrieve_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return bta_av_co_get_codec_LHDC_user_config(peer_address, config, clen);
+}
+
+// LHDC extended API: set config
+int btif_a2dp_source_encoder_LHDC_user_config_update_req(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return btif_a2dp_source_encoder_LHDC_user_config_update_event(peer_address, config, clen);
+}
+static int btif_a2dp_source_encoder_LHDC_user_config_update_event(
+    const RawAddress& peer_address,
+    const char *config, const int clen) {
+
+  return bta_av_co_set_codec_LHDC_user_config(peer_address, config, clen);
+}
+
+// LHDC extended API: set user data
+void btif_a2dp_source_encoder_LHDC_user_data_update_req(
+    uint16_t event, char* p_param){
+
+  btif_av_codec_lhdc_api_data_t *pData;
+  pData = (btif_av_codec_lhdc_api_data_t *) p_param;
+  RawAddress peer_address;
+  memcpy(&peer_address, &(pData->bd_addr), sizeof(RawAddress) );
+  char *data = pData->pData;
+  int clen = pData->clen;
+
+  btif_a2dp_source_thread.DoInThread(
+      FROM_HERE, base::Bind(&btif_a2dp_source_encoder_LHDC_user_data_update_event,
+          peer_address, data, clen));
+}
+static void btif_a2dp_source_encoder_LHDC_user_data_update_event(
+    const RawAddress& peer_address,
+    const char *data, const int clen) {
+
+  bta_av_co_set_codec_LHDC_user_data(peer_address, data, clen);
+}
+// Savitech LHDC EXT API -- END
diff --git a/system_bt/btif/src/btif_av.cc b/system_bt/btif/src/btif_av.cc
index 50717d9eb..aa642caf4 100644
--- a/system_bt/btif/src/btif_av.cc
+++ b/system_bt/btif/src/btif_av.cc
@@ -17,6 +17,7 @@
  ******************************************************************************/
 
 #define LOG_TAG "btif_av"
+#define SAVITECH_A2DP_SINKx  // Savitech Patch - A2DP_Sink_Enable
 
 #include <base/bind.h>
 #include <base/strings/stringprintf.h>
@@ -700,6 +701,7 @@ static void btif_av_sink_initiate_av_open_timer_timeout(void* data);
 static void bta_av_sink_media_callback(const RawAddress& peer_address,
                                        tBTA_AV_EVT event,
                                        tBTA_AV_MEDIA* p_data);
+static BtifAvPeer* btif_av_find_active_peer();
 
 static BtifAvPeer* btif_av_source_find_peer(const RawAddress& peer_address) {
   return btif_av_source.FindPeer(peer_address);
@@ -708,16 +710,68 @@ static BtifAvPeer* btif_av_sink_find_peer(const RawAddress& peer_address) {
   return btif_av_sink.FindPeer(peer_address);
 }
 static BtifAvPeer* btif_av_find_peer(const RawAddress& peer_address) {
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* avPeer = NULL;
+  avPeer = btif_av_find_active_peer();
+  if(avPeer) {
+    if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
+      return btif_av_sink_find_peer(peer_address);
+    }
+    if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
+      return btif_av_source_find_peer(peer_address);
+    }
+  }
+  return nullptr;
+#else
   if (btif_av_source.Enabled()) return btif_av_source_find_peer(peer_address);
   if (btif_av_sink.Enabled()) return btif_av_sink_find_peer(peer_address);
   return nullptr;
+#endif
 }
 static BtifAvPeer* btif_av_find_active_peer() {
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* activePeerIsSink = NULL;
+  BtifAvPeer* activePeerIsSrc = NULL;
+
+  if (btif_av_source.Enabled()) {
+    BTIF_TRACE_VERBOSE("%s: SRC Find -> ActivePeer:%s (%p)", __func__,
+      btif_av_source.ActivePeer().ToString().c_str(),
+      btif_av_source_find_peer(btif_av_source.ActivePeer()));
+    activePeerIsSink = btif_av_source_find_peer(btif_av_source.ActivePeer());
+  }
+  if (btif_av_sink.Enabled()) {
+    BTIF_TRACE_VERBOSE("%s: Sink Find -> ActivePeer:%s (%p)", __func__,
+        btif_av_sink.ActivePeer().ToString().c_str(),
+        btif_av_sink_find_peer(btif_av_sink.ActivePeer()));
+    activePeerIsSrc = btif_av_sink_find_peer(btif_av_sink.ActivePeer());
+  }
+
+  if( activePeerIsSrc != NULL && activePeerIsSink != NULL) {
+    //should not happened here
+    BTIF_TRACE_WARNING("%s: WARNING! Have both Src/Sink ActivePeers! (use default: SRC)", __func__);
+    return activePeerIsSrc;
+  }
+  if( activePeerIsSink != NULL) {
+    //AVDT_TSEP_SNK(1)
+    BTIF_TRACE_VERBOSE("%s: activePeerIsSink:%s Sep:%d", __func__,
+        activePeerIsSink->PeerAddress().ToString().c_str(), activePeerIsSink->PeerSep());
+    return activePeerIsSink;
+  }
+  if( activePeerIsSrc != NULL) {
+    //AVDT_TSEP_SRC(0)
+    BTIF_TRACE_VERBOSE("%s: activePeerIsSrc:%s Sep:%d", __func__,
+        activePeerIsSrc->PeerAddress().ToString().c_str(), activePeerIsSrc->PeerSep());
+    return activePeerIsSrc;
+  }
+  BTIF_TRACE_VERBOSE("%s: no any active peer found, Ret null", __func__);
+  return nullptr;
+#else
   if (btif_av_source.Enabled())
     return btif_av_source_find_peer(btif_av_source.ActivePeer());
   if (btif_av_sink.Enabled())
     return btif_av_sink_find_peer(btif_av_sink.ActivePeer());
   return nullptr;
+#endif
 }
 
 /*****************************************************************************
@@ -1495,6 +1549,34 @@ bool BtifAvStateMachine::StateIdle::ProcessEvent(uint32_t event, void* p_data) {
 
       bool can_connect = true;
       // Check whether connection is allowed
+#ifdef SAVITECH_A2DP_SINK
+      if (peer_.IsSink()) {
+        can_connect = btif_av_source.AllowedToConnect(peer_.PeerAddress());
+        if (!can_connect) {
+          src_disconnect_sink(peer_.PeerAddress());
+        } else {
+          alarm_set_on_mloop(
+                peer_.AvOpenOnRcTimer(), BtifAvPeer::kTimeoutAvOpenOnRcMs,
+                btif_av_source_initiate_av_open_timer_timeout, &peer_);
+        }
+      } else if (peer_.IsSource()) {
+        can_connect = btif_av_sink.AllowedToConnect(peer_.PeerAddress());
+        if (!can_connect) {
+          sink_disconnect_src(peer_.PeerAddress());
+        } else {
+          alarm_set_on_mloop(peer_.AvOpenOnRcTimer(),
+                               BtifAvPeer::kTimeoutAvOpenOnRcMs,
+                               btif_av_sink_initiate_av_open_timer_timeout, &peer_);
+        }
+      }
+      if (!can_connect) {
+        BTIF_TRACE_ERROR(
+            "%s: Cannot connect to peer %s: too many connected "
+            "peers",
+            __PRETTY_FUNCTION__, peer_.PeerAddress().ToString().c_str());
+        break;
+      }
+#else
       if (peer_.IsSink()) {
         can_connect = btif_av_source.AllowedToConnect(peer_.PeerAddress());
         if (!can_connect) src_disconnect_sink(peer_.PeerAddress());
@@ -1518,6 +1600,7 @@ bool BtifAvStateMachine::StateIdle::ProcessEvent(uint32_t event, void* p_data) {
                            BtifAvPeer::kTimeoutAvOpenOnRcMs,
                            btif_av_sink_initiate_av_open_timer_timeout, &peer_);
       }
+#endif
       if (event == BTA_AV_RC_OPEN_EVT) {
         btif_rc_handler(event, (tBTA_AV*)p_data);
       }
@@ -2380,6 +2463,32 @@ static void btif_report_connection_state(const RawAddress& peer_address,
   LOG_INFO("%s: peer_address=%s state=%d", __func__,
            peer_address.ToString().c_str(), state);
 
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* activePeer = NULL;
+  activePeer = btif_av_find_active_peer();
+  if(activePeer) {
+    if(activePeer->PeerSep()==AVDT_TSEP_SRC) {
+      LOG_INFO( "%s: ImSink -> connection_state_cb..", __func__);
+      do_in_jni_thread(FROM_HERE,
+          base::Bind(btif_av_sink.Callbacks()->connection_state_cb, peer_address, state));
+    }
+    if(activePeer->PeerSep()==AVDT_TSEP_SNK) {
+      LOG_INFO( "%s: ImSRC -> connection_state_cb..", __func__);
+      do_in_jni_thread(FROM_HERE,
+          base::Bind(btif_av_source.Callbacks()->connection_state_cb, peer_address, state));
+    }
+  } else {
+      if (btif_av_source.Enabled()) {
+        LOG_INFO( "%s: no active peer, source->connection_state_cb..", __func__);
+        do_in_jni_thread(FROM_HERE,
+            base::Bind(btif_av_source.Callbacks()->connection_state_cb, peer_address, state));
+      } else if (btif_av_sink.Enabled()) {
+        LOG_INFO( "%s: no active peer, sink->connection_state_cb..", __func__);
+        do_in_jni_thread(FROM_HERE,
+            base::Bind(btif_av_sink.Callbacks()->connection_state_cb, peer_address, state));
+      }
+  }
+#else
   if (btif_av_source.Enabled()) {
     do_in_jni_thread(FROM_HERE,
                      base::Bind(btif_av_source.Callbacks()->connection_state_cb,
@@ -2389,6 +2498,7 @@ static void btif_report_connection_state(const RawAddress& peer_address,
                      base::Bind(btif_av_sink.Callbacks()->connection_state_cb,
                                 peer_address, state));
   }
+#endif
 }
 
 /**
@@ -2405,6 +2515,36 @@ static void btif_report_audio_state(const RawAddress& peer_address,
   LOG_INFO("%s: peer_address=%s state=%d", __func__,
            peer_address.ToString().c_str(), state);
 
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* avPeer = NULL;
+  avPeer = btif_av_find_active_peer();
+  if(avPeer) {
+    if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
+      LOG_INFO( "%s: ImSink -> audio_state_cb..", __func__);
+        do_in_jni_thread(FROM_HERE,
+            base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
+                peer_address, state));
+    }
+    if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
+      LOG_INFO( "%s: ImSRC -> audio_state_cb..", __func__);
+        do_in_jni_thread(FROM_HERE,
+            base::Bind(btif_av_source.Callbacks()->audio_state_cb,
+                peer_address, state));
+    }
+  } else {
+      if (btif_av_source.Enabled()) {
+        LOG_INFO( "%s: no active peer, source->audio_state_cb..", __func__);
+          do_in_jni_thread(FROM_HERE,
+                           base::Bind(btif_av_source.Callbacks()->audio_state_cb,
+                                      peer_address, state));
+      } else if (btif_av_sink.Enabled()) {
+        LOG_INFO( "%s: no active peer, sink->audio_state_cb..", __func__);
+          do_in_jni_thread(FROM_HERE,
+                           base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
+                                      peer_address, state));
+      }
+  }
+#else
   if (btif_av_source.Enabled()) {
     do_in_jni_thread(FROM_HERE,
                      base::Bind(btif_av_source.Callbacks()->audio_state_cb,
@@ -2414,7 +2554,7 @@ static void btif_report_audio_state(const RawAddress& peer_address,
                      base::Bind(btif_av_sink.Callbacks()->audio_state_cb,
                                 peer_address, state));
   }
-
+#endif
   using android::bluetooth::a2dp::AudioCodingModeEnum;
   using android::bluetooth::a2dp::PlaybackStateEnum;
   PlaybackStateEnum playback_state = PlaybackStateEnum::PLAYBACK_STATE_UNKNOWN;
@@ -3026,6 +3166,88 @@ static void cleanup_sink(void) {
                                           base::Unretained(&btif_av_sink)));
 }
 
+// Savitech LHDC EXT API -- START
+static int lhdc_getApiVer_src(
+    const RawAddress& peer_address,
+    char* version, int clen) {
+
+  int status = BT_STATUS_NOT_READY;
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return BT_STATUS_NOT_READY;
+  }
+
+  status = btif_a2dp_source_encoder_LHDC_user_ApiVer_retrieve_req(peer_address, version, clen);
+
+  if (status != BT_STATUS_SUCCESS) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
+  }
+
+  return status;
+}
+
+static int lhdc_getApiCfg_src(
+    const RawAddress& peer_address,
+    char* config, int clen) {
+
+  int status = BT_STATUS_NOT_READY;
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return BT_STATUS_NOT_READY;
+  }
+
+  status = btif_a2dp_source_encoder_LHDC_user_config_retrieve_req(peer_address, config, clen);
+
+  if (status != BT_STATUS_SUCCESS) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
+  }
+
+  return status;
+}
+
+static int lhdc_setApiCfg_src(
+    const RawAddress& peer_address,
+    char* config, int clen) {
+
+  int status = BT_STATUS_NOT_READY;
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return BT_STATUS_NOT_READY;
+  }
+
+  status = btif_a2dp_source_encoder_LHDC_user_config_update_req(peer_address, config, clen);
+
+  if (status != BT_STATUS_SUCCESS) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source fails to config LHDC codec";
+  }
+
+  return status;
+}
+
+static void lhdc_setApiData_src(
+    const RawAddress& peer_address,
+    char* data, int clen) {
+
+  if (!btif_av_source.Enabled()) {
+    LOG(WARNING) << __func__ << ": BTIF AV Source is not enabled";
+    return;
+  }
+
+  btif_av_codec_lhdc_api_data_t codec_data;
+  memcpy(&codec_data.bd_addr, (uint8_t *)&peer_address, sizeof(RawAddress));
+  codec_data.clen = clen;
+  codec_data.pData = data;
+
+  btif_transfer_context(btif_a2dp_source_encoder_LHDC_user_data_update_req, 0,
+                          (char *)&codec_data, sizeof(codec_data), NULL);
+
+  return;
+}
+// Savitech LHDC EXT API -- END
+
 static const btav_source_interface_t bt_av_src_interface = {
     sizeof(btav_source_interface_t),
     init_src,
@@ -3035,6 +3257,10 @@ static const btav_source_interface_t bt_av_src_interface = {
     src_set_active_sink,
     codec_config_src,
     cleanup_src,
+    lhdc_getApiVer_src,
+    lhdc_getApiCfg_src,
+    lhdc_setApiCfg_src,
+    lhdc_setApiData_src,
 };
 
 static const btav_sink_interface_t bt_av_sink_interface = {
@@ -3351,11 +3577,26 @@ void btif_av_acl_disconnected(const RawAddress& peer_address) {
   LOG_INFO("%s: Peer %s : ACL Disconnected", __func__,
            peer_address.ToString().c_str());
 
+#ifdef SAVITECH_A2DP_SINK
+  BtifAvPeer* avPeer = NULL;
+  avPeer = btif_av_find_active_peer();
+  if(avPeer) {
+    if(avPeer->PeerSep()==AVDT_TSEP_SRC) {
+      LOG_INFO( "%s: peer is SRC", __func__);
+        btif_av_sink_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
+    }
+    if(avPeer->PeerSep()==AVDT_TSEP_SNK) {
+      LOG_INFO( "%s: peer is SNK", __func__);
+      btif_av_source_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
+    }
+  }
+#else
   if (btif_av_source.Enabled()) {
     btif_av_source_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
   } else if (btif_av_sink.Enabled()) {
     btif_av_sink_dispatch_sm_event(peer_address, BTIF_AV_ACL_DISCONNECTED);
   }
+#endif
 }
 
 static void btif_debug_av_peer_dump(int fd, const BtifAvPeer& peer) {
diff --git a/system_bt/btif/src/btif_avrcp_audio_track.cc b/system_bt/btif/src/btif_avrcp_audio_track.cc
index 8ca5c9798..0d7a93262 100644
--- a/system_bt/btif/src/btif_avrcp_audio_track.cc
+++ b/system_bt/btif/src/btif_avrcp_audio_track.cc
@@ -32,6 +32,7 @@ typedef struct {
   AAudioStream* stream;
   int bitsPerSample;
   int channelCount;
+  aaudio_format_t format;
   float* buffer;
   size_t bufferLength;
 } BtifAvrcpAudioTrack;
@@ -41,6 +42,7 @@ FILE* outputPcmSampleFile;
 char outputFilename[50] = "/data/misc/bluedroid/output_sample.pcm";
 #endif
 
+
 void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
                                 int channelCount) {
   LOG_VERBOSE("%s Track.cpp: btCreateTrack freq %d bps %d channel %d ",
@@ -48,9 +50,13 @@ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
 
   AAudioStreamBuilder* builder;
   AAudioStream* stream;
+  aaudio_format_t format;
+
   aaudio_result_t result = AAudio_createStreamBuilder(&builder);
   AAudioStreamBuilder_setSampleRate(builder, trackFreq);
-  AAudioStreamBuilder_setFormat(builder, AAUDIO_FORMAT_PCM_FLOAT);
+
+  format = AAUDIO_FORMAT_PCM_FLOAT;
+  AAudioStreamBuilder_setFormat(builder, format);
   AAudioStreamBuilder_setChannelCount(builder, channelCount);
   AAudioStreamBuilder_setSessionId(builder, AAUDIO_SESSION_ID_ALLOCATE);
   AAudioStreamBuilder_setPerformanceMode(builder,
@@ -64,6 +70,7 @@ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
   trackHolder->stream = stream;
   trackHolder->bitsPerSample = bitsPerSample;
   trackHolder->channelCount = channelCount;
+  trackHolder->format = format;
   trackHolder->bufferLength =
       trackHolder->channelCount * AAudioStream_getBufferSizeInFrames(stream);
   trackHolder->buffer = new float[trackHolder->bufferLength]();
@@ -71,6 +78,7 @@ void* BtifAvrcpAudioTrackCreate(int trackFreq, int bitsPerSample,
 #if (DUMP_PCM_DATA == TRUE)
   outputPcmSampleFile = fopen(outputFilename, "ab");
 #endif
+
   return (void*)trackHolder;
 }
 
@@ -152,7 +160,7 @@ static size_t transcodeQ15ToFloat(uint8_t* buffer, size_t length,
                                   BtifAvrcpAudioTrack* trackHolder) {
   size_t sampleSize = sampleSizeFor(trackHolder);
   size_t i = 0;
-  for (; i <= length / sampleSize; i++) {
+  for (; i < length / sampleSize; i++) {
     trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat;
   }
   return i * sampleSize;
@@ -162,9 +170,12 @@ static size_t transcodeQ23ToFloat(uint8_t* buffer, size_t length,
                                   BtifAvrcpAudioTrack* trackHolder) {
   size_t sampleSize = sampleSizeFor(trackHolder);
   size_t i = 0;
-  for (; i <= length / sampleSize; i++) {
+  for (; i < length / sampleSize; i++) {
     size_t offset = i * sampleSize;
-    int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
+    //int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0x00FFFFFF;
+    // FIXME: out of range memory access at buffer[-1]
+    int32_t sample = *((int32_t*)(buffer + offset - 1)) & 0xFFFFFF00;
+    sample = sample >> 8;
     trackHolder->buffer[i] = sample * kScaleQ23ToFloat;
   }
   return i * sampleSize;
@@ -172,9 +183,9 @@ static size_t transcodeQ23ToFloat(uint8_t* buffer, size_t length,
 
 static size_t transcodeQ31ToFloat(uint8_t* buffer, size_t length,
                                   BtifAvrcpAudioTrack* trackHolder) {
-  size_t sampleSize = sampleSizeFor(trackHolder);
+  size_t sampleSize = sampleSizeFor(trackHolder); //4
   size_t i = 0;
-  for (; i <= length / sampleSize; i++) {
+  for (; i < length / sampleSize; i++) {
     trackHolder->buffer[i] = ((int32_t*)buffer)[i] * kScaleQ31ToFloat;
   }
   return i * sampleSize;
@@ -210,14 +221,19 @@ int BtifAvrcpAudioTrackWriteData(void* handle, void* audioBuffer,
   size_t sampleSize = sampleSizeFor(trackHolder);
   int transcodedCount = 0;
   do {
+    // only PCM float
+    CHECK(trackHolder->format == AAUDIO_FORMAT_PCM_FLOAT);
+
     transcodedCount +=
         transcodeToPcmFloat(((uint8_t*)audioBuffer) + transcodedCount,
                             bufferLength - transcodedCount, trackHolder);
 
+    // FIXME: should return status not number of frames
     retval = AAudioStream_write(
         trackHolder->stream, trackHolder->buffer,
         transcodedCount / (sampleSize * trackHolder->channelCount),
         kTimeoutNanos);
+
     LOG_VERBOSE("%s Track.cpp: btWriteData len = %d ret = %d", __func__,
                 bufferLength, retval);
   } while (transcodedCount < bufferLength);
diff --git a/system_bt/common/metrics.cc b/system_bt/common/metrics.cc
index 9214dcbde..ada5d0692 100644
--- a/system_bt/common/metrics.cc
+++ b/system_bt/common/metrics.cc
@@ -249,6 +249,14 @@ static A2dpSourceCodec get_a2dp_source_codec(int64_t codec_index) {
       return A2dpSourceCodec::A2DP_SOURCE_CODEC_APTX_HD;
     case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
       return A2dpSourceCodec::A2DP_SOURCE_CODEC_LDAC;
+    // Savitech Patch - START  Offload
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV3;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV2;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2dpSourceCodec::A2DP_SOURCE_CODEC_LHDCV5;
+    // Savitech Patch - END
     default:
       return A2dpSourceCodec::A2DP_SOURCE_CODEC_UNKNOWN;
   }
diff --git a/system_bt/gd/os/log.h b/system_bt/gd/os/log.h
index 312de3dec..99e557442 100644
--- a/system_bt/gd/os/log.h
+++ b/system_bt/gd/os/log.h
@@ -51,6 +51,9 @@ static_assert(LOG_TAG != nullptr, "LOG_TAG is null after header inclusion");
     if (bluetooth::common::InitFlags::IsDebugLoggingEnabledForTag(LOG_TAG)) { \
       ALOGD("%s:%d %s: " fmt, __FILE__, __LINE__, __func__, ##args);          \
     }                                                                         \
+    else {                                                                    \
+      ALOGD("DBG: " fmt, ##args);     \
+    }                                                                         \
   } while (false)
 
 #define LOG_INFO(fmt, args...) ALOGI("%s:%d %s: " fmt, __FILE__, __LINE__, __func__, ##args)
diff --git a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
index 676798782..31d606fab 100644
--- a/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
+++ b/system_bt/gd/proto/bluetooth/metrics/bluetooth.proto
@@ -138,6 +138,11 @@ enum A2dpSourceCodec {
   A2DP_SOURCE_CODEC_APTX = 3;
   A2DP_SOURCE_CODEC_APTX_HD = 4;
   A2DP_SOURCE_CODEC_LDAC = 5;
+  // Savitech Patch - START  Offload
+  A2DP_SOURCE_CODEC_LHDCV3 = 6;
+  A2DP_SOURCE_CODEC_LHDCV2 = 7;
+  A2DP_SOURCE_CODEC_LHDCV5 = 8;
+  // Savitech Patch - END
 }
 
 // Session information that gets logged for A2DP session.
diff --git a/system_bt/include/hardware/bt_av.h b/system_bt/include/hardware/bt_av.h
index b3be7a234..432644ae3 100644
--- a/system_bt/include/hardware/bt_av.h
+++ b/system_bt/include/hardware/bt_av.h
@@ -54,6 +54,9 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
   BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
   BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+  BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
 
   BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
 
@@ -63,6 +66,8 @@ typedef enum {
   BTAV_A2DP_CODEC_INDEX_SINK_SBC = BTAV_A2DP_CODEC_INDEX_SINK_MIN,
   BTAV_A2DP_CODEC_INDEX_SINK_AAC,
   BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
+  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+  BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
 
   BTAV_A2DP_CODEC_INDEX_SINK_MAX,
 
@@ -154,6 +159,15 @@ typedef struct {
       case BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC:
         codec_name_str = "LDAC";
         break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+        codec_name_str = "LHDC V2";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+        codec_name_str = "LHDC V3";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+        codec_name_str = "LHDC V5";
+        break;
       case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
         codec_name_str = "SBC (Sink)";
         break;
@@ -163,6 +177,12 @@ typedef struct {
       case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
         codec_name_str = "LDAC (Sink)";
         break;
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+        codec_name_str = "LHDC V3 (Sink)";
+        break;
+      case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+        codec_name_str = "LHDC V5 (Sink)";
+        break;
       case BTAV_A2DP_CODEC_INDEX_MAX:
         codec_name_str = "Unknown(CODEC_INDEX_MAX)";
         break;
@@ -302,6 +322,15 @@ typedef struct {
   btav_audio_sink_config_callback audio_config_cb;
 } btav_sink_callbacks_t;
 
+/** Savitech LHDC EXT API -- START
+ *  Structure for LHDC Extended API data
+ */
+typedef struct {
+  RawAddress bd_addr;
+  int clen;
+  char* pData;
+} btif_av_codec_lhdc_api_data_t;
+
 /**
  * NOTE:
  *
@@ -346,6 +375,19 @@ typedef struct {
   /** Closes the interface. */
   void (*cleanup)(void);
 
+  // Savitech LHDC EXT API -- START
+  int (*getApiVer_lhdc)(   /* mapping to lhdc_getApiVer_src */
+      const RawAddress& bd_addr, char* version, int clen);
+
+  int (*getApiCfg_lhdc)(   /* mapping to lhdc_getApiCfg_src */
+      const RawAddress& bd_addr, char* config, int clen);
+
+  int (*setApiCfg_lhdc)(   /* mapping to lhdc_setApiCfg_src */
+      const RawAddress& bd_addr, char* config, int clen);
+
+  void (*setAPiData_lhdc)( /* mapping to lhdc_setApiData_src */
+      const RawAddress& bd_addr, char* data, int clen);
+  // Savitech LHDC EXT API -- END
 } btav_source_interface_t;
 
 /** Represents the standard BT-AV A2DP Sink interface.
diff --git a/system_bt/internal_include/bt_target.h b/system_bt/internal_include/bt_target.h
index dd8c74eba..bc06a2ee3 100644
--- a/system_bt/internal_include/bt_target.h
+++ b/system_bt/internal_include/bt_target.h
@@ -77,6 +77,7 @@
 
 #ifndef BTA_AV_SINK_INCLUDED
 #define BTA_AV_SINK_INCLUDED FALSE
+//#define BTA_AV_SINK_INCLUDED TRUE   // Savitech -- Enable A2DP Sink
 #endif
 
 #ifndef BTA_DISABLE_DELAY
@@ -813,7 +814,7 @@
 
 /* Number of simultaneous stream endpoints. */
 #ifndef AVDT_NUM_SEPS
-#define AVDT_NUM_SEPS 6
+#define AVDT_NUM_SEPS 14    //Savitech LHDC
 #endif
 
 /* Number of transport channels setup by AVDT for all media streams */
diff --git a/system_bt/main/Android.bp b/system_bt/main/Android.bp
index 67cb3eca4..9d7f922ff 100644
--- a/system_bt/main/Android.bp
+++ b/system_bt/main/Android.bp
@@ -156,6 +156,10 @@ cc_library_shared {
     required: [
         "bt_did.conf",
         "bt_stack.conf",
+        "liblhdcBT_enc",
+        "liblhdcBT_dec",
+        "liblhdcv5BT_enc",
+        "liblhdcv5BT_dec",
     ],
     cflags: [
         "-DBUILDCFG",
diff --git a/system_bt/stack/Android.bp b/system_bt/stack/Android.bp
index 9a5be5f67..10101e7ab 100644
--- a/system_bt/stack/Android.bp
+++ b/system_bt/stack/Android.bp
@@ -56,6 +56,14 @@ cc_library_static {
         "external/aac/libSYS/include",
         "external/libldac/inc",
         "external/libldac/abr/inc",
+        "external/liblhdc/inc",
+        "external/liblhdc/include",
+        "external/liblhdcdec/inc",
+        "external/liblhdcdec/include",
+        "external/liblhdcv5/inc",
+        "external/liblhdcv5/include",
+        "external/liblhdcv5dec/inc",
+        "external/liblhdcv5dec/include",
         "system/bt",
         "system/bt/btcore/include",
         "system/bt/vnd/include",
@@ -88,6 +96,15 @@ cc_library_static {
         "a2dp/a2dp_vendor_ldac_abr.cc",
         "a2dp/a2dp_vendor_ldac_decoder.cc",
         "a2dp/a2dp_vendor_ldac_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv2.cc",
+        "a2dp/a2dp_vendor_lhdcv2_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv3.cc",
+        "a2dp/a2dp_vendor_lhdcv3_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv3_dec.cc",
+        "a2dp/a2dp_vendor_lhdcv3_decoder.cc",
+        "a2dp/a2dp_vendor_lhdcv5.cc",
+        "a2dp/a2dp_vendor_lhdcv5_encoder.cc",
+        "a2dp/a2dp_vendor_lhdcv5_decoder.cc",
         "avct/avct_api.cc",
         "avct/avct_bcb_act.cc",
         "avct/avct_ccb.cc",
@@ -212,6 +229,10 @@ cc_library_static {
     required: [
         "libldacBT_enc",
         "libldacBT_abr",
+        "liblhdcBT_enc",
+        "liblhdcBT_dec",
+        "liblhdcv5BT_enc",
+        "liblhdcv5BT_dec",
     ],
     host_supported: true,
 }
diff --git a/system_bt/stack/a2dp/a2dp_codec_config.cc b/system_bt/stack/a2dp/a2dp_codec_config.cc
index a90c88108..0869fad5e 100644
--- a/system_bt/stack/a2dp/a2dp_codec_config.cc
+++ b/system_bt/stack/a2dp/a2dp_codec_config.cc
@@ -33,6 +33,10 @@
 #include "a2dp_vendor_aptx.h"
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
+#include "a2dp_vendor_lhdcv2.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+#include "a2dp_vendor_lhdcv5.h"
 #endif
 
 #include "bta/av/bta_av_int.h"
@@ -139,6 +143,21 @@ A2dpCodecConfig* A2dpCodecConfig::createCodec(
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       codec_config = new A2dpCodecConfigLdacSink(codec_priority);
       break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      codec_config = new A2dpCodecConfigLhdcV2(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      codec_config = new A2dpCodecConfigLhdcV3(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      codec_config = new A2dpCodecConfigLhdcV5Source(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      codec_config = new A2dpCodecConfigLhdcV3Sink(codec_priority);
+      break;
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      codec_config = new A2dpCodecConfigLhdcV5Sink(codec_priority);
+      break;
 #endif
     case BTAV_A2DP_CODEC_INDEX_MAX:
     default:
@@ -248,12 +267,430 @@ bool A2dpCodecConfig::getCodecSpecificConfig(tBT_A2DP_OFFLOAD* p_a2dp_offload) {
         LOG_VERBOSE("%s: Ldac specific channelmode =%d", __func__,
                     p_a2dp_offload->codec_info[7]);
       }
+      // Savitech Patch - START  Offload
+      else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+        //
+        // LHDC V3
+        //
+        // Main Version
+        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER3 &&
+            (codec_config[10] & A2DP_LHDC_VERSION_MASK) != A2DP_LHDC_VER6) {
+          LOG_ERROR("%s: [LHDC V3] Unsupported version 0x%x", __func__,
+              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
+          goto fail;
+        }
+
+        LOG_DEBUG("%s: [LHDC V3] isLLAC=%d isLHDCV4=%d", __func__,
+            (codec_config[10] & A2DP_LHDC_FEATURE_LLAC),
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4));
+        // LHDC/LLAC handle Version
+        if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) != 0 &&
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
+          // LLAC (isLLAC && !isLHDCV4)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_LLAC-1);
+          LOG_DEBUG("%s: [LHDC V3] init to LLAC (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) != 0) {
+          // LHDC V4 Only (!isLLAC && isLHDCV4)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V4_ONLY-1);
+          LOG_DEBUG("%s: [LHDC V3] init to LHDCV4 only (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        } else if ((codec_config[10] & A2DP_LHDC_FEATURE_LLAC) == 0 &&
+            (codec_config[11] & A2DP_LHDC_FEATURE_LHDCV4) == 0) {
+          // LHDC V3 Only (!isLLAC && !isLHDCV4)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
+          LOG_DEBUG("%s: [LHDC V3] init to LHDCV3 only (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        }else {
+          // LHDC V3 Only - default
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV3_V3_ONLY-1);
+          LOG_DEBUG("%s: [LHDC V3] flags check incorrect. So init to LHDCV3 only (0x%02X)", __func__,
+              p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+        }
+
+        // bit rate index
+        switch (codec_config_.codec_specific_1 & 0x0F) {
+        case A2DP_LHDC_QUALITY_LOW0:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW2:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW3:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW4:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_MID:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_HIGH:
+        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V3
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_ABR:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        default:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        }
+        LOG_DEBUG("%s: [LHDC V3] Bit Rate = 0x%02X", __func__,
+            (uint8_t)(codec_config_.codec_specific_1 & 0x0F));
+
+        // max bit rate index
+        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V3] Max Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
+
+        // min bit rate index
+        if ((codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR) == A2DP_LHDC_FEATURE_MIN_BR) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+        } else {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V3] Min Bit Rate = 0x%02X", __func__,
+            codec_config[11] & A2DP_LHDC_FEATURE_MIN_BR);
+
+        // frameDuration - not supported
+        // p_a2dp_offload->codec_info[13]
+
+        // data interval
+        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
+          // LL is enabled (10 ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
+          LOG_DEBUG("%s: [LHDC V3] Low Latency mode", __func__);
+        } else {
+          // LL is disabled (20ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
+          LOG_DEBUG("%s: [LHDC V3] Normal Latency mode", __func__);
+        }
+
+        // Codec specific 1
+        if ((codec_config[9] & A2DP_LHDC_FEATURE_AR) != 0) {
+          // AR
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
+          LOG_DEBUG("%s: [LHDC V3] Has feature AR", __func__);
+        }
+        if ((codec_config[9] & A2DP_LHDC_FEATURE_JAS) != 0) {
+          // JAS
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
+          LOG_DEBUG("%s: [LHDC V3] Has feature JAS", __func__);
+        }
+        if ((codec_config[11] & A2DP_LHDC_FEATURE_META) != 0) {
+          // META
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
+          LOG_DEBUG("%s: [LHDC V3] Has feature META", __func__);
+        }
+
+        // Codec specific 2
+        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
+          // split mode disabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
+          LOG_DEBUG("%s: [LHDC V3] No ch split", __func__);
+        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
+          // split mode enabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
+          LOG_DEBUG("%s: [LHDC V3] Has ch split", __func__);
+        } else {
+          LOG_ERROR("%s: [LHDC V3] Unsupported split mode 0x%x", __func__,
+              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
+          goto fail;
+        }
+
+      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+        //
+        // LHDC V2
+        //
+        // Version
+        if ((codec_config[10] & A2DP_LHDC_VERSION_MASK) > A2DP_LHDC_VER2) {
+          LOG_ERROR("%s: [LHDC V2] Unsupported version 0x%x", __func__,
+              (codec_config[10] & A2DP_LHDC_VERSION_MASK));
+          goto fail;
+        }
+        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV2_VER_1-1);
+        LOG_DEBUG("%s: [LHDC V2] version (0x%02X)", __func__,
+            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+
+        // bit rate index
+        switch (codec_config_.codec_specific_1 & 0x0F) {
+        case A2DP_LHDC_QUALITY_LOW0:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW2:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW3:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW4:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_LOW:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_MID:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_HIGH:
+        case A2DP_LHDC_QUALITY_HIGH1: //HIGH1 not supported in LHDC V2
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDC_QUALITY_ABR:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        default:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        }
+        LOG_DEBUG("%s: [LHDC V2] Bit Rate = 0x%02X", __func__,
+            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
+
+        // max bit rate index
+        if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+        } else {  //default option: A2DP_LHDC_MAX_BIT_RATE_900K
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V2] Max Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDC_MAX_BIT_RATE_MASK);
+
+        // min bit rate index - not supported
+        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L]
+        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H]
+
+        // frameDuration - not supported
+        //p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR]
+
+        // data interval
+        if ((codec_config[10] & A2DP_LHDC_LL_MASK) != 0) {
+          // LL is enabled (10 ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
+          LOG_DEBUG("%s: [LHDC V2] Low Latency mode", __func__);
+        } else {
+          // LL is disabled (20ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
+          LOG_DEBUG("%s: [LHDC V2] Normal Latency mode", __func__);
+        }
+
+        // Codec specific 1 - not supported
+        // p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1]
+
+        // Codec specific 2
+        if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_NONE) {
+          // split mode disabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] = 0;
+          LOG_DEBUG("%s: [LHDC V2] No ch split", __func__);
+        } else if ((codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK) == A2DP_LHDC_CH_SPLIT_TWS) {
+          // split mode enabled
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT;
+          LOG_DEBUG("%s: [LHDC V2] Has ch split", __func__);
+        } else {
+          LOG_ERROR("%s: [LHDC V2] Unsupported split mode 0x%x", __func__,
+              codec_config[11] & A2DP_LHDC_CH_SPLIT_MSK);
+          goto fail;
+        }
+      } else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+        //
+        // LHDC V5
+        //
+
+        // Version
+        if ((codec_config[11] & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_1) {
+          LOG_ERROR("%s: [LHDC V5] unsupported version 0x%x", __func__,
+              (codec_config[11] & A2DP_LHDCV5_VERSION_MASK));
+          goto fail;
+        }
+        p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER] = 1 << (A2DP_OFFLOAD_LHDCV5_VER_1-1);
+        LOG_DEBUG("%s: [LHDC V5] version (0x%02X)", __func__,
+            p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_VER]);
+
+        // bit rate index
+        switch (codec_config_.codec_specific_1 & 0xF) {
+        case A2DP_LHDCV5_QUALITY_LOW0:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW2:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW2) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW3:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW4:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW4) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_LOW:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_MID:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_HIGH:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_HIGH1:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
+          break;
+        case A2DP_LHDCV5_QUALITY_ABR:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        default:
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_BITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_ABR) >> 8) & ((uint16_t) 0xFF));
+          break;
+        }
+        LOG_DEBUG("%s: [LHDC V5] Bit Rate = 0x%02X", __func__,
+            (uint8_t)codec_config_.codec_specific_1 & 0x0F);
+
+        // max bit rate index
+        if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_MID) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH) >> 8) & ((uint16_t) 0xFF));
+        } else {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_HIGH1) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V5] Max Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+
+        // min bit rate index
+        if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW0) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW1) >> 8) & ((uint16_t) 0xFF));
+        } else if ((codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW3) >> 8) & ((uint16_t) 0xFF));
+        } else {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L] = (uint8_t) (((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) & ((uint16_t) 0xFF));
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H] = (uint8_t) ((((uint16_t) A2DP_OFFLOAD_LHDC_QUALITY_LOW) >> 8) & ((uint16_t) 0xFF));
+        }
+        LOG_DEBUG("%s: [LHDC V5] Min Bit Rate = 0x%02X", __func__,
+            codec_config[10] & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+
+        // frame duration
+        if ((codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK) != 0) {
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR] = A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US;
+          LOG_DEBUG("%s: [LHDC V5] Frame Duration: 5ms ", __func__);
+        } else {
+          LOG_ERROR("%s: [LHDC V5] unsupported frame duration 0x%x", __func__,
+              codec_config[11] & A2DP_LHDCV5_FRAME_LEN_MASK);
+          goto fail;
+        }
+
+        // data interval
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_LL) != 0) {
+          // LL is disabled (10 ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS;
+          LOG_DEBUG("%s: [LHDC V5] Low Latency mode", __func__);
+        } else {
+          // LL is enabled (20ms)
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_INTERVAL] = A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS;
+          LOG_DEBUG("%s: [LHDC V5] Normal Latency mode", __func__);
+        }
+
+        // Codec specific 1
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_AR) != 0) {
+          // AR
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR;
+          LOG_DEBUG("%s: [LHDC V5] Has feature AR", __func__);
+        }
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_JAS) != 0) {
+          // JAS
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS;
+          LOG_DEBUG("%s: [LHDC V5] Has feature JAS", __func__);
+        }
+        if ((codec_config[12] & A2DP_LHDCV5_FEATURE_META) != 0) {
+          // META
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC1] |= A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META;
+          LOG_DEBUG("%s: [LHDC V5] Has feature META", __func__);
+        }
+
+        // Codec specific 2
+        if ((codec_config[13] & A2DP_LHDCV5_AR_ON) != 0) {
+          // AR_ON
+          p_a2dp_offload->codec_info[A2DP_OFFLOAD_LHDC_CFG_SPEC2] |= A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON;
+          LOG_DEBUG("%s: [LHDC V5] AR_ON is set", __func__);
+        }
+      }
+      // Savitech Patch - END
       break;
 #endif
     default:
       break;
   }
   return true;
+
+fail:
+  return false;
 }
 
 bool A2dpCodecConfig::isValid() const { return true; }
@@ -375,9 +812,11 @@ bool A2dpCodecConfig::setCodecUserConfig(
   //
   btav_a2dp_codec_config_t new_codec_config = getCodecConfig();
   if ((saved_codec_config.sample_rate != new_codec_config.sample_rate) ||
-      (saved_codec_config.bits_per_sample !=
-       new_codec_config.bits_per_sample) ||
-      (saved_codec_config.channel_mode != new_codec_config.channel_mode)) {
+      (saved_codec_config.bits_per_sample != new_codec_config.bits_per_sample) ||
+      (saved_codec_config.channel_mode != new_codec_config.channel_mode) ||
+      (saved_codec_config.codec_specific_1 != new_codec_config.codec_specific_1) || // Savitech LHDC
+      (saved_codec_config.codec_specific_2 != new_codec_config.codec_specific_2) ||
+      (saved_codec_config.codec_specific_3 != new_codec_config.codec_specific_3)) {
     *p_restart_input = true;
   }
 
@@ -600,6 +1039,15 @@ bool A2dpCodecs::init() {
       } else if (strcmp(tok, "ldac") == 0) {
         LOG_INFO("%s: LDAC offload supported", __func__);
         offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC] = true;
+      } else if (strcmp(tok, "lhdcv2") == 0) {  // Savitech LHDC
+        LOG_INFO("%s: LHDCV2 offload not supported", __func__);
+        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2] = false;
+      } else if (strcmp(tok, "lhdcv3") == 0) {
+        LOG_INFO("%s: LHDCV3 offload not supported", __func__);
+        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3] = false;
+      } else if (strcmp(tok, "lhdcv5") == 0) {
+        LOG_INFO("%s: LHDCV5 offload not supported", __func__);
+        offload_codec_support[BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5] = false;
 #endif
       }
       tok = strtok_r(NULL, "-", &tmp_token);
@@ -729,6 +1177,288 @@ bool A2dpCodecs::setSinkCodecConfig(const uint8_t* p_peer_codec_info,
   return true;
 }
 
+/***********************************************
+ * Savitech LHDC EXT API -- START
+ ***********************************************/
+static bool swapInt64toByteArray(unsigned char *byteArray, int64_t integer64)
+{
+  bool ret = false;
+  if (!byteArray) {
+    APPL_TRACE_ERROR("%s: null ptr", __func__);
+    return ret;
+  }
+
+  byteArray[7] = ((integer64 & 0x00000000000000FF) >> 0);
+  byteArray[6] = ((integer64 & 0x000000000000FF00) >> 8);
+  byteArray[5] = ((integer64 & 0x0000000000FF0000) >> 16);
+  byteArray[4] = ((integer64 & 0x00000000FF000000) >> 24);
+  byteArray[3] = ((integer64 & 0x000000FF00000000) >> 32);
+  byteArray[2] = ((integer64 & 0x0000FF0000000000) >> 40);
+  byteArray[1] = ((integer64 & 0x00FF000000000000) >> 48);
+  byteArray[0] = ((integer64 & 0xFF00000000000000) >> 56);
+
+  ret = true;
+  return ret;
+}
+
+static bool getLHDCA2DPSpecficV2(btav_a2dp_codec_config_t *a2dpCfg, unsigned char *pucConfig, const int clen)
+{
+  if (clen < (int)LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2 ) {
+    APPL_TRACE_ERROR("%s: payload size too small! clen=%d ",__func__, clen);
+    return false;
+  }
+
+  /* copy specifics into buffer */
+  if ( !(
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2], a2dpCfg->codec_specific_1) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2], a2dpCfg->codec_specific_2) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2], a2dpCfg->codec_specific_3) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2], a2dpCfg->codec_specific_4)
+      )) {
+    APPL_TRACE_ERROR("%s: fail to copy specifics to buffer!",  __func__);
+    return false;
+  }
+
+  /* fill capability metadata fields */
+  if( A2DP_VendorGetSrcCapVectorLhdcv3(&pucConfig[LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2]) ) {
+    APPL_TRACE_DEBUG("%s: Get metadata of capabilities success!", __func__);
+  } else {
+    APPL_TRACE_ERROR("%s: fail to get capability fields!",  __func__);
+    return false;
+  }
+
+  return true;
+}
+
+static bool getLHDCA2DPSpecficV1(btav_a2dp_codec_config_t *a2dpCfg, unsigned char *pucConfig, const int clen)
+{
+  if (clen < (int)LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1 ) {
+    APPL_TRACE_ERROR("%s: payload size too small! clen=%d ",__func__, clen);
+    return false;
+  }
+
+  /* copy specifics into buffer */
+  if( !(
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1], a2dpCfg->codec_specific_1) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1], a2dpCfg->codec_specific_2) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1], a2dpCfg->codec_specific_3) &&
+      swapInt64toByteArray(&pucConfig[LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1], a2dpCfg->codec_specific_4)
+      )) {
+    APPL_TRACE_ERROR("%s: fail to copy specifics to buffer!",  __func__);
+    return false;
+  }
+
+  return true;
+}
+
+int A2dpCodecs::getLHDCCodecUserConfig(
+    A2dpCodecConfig* peerCodec,
+    const char* codecConfig, const int clen) {
+
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || codecConfig == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p codecConfig:%p)", __func__, peerCodec, codecConfig);
+    return BT_STATUS_FAIL;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+
+  switch(peerCodecIndex)
+  {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    result = peerCodec->getLhdcExtendAPIConfig(peerCodec, codecConfig, clen);
+    break;
+
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    if (codecConfig[LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD] == LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK) {
+      /* **************************************
+       * LHDC A2DP related APIs:
+       * **************************************/
+      unsigned char *pucConfig = (unsigned char *) codecConfig;
+      unsigned int exFuncVer = 0;
+      unsigned int exFuncCode = 0;
+
+      if (pucConfig == NULL) {
+          APPL_TRACE_ERROR("%s: User Config error!(%p)",  __func__, codecConfig);
+          goto Fail;
+      }
+
+      /* check required buffer size for generic header */
+      if (clen < (int)(LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE)) {
+           // Buffer is too small for generic header size
+          APPL_TRACE_ERROR("%s: buffer is too small for command clen=%d",  __func__, clen);
+          goto Fail;
+      }
+
+      if (current_codec_config_ == NULL) {
+          APPL_TRACE_ERROR("%s: Can not get current a2dp codec config!",  __func__);
+          goto Fail;
+      }
+
+      A2dpCodecConfig *a2dp_codec_config = current_codec_config_;
+      btav_a2dp_codec_config_t codec_config_tmp;
+
+      exFuncVer = (((unsigned int) pucConfig[3]) & ((unsigned int)0xff)) |
+                 ((((unsigned int) pucConfig[2]) & ((unsigned int)0xff)) << 8)  |
+                 ((((unsigned int) pucConfig[1]) & ((unsigned int)0xff)) << 16) |
+                 ((((unsigned int) pucConfig[0]) & ((unsigned int)0xff)) << 24);
+      exFuncCode = (((unsigned int) pucConfig[7]) & ((unsigned int)0xff)) |
+                  ((((unsigned int) pucConfig[6]) & ((unsigned int)0xff)) << 8)  |
+                  ((((unsigned int) pucConfig[5]) & ((unsigned int)0xff)) << 16) |
+                  ((((unsigned int) pucConfig[4]) & ((unsigned int)0xff)) << 24);
+
+      switch (exFuncCode)
+      {
+        case EXTEND_FUNC_CODE_GET_SPECIFIC:
+          /* **************************************
+           * API::Get A2DP Specifics
+           * **************************************/
+          switch(pucConfig[LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD])
+          {
+            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG:
+              codec_config_tmp = a2dp_codec_config->getCodecConfig();
+              break;
+            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP:
+              codec_config_tmp = a2dp_codec_config->getCodecCapability();
+              break;
+            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP:
+              codec_config_tmp = a2dp_codec_config->getCodecLocalCapability();
+              break;
+            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP:
+              codec_config_tmp = a2dp_codec_config->getCodecSelectableCapability();
+              break;
+            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG:
+              codec_config_tmp = a2dp_codec_config->getCodecUserConfig();
+              break;
+            case LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG:
+              codec_config_tmp = a2dp_codec_config->getCodecAudioConfig();
+              break;
+            default:
+              APPL_TRACE_ERROR("%s: target a2dp config not found!",  __func__);
+              goto Fail;
+          }
+
+          switch (exFuncVer)
+          {
+            case EXTEND_FUNC_VER_GET_SPECIFIC_V1:
+              if (!getLHDCA2DPSpecficV1(&codec_config_tmp, pucConfig, clen))
+                goto Fail;
+              break;
+            case EXTEND_FUNC_VER_GET_SPECIFIC_V2:
+              if (!getLHDCA2DPSpecficV2(&codec_config_tmp, pucConfig, clen))
+                goto Fail;
+              break;
+            default:
+              APPL_TRACE_DEBUG("%s: Invalid Ex. Function Version!(0x%X)",  __func__, exFuncVer);
+              goto Fail;
+          }
+          result = BT_STATUS_SUCCESS;
+          break;
+
+      default:
+        APPL_TRACE_DEBUG("%s: Invalid Ex. Function Code!(0x%X)",  __func__, exFuncCode);
+        goto Fail;
+      } // switch (exFuncCode)
+    } else if ( codecConfig[LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD] == LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK ) {
+      result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(codecConfig, clen);
+    }
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_DEBUG("%s: feature not support!", __func__);
+    goto Fail;
+  }
+
+Fail:
+  return result;
+}
+
+int A2dpCodecs::setLHDCCodecUserConfig(
+    A2dpCodecConfig* peerCodec,
+    const char* codecConfig, const int clen) {
+
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || codecConfig == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, codecConfig);
+    return BT_STATUS_FAIL;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+
+  switch(peerCodecIndex)
+  {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    result = peerCodec->setLhdcExtendAPIConfig(peerCodec, codecConfig, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    result = A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(codecConfig, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+    return result;
+  }
+
+  return result;
+}
+
+bool A2dpCodecs::setLHDCCodecUserData(
+    A2dpCodecConfig* peerCodec,
+    const char* codecData, const int clen) {
+
+  if (peerCodec == nullptr || codecData == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, codecData);
+    return false;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+
+  switch(peerCodecIndex)
+  {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    peerCodec->setLhdcExtendAPIData(peerCodec, codecData, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(codecData, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+    return false;
+  }
+
+  return true;
+}
+
+int A2dpCodecs::getLHDCCodecUserApiVer(
+    A2dpCodecConfig* peerCodec,
+    const char* version, const int clen) {
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || version == nullptr) {
+    APPL_TRACE_ERROR("A2dpCodecs::%s: null input(peerCodec:%p version:%p)", __func__, peerCodec, version);
+    return BT_STATUS_FAIL;
+  }
+  btav_a2dp_codec_index_t peerCodecIndex = peerCodec->codecIndex();
+
+  switch(peerCodecIndex) {
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+    result = peerCodec->getLhdcExtendAPIVersion(peerCodec, version, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+    result = A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(version, clen);
+    break;
+  case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+  default:
+    APPL_TRACE_DEBUG("%s: peer codecIndex(%d) not support the feature!", __func__, peerCodecIndex);
+    return result;
+  }
+
+  return result;
+}
+/***********************************************
+ * Savitech LHDC EXT API -- END
+ ***********************************************/
+
 bool A2dpCodecs::setCodecUserConfig(
     const btav_a2dp_codec_config_t& codec_user_config,
     const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
@@ -1403,11 +2133,14 @@ const tA2DP_DECODER_INTERFACE* A2DP_GetDecoderInterface(
 
   switch (codec_type) {
     case A2DP_MEDIA_CT_SBC:
+      LOG_DEBUG("%s: SBC", __func__);
       return A2DP_GetDecoderInterfaceSbc(p_codec_info);
 #if !defined(EXCLUDE_NONSTANDARD_CODECS)
     case A2DP_MEDIA_CT_AAC:
+      LOG_DEBUG("%s: AAC", __func__);
       return A2DP_GetDecoderInterfaceAac(p_codec_info);
     case A2DP_MEDIA_CT_NON_A2DP:
+      LOG_DEBUG("%s: VENDOR CODEC", __func__);
       return A2DP_VendorGetDecoderInterface(p_codec_info);
 #endif
     default:
diff --git a/system_bt/stack/a2dp/a2dp_vendor.cc b/system_bt/stack/a2dp/a2dp_vendor.cc
index bcea13d1c..b9936427f 100644
--- a/system_bt/stack/a2dp/a2dp_vendor.cc
+++ b/system_bt/stack/a2dp/a2dp_vendor.cc
@@ -24,6 +24,10 @@
 #include "a2dp_vendor_aptx.h"
 #include "a2dp_vendor_aptx_hd.h"
 #include "a2dp_vendor_ldac.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "a2dp_vendor_lhdcv2.h"
+#include "a2dp_vendor_lhdcv3_dec.h"
+#include "a2dp_vendor_lhdcv5.h"
 #include "bt_target.h"
 #include "osi/include/log.h"
 #include "osi/include/osi.h"
@@ -49,6 +53,21 @@ bool A2DP_IsVendorSourceCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSourceCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -66,6 +85,16 @@ bool A2DP_IsVendorSinkCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSinkCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info);
+  }
+
   return false;
 }
 
@@ -81,6 +110,15 @@ bool A2DP_IsVendorPeerSourceCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorPeerSourceCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorPeerSourceCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorPeerSourceCodecValidLhdcV5(p_codec_info);
+  }
   return false;
 }
 
@@ -105,6 +143,21 @@ bool A2DP_IsVendorPeerSinkCodecValid(const uint8_t* p_codec_info) {
     return A2DP_IsVendorPeerSinkCodecValidLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorPeerSinkCodecValidLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -122,6 +175,16 @@ bool A2DP_IsVendorSinkCodecSupported(const uint8_t* p_codec_info) {
     return A2DP_IsVendorSinkCodecSupportedLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecSupportedLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  else if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsVendorSinkCodecSupportedLhdcV5(p_codec_info);
+  }
+
   return false;
 }
 
@@ -137,6 +200,16 @@ bool A2DP_IsVendorPeerSourceCodecSupported(const uint8_t* p_codec_info) {
     return A2DP_IsPeerSourceCodecSupportedLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_IsPeerSourceCodecSupportedLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_IsPeerSourceCodecSupportedLhdcV5(p_codec_info);
+  }
+
   return false;
 }
 
@@ -183,6 +256,23 @@ bool A2DP_VendorUsesRtpHeader(bool content_protection_enabled,
                                         p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV2(content_protection_enabled,
+                                          p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV3(content_protection_enabled,
+                                          p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorUsesRtpHeaderLhdcV5(content_protection_enabled,
+                                          p_codec_info);
+  }
   // Add checks based on <content_protection_enabled, vendor_id, codec_id>
 
   return true;
@@ -209,6 +299,21 @@ const char* A2DP_VendorCodecName(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecNameLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecNameLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return "UNKNOWN VENDOR CODEC";
@@ -248,6 +353,21 @@ bool A2DP_VendorCodecTypeEquals(const uint8_t* p_codec_info_a,
     return A2DP_VendorCodecTypeEqualsLdac(p_codec_info_a, p_codec_info_b);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecTypeEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
+  }
+
   // OPTIONAL: Add extra vendor-specific checks based on the
   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
 
@@ -288,6 +408,21 @@ bool A2DP_VendorCodecEquals(const uint8_t* p_codec_info_a,
     return A2DP_VendorCodecEqualsLdac(p_codec_info_a, p_codec_info_b);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV2(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV3(p_codec_info_a, p_codec_info_b);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id_a == A2DP_LHDC_VENDOR_ID && codec_id_a == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecEqualsLhdcV5(p_codec_info_a, p_codec_info_b);
+  }
+
   // Add extra vendor-specific checks based on the
   // vendor-specific data stored in "p_codec_info_a" and "p_codec_info_b".
 
@@ -315,6 +450,21 @@ int A2DP_VendorGetBitRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetBitRateLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetBitRateLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -341,6 +491,21 @@ int A2DP_VendorGetTrackSampleRate(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackSampleRateLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -367,6 +532,21 @@ int A2DP_VendorGetTrackBitsPerSample(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackBitsPerSampleLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -393,6 +573,21 @@ int A2DP_VendorGetTrackChannelCount(const uint8_t* p_codec_info) {
     return A2DP_VendorGetTrackChannelCountLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return -1;
@@ -410,6 +605,16 @@ int A2DP_VendorGetSinkTrackChannelType(const uint8_t* p_codec_info) {
     return A2DP_VendorGetSinkTrackChannelTypeLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDC V3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetSinkTrackChannelTypeLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDC V5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetSinkTrackChannelTypeLhdcV5(p_codec_info);
+  }
+
   return -1;
 }
 
@@ -437,6 +642,21 @@ bool A2DP_VendorGetPacketTimestamp(const uint8_t* p_codec_info,
     return A2DP_VendorGetPacketTimestampLdac(p_codec_info, p_data, p_timestamp);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV2(p_codec_info, p_data, p_timestamp);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV3(p_codec_info, p_data, p_timestamp);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetPacketTimestampLhdcV5(p_codec_info, p_data, p_timestamp);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -467,6 +687,24 @@ bool A2DP_VendorBuildCodecHeader(const uint8_t* p_codec_info, BT_HDR* p_buf,
                                            frames_per_packet);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV2(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV3(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorBuildCodecHeaderLhdcV5(p_codec_info, p_buf,
+                                               frames_per_packet);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -494,6 +732,21 @@ const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterface(
     return A2DP_VendorGetEncoderInterfaceLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetEncoderInterfaceLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return NULL;
@@ -512,6 +765,16 @@ const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterface(
     return A2DP_VendorGetDecoderInterfaceLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV3 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorGetDecoderInterfaceLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5 Sink
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorGetDecoderInterfaceLhdcV5(p_codec_info);
+  }
+
   return NULL;
 }
 
@@ -536,6 +799,21 @@ bool A2DP_VendorAdjustCodec(uint8_t* p_codec_info) {
     return A2DP_VendorAdjustCodecLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorAdjustCodecLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return false;
@@ -563,6 +841,21 @@ btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndex(
     return A2DP_VendorSourceCodecIndexLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorSourceCodecIndexLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return BTAV_A2DP_CODEC_INDEX_MAX;
@@ -580,6 +873,16 @@ btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndex(const uint8_t* p_codec_info) {
     return A2DP_VendorSinkCodecIndexLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDC V3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorSinkCodecIndexLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDC V5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorSinkCodecIndexLhdcV5(p_codec_info);
+  }
+
   return BTAV_A2DP_CODEC_INDEX_MAX;
 }
 
@@ -599,6 +902,18 @@ const char* A2DP_VendorCodecIndexStr(btav_a2dp_codec_index_t codec_index) {
       return A2DP_VendorCodecIndexStrLdac();
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       return A2DP_VendorCodecIndexStrLdacSink();
+    // Savitech Patch - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      return A2DP_VendorCodecIndexStrLhdcV2();
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2DP_VendorCodecIndexStrLhdcV3();
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2DP_VendorCodecIndexStrLhdcV5();
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      return A2DP_VendorCodecIndexStrLhdcV3Sink();
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      return A2DP_VendorCodecIndexStrLhdcV5Sink();
+    // Savitech Patch - END
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -624,6 +939,18 @@ bool A2DP_VendorInitCodecConfig(btav_a2dp_codec_index_t codec_index,
       return A2DP_VendorInitCodecConfigLdac(p_cfg);
     case BTAV_A2DP_CODEC_INDEX_SINK_LDAC:
       return A2DP_VendorInitCodecConfigLdacSink(p_cfg);
+    // Savitech Patch - START
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+      return A2DP_VendorInitCodecConfigLhdcV2(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+      return A2DP_VendorInitCodecConfigLhdcV3(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+      return A2DP_VendorInitCodecConfigLhdcV5(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+      return A2DP_VendorInitCodecConfigLhdcV3Sink(p_cfg);
+    case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+      return A2DP_VendorInitCodecConfigLhdcV5Sink(p_cfg);
+    // Savitech Patch - END
     // Add a switch statement for each vendor-specific codec
     case BTAV_A2DP_CODEC_INDEX_MAX:
       break;
@@ -653,6 +980,21 @@ std::string A2DP_VendorCodecInfoString(const uint8_t* p_codec_info) {
     return A2DP_VendorCodecInfoStringLdac(p_codec_info);
   }
 
+  // Check for Savitech LHDCV2
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV2(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV3
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV3(p_codec_info);
+  }
+
+  // Check for Savitech LHDCV5
+  if (vendor_id == A2DP_LHDC_VENDOR_ID && codec_id == A2DP_LHDCV5_CODEC_ID) {
+    return A2DP_VendorCodecInfoStringLhdcV5(p_codec_info);
+  }
+
   // Add checks based on <vendor_id, codec_id>
 
   return "Unsupported codec vendor_id: " + loghex(vendor_id) +
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
new file mode 100644
index 000000000..6b0cc11b3
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2.cc
@@ -0,0 +1,1431 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDC Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv2"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv2.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv2_encoder.h"
+#include "bt_utils.h"
+#include "btif_av_co.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+} tA2DP_LHDC_CIE;
+
+/* LHDC Source codec capabilities */
+static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV2_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+    //Version number
+    A2DP_LHDC_VER2,
+    //Max target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    false,
+};
+    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV2_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER2,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    false,
+};
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv2 = {
+    a2dp_vendor_lhdcv2_encoder_init,
+    a2dp_vendor_lhdcv2_encoder_cleanup,
+    a2dp_vendor_lhdcv2_feeding_reset,
+    a2dp_vendor_lhdcv2_feeding_flush,
+    a2dp_vendor_lhdcv2_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv2_send_frames,
+    a2dp_vendor_lhdcv2_set_transmit_queue_length};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV2(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_peer_codec_info);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV2(uint8_t media_type,
+                                       const tA2DP_LHDC_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV2_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      para |= A2DP_LHDC_BIT_FMT_24;
+  if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      para |= A2DP_LHDC_BIT_FMT_16;
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  *p_result++ = para;   //b
+
+  LOG_DEBUG( "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
+                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV2(tA2DP_LHDC_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+
+  //LOG_DEBUG( "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV2_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG( "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  LOG_DEBUG( "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV2_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+  //p_ie->version = 1;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+  //p_ie->isLLSupported = false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+  //p_ie->channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
+
+
+
+
+    LOG_DEBUG( "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+
+  return A2DP_SUCCESS;
+}
+
+// Build the LHDC Media Payload Header.
+// |p_dst| points to the location where the header should be written to.
+// If |frag| is true, the media payload frame is fragmented.
+// |start| is true for the first packet of a fragmented frame.
+// |last| is true for the last packet of a fragmented frame.
+// If |frag| is false, |num| is the number of number of frames in the packet,
+// otherwise is the number of remaining fragments (including this one).
+/*
+static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
+  if (p == NULL) return;
+  *p = ( uint8_t)( num & 0xff);
+}
+*/
+
+static bool A2DP_MaxBitRatetoQualityLevelLhdcV2(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+  case A2DP_LHDC_MAX_BIT_RATE_900K:
+    *mode = A2DP_LHDC_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDC_MAX_BIT_RATE_500K:
+    *mode = A2DP_LHDC_QUALITY_MID;
+    return true;
+  case A2DP_LHDC_MAX_BIT_RATE_400K:
+    *mode = A2DP_LHDC_QUALITY_LOW;
+    return true;
+  }
+  return false;
+}
+
+static std::string lhdcV2_QualityModeBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+// the device's codec capabilities.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// |p_codec_info| contains the codec capabilities for a peer device that
+// is acting as an A2DP source.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV2(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV2(UNUSED_ATTR bool content_protection_enabled,
+                                  UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V2";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV2(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV2(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample);
+}
+
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 600000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        [[fallthrough]];
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
+
+int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info) {
+    tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return 16;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return 24;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+      return 32;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      return -1;
+  }
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return 2;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+int16_t A2DP_VendorGetMaxDatarateLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+/*
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+
+#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+*/
+  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+      case A2DP_LHDC_MAX_BIT_RATE_900K:
+      return A2DP_LHDC_QUALITY_HIGH;
+      case A2DP_LHDC_MAX_BIT_RATE_500K:
+      return A2DP_LHDC_QUALITY_MID;
+      case A2DP_LHDC_MAX_BIT_RATE_400K:
+      return A2DP_LHDC_QUALITY_LOW;
+  }
+  return -1;
+}
+
+bool A2DP_VendorGetLowLatencyStateLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_INFO( "%s: isLLSupported =%d", __func__, lhdc_cie.isLLSupported);
+
+  return lhdc_cie.isLLSupported ? true : false;
+}
+
+uint8_t A2DP_VendorGetVersionLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_INFO( "%s: version =%d", __func__, lhdc_cie.version);
+
+  return lhdc_cie.version;
+}
+
+
+int8_t A2DP_VendorGetChannelSplitModeLhdcV2(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_INFO( "%s: channelSplitMode =%d", __func__, lhdc_cie.channelSplitMode);
+
+  return lhdc_cie.channelSplitMode;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV2(UNUSED_ATTR const uint8_t* p_codec_info,
+                                     BT_HDR* p_buf,
+                                     uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV2(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  LOG_DEBUG( "%s", __func__);
+
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV2 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG( "\tsamp_freq: 0x%x", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    LOG_DEBUG( "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    LOG_DEBUG( "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    LOG_DEBUG( "\tsamp_freq: (88200)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    LOG_DEBUG( "\tsamp_freq: (96000)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV2(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV2(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV2 fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version <= A2DP_LHDC_VER2),
+              "LHDC V2");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV2(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSourceCodecValidLhdcV2(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv2;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV2(uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV2(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV2(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV2(void) { return "LHDC V2"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg) {
+  if (A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
+                         p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV2::A2dpCodecConfigLhdcV2(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2, "LHDC V2",
+                      codec_priority) {
+  // Compute the local capability
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
+
+  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV2::~A2dpCodecConfigLhdcV2() {}
+
+bool A2dpCodecConfigLhdcV2::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV2()) {
+    LOG_ERROR( "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV2::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDC_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV2::copySinkCapability(uint8_t * codec_info){
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
+    return true;
+}
+
+bool A2dpCodecConfigLhdcV2::setCodecConfig(const uint8_t* p_peer_codec_info,
+                                         bool is_capability,
+                                         uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE sink_info_cie;
+  tA2DP_LHDC_CIE result_config_cie;
+  uint8_t sampleRate;
+  uint8_t qualityMode = 0;
+  uint8_t bitRateQmode = 0;
+  bool isLLEnabled;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV2(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
+              __func__, status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
+
+  if (sink_info_cie.version > a2dp_lhdc_source_caps.version) {
+    LOG_ERROR( "%s: Sink capbility version miss match! peer(%d), host(%d)",
+              __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
+    goto fail;
+  }
+
+  result_config_cie.version = sink_info_cie.version;
+
+  if (sink_info_cie.channelSplitMode & A2DP_LHDC_CH_SPLIT_TWS) {
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_TWS;
+  }else{
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
+  }
+
+
+  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
+  result_config_cie.isLLSupported = false;
+  switch (codec_user_config_.codec_specific_2 & 0x1ULL) {
+    case A2DP_LHDC_LL_ENABLE:
+    if (isLLEnabled) {
+      result_config_cie.isLLSupported = true;
+      codec_config_.codec_specific_2 |= 0x1ULL;
+    }
+    break;
+    case A2DP_LHDC_LL_DISABLE:
+      result_config_cie.isLLSupported = false;
+      codec_config_.codec_specific_2 &= ~0x1ULL;
+    break;
+  }
+  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
+  LOG_ERROR( "%s: isLLSupported, Sink(0x%02x) Set(0x%08x), result(0x%02x)", __func__,
+                                sink_info_cie.isLLSupported,
+                                (uint32_t)codec_user_config_.codec_specific_2,
+                                result_config_cie.isLLSupported);
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
+  LOG_ERROR( "%s: samplrate = 0x%x", __func__, sampleRate);
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) break;
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                 &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_sample_rate(
+            a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
+            &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                &codec_config_)) {
+      break;
+    }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(
+              "%s: cannot match sample frequency: source caps = 0x%x "
+              "sink info = 0x%x",
+              __func__, a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+
+  //
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  LOG_ERROR( "%s: a2dp_lhdc_source_caps.bits_per_sample = 0x%02x, sink_info_cie.bits_per_sample = 0x%02x", __func__, a2dp_lhdc_source_caps.bits_per_sample, sink_info_cie.bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) break;
+
+    // Compute the common capability
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      break;
+    }
+  } while (false);
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(
+              "%s: cannot match bits per sample: default = 0x%x "
+              "user preference = 0x%x",
+              __func__, a2dp_lhdc_default_config.bits_per_sample,
+              codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+
+  //
+  // Select the channel mode
+  //
+  LOG_ERROR( "%s: channelMode = Only supported stereo", __func__);
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      codec_capability_.channel_mode = codec_user_config_.channel_mode;
+      codec_config_.channel_mode = codec_user_config_.channel_mode;
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    LOG_ERROR(
+              "%s: codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO "
+              , __func__);
+    goto fail;
+  }
+
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+
+  LOG_DEBUG( "%s: max target bitrate: 0x%02x", __func__,
+      result_config_cie.maxTargetBitrate);
+
+
+  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+  LOG_ERROR("%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
+
+  // quality mode (BitRate) adjust
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
+    LOG_DEBUG( "%s: tag not match, use default Mode: ABR", __func__);
+  }
+  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDC_QUALITY_MASK;
+
+  //
+  // quality mode adjust when non-ABR
+  //
+  if (qualityMode != A2DP_LHDC_QUALITY_ABR) {
+    // get corresponding quality mode of the max target bit rate
+    if (!A2DP_MaxBitRatetoQualityLevelLhdcV2(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+      LOG_ERROR( "%s: get quality mode from maxTargetBitrate error", __func__);
+      goto fail;
+    }
+    // downgrade audio quality according to the max target bit rate
+    if (qualityMode > bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LOG_DEBUG( "%s: downgrade quality mode to 0x%02X by max target bitrate", __func__, qualityMode);
+    }
+
+    // High1(1000K) does not supported in V2, downgrade to High(900K)
+    if (qualityMode == A2DP_LHDC_QUALITY_HIGH1) {
+      LOG_DEBUG( "%s: reset non-supported quality mode %s to HIGH (900 Kbps)", __func__,
+          lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+      qualityMode = A2DP_LHDC_QUALITY_HIGH;
+    }
+  }
+
+  LOG_DEBUG( "%s: => final quality mode(0x%02X) = %s", __func__,
+      qualityMode,
+      lhdcV2_QualityModeBitRate_toString(qualityMode).c_str());
+
+  if (int ret = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                         p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR("%s: A2DP_BuildInfoLhdcV2 fail(0x%x)", __func__, ret);
+    goto fail;
+  }
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  //codec_config_.codec_specific_3 = result_config_cie.isLLSupported == true ? 1 : 0;
+
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+    LOG_ERROR("%s: is_capability = %d", __func__, is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                              ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+
+
+bool A2dpCodecConfigLhdcV2::setPeerCodecCapabilities(
+                                                   const uint8_t* p_peer_codec_capabilities) {
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    tA2DP_LHDC_CIE peer_info_cie;
+    uint8_t sampleRate;
+    uint8_t bits_per_sample;
+
+    // Save the internal state
+    btav_a2dp_codec_config_t saved_codec_selectable_capability =
+    codec_selectable_capability_;
+    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+           sizeof(ota_codec_peer_capability_));
+
+    tA2DP_STATUS status =
+    A2DP_ParseInfoLhdcV2(&peer_info_cie, p_peer_codec_capabilities, true);
+    if (status != A2DP_SUCCESS) {
+        LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
+                  __func__, status);
+        goto fail;
+    }
+
+    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
+        LOG_ERROR( "%s: can't parse peer's capabilities: Missmatch version(%u:%u)",
+                  __func__, a2dp_lhdc_source_caps.version, peer_info_cie.version);
+        goto fail;
+    }
+
+    codec_selectable_capability_.codec_specific_3 = peer_info_cie.isLLSupported ? 1 : 0;
+
+    // Compute the selectable capability - bits per sample
+    //codec_selectable_capability_.bits_per_sample =
+    //a2dp_lhdc_source_caps.bits_per_sample;
+    bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    }
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    }
+
+
+    // Compute the selectable capability - sample rate
+    sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+
+    // Compute the selectable capability - channel mode
+    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+    status = A2DP_BuildInfoLhdcV2(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                                ota_codec_peer_capability_);
+    CHECK(status == A2DP_SUCCESS);
+    return true;
+
+fail:
+    // Restore the internal state
+    codec_selectable_capability_ = saved_codec_selectable_capability;
+    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+           sizeof(ota_codec_peer_capability_));
+    return false;
+}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
new file mode 100644
index 000000000..675125a3d
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv2_encoder.cc
@@ -0,0 +1,941 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv2_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv2_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv2.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static void* lhdc_encoder_lib_handle = NULL;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+
+//static const char* LHDC_GET_SAMPLING_FREQ_NAME = "lhdcBT_get_sampling_freq";
+//typedef int (*tLHDC_GET_SAMPLING_FREQ)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_INIT_HANDLE_ENCODE_NAME = "lhdcBT_init_encoder";
+typedef int (*tLHDC_INIT_HANDLE_ENCODE)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+
+
+static const char* LHDC_ENCODE_NAME = "lhdcBT_encode";
+typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* p_stream);
+
+static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
+typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
+
+//static const char* LHDC_GET_ERROR_CODE_NAME = "lhdcBT_get_error_code";
+//typedef int (*tLHDC_GET_ERROR_CODE)(HANDLE_LHDC_BT hLhdcParam);
+
+//static const char* LHDC_GET_SUPPORTED_VERSION = "lhdcBT_getSupportedVersion";
+//typedef int (*tLHDC_GET_SUPPORTED_VERSION)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
+typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
+
+static tLHDC_GET_HANDLE lhdc_get_handle_func;
+static tLHDC_FREE_HANDLE lhdc_free_handle_func;
+static tLHDC_GET_BITRATE lhdc_get_bitrate_func;
+static tLHDC_SET_BITRATE lhdc_set_bitrate_func;
+static tLHDC_INIT_HANDLE_ENCODE lhdc_init_handle_encode_func;
+static tLHDC_ENCODE lhdc_encode_func;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate_func;
+//static tLHDC_GET_ERROR_CODE lhdc_get_error_code_func;
+static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
+//static tLHDC_GET_SUPPORTED_VERSION lhdc_get_supported_version;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 11
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
+
+typedef struct {
+  uint32_t sample_rate;
+  uint8_t channel_mode;
+  uint8_t bits_per_sample;
+  int quality_mode_index;
+  int latency_mode_index;
+  int pcm_wlength;
+  LHDCBT_SMPL_FMT_T pcm_fmt;
+  int8_t channelSplitMode;
+  int8_t maxTargetBitrate;
+  bool isLLEnabled;
+} tA2DP_LHDC_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+  uint32_t n_frames;
+} tA2DP_LHDC_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  size_t media_read_total_expected_packets;
+  size_t media_read_total_expected_reads_count;
+  size_t media_read_total_expected_read_bytes;
+
+  size_t media_read_total_dropped_packets;
+  size_t media_read_total_actual_reads_count;
+  size_t media_read_total_actual_read_bytes;
+} a2dp_lhdc_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint16_t TxAaMtuSize;
+  size_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDC_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+  uint8_t version;
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdc_encoder_stats_t stats;
+  uint32_t buf_seq;
+} tA2DP_LHDC_ENCODER_CB;
+
+//static bool lhdc_abr_loaded = false;
+
+
+
+typedef struct _lhdc_frame_Info {
+    uint32_t frame_len;
+    uint32_t isSplit;
+    uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+#define _RECODER_FILE_
+#if defined(_RECODER_FILE_)
+static FILE  *RecFile = NULL;
+#endif
+
+static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated);
+static void a2dp_lhdcv2_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us);
+static void a2dp_lhdcv2_encode_frames(uint8_t nb_frame);
+static bool a2dp_lhdcv2_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+static std::string quality_mode_index_to_name(int quality_mode_index);
+//static std::string latency_mode_index_to_name(int latency_mode_index);
+
+static void* load_func(const char* func_name) {
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadEncoderLhdcV2();
+    return NULL;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV2(void) {
+  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == NULL) {
+    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
+              LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdc_get_handle_func = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle_func == NULL) return false;
+  lhdc_free_handle_func = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle_func == NULL) return false;
+  lhdc_get_bitrate_func = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate_func == NULL) return false;
+  lhdc_set_bitrate_func = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate_func == NULL) return false;
+  lhdc_init_handle_encode_func =
+      (tLHDC_INIT_HANDLE_ENCODE)load_func(LHDC_INIT_HANDLE_ENCODE_NAME);
+  if (lhdc_init_handle_encode_func == NULL) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == NULL) return false;
+  lhdc_auto_adjust_bitrate_func = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate_func == NULL) return false;
+  //lhdc_get_error_code_func = (tLHDC_GET_ERROR_CODE)load_func(LHDC_GET_ERROR_CODE_NAME);
+  //if (lhdc_get_error_code_func == NULL) return false;
+
+
+  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+  if (lhdc_set_limit_bitrate == NULL) return false;
+  //lhdc_get_supported_version = (tLHDC_GET_SUPPORTED_VERSION)load_func(LHDC_GET_SUPPORTED_VERSION);
+  //if (lhdc_get_supported_version == NULL) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == NULL) return false;
+
+  return true;
+}
+
+void A2DP_VendorUnloadEncoderLhdcV2(void) {
+  // Cleanup any LHDC-related state
+
+    LOG_DEBUG( "%s: a2dp_lhdc_encoder_cb.has_lhdc_handle = %d, lhdc_free_handle_func = %p",
+              __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle_func);
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle_func != NULL)
+    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle_func = NULL;
+  lhdc_free_handle_func = NULL;
+  lhdc_get_bitrate_func = NULL;
+  lhdc_set_bitrate_func = NULL;
+  lhdc_init_handle_encode_func = NULL;
+  lhdc_encode_func = NULL;
+  lhdc_auto_adjust_bitrate_func = NULL;
+  //lhdc_get_error_code_func = NULL;
+  lhdc_set_limit_bitrate = NULL;
+
+  if (lhdc_encoder_lib_handle != NULL) {
+    dlclose(lhdc_encoder_lib_handle);
+    lhdc_encoder_lib_handle = NULL;
+  }
+}
+
+void a2dp_vendor_lhdcv2_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv2_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+                                  a2dp_codec_config, &restart_input,
+                                  &restart_output, &config_updated);
+}
+
+bool A2dpCodecConfigLhdcV2::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid peer MTU",
+              __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv2_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+                                  p_restart_input, p_restart_output,
+                                  p_config_updated);
+  return true;
+}
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv2_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated) {
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  //Example for limit bit rate
+  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
+
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid codec config",
+              __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+  const uint8_t* p_codec_info = codec_info;
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle_func(A2DP_VendorGetVersionLhdcV2(p_codec_info) <= A2DP_LHDC_VER2 ? 1 : -1);
+      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
+        LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
+        return;  // TODO: Return an error?
+      }
+      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV2(p_codec_info);
+
+
+  // The feeding parameters
+  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  p_feeding_params->sample_rate =
+      A2DP_VendorGetTrackSampleRateLhdcV2(p_codec_info);
+  p_feeding_params->bits_per_sample =
+      a2dp_codec_config->getAudioBitsPerSample();
+  p_feeding_params->channel_count =
+      A2DP_VendorGetTrackChannelCountLhdcV2(p_codec_info);
+  LOG_DEBUG( "%s:(feeding) sample_rate=%u bits_per_sample=%u channel_count=%u",
+            __func__, p_feeding_params->sample_rate,
+            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+
+  // The codec parameters
+  p_encoder_params->sample_rate =
+      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  uint16_t mtu_size =
+      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = a2dp_lhdc_encoder_cb.TxAaMtuSize & ((uint16_t)0xFFFE);
+
+  //get separation feature.
+  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV2(p_codec_info);
+  // Set the quality mode index
+  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+  LOG_DEBUG( "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_1 & 0xff;
+
+      // adjust non-supported quality modes and wrap to internal library used index
+      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+        newValue = LHDCBT_QUALITY_AUTO; //9->8
+      }
+
+      if (newValue != p_encoder_params->quality_mode_index) {
+        p_encoder_params->quality_mode_index = newValue;
+        LOG_DEBUG( "%s: setting internal quality mode: %s(%d)", __func__,
+            quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+            .c_str(), p_encoder_params->quality_mode_index);
+      }
+  }else {
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
+  }
+
+  //To correcting data to middle.
+  if (p_encoder_params->channelSplitMode >= A2DP_LHDC_CH_SPLIT_TWS
+       && p_encoder_params->quality_mode_index >= LHDCBT_QUALITY_HIGH) {
+      /* code */
+      LOG_DEBUG( "%s: Channel separation enabled, Max bit rate = LHDCBT_QUALITY_MID", __func__);
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_MID;
+  }
+
+  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV2(p_codec_info);
+
+/*
+  //p_encoder_params->latency_mode_index = 1;
+  if ((codec_config.codec_specific_2 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_LATENCY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_2 & 0xff;
+      if (newValue != p_encoder_params->latency_mode_index) {
+          p_encoder_params->latency_mode_index = newValue;
+          LOG_DEBUG( "%s: setting latency value to %s(%d)", __func__,
+                    latency_mode_index_to_name(p_encoder_params->latency_mode_index).c_str(),
+                    p_encoder_params->latency_mode_index);
+      }
+  }else {
+      p_encoder_params->latency_mode_index = A2DP_LHDC_LATENCY_MID;
+  }
+*/
+
+  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
+
+
+  p_encoder_params->pcm_wlength =
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
+  // Set the Audio format from pcm_wlength
+  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  if (p_encoder_params->pcm_wlength == 2)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  else if (p_encoder_params->pcm_wlength == 3)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+ // else if (p_encoder_params->pcm_wlength == 4)
+//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
+
+  LOG_DEBUG( "%s: MTU=%d, peer_mtu=%d", __func__,
+            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
+  LOG_DEBUG(
+            "%s: sample_rate: %d "
+            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
+            __func__, p_encoder_params->sample_rate,
+            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+            p_encoder_params->pcm_fmt);
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  int result = lhdc_init_handle_encode_func(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
+      0 /* This parameter alaways is 0 in A2DP */ ,
+      max_mtu_len,
+      a2dp_vendor_lhdcv2_get_encoder_interval_ms()
+  );
+    lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
+
+    lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+
+#if defined(_RECODER_FILE_)
+  if (RecFile == NULL) {
+      RecFile = fopen("/sdcard/Download/lhdc.raw","wb");
+    LOG_ERROR( "%s: Create recode file = %p", __func__, RecFile);
+  }
+#endif
+  if (result != 0) {
+    LOG_ERROR( "%s: error initializing the LHDC encoder: %d", __func__,
+              result);
+  }
+}
+
+void a2dp_vendor_lhdcv2_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle_func(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+#if defined(_RECODER_FILE_)
+  if (RecFile != NULL) {
+      fclose(RecFile);
+      RecFile = NULL;
+  }
+#endif
+}
+
+void a2dp_vendor_lhdcv2_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  int encoder_interval = a2dp_vendor_lhdcv2_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+       encoder_interval) /
+      1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG("%s: has_lhdc_handle %d (%d)", __func__,
+      a2dp_lhdc_encoder_cb.has_lhdc_handle,p_encoder_params->quality_mode_index);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate_func != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle)
+      lhdc_set_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+  }
+  LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+void a2dp_vendor_lhdcv2_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames = 0;
+  LOG_DEBUG( "%s", __func__);
+}
+
+uint64_t a2dp_vendor_lhdcv2_get_encoder_interval_ms(void) {
+  //LOG_DEBUG( "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",
+              //__func__, a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+      return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+void a2dp_vendor_lhdcv2_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv2_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_DEBUG( "%s: Sending %d frames per iteration, %d iterations",
+              __func__, nb_frame, nb_iterations);
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    if (a2dp_lhdc_encoder_cb.version <= 1) {
+        a2dp_lhdcv2_encode_frames(nb_frame);
+    }
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv2_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us) {
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+  uint32_t pcm_bytes_per_frame = LHDCV2_BT_ENC_BLOCK_SIZE *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;;
+  //LOG_DEBUG( "%s: pcm_bytes_per_frame %u", __func__,
+//              pcm_bytes_per_frame);
+
+  int encoder_interval = a2dp_vendor_lhdcv2_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
+    us_this_tick =
+        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  //LOG_DEBUG( "%s: effective num of frames %u, iterations %u",
+//              __func__, nof, noi);
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames += nof;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames > A2DP_LHDCV2_HDR_NUM_MAX) {
+    nof = A2DP_LHDCV2_HDR_NUM_MAX;
+  } else {
+    nof = a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames;
+  }
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.n_frames -= nof;
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+    if ( p_buf == NULL) {
+        // LeoKu(C): should not happen
+        LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
+        return  NULL;
+    }
+
+    p_buf->offset = A2DP_LHDC_OFFSET;
+    p_buf->len = 0;
+    p_buf->layer_specific = 0;
+    return  p_buf;
+}
+
+/**
+ * get lhdc frame header
+ */
+ /*
+static int a2dp_get_lhdc_header(uint8_t * in, lhdc_frame_Info_t * h) {
+    #define LHDC_HDR_LEN 4
+    uint32_t hdr = 0;
+    int ret = -1;
+    memcpy(&hdr, in , LHDC_HDR_LEN);
+    h->frame_len = ( int)( ( hdr >> 8) & 0x1fff);
+    h->isSplit = ( ( hdr & 0x00600000) == 0x00600000);
+    h->isLeft = ((hdr & 0xf) == 0);
+
+    if ( ( hdr & 0x4c000000) != 0x4c000000){
+        //printf( "lhdc hdr err!\n");
+    } else {
+        ret = 0;
+    }
+    return ret;
+}
+*/
+
+#include <vector>
+using namespace std;
+
+static void a2dp_lhdcv2_encode_frames(uint8_t nb_frame) {
+    BT_HDR * p_buf = NULL;
+    //BT_HDR * p_btBufs[128];
+    vector<BT_HDR * > btBufs;
+    uint8_t nb_frame_org = nb_frame;
+    //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+    //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+    uint32_t pcm_bytes_per_frame = LHDCV2_BT_ENC_BLOCK_SIZE *
+                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+    uint8_t * read_buffer = (uint8_t*)malloc(pcm_bytes_per_frame * 2);
+    uint8_t * write_buffer = (uint8_t*)&(read_buffer[pcm_bytes_per_frame]);
+    uint8_t latency = 0;//p_encoder_params->latency_mode_index;
+    int out_offset = 0;
+    int out_len = 0;
+    static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+    static uint32_t allSendbytes = 0;
+    uint32_t bytes_read = 0;
+
+        while( nb_frame) {
+
+            uint32_t temp_bytes_read = 0;
+            if ( !a2dp_lhdcv2_read_feeding(read_buffer, &temp_bytes_read)) {
+            LOG_WARN( "%s: underflow %d", __func__, nb_frame);
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+                      nb_frame * LHDCV2_BT_ENC_BLOCK_SIZE *
+                      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+                break;
+            }
+            bytes_read += temp_bytes_read;
+            out_offset = 0;
+            out_len = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, write_buffer);
+    #if defined(_RECODER_FILE_)
+            if (RecFile != NULL && out_len > 0) {
+                fwrite(write_buffer, sizeof(uint8_t), out_len, RecFile);
+            }
+    #endif
+            nb_frame--;
+
+            while (out_len > 0) {
+                if (p_buf == NULL) {
+                    if (NULL == (p_buf = bt_buf_new())) {
+                        LOG_ERROR ( "%s: ERROR", __func__);
+                        if (read_buffer) {
+                            free(read_buffer);
+                            read_buffer = NULL;
+                        }
+                        for(BT_HDR*  p : btBufs) {
+                            free(p);
+                        }
+                        btBufs.clear();
+                        return;
+                    }
+                }
+
+                uint8_t *p = ( uint8_t *)( p_buf + 1) + p_buf->offset + p_buf->len;
+                int space = max_mtu_len - p_buf->len;
+                int bytes = ( out_len < space)? out_len : space;
+                memcpy( p, &write_buffer[out_offset], bytes);
+                out_offset += bytes;
+                out_len -= bytes;
+                p_buf->len += bytes;
+                allSendbytes += bytes;
+
+                if ( p_buf->len >= max_mtu_len ) {
+                    btBufs.push_back(p_buf);
+                    // allocate new one
+                    p_buf = NULL;
+                    if (btBufs.size() >= 64) {
+                        LOG_ERROR( "%s: Packet buffer usage to big!(%u)", __func__, (uint32_t)btBufs.size());
+                        break;
+                    }
+                }
+            }
+        }
+        uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+        if (now_ms - time_prev >= 1000 ) {
+            /* code */
+            LOG_WARN( "%s: Current data rate about %d kbps", __func__, (allSendbytes * 8) / 1000);
+            allSendbytes = 0;
+            time_prev = now_ms;
+        }
+
+        if ( p_buf) {
+            btBufs.push_back(p_buf);
+        }
+
+        LOG_DEBUG( "%s:btBufs.size() = %u", __func__, (uint32_t)btBufs.size());
+        if ( btBufs.size() == 1) {
+            p_buf = btBufs[0];
+
+            p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+            p_buf->layer_specific <<= 8;
+            p_buf->layer_specific |= ( latency | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+
+            *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+
+            a2dp_lhdc_encoder_cb.enqueue_callback( p_buf, 1, bytes_read);
+            LOG_DEBUG ( "%s: Read bytes(%d)", __func__, bytes_read);
+            bytes_read = 0;
+
+        } else {
+
+            uint8_t i;
+
+            for( i = 0; i < btBufs.size(); i++) {
+                p_buf = btBufs[i];
+
+                p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+                p_buf->layer_specific <<= 8;
+                p_buf->layer_specific |= ( A2DP_LHDC_HDR_F_MSK | latency);
+
+                if ( i == 0) {
+                    p_buf->layer_specific |= ( A2DP_LHDC_HDR_S_MSK | ( nb_frame_org << A2DP_LHDC_HDR_NUM_SHIFT));
+                } else if ( i == ( btBufs.size() - 1)) {
+                    p_buf->layer_specific |= A2DP_LHDC_HDR_L_MSK;
+                    bytes_read = 0;
+                }
+
+                *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+
+                a2dp_lhdc_encoder_cb.enqueue_callback( p_buf, 1, bytes_read);
+                LOG_DEBUG ( "%s: Read bytes(%d)", __func__, bytes_read);
+            }
+        }
+
+        a2dp_lhdc_encoder_cb.timestamp += ( nb_frame_org * LHDCV2_BT_ENC_BLOCK_SIZE);
+        if (read_buffer) {
+            free(read_buffer);
+            read_buffer = NULL;
+        }
+        btBufs.clear();
+}
+
+static bool a2dp_lhdcv2_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+    uint32_t read_size = LHDCV2_BT_ENC_BLOCK_SIZE * bytes_per_sample;
+
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  uint32_t nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG( "%s: want to read size %u, read byte number %u",
+                    __func__, read_size, nb_byte_read);
+
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+      LOG_ERROR( "%s: PCM data not alignment. The audio sample is shfit %d bytes.", __func__,(nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+
+    *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// internal library: quality mode index table
+static std::string quality_mode_index_to_name(int quality_mode_index) {
+  switch (quality_mode_index) {
+    case LHDCBT_QUALITY_AUTO:
+      return "ABR";
+    case LHDCBT_QUALITY_HIGH:
+      return "HIGH";
+    case LHDCBT_QUALITY_MID:
+      return "MID";
+    case LHDCBT_QUALITY_LOW:
+      return "LOW";
+    case LHDCBT_QUALITY_LOW4:
+      return "LOW_320";
+    case LHDCBT_QUALITY_LOW3:
+      return "LOW_256";
+    case LHDCBT_QUALITY_LOW2:
+      return "LOW_192";
+    case LHDCBT_QUALITY_LOW1:
+      return "LOW_128";
+    case LHDCBT_QUALITY_LOW0:
+      return "LOW_64";
+    default:
+      return "Unknown";
+  }
+}
+/*
+static std::string latency_mode_index_to_name(int latency_mode_index){
+    switch (latency_mode_index) {
+      case A2DP_LHDC_LL_ENABLE:
+        return "LL is enabled";
+      case A2DP_LHDC_LL_DISABLE:
+        return "LL is diabled";
+      default:
+        return "Unknown";
+    }
+}
+*/
+
+void a2dp_vendor_lhdcv2_set_transmit_queue_length(size_t transmit_queue_length) {
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+      LOG_DEBUG( "%s: Auto Bitrate Enabled!", __func__);
+      if (lhdc_auto_adjust_bitrate_func != NULL) {
+          lhdc_auto_adjust_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
+      }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV2::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv2_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV2::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV2::debug_codec_dump(int fd) {
+  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+          "  Packet counts (expected/dropped)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_packets,
+          stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+          "  PCM read counts (expected/actual)                       : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_reads_count,
+          stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+          "  PCM read bytes (expected/actual)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_read_bytes,
+          stats->media_read_total_actual_read_bytes);
+
+  dprintf(
+      fd, "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  dprintf(fd,
+          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+          lhdc_get_bitrate_func(a2dp_lhdc_encoder_cb.lhdc_handle));
+
+  dprintf(fd,
+          "  LHDC saved transmit queue length                        : %zu\n",
+          a2dp_lhdc_encoder_cb.TxQueueLength);
+/*
+  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
+    dprintf(fd,
+            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
+    dprintf(fd,
+            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
+  }
+  */
+}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
new file mode 100644
index 000000000..2269aad67
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3.cc
@@ -0,0 +1,2613 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDC Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv3"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv3.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3_encoder.h"
+#include "bt_utils.h"
+#include "btif_av_co.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;    /* code definition for LHDC API ex: LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE */
+  uint8_t   inSpecBank;     /* in which specific bank */
+  uint8_t   bitPos;         /* at which bit index number of the specific bank */
+}tA2DP_LHDC_FEATURE_POS;
+
+/* source side metadata of JAS feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_JAS = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_JAS_SPEC_BIT_POS,
+};
+/* source side metadata of AR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_AR = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_AR_SPEC_BIT_POS
+};
+/* source side metadata of LLAC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LLAC = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_LLAC_SPEC_BIT_POS
+};
+/* source side metadata of META feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_META = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_META_SPEC_BIT_POS
+};
+/* source side metadata of MBR feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_MBR = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_MBR_SPEC_BIT_POS
+};
+/* source side metadata of LARC feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LARC = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_LARC_SPEC_BIT_POS
+};
+/* source side metadata of LHDCV4 feature */
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_LHDCV4 = {
+    LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+    LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX,
+    A2DP_LHDC_V4_SPEC_BIT_POS
+};
+
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdc_source_caps_all[] = {
+    a2dp_lhdc_source_caps_JAS,
+    a2dp_lhdc_source_caps_AR,
+    a2dp_lhdc_source_caps_LLAC,
+    a2dp_lhdc_source_caps_META,
+    a2dp_lhdc_source_caps_MBR,
+    a2dp_lhdc_source_caps_LARC,
+    a2dp_lhdc_source_caps_LHDCV4,
+};
+
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency for LHDC*/
+  uint8_t llac_sampleRate;  /* Sampling Frequency for LLAC */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+  //uint8_t supportedBitrate;
+  bool hasFeatureJAS;
+  bool hasFeatureAR;
+  bool hasFeatureLLAC;
+  bool hasFeatureMETA;
+  bool hasFeatureMinBitrate;
+  bool hasFeatureLARC;
+  bool hasFeatureLHDCV4;
+} tA2DP_LHDC_CIE;
+
+/* LHDC Source codec capabilities */
+static const tA2DP_LHDC_CIE a2dp_lhdc_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV3_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_96000),
+	(A2DP_LHDC_SAMPLING_FREQ_48000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+    A2DP_LHDC_BITRATE_ALL,
+    //Version number
+    A2DP_LHDC_VER3 | A2DP_LHDC_VER4 | A2DP_LHDC_VER6,
+    //Target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    true,
+
+    /*******************************
+     *  LHDC features/capabilities:
+     *  hasFeatureJAS
+     *  hasFeatureAR
+     *  hasFeatureLLAC
+     *  hasFeatureMETA
+     *  hasFeatureMinBitrate
+     *  hasFeatureLARC
+     *  hasFeatureLHDCV4
+     *******************************/
+    //bool hasFeatureJAS;
+    true,
+
+    //bool hasFeatureAR;
+    true,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    true,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+    //(BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)};
+
+/* for response to API */
+static int A2DP_VendorGetSrcCapNumberLhdcv3()
+{
+  return (sizeof(a2dp_lhdc_source_caps_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
+}
+
+/* for response to API */
+bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t *capVector)
+{
+    int capNumber = 0, run = 0;
+
+    if(!capVector)
+    {
+        LOG_ERROR( "%s: null buffer!", __func__);
+        return false;
+    }
+
+    /* count and check the number of source available capabilities */
+    capNumber = A2DP_VendorGetSrcCapNumberLhdcv3();
+
+    if(capNumber <= 0)
+    {
+      LOG_DEBUG( "%s: no capabilities, nothing to do!", __func__);
+      return true;
+    }
+
+    /* configure capabilities vector for LHDC API */
+    /* Byte-1:      featureCode
+     * Byte-2[7-6]: inSpecBank
+     * Byte-2[5-0]: bitPos
+     */
+    for(int i=0; i<capNumber; i++)
+    {
+      capVector[run] = a2dp_lhdc_source_caps_all[i].featureCode;
+      capVector[run+1] = a2dp_lhdc_source_caps_all[i].inSpecBank | a2dp_lhdc_source_caps_all[i].bitPos;
+      //LOG_DEBUG( "%s: fill cap(%d):[0x%02X 0x%02X]", __func__, i, capVector[run], capVector[run+1]);
+      run+=2;
+    }
+
+    return true;
+}
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDC_CIE a2dp_lhdc_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV3_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // LHDC default best sampleRate
+	A2DP_LHDC_SAMPLING_FREQ_48000,      // LLAC default best sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER3,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    false,
+
+    //bool hasFeatureJAS;
+    false,
+
+    //bool hasFeatureAR;
+    false,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    false,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+static std::string lhdcV3_QualityModeBitRate_toString(uint32_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDC_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDC_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDC_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDC_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDC_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv3 = {
+    a2dp_vendor_lhdcv3_encoder_init,
+    a2dp_vendor_lhdcv3_encoder_cleanup,
+    a2dp_vendor_lhdcv3_feeding_reset,
+    a2dp_vendor_lhdcv3_feeding_flush,
+    a2dp_vendor_lhdcv3_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv3_send_frames,
+    a2dp_vendor_lhdcv3_set_transmit_queue_length};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_peer_codec_info);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV3(uint8_t media_type,
+                                       const tA2DP_LHDC_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
+      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
+      para = para | A2DP_LHDC_BIT_FMT_24;
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
+      para = para | A2DP_LHDC_BIT_FMT_16;
+  }
+
+  if (p_ie->hasFeatureJAS)
+  {
+    para |= A2DP_LHDC_FEATURE_JAS;
+  }
+
+  if (p_ie->hasFeatureAR)
+  {
+    para |= A2DP_LHDC_FEATURE_AR;
+  }
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  if (p_ie->hasFeatureLLAC)
+  {
+    para |= A2DP_LHDC_FEATURE_LLAC;
+  }
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  if (p_ie->hasFeatureMETA)
+  {
+    para |= A2DP_LHDC_FEATURE_META;
+  }
+
+  if (p_ie->hasFeatureMinBitrate)
+  {
+    para |= A2DP_LHDC_FEATURE_MIN_BR;
+  }
+
+  if (p_ie->hasFeatureLARC)
+  {
+    para |= A2DP_LHDC_FEATURE_LARC;
+  }
+
+  if (p_ie->hasFeatureLHDCV4)
+  {
+    para |= A2DP_LHDC_FEATURE_LHDCV4;
+  }
+
+  *p_result++ = para;   //b
+
+  //Save octet 12
+  //para = p_ie->supportedBitrate;
+  //*p_result++ = para;   //c
+
+  LOG_DEBUG( "%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
+                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV3(tA2DP_LHDC_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+
+  //LOG_DEBUG( "%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV3_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG( "%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  LOG_VERBOSE( "%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDC_FEATURE_JAS) != 0) ? true : false;
+
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDC_FEATURE_AR) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+
+  p_ie->hasFeatureLLAC = ((*p_codec_info & A2DP_LHDC_FEATURE_LLAC) != 0) ? true : false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDC_FEATURE_META) != 0) ? true : false;
+
+  p_ie->hasFeatureMinBitrate = ((*p_codec_info & A2DP_LHDC_FEATURE_MIN_BR) != 0) ? true : false;
+
+  p_ie->hasFeatureLARC = ((*p_codec_info & A2DP_LHDC_FEATURE_LARC) != 0) ? true : false;
+
+  p_ie->hasFeatureLHDCV4 = ((*p_codec_info & A2DP_LHDC_FEATURE_LHDCV4) != 0) ? true : false;
+  
+  LOG_DEBUG( "%s:Has LL(%d) JAS(%d) AR(%d) META(%d) LLAC(%d) MBR(%d) LARC(%d) V4(%d)", __func__,
+      p_ie->isLLSupported,
+      p_ie->hasFeatureJAS,
+      p_ie->hasFeatureAR,
+      p_ie->hasFeatureMETA,
+      p_ie->hasFeatureLLAC,
+      p_ie->hasFeatureMinBitrate,
+      p_ie->hasFeatureLARC,
+      p_ie->hasFeatureLHDCV4);
+
+  LOG_DEBUG( "%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+
+  return A2DP_SUCCESS;
+}
+
+// Build the LHDC Media Payload Header.
+// |p_dst| points to the location where the header should be written to.
+// If |frag| is true, the media payload frame is fragmented.
+// |start| is true for the first packet of a fragmented frame.
+// |last| is true for the last packet of a fragmented frame.
+// If |frag| is false, |num| is the number of number of frames in the packet,
+// otherwise is the number of remaining fragments (including this one).
+/*
+static void A2DP_BuildMediaPayloadHeaderLhdc(uint8_t* p, uint16_t num) {
+  if (p == NULL) return;
+  *p = ( uint8_t)( num & 0xff);
+}
+*/
+
+bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the LHDC codec configuration. |p_codec_info| is
+// the device's codec capabilities.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// |p_codec_info| contains the codec capabilities for a peer device that
+// is acting as an A2DP source.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3(
+    const tA2DP_LHDC_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDC_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV3(UNUSED_ATTR bool content_protection_enabled,
+                                  UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V3";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDC_CIE lhdc_cie_a;
+  tA2DP_LHDC_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
+         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
+         (lhdc_cie_a.hasFeatureLLAC == lhdc_cie_b.hasFeatureLLAC) &&
+         (lhdc_cie_a.hasFeatureLHDCV4 == lhdc_cie_b.hasFeatureLHDCV4) &&
+         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+}
+
+// Savitech Patch - START  Offload
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info) {
+
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDC_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDC_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDC_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDC_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDC_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDC_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDC_QUALITY_MID:
+        return 600000;
+      case A2DP_LHDC_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDC_QUALITY_ABR:
+        return 9999999;
+      case A2DP_LHDC_QUALITY_HIGH1:
+        [[fallthrough]];
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+// Savitech Patch - END
+
+int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info) {
+    tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      return 16;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      return 24;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+      return 32;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      return -1;
+  }
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return 2;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+/*
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+
+#define A2DP_LHDC_QUALITY_HIGH   7  // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500/560kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+*/
+  switch (lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) {
+      case A2DP_LHDC_MAX_BIT_RATE_900K:
+      return A2DP_LHDC_QUALITY_HIGH;
+      case A2DP_LHDC_MAX_BIT_RATE_500K:
+      return A2DP_LHDC_QUALITY_MID;
+      case A2DP_LHDC_MAX_BIT_RATE_400K:
+      return A2DP_LHDC_QUALITY_LOW;
+  }
+  return -1;
+}
+
+bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_DEBUG( "%s: isLLSupported =%d", __func__, lhdc_cie.isLLSupported);
+
+  return lhdc_cie.isLLSupported ? true : false;
+}
+
+
+
+
+//Always return newest version.
+uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+  uint8_t result;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+
+  for (result = 0x08; result != 0; ) {
+    if ((lhdc_cie.version & result) != 0) {
+      break;
+    }
+    result >>= 1;
+  }
+  //LOG_DEBUG( "%s: version = 0x%02x, result = 0x%02x", __func__, lhdc_cie.version, result);
+
+
+  switch (result) {
+    case A2DP_LHDC_VER3:
+    return 1;
+    case A2DP_LHDC_VER4:
+    return 2;
+    case A2DP_LHDC_VER5:
+    return 3;
+    case A2DP_LHDC_VER6:
+    return 4;
+    default:
+    return -1;
+  }
+}
+
+
+int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info){
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  LOG_DEBUG( "%s: channelSplitMode =%d", __func__, lhdc_cie.channelSplitMode);
+
+  return lhdc_cie.channelSplitMode;
+
+}
+
+bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLHDCV4;
+}
+
+bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureJAS;
+}
+
+bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureAR;
+}
+
+bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLLAC;
+}
+
+bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureMETA;
+}
+
+bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureMinBitrate;
+}
+
+bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE lhdc_cie;
+  if (A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, false) != A2DP_SUCCESS)
+    return false;
+
+  return lhdc_cie.hasFeatureLARC;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV3(UNUSED_ATTR const uint8_t* p_codec_info,
+                                     BT_HDR* p_buf,
+                                     uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+  //A2DP_BuildMediaPayloadHeaderLhdc(p, frames_per_packet);
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  LOG_DEBUG( "%s", __func__);
+
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV3 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG( "\tsamp_freq: 0x%x", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    LOG_DEBUG( "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    LOG_DEBUG( "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    LOG_DEBUG( "\tsamp_freq: (88200)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    LOG_DEBUG( "\tsamp_freq: (96000)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDC_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV3(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV3 fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
+              "LHDC V3");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSourceCodecValidLhdcV3(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv3;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info) {
+  tA2DP_LHDC_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV3(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV3(void) { return "LHDC V3"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg) {
+  if (A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdc_source_caps,
+                         p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDC_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV3::A2dpCodecConfigLhdcV3(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfig(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3, "LHDC V3",
+                      codec_priority) {
+  // Compute the local capability
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  }
+  if (a2dp_lhdc_source_caps.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  codec_local_capability_.bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample;
+
+  codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+A2dpCodecConfigLhdcV3::~A2dpCodecConfigLhdcV3() {}
+
+bool A2dpCodecConfigLhdcV3::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV3()) {
+    LOG_ERROR( "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+                                    tA2DP_LHDC_CIE* p_result,
+                                    btav_a2dp_codec_config_t* p_codec_config) {
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDC_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        p_result->sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bits_per_sample|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    return true;
+  }
+  if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bits_per_sample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    btav_a2dp_codec_bits_per_sample_t bits_per_sample, tA2DP_LHDC_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  switch (p_codec_audio_config->bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        p_result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        return true;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      break;
+  }
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV3::copySinkCapability(uint8_t * codec_info){
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    memcpy(codec_info, ota_codec_peer_capability_, AVDT_CODEC_SIZE);
+    return true;
+}
+
+static bool A2DP_IsFeatureInUserConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+  default:
+    break;
+  }
+
+  return false;
+}
+static bool A2DP_IsFeatureInCodecConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode)
+{
+  switch(featureCode)
+  {
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+      }
+      break;
+    case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+      {
+        CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_, a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+      }
+      break;
+
+  default:
+    break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV3(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value)
+{
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+  }
+  if(toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_)
+  {
+    SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+  }
+}
+
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV3(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature)
+{
+
+  //LOG_DEBUG( "%s: featureCode:0x%02X toCfgs:0x%04X, toSet:%d", __func__, featureCode, toCodecCfg, hasFeature);
+
+  switch(featureCode)
+  {
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_JAS.inSpecBank, A2DP_LHDC_JAS_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_AR.inSpecBank, A2DP_LHDC_AR_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_META.inSpecBank, A2DP_LHDC_META_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LLAC.inSpecBank, A2DP_LHDC_LLAC_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_MBR.inSpecBank, A2DP_LHDC_MBR_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LARC.inSpecBank, A2DP_LHDC_LARC_ENABLED);
+    break;
+  case LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE:
+    A2DP_UpdateFeatureToSpecLhdcV3(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdc_source_caps_LHDCV4.inSpecBank, A2DP_LHDC_V4_ENABLED);
+    break;
+
+  default:
+    break;
+  }
+}
+
+
+static uint32_t A2DP_MaxBitRatetoQualityLevelLhdcV3(uint8_t maxTargetBitrate)
+{
+	switch (maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK)
+	{
+	case A2DP_LHDC_MAX_BIT_RATE_900K:
+		return A2DP_LHDC_QUALITY_HIGH;
+	case A2DP_LHDC_MAX_BIT_RATE_500K:
+		return A2DP_LHDC_QUALITY_MID;
+	case A2DP_LHDC_MAX_BIT_RATE_400K:
+		return A2DP_LHDC_QUALITY_LOW;
+	default:
+		return (0xFF);
+	}
+}
+
+
+bool A2dpCodecConfigLhdcV3::setCodecConfig(const uint8_t* p_peer_codec_info,
+                                         bool is_capability,
+                                         uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDC_CIE sink_info_cie;
+  tA2DP_LHDC_CIE result_config_cie;
+  uint8_t sampleRate;
+  bool isLLEnabled;
+  bool hasFeature;
+  uint32_t quality_mode, maxBitRate_Qmode;
+  //uint8_t supportedBitrate;
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+         sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  tA2DP_STATUS status =
+      A2DP_ParseInfoLhdcV3(&sink_info_cie, p_peer_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
+              __func__, status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = a2dp_lhdc_source_caps.vendorId;
+  result_config_cie.codecId = a2dp_lhdc_source_caps.codecId;
+
+
+  LOG_DEBUG( "%s: incoming version: peer(0x%02x), host(0x%02x)",
+            __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
+
+  // 2021/08/19: when sink's version is "V3_NotComapatible(version == A2DP_LHDC_VER6(0x8))",
+  //				wrap it to A2DP_LHDC_VER3 to accept and treat as an A2DP_LHDC_VER3 device.
+  if(sink_info_cie.version == A2DP_LHDC_VER6) {
+	  sink_info_cie.version = A2DP_LHDC_VER3;
+	  LOG_DEBUG( "%s: wrap V3_NotComapatible sink version to A2DP_LHDC_VER3", __func__);
+  }
+
+  if ((sink_info_cie.version & a2dp_lhdc_source_caps.version) == 0) {
+    LOG_ERROR( "%s: Sink versoin unsupported! peer(0x%02x), host(0x%02x)",
+              __func__, sink_info_cie.version, a2dp_lhdc_source_caps.version);
+    goto fail;
+  }
+  result_config_cie.version = sink_info_cie.version;
+
+
+/*
+  if (sink_info_cie.channelSplitMode & A2DP_LHDC_CH_SPLIT_TWS) {
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_TWS;
+  }else{
+      result_config_cie.channelSplitMode = A2DP_LHDC_CH_SPLIT_NONE;
+  }
+  */
+
+  LOG_DEBUG( "%s: Enter User_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)(codec_user_config_.codec_specific_1),
+		  (unsigned long long)(codec_user_config_.codec_specific_2),
+		  (unsigned long long)(codec_user_config_.codec_specific_3),
+		  (unsigned long long)(codec_user_config_.codec_specific_4));
+  LOG_DEBUG( "%s: Enter Codec_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)(codec_config_.codec_specific_1),
+		  (unsigned long long)(codec_config_.codec_specific_2),
+		  (unsigned long long)(codec_config_.codec_specific_3),
+		  (unsigned long long)(codec_config_.codec_specific_4));
+
+  /*******************************************
+   * Update Capabilities: LHDC Low Latency
+   * to A2DP specifics 2
+   *******************************************/
+  isLLEnabled = (a2dp_lhdc_source_caps.isLLSupported & sink_info_cie.isLLSupported);
+  result_config_cie.isLLSupported = false;
+  switch (codec_user_config_.codec_specific_2 & A2DP_LHDC_LL_ENABLED) {
+    case A2DP_LHDC_LL_ENABLE:
+    if (isLLEnabled) {
+      result_config_cie.isLLSupported = true;
+      codec_config_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    }
+    break;
+    case A2DP_LHDC_LL_DISABLE:
+    if (!isLLEnabled) {
+      result_config_cie.isLLSupported = false;
+      codec_config_.codec_specific_2 &= ~A2DP_LHDC_LL_ENABLED;
+    }
+    break;
+  }
+  if (isLLEnabled) {
+    codec_selectable_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+    codec_capability_.codec_specific_2 |= A2DP_LHDC_LL_ENABLED;
+  }
+  //result_config_cie.isLLSupported = sink_info_cie.isLLSupported;
+  LOG_DEBUG( "%s: isLLSupported, Sink(0x%02x) Set(0x%08x), result(0x%02x)", __func__,
+                                sink_info_cie.isLLSupported,
+                                (uint32_t)codec_user_config_.codec_specific_2,
+                                result_config_cie.isLLSupported);
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = a2dp_lhdc_source_caps.sampleRate & sink_info_cie.sampleRate;
+  LOG_DEBUG( "%s: sampleRate src:0x%x sink:0x%x matched:0x%x", __func__,
+		  a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate, sampleRate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_44100;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_88200;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+      if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_96000;
+        codec_capability_.sample_rate = codec_user_config_.sample_rate;
+        codec_config_.sample_rate = codec_user_config_.sample_rate;
+      }
+      break;
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+      codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+      break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+      codec_selectable_capability_.sample_rate |=
+          BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+    //Above Parts: if codec_config is setup successfully(ie., sampleRate in codec_user_config_ is valid), ignore following parts.
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    	LOG_DEBUG( "%s: setup sample_rate:0x%x from user_config", __func__, codec_config_.sample_rate);
+    	break;
+    }
+    //Below Parts: if codec_config is still not setup successfully, test default sample rate or use the best match
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+                                 &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select audio sample rate:(0x%x)", __func__, result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (sink_info_cie.hasFeatureLLAC) {
+      if (select_best_sample_rate(
+              a2dp_lhdc_default_config.llac_sampleRate & sink_info_cie.sampleRate,
+              &result_config_cie, &codec_config_)) {
+    	LOG_DEBUG( "%s: select best sample rate(LLAC default):0x%x", __func__, result_config_cie.sampleRate);
+        break;
+      }
+    } else {
+      if (select_best_sample_rate(
+              a2dp_lhdc_default_config.sampleRate & sink_info_cie.sampleRate,
+              &result_config_cie, &codec_config_)) {
+        LOG_DEBUG( "%s: select best sample rate(LHDC default):0x%x", __func__, result_config_cie.sampleRate);
+        break;
+      }
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+                                &codec_config_)) {
+      LOG_DEBUG( "%s: select best sample rate(best):0x%x", __func__, result_config_cie.sampleRate);
+      break;
+    }
+  } while (false);
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(
+              "%s: cannot match sample frequency: source caps = 0x%x "
+              "sink info = 0x%x",
+              __func__, a2dp_lhdc_source_caps.sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+
+  //
+  // Select the bits per sample
+  //
+  // NOTE: this information is NOT included in the LHDC A2DP codec description
+  // that is sent OTA.
+  bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & sink_info_cie.bits_per_sample;
+  LOG_DEBUG( "%s: bits_per_sample src:0x%02x sink:0x%02x matched:0x%02x", __func__,
+		  a2dp_lhdc_source_caps.bits_per_sample, sink_info_cie.bits_per_sample, bits_per_sample);
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+        codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+      }
+      break;
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+      result_config_cie.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+      break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+      // Compute the selectable capability
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE){
+    	LOG_DEBUG( "%s: setup bit_per_sample:0x%02x user_config", __func__, codec_config_.bits_per_sample);
+    	break;
+    }
+
+    // Compute the common capability
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bits_per_sample,
+                                     &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select audio bits_per_sample:0x%x", __func__, result_config_cie.bits_per_sample);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(a2dp_lhdc_default_config.bits_per_sample & sink_info_cie.bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select best bits_per_sample(default):0x%x", __func__, result_config_cie.bits_per_sample);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bits_per_sample,
+                                    &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select best bits_per_sample(best):0x%x", __func__, result_config_cie.bits_per_sample);
+      break;
+    }
+  } while (false);
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(
+              "%s: cannot match bits per sample: default = 0x%x "
+              "user preference = 0x%x",
+              __func__, a2dp_lhdc_default_config.bits_per_sample,
+              codec_user_config_.bits_per_sample);
+    goto fail;
+  }
+
+  //
+  // Select the channel mode
+  //
+  LOG_DEBUG( "%s: channelMode = Only supported stereo", __func__);
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  switch (codec_user_config_.channel_mode) {
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO:
+      codec_capability_.channel_mode = codec_user_config_.channel_mode;
+      codec_config_.channel_mode = codec_user_config_.channel_mode;
+      break;
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_MONO:
+    case BTAV_A2DP_CODEC_CHANNEL_MODE_NONE:
+      codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+      break;
+  }
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  if (codec_config_.channel_mode == BTAV_A2DP_CODEC_CHANNEL_MODE_NONE) {
+    LOG_ERROR(
+              "%s: codec_config_.channel_mode != BTAV_A2DP_CODEC_CHANNEL_MODE_NONE or BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO "
+              , __func__);
+    goto fail;
+  }
+
+  /*******************************************
+   * Update maxTargetBitrate
+   *
+   *******************************************/
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+
+  LOG_DEBUG( "%s: Config Max bitrate result(0x%02x)", __func__, result_config_cie.maxTargetBitrate);
+
+  /*******************************************
+   * Update channelSplitMode
+   *
+   *******************************************/
+  result_config_cie.channelSplitMode = sink_info_cie.channelSplitMode;
+  LOG_DEBUG("%s: channelSplitMode = %d", __func__, result_config_cie.channelSplitMode);
+
+
+  /*******************************************
+   * quality mode: magic num check and reconfigure
+   * to specific 1
+   *******************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_ABR;
+      LOG_DEBUG("%s: use default quality_mode:ABR", __func__);
+  }
+  quality_mode = codec_user_config_.codec_specific_1 & 0xff;
+
+  // filter non-supported quality modes(those supported in LHDCV5 or higher version) for internal use
+  if (quality_mode == A2DP_LHDC_QUALITY_HIGH1) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_HIGH;
+    quality_mode = A2DP_LHDC_QUALITY_HIGH;
+    LOG_DEBUG("%s: reset non-supported quality_mode to %s", __func__,
+        lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+  }
+
+  /*******************************************
+   * LHDC features: safety tag check
+   * to specific 3
+   *******************************************/
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
+  {
+      LOG_DEBUG( "%s: LHDC feature tag not matched! use old feature settings", __func__);
+
+      /* *
+       * Magic num does not match:
+       * 1. add tag
+       * 2. Re-adjust previous feature(which refers to codec_user_config)'s state(in codec_config_) to codec_user_config_:
+       * 	AR(has UI), Meta(no UI yet), LARC(no UI yet)
+       * */
+      // clean entire specific and set safety tag
+      codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
+
+      // Feature: AR
+      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE) )
+      {
+    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+    	        &allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+    	        true);
+    	    LOG_DEBUG( "%s: restore user_cfg to previous AR status => ON", __func__);
+      }
+      else
+      {
+			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+				&allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+				A2DP_LHDC_TO_A2DP_CODEC_USER_,
+				false);
+			LOG_DEBUG( "%s: restore user_cfg to previous AR status => OFF", __func__);
+      }
+      // Feature: META
+      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE) )
+      {
+    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+    	        &allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+    	        true);
+    	    LOG_DEBUG( "%s: restore user_cfg to previous META status => ON", __func__);
+      }
+      else
+      {
+			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+				&allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+				A2DP_LHDC_TO_A2DP_CODEC_USER_,
+				false);
+			LOG_DEBUG( "%s: restore user_cfg to previous META status => OFF", __func__);
+      }
+      // Feature: LARC
+      if( A2DP_IsFeatureInCodecConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE) )
+      {
+    	    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+    	        &allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+    	        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+    	        true);
+    	    LOG_DEBUG( "%s: restore user_cfg to previous LARC status => ON", __func__);
+      }
+      else
+      {
+			A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+				&allCfgPack,
+				LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+				A2DP_LHDC_TO_A2DP_CODEC_USER_,
+				false);
+			LOG_DEBUG( "%s: restore user_cfg to previous LARC status => OFF", __func__);
+      }
+  }
+  else
+  {
+	  LOG_DEBUG( "%s: LHDC feature tag matched!", __func__);
+  }
+
+
+  /**
+  *LHDC V4 modify
+  */
+
+  /*******************************************
+   * Update Feature/Capabilities: LLAC
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureLLAC = sink_info_cie.hasFeatureLLAC;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLLAC & sink_info_cie.hasFeatureLLAC);
+  result_config_cie.hasFeatureLLAC = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_LLAC_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  if (hasFeature /*&& 
+      (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
+      )*/
+     ) {
+    result_config_cie.hasFeatureLLAC = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    //codec_user_config_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        true);
+  }
+
+  if(hasFeature)
+  {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_LLAC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG( "%s: Has LLAC feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureLLAC,
+                                sink_info_cie.hasFeatureLLAC,
+                                result_config_cie.hasFeatureLLAC);
+  LOG_DEBUG( "%s: LLAC update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_LLAC_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: LHDCV4
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureLHDCV4 = sink_info_cie.hasFeatureLHDCV4;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLHDCV4 & sink_info_cie.hasFeatureLHDCV4);
+  result_config_cie.hasFeatureLHDCV4 = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_V4_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  if (hasFeature /*&& 
+      (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
+      )*/
+     ) {
+    result_config_cie.hasFeatureLHDCV4 = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    //codec_user_config_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_| A2DP_LHDC_TO_A2DP_CODEC_USER_),
+        true);
+  }
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_V4_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG( "%s: Has V4 feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureLHDCV4,
+                                sink_info_cie.hasFeatureLHDCV4,
+                                result_config_cie.hasFeatureLHDCV4);
+  LOG_DEBUG( "%s: V4 update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_V4_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_V4_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: JAS
+   * to A2DP specifics
+   *******************************************/
+  {
+    //result_config_cie.hasFeatureJAS = sink_info_cie.hasFeatureJAS;
+    hasFeature = (a2dp_lhdc_source_caps.hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    result_config_cie.hasFeatureJAS = false;
+
+    /* *
+     * reset bit in A2DP configs
+     *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_JAS_ENABLED;
+     *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_JAS_ENABLED;
+     *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_JAS_ENABLED;
+     * */
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+        false);
+
+    //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED) && hasFeature) {
+    /*  06/02/2021: enable JAS without UI control */
+    //if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE) )
+    if( hasFeature )
+    {
+      result_config_cie.hasFeatureJAS = true;
+      //codec_config_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+          A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+          true);
+    }
+
+    if(hasFeature)
+    {
+      //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
+      //codec_capability_.codec_specific_3 |= A2DP_LHDC_JAS_ENABLED;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+          &allCfgPack,
+          LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+          true);
+    }
+    LOG_DEBUG( "%s: Has JAS feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                  hasFeature,
+                                  a2dp_lhdc_source_caps.hasFeatureJAS,
+                                  sink_info_cie.hasFeatureJAS,
+                                  result_config_cie.hasFeatureJAS);
+    LOG_DEBUG( "%s: JAS update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                  (codec_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
+                                  (codec_capability_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
+                                  (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED),
+                                  (codec_user_config_.codec_specific_3 & A2DP_LHDC_JAS_ENABLED));
+  }
+
+  /*******************************************
+   * Update Feature/Capabilities: AR
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureAR = sink_info_cie.hasFeatureAR;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureAR & sink_info_cie.hasFeatureAR);
+  result_config_cie.hasFeatureAR = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_AR_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_AR_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_AR_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED) && hasFeature) {
+  if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE) ){
+    result_config_cie.hasFeatureAR = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+        true);
+    /* 06/02/2021: When AR function is turned ON, downgrade the sample rate to 48KHz if needed.
+     * 	Reason: prevent high CPU loading of AR engine running on higher sample rate(ex:96KHz)
+     */
+    if(codec_user_config_.sample_rate > BTAV_A2DP_CODEC_SAMPLE_RATE_48000)
+    {
+    	LOG_DEBUG( "%s: Limit current sample rate(0x%02X) to 48Khz when AR feature turnned on", __func__,
+    			codec_user_config_.sample_rate);
+		codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+		codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+		result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+    }
+  }
+
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_AR_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG( "%s: Has AR feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureAR,
+                                sink_info_cie.hasFeatureAR,
+                                result_config_cie.hasFeatureAR);
+  LOG_DEBUG( "%s: AR update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_AR_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_AR_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: META
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureMETA = sink_info_cie.hasFeatureMETA;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+  result_config_cie.hasFeatureMETA = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_META_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_META_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_META_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED) && hasFeature) {
+  if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE) ){
+    result_config_cie.hasFeatureMETA = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+        true);
+  }
+
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_META_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG( "%s: Has META feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureMETA,
+                                sink_info_cie.hasFeatureMETA,
+                                result_config_cie.hasFeatureMETA);
+  LOG_DEBUG( "%s: META update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_META_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_META_ENABLED));
+
+  /*******************************************
+   * Update Feature/Capabilities: MBR
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureMinBitrate = sink_info_cie.hasFeatureMinBitrate;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureMinBitrate & sink_info_cie.hasFeatureMinBitrate);
+  result_config_cie.hasFeatureMinBitrate = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_MBR_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_MBR_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_MBR_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  if (hasFeature) {
+    result_config_cie.hasFeatureMinBitrate = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_MBR_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG( "%s: Has MBR feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureMinBitrate,
+                                sink_info_cie.hasFeatureMinBitrate,
+                                result_config_cie.hasFeatureMinBitrate);
+  LOG_DEBUG( "%s: MBR update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_MBR_ENABLED));
+
+
+  /*******************************************
+   * Update Feature/Capabilities: LARC
+   * to A2DP specifics
+   *******************************************/
+  //result_config_cie.hasFeatureLARC = sink_info_cie.hasFeatureLARC;
+  hasFeature = (a2dp_lhdc_source_caps.hasFeatureLARC & sink_info_cie.hasFeatureLARC);
+  result_config_cie.hasFeatureLARC = false;
+
+  /* *
+   * reset bit in A2DP configs
+   *     codec_config_.codec_specific_3 &= ~A2DP_LHDC_LARC_ENABLED;
+   *     codec_selectable_capability_.codec_specific_3 &= ~A2DP_LHDC_LARC_ENABLED;
+   *     codec_capability_.codec_specific_3 &= ~ A2DP_LHDC_LARC_ENABLED;
+   * */
+  A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+      &allCfgPack,
+      LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+      (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_|A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_|A2DP_LHDC_TO_A2DP_CODEC_CAP_),
+      false);
+
+  //if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED) && hasFeature) {
+  //if( hasFeature && A2DP_IsFeatureInUserConfigLhdcV3(&allCfgPack, LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE) ){
+  if( hasFeature ){
+    result_config_cie.hasFeatureLARC = true;
+    //codec_config_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+        A2DP_LHDC_TO_A2DP_CODEC_CONFIG_,
+        true);
+  }
+
+  if (hasFeature) {
+    //codec_selectable_capability_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
+    //codec_capability_.codec_specific_3 |= A2DP_LHDC_LARC_ENABLED;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV3(
+        &allCfgPack,
+        LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE,
+        (A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        true);
+  }
+
+  LOG_DEBUG( "%s: Has LARC feature?(0x%02x) Src(0x%02x) Sink(0x%02x) result(0x%02x)", __func__,
+                                hasFeature,
+                                a2dp_lhdc_source_caps.hasFeatureLARC,
+                                sink_info_cie.hasFeatureLARC,
+                                result_config_cie.hasFeatureLARC);
+  LOG_DEBUG( "%s: LARC update:[config:(0x%016llX) cap:(0x%016llX) selcap:(0x%016llX) user:(0x%016llX)] ", __func__,
+                                (codec_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
+                                (codec_capability_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
+                                (codec_selectable_capability_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED),
+                                (codec_user_config_.codec_specific_3 & A2DP_LHDC_LARC_ENABLED));
+
+
+  /*******************************************
+   * quality mode: re-adjust according to maxTargetBitrate(smaller one adopted)
+   *******************************************/
+  if ( (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) &&
+	   (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) &&
+	   (quality_mode != A2DP_LHDC_QUALITY_ABR))
+  {
+	  //In this case, max bit rate mechanism is disabled(set to 900k)
+	  result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+	  LOG_DEBUG("%s: [LLAC + LHDC V4]: set MBR (0x%x)", __func__, result_config_cie.maxTargetBitrate);
+
+	  //dont re-adjust quality mode in this case
+	  LOG_DEBUG("%s: do not adjust quality_mode in this case", __func__);
+  }
+  else
+  {
+	  maxBitRate_Qmode = A2DP_MaxBitRatetoQualityLevelLhdcV3(result_config_cie.maxTargetBitrate);
+	  if(maxBitRate_Qmode < 0xFF) {
+		  if(quality_mode != A2DP_LHDC_QUALITY_ABR && quality_mode > maxBitRate_Qmode){
+			  LOG_DEBUG("%s: adjust quality_mode:0x%x to 0x%x by maxTargetBitrate:0x%x", __func__,
+					  quality_mode, maxBitRate_Qmode, result_config_cie.maxTargetBitrate);
+			  quality_mode = maxBitRate_Qmode;
+			  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | quality_mode;
+		  }
+	  }
+  }
+
+  /*
+   * Final Custom Rules of resolving conflict between capabilities and version
+   */
+  if (result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDCV4 + LLAC
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+
+      if (quality_mode == A2DP_LHDC_QUALITY_ABR) {
+		result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+		codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+		codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
+		result_config_cie.hasFeatureLHDCV4 = false;
+		codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+		LOG_DEBUG("%s: [LLAC + LHDC V4]: LLAC, reset sampleRate (0x%x)", __func__, result_config_cie.sampleRate);
+      } else {
+        result_config_cie.hasFeatureLLAC = false;
+        codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+        LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC", __func__);
+
+  	    //result_config_cie.maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+  	    //LOG_DEBUG("%s: [LLAC + LHDC V4]: set MBR (0x%x)", __func__, result_config_cie.maxTargetBitrate);
+
+      	if (result_config_cie.hasFeatureMinBitrate) {
+          if (quality_mode < A2DP_LHDC_QUALITY_MID) {
+            codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_MID;
+            quality_mode = A2DP_LHDC_QUALITY_MID;
+            LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x%x)", __func__, quality_mode);
+          }
+      	} else {
+    	  if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+		    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+		    quality_mode = A2DP_LHDC_QUALITY_LOW;
+		    LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC 96KSR, reset Qmode (0x%x)", __func__, quality_mode);
+		  }
+      	}
+      }
+    } else if (
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR)) ||
+        (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR))
+       ) {
+      result_config_cie.hasFeatureLLAC = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_LLAC_ENABLED;
+      LOG_DEBUG("%s: [LLAC + LHDC V4]: LHDC", __func__);
+    } else if (
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_48000 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR)) ||
+       (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_44100 && (quality_mode <= A2DP_LHDC_QUALITY_LOW || quality_mode == A2DP_LHDC_QUALITY_ABR))
+      ) {
+      result_config_cie.hasFeatureLHDCV4 = false;
+      codec_config_.codec_specific_3 &= ~A2DP_LHDC_V4_ENABLED;
+      LOG_DEBUG("%s: [LLAC + LHDC V4]: LLAC", __func__);
+
+      /* LLAC: prevent quality mode using 64kbps */
+      if (result_config_cie.hasFeatureMinBitrate) {
+    	if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+    	  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
+    	  quality_mode = A2DP_LHDC_QUALITY_LOW1;
+    	  LOG_DEBUG("%s: [LLAC + LHDC V4]: LLAC, reset Qmode (0x%x)", __func__, quality_mode);
+    	}
+      }
+    } else {
+      LOG_ERROR("%s: [LLAC + LHDC V4]: format incorrect.", __func__);
+      goto fail;
+    }
+
+  } else if (!result_config_cie.hasFeatureLLAC && result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V4 only
+    LOG_DEBUG("%s: [LHDCV4 only]", __func__);
+	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+				quality_mode = A2DP_LHDC_QUALITY_LOW;
+				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x)", __func__, quality_mode);
+			}
+		}
+	} else {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+				quality_mode = A2DP_LHDC_QUALITY_LOW4;
+				LOG_DEBUG("%s: [LHDCV4 only]: reset Qmode (0x%x), ", __func__, quality_mode);
+			}
+		}
+	}
+
+  } else if (result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LLAC only
+    LOG_DEBUG("%s: [LLAC only]", __func__);
+    if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDC_SAMPLING_FREQ_48000;
+      codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;	//also set UI settings
+      LOG_DEBUG("%s: [LLAC only]: reset SampleRate (0x%x)", __func__, result_config_cie.sampleRate);
+    }
+
+    if (quality_mode > A2DP_LHDC_QUALITY_LOW && quality_mode != A2DP_LHDC_QUALITY_ABR) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+      quality_mode = A2DP_LHDC_QUALITY_LOW;
+      LOG_DEBUG("%s: [LLAC only]: reset Qmode (0x%x)", __func__, quality_mode);
+    }
+    
+    /* LLAC: prevent quality mode using 64kbps */
+    if (result_config_cie.hasFeatureMinBitrate) {
+		if (quality_mode < A2DP_LHDC_QUALITY_LOW1) {
+		  codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW1;
+		  quality_mode = A2DP_LHDC_QUALITY_LOW1;
+		  LOG_DEBUG("%s: [LLAC only]: reset Qmode (0x%x)", __func__, quality_mode);
+		}
+    }
+
+  } else if (!result_config_cie.hasFeatureLLAC && !result_config_cie.hasFeatureLHDCV4) {
+    //LHDC V3 only
+    LOG_DEBUG("%s: [LHDCV3 only]", __func__);
+	if (result_config_cie.sampleRate == A2DP_LHDC_SAMPLING_FREQ_96000) {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+				quality_mode = A2DP_LHDC_QUALITY_LOW;
+				LOG_DEBUG("%s: [LHDCV3 only]: reset Qmode (0x%x)", __func__, quality_mode);
+			}
+		}
+	} else {
+		if (result_config_cie.hasFeatureMinBitrate) {
+			if (quality_mode < A2DP_LHDC_QUALITY_LOW4) {
+				codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW4;
+				quality_mode = A2DP_LHDC_QUALITY_LOW4;
+				LOG_DEBUG("%s: [LHDCV3 only]: reset Qmode (0x%x), ", __func__, quality_mode);
+			}
+		}
+	}
+  }
+
+  LOG_DEBUG("%s: Final quality_mode = (%d) %s", __func__,
+      quality_mode,
+      lhdcV3_QualityModeBitRate_toString(quality_mode).c_str());
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+  
+  /* Setup final nego result codec config to peer */
+  if (int ret = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                         p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR("%s: A2DP_BuildInfoLhdcV3 fail(0x%x)", __func__, ret);
+    goto fail;
+  }
+
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+    LOG_ERROR("%s: is_capability = %d", __func__, is_capability);
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+                                ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+                              ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+
+  LOG_DEBUG( "%s: Final User_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)codec_user_config_.codec_specific_1,
+		  (unsigned long long)codec_user_config_.codec_specific_2,
+		  (unsigned long long)codec_user_config_.codec_specific_3,
+		  (unsigned long long)codec_user_config_.codec_specific_4);
+  LOG_DEBUG( "%s: Final Codec_SP1=(0x%016llX); SP2=(0x%016llX); SP3=(0x%016llX); SP4=(0x%016llX)", __func__,
+		  (unsigned long long)(codec_config_.codec_specific_1),
+		  (unsigned long long)(codec_config_.codec_specific_2),
+		  (unsigned long long)(codec_config_.codec_specific_3),
+		  (unsigned long long)(codec_config_.codec_specific_4));
+
+  return true;
+
+fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+         sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+         sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+
+
+bool A2dpCodecConfigLhdcV3::setPeerCodecCapabilities(
+                                                   const uint8_t* p_peer_codec_capabilities) {
+    std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+    tA2DP_LHDC_CIE peer_info_cie;
+    uint8_t sampleRate;
+    uint8_t bits_per_sample;
+
+    // Save the internal state
+    btav_a2dp_codec_config_t saved_codec_selectable_capability =
+    codec_selectable_capability_;
+    uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+    memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+           sizeof(ota_codec_peer_capability_));
+
+    tA2DP_STATUS status =
+    A2DP_ParseInfoLhdcV3(&peer_info_cie, p_peer_codec_capabilities, true);
+    if (status != A2DP_SUCCESS) {
+        LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
+                  __func__, status);
+        goto fail;
+    }
+/*
+    if (peer_info_cie.version > a2dp_lhdc_source_caps.version) {
+        LOG_ERROR( "%s: can't parse peer's capabilities: Missmatch version(%u:%u)",
+                  __func__, a2dp_lhdc_source_caps.version, peer_info_cie.version);
+        goto fail;
+    }
+*/
+
+    // Compute the selectable capability - bits per sample
+    //codec_selectable_capability_.bits_per_sample =
+    //a2dp_lhdc_source_caps.bits_per_sample;
+    bits_per_sample = a2dp_lhdc_source_caps.bits_per_sample & peer_info_cie.bits_per_sample;
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    }
+    if (bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    }
+
+
+    // Compute the selectable capability - sample rate
+    sampleRate = a2dp_lhdc_source_caps.sampleRate & peer_info_cie.sampleRate;
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    }
+    if (sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000) {
+        codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    }
+
+
+    // Compute the selectable capability - channel mode
+    codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+    status = A2DP_BuildInfoLhdcV3(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+                                ota_codec_peer_capability_);
+    CHECK(status == A2DP_SUCCESS);
+    return true;
+
+fail:
+    // Restore the internal state
+    codec_selectable_capability_ = saved_codec_selectable_capability;
+    memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+           sizeof(ota_codec_peer_capability_));
+    return false;
+}
+
+
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
new file mode 100644
index 000000000..894cabd0a
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_dec.cc
@@ -0,0 +1,747 @@
+/******************************************************************************
+ *
+ *  Copyright 2002-2012 Broadcom Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at:
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ *
+ ******************************************************************************/
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse SBC Codec Information Element
+ *  and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv3_dec"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv3_dec.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3_decoder.h"
+#include "bt_utils.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+// data type for the LHDC Codec Information Element */
+// NOTE: bits_per_sample is needed only for LHDC encoder initialization.
+typedef struct {
+  uint32_t vendorId;
+  uint16_t codecId;    /* Codec ID for LHDC */
+  uint8_t sampleRate;  /* Sampling Frequency */
+  btav_a2dp_codec_bits_per_sample_t bits_per_sample;
+  uint8_t channelSplitMode;
+  uint8_t version;
+  uint8_t maxTargetBitrate;
+  bool isLLSupported;
+  //uint8_t supportedBitrate;
+  bool hasFeatureJAS;
+  bool hasFeatureAR;
+  bool hasFeatureLLAC;
+  bool hasFeatureMETA;
+  bool hasFeatureMinBitrate;
+  bool hasFeatureLARC;
+  bool hasFeatureLHDCV4;
+} tA2DP_LHDCV3_SINK_CIE;
+
+/* LHDC Sink codec capabilities */
+static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV3_CODEC_ID,   // codecId
+    // sampleRate
+    //(A2DP_LHDC_SAMPLING_FREQ_48000),
+    (A2DP_LHDC_SAMPLING_FREQ_44100 | A2DP_LHDC_SAMPLING_FREQ_48000 | A2DP_LHDC_SAMPLING_FREQ_88200 | A2DP_LHDC_SAMPLING_FREQ_96000),
+    // bits_per_sample
+    (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+    //Channel Separation
+    //A2DP_LHDC_CH_SPLIT_NONE | A2DP_LHDC_CH_SPLIT_TWS,
+	A2DP_LHDC_CH_SPLIT_NONE,
+    //Version number
+    A2DP_LHDC_VER3,
+    //Target bit Rate
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    //LL supported ?
+    true,
+
+    /*******************************
+     *  LHDC features/capabilities:
+     *  hasFeatureJAS
+     *  hasFeatureAR
+     *  hasFeatureLLAC
+     *  hasFeatureMETA
+     *  hasFeatureMinBitrate
+     *  hasFeatureLARC
+     *  hasFeatureLHDCV4
+     *******************************/
+    //bool hasFeatureJAS;
+    true,
+
+    //bool hasFeatureAR;
+    true,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    true,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+/* Default LHDC codec configuration */
+static const tA2DP_LHDCV3_SINK_CIE a2dp_lhdcv3_sink_default_config = {
+    A2DP_LHDC_VENDOR_ID,                // vendorId
+    A2DP_LHDCV3_CODEC_ID,                 // codecId
+    A2DP_LHDC_SAMPLING_FREQ_96000,      // sampleRate
+    BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24,  // bits_per_sample
+    A2DP_LHDC_CH_SPLIT_NONE,
+    A2DP_LHDC_VER3,
+    A2DP_LHDC_MAX_BIT_RATE_900K,
+    false,
+
+    //bool hasFeatureJAS;
+    false,
+
+    //bool hasFeatureAR;
+    false,
+
+    //bool hasFeatureLLAC;
+    true,
+
+    //bool hasFeatureMETA;
+    false,
+
+    //bool hasFeatureMinBitrate;
+    true,
+
+    //bool hasFeatureLARC;
+    false,
+
+    //bool hasFeatureLHDCV4;
+    true,
+};
+
+static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv3 = {
+    a2dp_vendor_lhdcv3_decoder_init,
+    a2dp_vendor_lhdcv3_decoder_cleanup,
+    a2dp_vendor_lhdcv3_decoder_decode_packet,
+    a2dp_vendor_lhdcv3_decoder_start,
+    a2dp_vendor_lhdcv3_decoder_suspend,
+    a2dp_vendor_lhdcv3_decoder_configure,
+};
+
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
+    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability);
+
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV3Sink(uint8_t media_type,
+                                       const tA2DP_LHDCV3_SINK_CIE* p_ie,
+                                       uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  if (p_ie == NULL || p_result == NULL) {
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV3_CODEC_LEN;    //0
+  *p_result++ = (media_type << 4);      //1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //2
+
+  // Vendor ID and Codec ID
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF); //3
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);  //4
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16); //5
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24); //6
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);  //7
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);   //8
+
+  // Sampling Frequency & Bits per sample
+  uint8_t para = 0;
+
+  // sample rate bit0 ~ bit2
+  para = (uint8_t)(p_ie->sampleRate & A2DP_LHDC_SAMPLING_FREQ_MASK);
+
+  if (p_ie->bits_per_sample == (BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24 | BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16)) {
+      para = para | (A2DP_LHDC_BIT_FMT_24 | A2DP_LHDC_BIT_FMT_16);
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24){
+      para = para | A2DP_LHDC_BIT_FMT_24;
+  }else if(p_ie->bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16){
+      para = para | A2DP_LHDC_BIT_FMT_16;
+  }
+
+  if (p_ie->hasFeatureJAS)
+  {
+    para |= A2DP_LHDC_FEATURE_JAS;
+  }
+
+  if (p_ie->hasFeatureAR)
+  {
+    para |= A2DP_LHDC_FEATURE_AR;
+  }
+
+  // Save octet 9
+  *p_result++ = para;   //9
+
+  para = p_ie->version;
+
+  para |= p_ie->maxTargetBitrate;
+
+  para |= p_ie->isLLSupported ? A2DP_LHDC_LL_SUPPORTED : A2DP_LHDC_LL_NONE;
+
+  if (p_ie->hasFeatureLLAC)
+  {
+    para |= A2DP_LHDC_FEATURE_LLAC;
+  }
+
+  // Save octet 10
+  *p_result++ = para;   //a
+
+  //Save octet 11
+  para = p_ie->channelSplitMode;
+
+  if (p_ie->hasFeatureMETA)
+  {
+    para |= A2DP_LHDC_FEATURE_META;
+  }
+
+  if (p_ie->hasFeatureMinBitrate)
+  {
+    para |= A2DP_LHDC_FEATURE_MIN_BR;
+  }
+
+  if (p_ie->hasFeatureLARC)
+  {
+    para |= A2DP_LHDC_FEATURE_LARC;
+  }
+
+  if (p_ie->hasFeatureLHDCV4)
+  {
+    para |= A2DP_LHDC_FEATURE_LHDCV4;
+  }
+
+  *p_result++ = para;   //b
+
+  //Save octet 12
+  //para = p_ie->supportedBitrate;
+  //*p_result++ = para;   //c
+
+  LOG_DEBUG("%s: Info build result = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, "
+                     "[4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+     __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3],
+                    tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV3Sink(tA2DP_LHDCV3_SINK_CIE* p_ie,
+                                       const uint8_t* p_codec_info,
+                                       bool is_capability) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+  const uint8_t* p_codec_Info_save = p_codec_info;
+
+  //LOG_DEBUG("%s: p_ie = %p, p_codec_info = %p", __func__, p_ie, p_codec_info);
+  if (p_ie == NULL || p_codec_info == NULL) return A2DP_INVALID_PARAMS;
+
+  // Check the codec capability length
+  losc = *p_codec_info++;
+
+  if (losc != A2DP_LHDCV3_CODEC_LEN) return A2DP_WRONG_CODEC;
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+    //LOG_DEBUG("%s: media_type = %d, codec_type = %d", __func__, media_type, codec_type);
+  /* Check the Media Type and Media Codec Type */
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Check the Vendor ID and Codec ID */
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+                   (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+                   (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+                   (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId =
+      (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  LOG_DEBUG("%s:Vendor(0x%08x), Codec(0x%04x)", __func__, p_ie->vendorId, p_ie->codecId);
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV3_CODEC_ID) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->sampleRate = *p_codec_info & A2DP_LHDC_SAMPLING_FREQ_MASK;
+  if ((*p_codec_info & A2DP_LHDC_BIT_FMT_MASK) == 0) {
+    return A2DP_WRONG_CODEC;
+  }
+
+  p_ie->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_24)
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (*p_codec_info & A2DP_LHDC_BIT_FMT_16) {
+    p_ie->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+
+
+  p_codec_info += 1;
+
+  p_ie->version = (*p_codec_info) & A2DP_LHDC_VERSION_MASK;
+  //p_ie->version = 1;
+
+  p_ie->maxTargetBitrate = (*p_codec_info) & A2DP_LHDC_MAX_BIT_RATE_MASK;
+  //p_ie->maxTargetBitrate = A2DP_LHDC_MAX_BIT_RATE_900K;
+
+  p_ie->isLLSupported = ((*p_codec_info & A2DP_LHDC_LL_MASK) != 0)? true : false;
+  //p_ie->isLLSupported = false;
+
+  p_codec_info += 1;
+
+  p_ie->channelSplitMode = (*p_codec_info) & A2DP_LHDC_CH_SPLIT_MSK;
+
+  //p_codec_info += 1;
+
+  //p_ie->supportedBitrate = (*p_codec_info);
+
+
+
+
+    LOG_DEBUG("%s: codec info = [0]:0x%x, [1]:0x%x, [2]:0x%x, [3]:0x%x, [4]:0x%x, [5]:0x%x, [6]:0x%x, [7]:0x%x, [8]:0x%x, [9]:0x%x, [10]:0x%x, [11]:0x%x",
+            __func__, tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6],
+                        tmpInfo[7], tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11]);
+
+  if (is_capability) return A2DP_SUCCESS;
+
+  if (A2DP_BitsSet(p_ie->sampleRate) != A2DP_SET_ONE_BIT)
+    return A2DP_BAD_SAMP_FREQ;
+
+  save_codec_info (p_codec_Info_save);
+
+  return A2DP_SUCCESS;
+}
+
+const char* A2DP_VendorCodecNameLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V3";
+}
+
+bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, false) == A2DP_SUCCESS) ||
+         (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) == A2DP_SUCCESS);
+}
+
+
+bool A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
+                                             false) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(&a2dp_lhdcv3_sink_caps, p_codec_info,
+                                             true) == A2DP_SUCCESS);
+}
+
+void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info) {
+  LOG_DEBUG("%s: enter", __func__);
+  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_default_config,
+                        p_codec_info) != A2DP_SUCCESS) {
+    LOG_ERROR("%s: A2DP_BuildInfoSbc failed", __func__);
+  }
+}
+
+// Checks whether A2DP SBC codec configuration matches with a device's codec
+// capabilities. |p_cap| is the SBC codec configuration. |p_codec_info| is
+// the device's codec capabilities. |is_capability| is true if
+// |p_codec_info| contains A2DP codec capability.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV3Sink(
+    const tA2DP_LHDCV3_SINK_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  /* parse configuration */
+  status = A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, is_capability);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  /* verify that each parameter is in range */
+
+  LOG_DEBUG("%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG("%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+            cfg_cie.bits_per_sample, p_cap->bits_per_sample);
+
+  /* sampling frequency */
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  /* bit per sample */
+  if ((cfg_cie.bits_per_sample & p_cap->bits_per_sample) == 0) return A2DP_NS_CH_MODE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_a;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie_b;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status =
+      A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_a, p_codec_info_a, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie_b, p_codec_info_b, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return false;
+  }
+
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+         (lhdc_cie_a.bits_per_sample == lhdc_cie_b.bits_per_sample) &&
+         /*(lhdc_cie_a.supportedBitrate == lhdc_cie_b.supportedBitrate) &&*/
+         (lhdc_cie_a.isLLSupported == lhdc_cie_b.isLLSupported);
+}
+
+
+int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+    case A2DP_LHDC_SAMPLING_FREQ_44100:
+      return 44100;
+    case A2DP_LHDC_SAMPLING_FREQ_48000:
+      return 48000;
+    case A2DP_LHDC_SAMPLING_FREQ_88200:
+      return 88200;
+    case A2DP_LHDC_SAMPLING_FREQ_96000:
+      return 96000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  // Check whether the codec info contains valid data
+  tA2DP_STATUS a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, false);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR("%s: cannot decode codec information: %d", __func__,
+              a2dp_status);
+    return -1;
+  }
+  return A2DP_LHDC_CHANNEL_MODE_STEREO;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp) {
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+/*
+bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(UNUSED_ATTR const uint8_t* p_codec_info,
+                              BT_HDR* p_buf, uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  p_buf->offset -= A2DP_SBC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_SBC_MPL_HDR_LEN;
+  A2DP_BuildMediaPayloadHeaderSbc(p, false, false, false,
+                                  (uint8_t)frames_per_packet);
+
+  return true;
+}
+*/
+std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV3_SINK_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV3Sink(&lhdc_cie, p_codec_info, true);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV3Sink fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == 0), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100),
+              "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000),
+              "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200),
+              "88200");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000),
+              "96000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, 1,
+             "Stereo");
+  res << "\tch_mode: " << field << " (" << "Only support stereo."
+      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16),
+              "16");
+  AppendField(&field, (lhdc_cie.bits_per_sample & BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24),
+              "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bits_per_sample)
+      << ")\n";
+
+  // Max data rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_900K),
+              "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_500K),
+              "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK) == A2DP_LHDC_MAX_BIT_RATE_400K),
+              "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDC_MAX_BIT_RATE_MASK))
+      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDC_VER3),
+              "LHDC V3");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+      << ")\n";
+
+
+  /*
+  field.clear();
+  AppendField(&field, 0, "NONE");
+  AppendField(&field, 0,
+              "Mono");
+  AppendField(&field, 0,
+              "Dual");
+  AppendField(&field, 1,
+              "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+      << ")\n";
+*/
+  return res.str();
+}
+
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info) {
+  if (!A2DP_IsVendorSinkCodecValidLhdcV3(p_codec_info)) return NULL;
+
+  return &a2dp_decoder_interface_lhdcv3;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info) {
+  tA2DP_LHDCV3_SINK_CIE cfg_cie;
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV3Sink(&cfg_cie, p_codec_info, true) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void) { return "LHDC V3 SINK"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg) {
+  LOG_DEBUG("%s: enter", __func__);
+  if (A2DP_BuildInfoLhdcV3Sink(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv3_sink_caps,
+                        p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV3_SINK_CIE& config_cie,
+                                           btav_a2dp_codec_config_t* result) {
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_88200)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_88200;
+  if (config_cie.sampleRate & A2DP_LHDC_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+
+  result->bits_per_sample = config_cie.bits_per_sample;
+
+  result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+}
+
+
+
+
+
+A2dpCodecConfigLhdcV3Sink::A2dpCodecConfigLhdcV3Sink(
+    btav_a2dp_codec_priority_t codec_priority)
+    : A2dpCodecConfigLhdcV3Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+                             A2DP_VendorCodecIndexStrLhdcV3Sink(), codec_priority,
+                             false) {}
+
+A2dpCodecConfigLhdcV3Sink::~A2dpCodecConfigLhdcV3Sink() {}
+
+bool A2dpCodecConfigLhdcV3Sink::init() {
+  if (!isValid()) return false;
+
+  // Load the decoder
+  if (!A2DP_VendorLoadDecoderLhdcV3()) {
+    LOG_ERROR("%s: cannot load the decoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3Sink::useRtpHeaderMarkerBit() const {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV3Sink::updateEncoderUserConfig(
+    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
+    UNUSED_ATTR bool* p_config_updated) {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+uint64_t A2dpCodecConfigLhdcV3Sink::encoderIntervalMs() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+int A2dpCodecConfigLhdcV3Sink::getEffectiveMtu() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+
+bool A2dpCodecConfigLhdcV3Base::setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) {
+  is_source_ = false;
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV3Base::setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) {
+  is_source_ = false;
+  return true;
+}
+
+
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
new file mode 100644
index 000000000..4124345eb
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_decoder.cc
@@ -0,0 +1,550 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv3_decoder"
+
+#include "a2dp_vendor_lhdcv3_decoder.h"
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT_dec.h>
+
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+
+#define A2DP_LHDC_FUNC_DISABLE		0
+#define A2DP_LHDC_FUNC_ENABLE		1
+
+#define LHDCV3_DEC_MAX_SAMPLES_PER_FRAME  256
+#define LHDCV3_DEC_MAX_CHANNELS           2
+#define LHDCV3_DEC_MAX_BIT_DEPTH          32
+#define LHDCV3_DEC_FRAME_NUM              16
+#define LHDCV3_DEC_BUF_BYTES              (LHDCV3_DEC_FRAME_NUM * LHDCV3_DEC_MAX_SAMPLES_PER_FRAME * LHDCV3_DEC_MAX_CHANNELS * (LHDCV3_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV3_DEC_PACKET_NUM             8
+
+#define LHDCV3_DEC_INPUT_BUF_BYTES        1024
+
+#define LHDCV3_DEC_PKT_HDR_BYTES          2
+
+typedef struct {
+  lhdc_ver_t  version;
+  uint32_t    sample_rate;
+  uint8_t     bits_per_sample;
+  uint8_t     func_ch_split;
+  uint8_t     func_ar;
+  uint8_t     func_jas;
+  uint8_t     func_meta;
+
+  uint32_t    timestamp;        // Timestamp for the A2DP frames
+  uint8_t     decode_buf[LHDCV3_DEC_PACKET_NUM][LHDCV3_DEC_BUF_BYTES];
+  uint32_t    dec_buf_idx;
+
+  uint8_t     dec_input_buf[LHDCV3_DEC_INPUT_BUF_BYTES];
+  uint32_t    dec_input_buf_bytes;
+
+  decoded_data_callback_t decode_callback;
+} tA2DP_LHDCV3_DECODER_CB;
+
+static tA2DP_LHDCV3_DECODER_CB a2dp_lhdcv3_decoder_cb;
+
+
+#define _DEC_REC_FILE_
+#if defined(_DEC_REC_FILE_)
+#define RAW_FILE_NAME "/sdcard/Download/lhdcdec.raw"
+#define PCM_FILE_NAME "/sdcard/Download/decoded.pcm"
+static FILE *rawFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+//
+// Decoder for LHDC Sink Codec
+//
+
+//
+// The LHDC decoder shared library, and the functions to use
+//
+static const char* LHDC_DECODER_LIB_NAME = "liblhdcBT_dec.so";
+static void* lhdc_decoder_lib_handle = NULL;
+
+
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcBT_dec_init_decoder";
+typedef int (*tLHDCDEC_INIT_DECODER)(tLHDCV3_DEC_CONFIG *config);
+
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME = "lhdcBT_dec_check_frame_data_enough";
+typedef int (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData, uint32_t frameBytes, uint32_t *packetBytes);
+
+static const char* LHDCDEC_DECODE_NAME = "lhdcBT_dec_decode";
+typedef int (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes, uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcBT_dec_deinit_decoder";
+typedef int (*tLHDCDEC_DEINIT_DECODER)(void);
+
+
+static tLHDCDEC_INIT_DECODER lhdcdec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcdec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcdec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcdec_deinit_decoder;
+
+
+
+
+// LHDC v4 Extend flags
+#define A2DP_LHDC_FLAG_JAS            0x40
+#define A2DP_LHDC_FLAG_AR             0x80
+
+#define A2DP_LHDC_FLAG_LLAC           0x80
+
+#define A2DP_LHDC_FLAG_META           0x10
+#define A2DP_LHDC_FLAG_MBR            0x20
+#define A2DP_LHDC_FLAG_LARC           0x40
+#define A2DP_LHDC_FLAG_V4             0x80
+
+
+
+// offset  0		1B	codec capability length (11 Bytes)
+// offset  1		1B	[7:4] media type
+// offset  2		1B  codec type
+// offset  3		4B	Vendor ID
+// offset  7		2B	Codec ID
+// offset  9		3B 	LHDC specific capability
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1	9
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2	10
+#define A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3	11
+
+
+bool save_codec_info (const uint8_t* p_codec_info)
+{
+  if (p_codec_info == NULL)
+  {
+    return false;
+  }
+
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+      A2DP_LHDC_SAMPLING_FREQ_44100)
+  {
+    a2dp_lhdcv3_decoder_cb.sample_rate = 44100;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_SAMPLING_FREQ_48000)
+  {
+	a2dp_lhdcv3_decoder_cb.sample_rate = 48000;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_SAMPLING_FREQ_96000)
+  {
+	a2dp_lhdcv3_decoder_cb.sample_rate = 96000;
+  }
+  else
+  {
+    return false;
+  }
+
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+      A2DP_LHDC_BIT_FMT_16)
+  {
+    a2dp_lhdcv3_decoder_cb.bits_per_sample = 16;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & 
+           A2DP_LHDC_BIT_FMT_24)
+  {
+	a2dp_lhdcv3_decoder_cb.bits_per_sample = 24;
+  }
+  else
+  {
+    return false;
+  }
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_2] & A2DP_LHDC_FLAG_LLAC)
+  {
+    //LLAC only 
+    a2dp_lhdcv3_decoder_cb.version = VERSION_LLAC;
+    LOG_DEBUG("%s: LLAC only", __func__);
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_V4) 
+  {
+    //LHDCV4 only 
+    a2dp_lhdcv3_decoder_cb.version = VERSION_4;
+    LOG_DEBUG("%s: LHDC V4 only", __func__);
+  }
+  else
+  {
+    //LHDCV3 only 
+	a2dp_lhdcv3_decoder_cb.version = VERSION_3;
+    LOG_DEBUG("%s: LHDC V3 only", __func__);
+  }
+
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_NONE)
+  {
+    a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_DISABLE;
+  }
+  else if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_CH_SPLIT_TWS)
+  {
+	a2dp_lhdcv3_decoder_cb.func_ch_split = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    return false;
+  }
+
+  // AR
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_AR)
+  {
+	a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // JAS
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_1] & A2DP_LHDC_FLAG_JAS)
+  {
+	a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // META
+  if (p_codec_info[A2DP_LHDCV3_CODEC_INFO_SPECIFIC_3] & A2DP_LHDC_FLAG_META)
+  {
+	a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
+  }
+  else
+  {
+    a2dp_lhdcv3_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  return true;
+
+}
+
+
+static void* load_func(const char* func_name) {
+
+  void* func_ptr = NULL;
+
+  if ((func_name == NULL) ||
+      (lhdc_decoder_lib_handle == NULL))  {
+
+    return NULL;
+  }
+
+  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
+
+  if (func_ptr == NULL) {
+    LOG_ERROR(
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadDecoderLhdcV3();
+    return NULL;
+  }
+
+  return func_ptr;
+}
+
+
+bool A2DP_VendorLoadDecoderLhdcV3(void) {
+
+  if (lhdc_decoder_lib_handle != NULL) return true;  // Already loaded
+
+  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
+
+  // Open the encoder library
+  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_decoder_lib_handle == NULL) {
+    LOG_ERROR("%s: cannot open LHDC decoder library %s: %s", __func__,
+              LHDC_DECODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdcdec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcdec_init_decoder == NULL) return false;
+
+  lhdcdec_check_frame_data_enough = (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcdec_check_frame_data_enough == NULL) return false;
+
+  lhdcdec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcdec_decode == NULL) return false;
+
+  lhdcdec_deinit_decoder = (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcdec_deinit_decoder == NULL) return false;
+
+  return true;
+}
+
+
+void A2DP_VendorUnloadDecoderLhdcV3(void) {
+  a2dp_vendor_lhdcv3_decoder_cleanup();
+}
+
+
+bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback) {
+  LOG_ERROR("%s: A2DP Sink", __func__);
+
+  tLHDCV3_DEC_CONFIG  lhdcdec_config;
+  int  fn_ret;
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcdec_init_decoder == NULL) ||
+	  (lhdcdec_deinit_decoder == NULL)) {
+
+	return false;
+  }
+
+  lhdcdec_deinit_decoder ();
+
+  lhdcdec_config.version = a2dp_lhdcv3_decoder_cb.version;
+  lhdcdec_config.sample_rate = a2dp_lhdcv3_decoder_cb.sample_rate;
+  lhdcdec_config.bits_depth = a2dp_lhdcv3_decoder_cb.bits_per_sample;
+
+  fn_ret = lhdcdec_init_decoder (&lhdcdec_config);
+
+  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    return false;
+  }
+
+  a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+  a2dp_lhdcv3_decoder_cb.decode_callback = decode_callback;
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile == NULL) {
+    rawFile = fopen(RAW_FILE_NAME,"wb");
+    LOG_DEBUG("%s: Create recode file = %p", __func__, rawFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(PCM_FILE_NAME,"wb");
+    LOG_DEBUG("%s: Create recode file = %p", __func__, pcmFile);
+  }
+#endif
+  return true;
+}
+
+
+void a2dp_vendor_lhdcv3_decoder_cleanup(void) {
+  // Cleanup any LHDC-related state
+
+  LOG_DEBUG("%s: lhdc_decoder_lib_handle = %p", __func__, lhdc_decoder_lib_handle);
+
+  if (lhdc_decoder_lib_handle == NULL) {
+
+	return;
+  }
+
+  if (lhdcdec_deinit_decoder != NULL) {
+
+    lhdcdec_deinit_decoder ();
+  }
+
+  memset(&a2dp_lhdcv3_decoder_cb, 0, sizeof(a2dp_lhdcv3_decoder_cb));
+
+  dlclose(lhdc_decoder_lib_handle);
+  lhdc_decoder_lib_handle = NULL;
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(PCM_FILE_NAME);
+  }
+#endif
+}
+
+bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf) {
+  uint8_t* data;
+  size_t data_size;
+  uint32_t out_used = 0;
+  int fn_ret;
+  uint32_t dec_buf_idx;
+  uint8_t *ptr_src;
+  uint8_t *ptr_dst;
+  uint32_t packet_bytes;
+  uint32_t i;
+
+
+  if (p_buf == NULL) {
+
+	return false;
+  }
+
+  data = p_buf->data + p_buf->offset;
+  data_size = p_buf->len;
+
+  dec_buf_idx = a2dp_lhdcv3_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv3_decoder_cb.dec_buf_idx >= LHDCV3_DEC_PACKET_NUM)
+  {
+	a2dp_lhdcv3_decoder_cb.dec_buf_idx = 0;
+  }
+
+
+  if (data_size == 0) {
+    LOG_ERROR("%s: Empty packet", __func__);
+    return false;
+  }
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcdec_decode == NULL)) {
+
+    LOG_ERROR("%s: Invalid handle!", __func__);
+    return false;
+  }
+
+#if defined(_DEC_REC_FILE_)
+  if (rawFile != NULL && data_size > 0) {
+    fwrite(data + LHDCV3_DEC_PKT_HDR_BYTES, sizeof(uint8_t), data_size - LHDCV3_DEC_PKT_HDR_BYTES, rawFile);
+  }
+#endif
+
+  if ((a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV3_DEC_INPUT_BUF_BYTES)
+  {
+	// the data queued is useless
+	// discard them
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+
+	if (data_size > LHDCV3_DEC_INPUT_BUF_BYTES)
+	{
+	  // input data is too big (more than buffer size)!!
+	  // just ingore it, and do nothing
+	  return true;
+	}
+  }
+
+  memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
+          data, 
+          data_size);
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
+
+  packet_bytes = 0;
+  fn_ret = lhdcdec_check_frame_data_enough (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
+                                            a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes,
+											&packet_bytes);
+
+  if (fn_ret == LHDCBT_DEC_FUNC_INPUT_NOT_ENOUGH) {
+    LOG_ERROR("%s: Input buffer is NOT enough!, but return true", __func__);
+    return true;
+  }
+  else if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    LOG_ERROR("%s: fail to check frame data!", __func__);
+
+    // clear the data in the input buffer
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+    return false;
+  }
+
+  if (packet_bytes != (a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes - LHDCV3_DEC_PKT_HDR_BYTES))
+  {
+	// strange!
+	// queued data is NOT exactly equal to one packet!
+	// maybe wrong data in buffer
+	// discard data queued previously, and save input data
+	LOG_ERROR("%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)", __func__, packet_bytes, a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes);
+
+	a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+	memcpy (&(a2dp_lhdcv3_decoder_cb.dec_input_buf[a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes]), 
+            data, 
+            data_size);
+    a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes += data_size;
+	return true;
+  }
+
+  out_used = sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]);
+  fn_ret = lhdcdec_decode (a2dp_lhdcv3_decoder_cb.dec_input_buf, 
+                           a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes, 
+                           a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx],
+						   &out_used,
+						   a2dp_lhdcv3_decoder_cb.bits_per_sample);
+
+  // finish decoding
+  // clear the data in the input buffer
+  a2dp_lhdcv3_decoder_cb.dec_input_buf_bytes = 0;
+
+  if (fn_ret != LHDCBT_DEC_FUNC_SUCCEED) {
+
+    LOG_ERROR("%s: fail to decode lhdc stream!", __func__);
+    return false;
+  }
+
+  if (a2dp_lhdcv3_decoder_cb.bits_per_sample == 24) {
+    ptr_src = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
+	ptr_dst = a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+	  *ptr_dst++ = *ptr_src++;
+	  *ptr_dst++ = *ptr_src++;
+	  *ptr_dst++ = *ptr_src++;
+	  ptr_src++;
+    }
+	
+	out_used = (out_used >> 2) * 3;
+  }
+
+#if defined(_DEC_REC_FILE_)
+  if (pcmFile != NULL && out_used > 0 && out_used <= sizeof(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx])) {
+    int write_bytes;
+
+    write_bytes = fwrite(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx], sizeof(uint8_t), out_used, pcmFile);
+  }
+#endif
+
+  a2dp_lhdcv3_decoder_cb.decode_callback(
+      reinterpret_cast<uint8_t*>(a2dp_lhdcv3_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+
+  return true;
+}
+
+void a2dp_vendor_lhdcv3_decoder_start(void) {
+  LOG_INFO("%s", __func__);
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv3_decoder_suspend(void) {
+  LOG_INFO("%s", __func__);
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info) {
+  //int32_t sample_rate;
+  //int32_t bits_per_sample;
+  //int32_t channel_mode;
+
+  if (p_codec_info == NULL) {
+    LOG_ERROR("%s: p_codec_info is NULL", __func__);
+    return;
+  }
+
+  LOG_ERROR("%s", __func__);
+}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
new file mode 100644
index 000000000..47877a676
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv3_encoder.cc
@@ -0,0 +1,1034 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv3_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv3_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcBT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv3.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static void* lhdc_encoder_lib_handle = NULL;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcBT_get_handle";
+typedef HANDLE_LHDC_BT (*tLHDC_GET_HANDLE)(int version);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcBT_free_handle";
+typedef void (*tLHDC_FREE_HANDLE)(HANDLE_LHDC_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcBT_get_bitrate";
+typedef int (*tLHDC_GET_BITRATE)(HANDLE_LHDC_BT hLhdcParam);
+static const char* LHDC_SET_BITRATE_NAME = "lhdcBT_set_bitrate";
+typedef int (*tLHDC_SET_BITRATE)(HANDLE_LHDC_BT hLhdcParam, int index);
+
+static const char* LHDC_INIT_ENCODER_NAME = "lhdcBT_init_encoder";
+typedef int (*tLHDC_INIT_ENCODER)(HANDLE_LHDC_BT hLhdcParam,int sampling_freq, int bitPerSample, int bitrate_inx, int dualChannels, int need_padding, int mtu_size, int interval);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcBT_adjust_bitrate";
+typedef int (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDC_BT hLhdcParam, size_t queueLength);
+
+
+static const char* LHDC_ENCODE_NAME = "lhdcBT_encodeV3";
+typedef int (*tLHDC_ENCODE)(HANDLE_LHDC_BT hLhdcParam, void* p_pcm, unsigned char* out_put, uint32_t * written, uint32_t * out_fraems);
+
+static const char* LHDC_SET_LIMIT_BITRATE_ENABLED_NAME = "lhdcBT_set_max_bitrate";
+typedef void (*tLHDC_SET_LIMIT_BITRATE_ENABLED)(HANDLE_LHDC_BT hLhdcParam, int max_rate_index);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcBT_get_block_Size";
+typedef int (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDC_BT hLhdcParam);
+
+
+static const char* LHDC_SET_EXT_FUNC = "lhdcBT_set_ext_func_state";
+typedef int (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len);
+
+
+static const char* LHDC_SET_MBR_FUNC = "lhdcBT_set_hasMinBitrateLimit";
+typedef int (*tLHDC_SET_MBR_FUNC)(HANDLE_LHDC_BT handle, bool enabled);
+//int lhdcBT_set_hasMinBitrateLimit(HANDLE_LHDC_BT handle, bool enabled )
+//int lhdcBT_set_ext_func_state(HANDLE_LHDC_BT handle, lhdcBT_ext_func_field_t field, bool enabled, void * priv, int priv_data_len)
+/*leo set_gyro_pos */
+//static const char* LHDC_SET_GYRO_POS_NAME = "lhdcBT_set_gyro_pos";
+//typedef int (*tLHDC_SET_GYRO_POS)(HANDLE_LHDC_BT hLhdcParam, uint32_t world_coordinate_x, uint32_t world_coordinate_y, uint32_t world_coordinate_z);
+
+/**************************************/
+/*   LHDC extend function API Lib     */
+/**************************************/
+static const char* LHDC_GET_USER_EXAPIVER_NAME = "lhdcBT_get_user_exApiver";
+typedef int (*tLHDC_GET_USER_EXAPIVER)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static const char* LHDC_GET_USER_EXCONFIG_NAME = "lhdcBT_get_user_exconfig";
+typedef int (*tLHDC_GET_USER_EXCONFIG)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static const char* LHDC_SET_USER_EXCONFIG_NAME = "lhdcBT_set_user_exconfig";
+typedef int (*tLHDC_SET_USER_EXCONFIG)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static const char* LHDC_SET_USER_EXDATA_NAME = "lhdcBT_set_user_exdata";
+typedef void (*tLHDC_SET_USER_EXDATA)(HANDLE_LHDC_BT hLhdcParam, const char* userConfig, const int clen);
+
+static tLHDC_GET_HANDLE lhdc_get_handle;
+static tLHDC_FREE_HANDLE lhdc_free_handle;
+static tLHDC_GET_BITRATE lhdc_get_bitrate;
+static tLHDC_SET_BITRATE lhdc_set_bitrate;
+static tLHDC_INIT_ENCODER lhdc_init_encoder;
+static tLHDC_ENCODE lhdc_encode_func;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
+static tLHDC_SET_LIMIT_BITRATE_ENABLED lhdc_set_limit_bitrate;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
+static tLHDC_SET_MBR_FUNC lhdc_set_mbr_func;
+
+//static tLHDC_SET_GYRO_POS lhdc_set_gyro_pos_func;   /*leo set_gyro_pos */
+
+static tLHDC_GET_USER_EXAPIVER lhdcBT_get_user_exApiVer_func;
+static tLHDC_GET_USER_EXCONFIG lhdcBT_get_user_exconfig_func;
+static tLHDC_SET_USER_EXCONFIG lhdcBT_set_user_exconfig_func;
+static tLHDC_SET_USER_EXDATA lhdcBT_set_user_exdata_func;
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+//#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + 0)
+
+typedef struct {
+  uint32_t sample_rate;
+  uint8_t channel_mode;
+  uint8_t bits_per_sample;
+  int quality_mode_index;
+  //int latency_mode_index;
+  int pcm_wlength;
+  LHDCBT_SMPL_FMT_T pcm_fmt;
+  int8_t channelSplitMode;
+  int8_t maxTargetBitrate;
+  bool isLLEnabled;
+} tA2DP_LHDC_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDC_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  size_t media_read_total_expected_packets;
+  size_t media_read_total_expected_reads_count;
+  size_t media_read_total_expected_read_bytes;
+
+  size_t media_read_total_dropped_packets;
+  size_t media_read_total_actual_reads_count;
+  size_t media_read_total_actual_read_bytes;
+} a2dp_lhdc_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint16_t TxAaMtuSize;
+  size_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDC_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+  uint8_t version;
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDC_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDC_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdc_encoder_stats_t stats;
+  uint32_t buf_seq;
+  uint32_t bytes_read;
+} tA2DP_LHDC_ENCODER_CB;
+
+//static bool lhdc_abr_loaded = false;
+
+
+
+typedef struct _lhdc_frame_Info {
+    uint32_t frame_len;
+    uint32_t isSplit;
+    uint32_t isLeft;
+
+} lhdc_frame_Info_t;
+
+
+#define _RECODER_FILE_
+#if defined(_RECODER_FILE_)
+#define ENCODED_FILE_NAME "/sdcard/Download/lhdc.raw"
+#define PCM_FILE_NAME     "/sdcard/Download/source.pcm"
+static FILE  *RecFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+static tA2DP_LHDC_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated);
+static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us);
+
+static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame);
+static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+static std::string quality_mode_index_to_name(int quality_mode_index);
+//static std::string latency_mode_index_to_name(int latency_mode_index);
+
+static void* load_func(const char* func_name) {
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(
+              "%s: cannot find function '%s' in the encoder library: %s",
+              __func__, func_name, dlerror());
+    A2DP_VendorUnloadEncoderLhdcV3();
+    return NULL;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV3(void) {
+  if (lhdc_encoder_lib_handle != NULL) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == NULL) {
+    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
+              LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+
+  // Load all functions
+  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle == NULL) return false;
+  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle == NULL) return false;
+  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate == NULL) return false;
+  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate == NULL) return false;
+  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
+  if (lhdc_init_encoder == NULL) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == NULL) return false;
+  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate == NULL) return false;
+
+
+  lhdc_set_limit_bitrate = (tLHDC_SET_LIMIT_BITRATE_ENABLED)load_func(LHDC_SET_LIMIT_BITRATE_ENABLED_NAME);
+  if (lhdc_set_limit_bitrate == NULL) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == NULL) return false;
+  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
+  if (lhdc_set_ext_func == NULL) return false;
+  lhdc_set_mbr_func = (tLHDC_SET_MBR_FUNC)load_func(LHDC_SET_MBR_FUNC);
+  if (lhdc_set_mbr_func == NULL) return false;
+
+  /*leo set_gyro_pos */
+//  lhdc_set_gyro_pos_func = (tLHDC_SET_GYRO_POS)load_func(LHDC_SET_GYRO_POS_NAME);
+//  if (lhdc_set_gyro_pos_func == NULL) return false;
+
+  lhdcBT_get_user_exApiVer_func = (tLHDC_GET_USER_EXAPIVER)load_func(LHDC_GET_USER_EXAPIVER_NAME);
+  if (lhdcBT_get_user_exApiVer_func == NULL) {
+      LOG_ERROR( "%s:cannot load %s", __func__, LHDC_GET_USER_EXAPIVER_NAME);
+      return false;
+  }
+
+  lhdcBT_get_user_exconfig_func = (tLHDC_GET_USER_EXCONFIG)load_func(LHDC_GET_USER_EXCONFIG_NAME);
+  if (lhdcBT_get_user_exconfig_func == NULL) {
+    LOG_ERROR( "%s:cannot load %s", __func__, LHDC_GET_USER_EXCONFIG_NAME);
+    return false;
+  }
+
+  lhdcBT_set_user_exconfig_func = (tLHDC_SET_USER_EXCONFIG)load_func(LHDC_SET_USER_EXCONFIG_NAME);
+  if (lhdcBT_set_user_exconfig_func == NULL)  {
+    LOG_ERROR( "%s:cannot load %s", __func__, LHDC_SET_USER_EXCONFIG_NAME);
+    return false;
+  }
+
+  lhdcBT_set_user_exdata_func = (tLHDC_SET_USER_EXDATA)load_func(LHDC_SET_USER_EXDATA_NAME);
+  if (lhdcBT_set_user_exdata_func == NULL)  {
+    LOG_ERROR( "%s:cannot load %s", __func__, LHDC_SET_USER_EXDATA_NAME);
+    return false;
+  }
+
+  return true;
+}
+
+void A2DP_VendorUnloadEncoderLhdcV3(void) {
+  // Cleanup any LHDC-related state
+
+    LOG_DEBUG( "%s: a2dp_lhdc_encoder_cb.has_lhdc_handle = %d, lhdc_free_handle = %p",
+              __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle, lhdc_free_handle);
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != NULL)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle = NULL;
+  lhdc_free_handle = NULL;
+  lhdc_get_bitrate = NULL;
+  lhdc_set_bitrate = NULL;
+  lhdc_init_encoder = NULL;
+  lhdc_encode_func = NULL;
+  lhdc_auto_adjust_bitrate = NULL;
+  lhdc_set_limit_bitrate = NULL;
+  lhdc_get_block_size = NULL;
+  lhdc_set_ext_func = NULL;
+  lhdc_set_mbr_func = NULL;
+//  lhdc_set_gyro_pos_func = NULL;    /*leo set_gyro_pos */
+
+  lhdcBT_get_user_exApiVer_func = NULL;
+  lhdcBT_get_user_exconfig_func = NULL;
+  lhdcBT_set_user_exconfig_func = NULL;
+  lhdcBT_set_user_exdata_func = NULL;
+
+
+  if (lhdc_encoder_lib_handle != NULL) {
+    dlclose(lhdc_encoder_lib_handle);
+    lhdc_encoder_lib_handle = NULL;
+  }
+}
+
+void a2dp_vendor_lhdcv3_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+                                  a2dp_codec_config, &restart_input,
+                                  &restart_output, &config_updated);
+}
+
+
+int A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserApiVer(const char* version, const int clen)
+{
+  if(lhdcBT_get_user_exApiVer_func)
+  {
+    //LOG_DEBUG( "%s: get API VERSION, clen:%d", __func__, clen);
+    return lhdcBT_get_user_exApiVer_func(a2dp_lhdc_encoder_cb.lhdc_handle, version, clen);
+  }
+  else
+  {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV3::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if(lhdcBT_get_user_exconfig_func)
+  {
+    //LOG_DEBUG( "%s: get API CONFIG, clen:%d", __func__, clen);
+    return lhdcBT_get_user_exconfig_func(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  }
+  else
+  {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if(lhdcBT_set_user_exconfig_func)
+  {
+    //LOG_DEBUG( "%s: set API CONFIG, clen:%d", __func__, clen);
+    return lhdcBT_set_user_exconfig_func(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  }
+  else
+  {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+bool A2dpCodecConfigLhdcV3::setEncoderExtendFuncUserData(const char* codecData, const int clen)
+{
+  if(lhdcBT_set_user_exdata_func)
+  {
+    //LOG_DEBUG( "%s: set API DATA, clen:%d", __func__, clen);
+    lhdcBT_set_user_exdata_func(a2dp_lhdc_encoder_cb.lhdc_handle, codecData, clen);
+    return true;
+  }
+  else
+  {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return false;
+  }
+}
+
+
+bool A2dpCodecConfigLhdcV3::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid peer MTU",
+              __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv3_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+                                  p_restart_input, p_restart_output,
+                                  p_config_updated);
+  return true;
+}
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv3_encoder_update(uint16_t peer_mtu,
+                                            A2dpCodecConfig* a2dp_codec_config,
+                                            bool* p_restart_input,
+                                            bool* p_restart_output,
+                                            bool* p_config_updated) {
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  //Example for limit bit rate
+  //lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, 0);
+
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(
+              "%s: Cannot update the codec encoder for %s: "
+              "invalid codec config",
+              __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+  const uint8_t* p_codec_info = codec_info;
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+
+  uint32_t verCode = A2DP_VendorGetVersionLhdcV3(p_codec_info);  //LHDC V3 should 1!
+
+  bool isLLAC = A2DP_VendorHasLLACFlagLhdcV3(p_codec_info);
+
+  bool isLHDCV4 = A2DP_VendorHasV4FlagLhdcV3(p_codec_info);
+
+
+  LOG_DEBUG( "%s:codec_config.codec_specific_1 = %d, codec_config.codec_specific_2 = %d", __func__, (int32_t)codec_config.codec_specific_1, (int32_t)codec_config.codec_specific_2);
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+      int newValue = codec_config.codec_specific_1 & 0xff;
+
+      // adjust non-supported quality modes and wrap to internal library used index
+      if (newValue == A2DP_LHDC_QUALITY_ABR) {
+        newValue = LHDCBT_QUALITY_AUTO; //9->8
+      }
+
+      if (newValue != p_encoder_params->quality_mode_index) {
+        p_encoder_params->quality_mode_index = newValue;
+        LOG_DEBUG( "%s: setting internal quality mode index: %s(%d)", __func__,
+                  quality_mode_index_to_name(p_encoder_params->quality_mode_index)
+                      .c_str(), p_encoder_params->quality_mode_index);
+      }
+  }else {
+      p_encoder_params->quality_mode_index = LHDCBT_QUALITY_AUTO;
+      LOG_DEBUG( "%s: setting default quality mode to ABR", __func__);
+  }
+
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      uint32_t versionSetup = 2;
+      if(isLLAC && !isLHDCV4 && verCode == 1){
+        //LLAC Only
+        versionSetup = 4;
+        LOG_DEBUG( "%s: init to LLAC : %d",__func__, versionSetup);
+      }else if(!isLLAC && isLHDCV4 && verCode == 1) {
+        //LHDCV4 Only
+        versionSetup = 3;
+        LOG_DEBUG( "%s: init to LHDC V4 : %d",__func__, versionSetup);
+      }else if(!isLLAC && !isLHDCV4 && verCode == 1) {
+        //LHDCV3 Only
+        versionSetup = 2;
+        LOG_DEBUG( "%s: init to LHDC V3 : %d",__func__, versionSetup);
+      }else {
+        LOG_DEBUG( "%s: Flags check incorrect. So init to LHDCV3 only : %d",__func__, versionSetup);
+      }
+
+
+      a2dp_lhdc_encoder_cb.lhdc_handle = lhdc_get_handle(versionSetup);
+      if (a2dp_lhdc_encoder_cb.lhdc_handle == NULL) {
+        LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
+        return;  // TODO: Return an error?
+      }
+      a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  a2dp_lhdc_encoder_cb.version = A2DP_VendorGetVersionLhdcV3(p_codec_info);
+
+
+  // The feeding parameters
+  tA2DP_FEEDING_PARAMS* p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  p_feeding_params->sample_rate =
+      A2DP_VendorGetTrackSampleRateLhdcV3(p_codec_info);
+  p_feeding_params->bits_per_sample =
+      a2dp_codec_config->getAudioBitsPerSample();
+  p_feeding_params->channel_count =
+      A2DP_VendorGetTrackChannelCountLhdcV3(p_codec_info);
+  LOG_DEBUG( "%s:(feeding) sample_rate=%u bits_per_sample=%u channel_count=%u",
+            __func__, p_feeding_params->sample_rate,
+            p_feeding_params->bits_per_sample, p_feeding_params->channel_count);
+
+  // The codec parameters
+  p_encoder_params->sample_rate =
+      a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  uint16_t mtu_size =
+      BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR);
+
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : peer_mtu;
+
+  //get separation feature.
+  p_encoder_params->channelSplitMode = A2DP_VendorGetChannelSplitModeLhdcV3(p_codec_info);
+  // Set the quality mode index
+  //int old_quality_mode_index = p_encoder_params->quality_mode_index;
+
+  p_encoder_params->maxTargetBitrate = A2DP_VendorGetMaxDatarateLhdcV3(p_codec_info);
+
+
+  p_encoder_params->isLLEnabled = (codec_config.codec_specific_2 & 1ULL) != 0 ? true :false; //A2DP_VendorGetLowLatencyState(p_codec_info);
+
+
+  p_encoder_params->pcm_wlength =
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample >> 3;
+  // Set the Audio format from pcm_wlength
+  p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  if (p_encoder_params->pcm_wlength == 2)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S16;
+  else if (p_encoder_params->pcm_wlength == 3)
+    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S24;
+ // else if (p_encoder_params->pcm_wlength == 4)
+//    p_encoder_params->pcm_fmt = LHDCBT_SMPL_FMT_S32;
+
+  LOG_DEBUG( "%s: MTU=%d, peer_mtu=%d", __func__,
+            a2dp_lhdc_encoder_cb.TxAaMtuSize, peer_mtu);
+  LOG_DEBUG(
+            "%s: sample_rate: %d "
+            "quality_mode_index: %d pcm_wlength: %d pcm_fmt: %d",
+            __func__, p_encoder_params->sample_rate,
+            p_encoder_params->quality_mode_index, p_encoder_params->pcm_wlength,
+            p_encoder_params->pcm_fmt);
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+    uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+  
+  LOG_DEBUG( "%s:AR Flag = %d", __func__, A2DP_VendorHasARFlagLhdcV3(p_codec_info));
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_AR, A2DP_VendorHasARFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_JAS, A2DP_VendorHasJASFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_EXT_FUNC_LARC, A2DP_VendorHasLARCFlagLhdcV3(p_codec_info), NULL, 0);
+  lhdc_set_mbr_func(a2dp_lhdc_encoder_cb.lhdc_handle, A2DP_VendorHasMinBRFlagLhdcV3(p_codec_info));
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  int result = lhdc_init_encoder(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      p_encoder_params->channelSplitMode > A2DP_LHDC_CH_SPLIT_NONE ? 1 : 0,
+      0 /* This parameter alaways is 0 in A2DP */ ,
+      max_mtu_len,
+      a2dp_vendor_lhdcv3_get_encoder_interval_ms()
+  );
+  lhdc_set_limit_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->maxTargetBitrate);
+
+  lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+
+#if defined(_RECODER_FILE_)
+  if (RecFile == NULL) {
+    RecFile = fopen(ENCODED_FILE_NAME,"wb");
+    LOG_DEBUG( "%s: Create recode file = %p", __func__, RecFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(PCM_FILE_NAME,"wb");
+    LOG_DEBUG( "%s: Create recode file = %p", __func__, pcmFile);
+  }
+#endif
+  if (result != 0) {
+    LOG_ERROR( "%s: error initializing the LHDC encoder: %d", __func__,
+              result);
+  }
+}
+
+void a2dp_vendor_lhdcv3_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle)
+    lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+#if defined(_RECODER_FILE_)
+  if (RecFile != NULL) {
+    fclose(RecFile);
+    RecFile = NULL;
+    remove(ENCODED_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(PCM_FILE_NAME);
+  }
+#endif
+}
+
+void a2dp_vendor_lhdcv3_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+         sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+       a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+       a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+       encoder_interval) /
+      1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.bytes_read = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      LOG_DEBUG("%s: reset ABR!", __func__);
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCBT_QUALITY_RESET_AUTO);
+    }
+  }
+  LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
+            a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+void a2dp_vendor_lhdcv3_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  LOG_DEBUG( "%s", __func__);
+}
+
+uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void) {
+  LOG_DEBUG( "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",
+              __func__, a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+      return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+      return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv3_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_DEBUG( "%s: Sending %d frames per iteration, %d iterations",
+              __func__, nb_frame, nb_iterations);
+
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV3_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv3_get_num_frame_iteration(uint8_t* num_of_iterations,
+                                              uint8_t* num_of_frames,
+                                              uint64_t timestamp_us) {
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+
+  *num_of_iterations = 0;
+  *num_of_frames = 0;
+
+  int32_t pcm_bytes_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (pcm_bytes_per_frame <= 0) {
+    LOG_DEBUG( "%s: lhdc_get_block_size error!", __func__);
+    return;
+  }
+
+  pcm_bytes_per_frame = pcm_bytes_per_frame *
+  a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+  a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  LOG_DEBUG( "%s: pcm_bytes_per_frame %u", __func__, pcm_bytes_per_frame);
+
+  int encoder_interval = a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0)
+    us_this_tick =
+        (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  LOG_DEBUG( "%s: effective num of frames %u, iterations %u", __func__, nof, noi);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+    BT_HDR *p_buf = ( BT_HDR*)osi_malloc( BT_DEFAULT_BUFFER_SIZE);
+    if ( p_buf == NULL) {
+        // LeoKu(C): should not happen
+        LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
+        return  NULL;
+    }
+
+    p_buf->offset = A2DP_LHDC_OFFSET;
+    p_buf->len = 0;
+    p_buf->layer_specific = 0;
+    return  p_buf;
+}
+
+static void a2dp_lhdcV3_encode_frames(uint8_t nb_frame){
+  //tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+  //    &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  int32_t samples_per_frame = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (samples_per_frame <= 0) {
+    LOG_ERROR ("%s: lhdc_get_block_size error!", __func__);
+    return;
+  }
+
+  uint32_t pcm_bytes_per_frame = samples_per_frame *
+                                 a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                                 a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  uint32_t max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  static float mtu_usage = 0;
+  static int mtu_usage_cnt = 0;
+  static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+  static uint32_t allSendbytes = 0;
+  uint8_t read_buffer[samples_per_frame * 2 * 4];
+  uint8_t latency =0; // p_encoder_params->latency_mode_index;
+  int32_t out_frames = 0, remain_nb_frame = nb_frame;
+  int32_t written = 0;
+  uint32_t bytes_read = 0;
+  uint8_t* packet;
+  BT_HDR * p_buf = NULL;
+
+  while (nb_frame) {
+      if ((p_buf = bt_buf_new()) == NULL) {
+          LOG_ERROR ( "%s: ERROR", __func__);
+          return;
+      }
+    uint32_t written_frame = 0;
+    do {
+      uint32_t temp_bytes_read = 0;
+      if (a2dp_lhdcv3_read_feeding(read_buffer, &temp_bytes_read)) {
+        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
+        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
+
+        //int result =
+
+      #if defined(_RECODER_FILE_)
+        if (pcmFile != NULL) {
+          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
+        }
+      #endif
+        lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle, read_buffer, packet, (uint32_t*)&written, (uint32_t*)&out_frames);
+
+        #if defined(_RECODER_FILE_)
+        if (RecFile != NULL && written > 0) {
+            fwrite(packet, sizeof(uint8_t), written, RecFile);
+        }
+        #endif
+
+        p_buf->len += written;
+        allSendbytes += written;
+        nb_frame--;
+        written_frame += out_frames;  // added a frame to the buffer
+        LOG_DEBUG ( "%s: nb_frame:%d, written:%d, out_frames:%d", __func__, nb_frame, written, out_frames);
+
+      }else{
+    	LOG_DEBUG ( "%s: underflow %d", __func__, nb_frame);
+        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+                        nb_frame * samples_per_frame *
+                        a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+                        a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+        // no more pcm to read
+        nb_frame = 0;
+      }
+    } while ((written == 0) && nb_frame);
+
+    if (p_buf->len) {
+      /*
+       * Timestamp of the media packet header represent the TS of the
+       * first frame, i.e the timestamp before including this frame.
+       */
+      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+      p_buf->layer_specific <<= 8;
+      p_buf->layer_specific |= ( latency | ( written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
+
+      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+      LOG_DEBUG ( "%s: Timestamp (%d)", __func__, a2dp_lhdc_encoder_cb.timestamp);
+
+      a2dp_lhdc_encoder_cb.timestamp += ( written_frame * samples_per_frame);
+
+      uint8_t done_nb_frame = remain_nb_frame - nb_frame;
+      remain_nb_frame = nb_frame;
+      LOG_DEBUG( "%s: nb_frame:%d, remain_nb_frame:%d, done_nb_frame:%d", __func__, nb_frame, remain_nb_frame, done_nb_frame);
+
+      mtu_usage += ((float)p_buf->len) / max_mtu_len;
+      mtu_usage_cnt++;
+
+      LOG_DEBUG ( "%s: Read bytes(%d)", __func__, a2dp_lhdc_encoder_cb.bytes_read);
+      LOG_DEBUG ( "%s: Send Frame(%d), length(%d)", __func__, written_frame, p_buf->len);
+      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
+      a2dp_lhdc_encoder_cb.bytes_read = 0;
+
+      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
+        return;
+    } else {
+      // NOTE: Unlike the execution path for other codecs, it is normal for
+      // LHDC to NOT write encoded data to the last buffer if there wasn't
+      // enough data to write to. That data is accumulated internally by
+      // the codec and included in the next iteration. Therefore, here we
+      // don't increment the "media_read_total_dropped_packets" counter.
+    	LOG_DEBUG ( "%s: free buffer len(%d)", __func__, p_buf->len);
+      osi_free(p_buf);
+    }
+  }
+  uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+  if (now_ms - time_prev >= 1000 ) {
+	  LOG_DEBUG ( "%s: Current data rate about %d kbps, packet usage %.2f%%", __func__, (allSendbytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
+      allSendbytes = 0;
+      mtu_usage_cnt = 0;
+      mtu_usage = 0;
+      time_prev = now_ms;
+  }
+}
+
+static bool a2dp_lhdcv3_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+    uint32_t bytes_per_sample = a2dp_lhdc_encoder_cb.feeding_params.channel_count * a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  uint32_t read_size = 0;
+  int32_t read_size_tmp = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle);
+  if (read_size_tmp <= 0) {
+    LOG_ERROR ("%s: lhdc_get_block_size error!", __func__);
+    return false;
+  }
+  read_size = read_size_tmp * bytes_per_sample;
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  uint32_t nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG( "%s: want to read size %u, read byte number %u",
+                    __func__, read_size, nb_byte_read);
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+	  LOG_DEBUG( "%s: PCM data not alignment. The audio sample is shfit %d bytes.", __func__,(nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+
+    *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// library index mapping: quality mode index
+static std::string quality_mode_index_to_name(int quality_mode_index) {
+  switch (quality_mode_index) {
+    case LHDCBT_QUALITY_AUTO:
+      return "ABR";
+    case LHDCBT_QUALITY_HIGH:
+      return "HIGH";
+    case LHDCBT_QUALITY_MID:
+      return "MID";
+    case LHDCBT_QUALITY_LOW:
+      return "LOW";
+    case LHDCBT_QUALITY_LOW4:
+      return "LOW_320";
+    case LHDCBT_QUALITY_LOW3:
+      return "LOW_256";
+    case LHDCBT_QUALITY_LOW2:
+      return "LOW_192";
+    case LHDCBT_QUALITY_LOW1:
+      return "LOW_128";
+    case LHDCBT_QUALITY_LOW0:
+      return "LOW_64";
+    default:
+      return "Unknown";
+  }
+}
+
+void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length) {
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_DEBUG( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+  if (p_encoder_params->quality_mode_index == LHDCBT_QUALITY_AUTO) {
+	  LOG_DEBUG( "%s: Auto Bitrate Enabled!", __func__);
+      if (lhdc_auto_adjust_bitrate != NULL) {
+          lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, transmit_queue_length);
+      }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV3::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv3_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV3::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV3::debug_codec_dump(int fd) {
+  a2dp_lhdc_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDC_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+          "  Packet counts (expected/dropped)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_packets,
+          stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+          "  PCM read counts (expected/actual)                       : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_reads_count,
+          stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+          "  PCM read bytes (expected/actual)                        : %zu / "
+          "%zu\n",
+          stats->media_read_total_expected_read_bytes,
+          stats->media_read_total_actual_read_bytes);
+
+  dprintf(
+      fd, "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  dprintf(fd,
+          "  LHDC transmission bitrate (Kbps)                        : %d\n",
+          lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle));
+
+  dprintf(fd,
+          "  LHDC saved transmit queue length                        : %zu\n",
+          a2dp_lhdc_encoder_cb.TxQueueLength);
+/*
+  if (a2dp_lhdc_encoder_cb.has_lhdc_abr_handle) {
+    dprintf(fd,
+            "  LHDC adaptive bit rate encode quality mode index        : %d\n",
+            a2dp_lhdc_encoder_cb.last_lhdc_abr_eqmid);
+    dprintf(fd,
+            "  LHDC adaptive bit rate adjustments                      : %zu\n",
+            a2dp_lhdc_encoder_cb.lhdc_abr_adjustments);
+  }
+  */
+}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
new file mode 100644
index 000000000..8b4c1f384
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5.cc
@@ -0,0 +1,2883 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ *
+ *  Utility functions to help build and parse the LHDCV5 Codec Information
+ *  Element and Media Payload.
+ *
+ ******************************************************************************/
+
+#define LOG_TAG "a2dp_vendor_lhdcv5"
+
+#include "bt_target.h"
+
+#include "a2dp_vendor_lhdcv5.h"
+
+#include <string.h>
+
+#include <base/logging.h>
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv5_encoder.h"
+#include "a2dp_vendor_lhdcv5_decoder.h"
+#include "bt_utils.h"
+#include "btif_av_co.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+// data type for the LHDC Codec Information Element
+typedef struct {
+  uint32_t vendorId;                                    /* Vendor ID */
+  uint16_t codecId;                                     /* Codec ID */
+  uint8_t sampleRate;                                   /* Sampling Frequency Type */
+  uint8_t bitsPerSample;                                /* Bits Per Sample Type */
+  uint8_t channelMode;                                  /* Channel Mode */
+  uint8_t version;                                      /* Codec SubVersion Number */
+  uint8_t frameLenType;                                 /* Frame Length Type */
+  uint8_t maxTargetBitrate;                             /* Max Target Bit Rate Type */
+  uint8_t minTargetBitrate;                             /* Min Target Bit Rate Type */
+  bool hasFeatureAR;                                    /* FeatureSupported: AR */
+  bool hasFeatureJAS;                                   /* FeatureSupported: JAS */
+  bool hasFeatureMETA;                                  /* FeatureSupported: META */
+  bool hasFeatureLL;                                    /* FeatureSupported: Low Latency */
+  bool hasFeatureLLESS;                                 /* FeatureSupported: Lossless */
+  //for runtime feature switch on/off, not caps
+  bool featureOnAR;                                     /* Feature TurnOn: AR */
+} tA2DP_LHDCV5_CIE;
+
+// source capabilities
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+    // Bits Per Sample
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24),
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec SubVersion Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_MASK,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_MASK,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+// default source capabilities for best select
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_source_default_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    A2DP_LHDCV5_SAMPLING_FREQ_48000,
+    // Bits Per Sample
+    A2DP_LHDCV5_BIT_FMT_24,
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+// sink capabilities
+static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    (A2DP_LHDCV5_SAMPLING_FREQ_44100 | A2DP_LHDCV5_SAMPLING_FREQ_48000 | A2DP_LHDCV5_SAMPLING_FREQ_96000 | A2DP_LHDCV5_SAMPLING_FREQ_192000),
+    // Bits Per Sample
+    (A2DP_LHDCV5_BIT_FMT_16 | A2DP_LHDCV5_BIT_FMT_24 | A2DP_LHDCV5_BIT_FMT_32),
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+// default sink capabilities
+UNUSED_ATTR static const tA2DP_LHDCV5_CIE a2dp_lhdcv5_sink_default_caps = {
+    A2DP_LHDC_VENDOR_ID,  // vendorId
+    A2DP_LHDCV5_CODEC_ID, // codecId
+    // Sampling Frequency
+    A2DP_LHDCV5_SAMPLING_FREQ_48000,
+    // Bits Per Sample
+    A2DP_LHDCV5_BIT_FMT_24,
+    // Channel Mode
+    A2DP_LHDCV5_CHANNEL_MODE_STEREO,
+    // Codec Version Number
+    A2DP_LHDCV5_VER_1,
+    // Encoded Frame Length
+    A2DP_LHDCV5_FRAME_LEN_5MS,
+    // Max Target Bit Rate Type
+    A2DP_LHDCV5_MAX_BIT_RATE_1000K,
+    // Min Target Bit Rate Type
+    A2DP_LHDCV5_MIN_BIT_RATE_64K,
+    // FeatureSupported: AR
+    true,
+    // FeatureSupported: JAS
+    true,
+    // FeatureSupported: META
+    true,
+    // FeatureSupported: Low Latency
+    true,
+    // FeatureSupported: Lossless
+    true,
+    // Feature On/OFF: AR
+    false,
+};
+
+//
+// Utilities for LHDC configuration on A2DP specifics - START
+//
+typedef struct {
+  btav_a2dp_codec_config_t *_codec_config_;
+  btav_a2dp_codec_config_t *_codec_capability_;
+  btav_a2dp_codec_config_t *_codec_local_capability_;
+  btav_a2dp_codec_config_t *_codec_selectable_capability_;
+  btav_a2dp_codec_config_t *_codec_user_config_;
+  btav_a2dp_codec_config_t *_codec_audio_config_;
+}tA2DP_CODEC_CONFIGS_PACK;
+
+typedef struct {
+  uint8_t   featureCode;  /* code of LHDC features */
+  uint8_t   inSpecBank;   /* target specific to store the feature flag */
+  uint8_t   bitPos;       /* the bit index(0~63) of the specific(int64_t) that bit store */
+  int64_t   value;        /* real value of the bit position written to the target specific */
+}tA2DP_LHDC_FEATURE_POS;
+
+// default settings of LHDC features configuration on specifics
+// info of feature: JAS
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_JAS = {
+    LHDCV5_FEATURE_CODE_JAS,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_JAS_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_JAS_SPEC_BIT_POS),
+};
+
+// info of feature: AR
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_AR = {
+    LHDCV5_FEATURE_CODE_AR,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_AR_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_AR_SPEC_BIT_POS),
+};
+
+// info of feature: META
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_META = {
+    LHDCV5_FEATURE_CODE_META,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_META_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_META_SPEC_BIT_POS),
+};
+
+// info of feature: Low Latency
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LL = {
+    LHDCV5_FEATURE_CODE_LL,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2,
+    LHDCV5_FEATURE_LL_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LL_SPEC_BIT_POS),
+};
+
+// info of feature: LossLess
+static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_LLESS = {
+    LHDCV5_FEATURE_CODE_LLESS,
+    LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3,
+    LHDCV5_FEATURE_LLESS_SPEC_BIT_POS,
+    (0x1ULL << LHDCV5_FEATURE_LLESS_SPEC_BIT_POS),
+};
+
+UNUSED_ATTR static const tA2DP_LHDC_FEATURE_POS a2dp_lhdcv5_source_spec_all[] = {
+    a2dp_lhdcv5_source_spec_JAS,
+    a2dp_lhdcv5_source_spec_AR,
+    a2dp_lhdcv5_source_spec_META,
+    a2dp_lhdcv5_source_spec_LL,
+    a2dp_lhdcv5_source_spec_LLESS,
+};
+
+// to check if target feature bit is set in codec_user_config_
+static bool A2DP_IsFeatureInUserConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
+  bool ret = false;
+
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+  {
+    ret = LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+    return ret;
+  } break;
+  case LHDCV5_FEATURE_CODE_AR:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_META:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LL:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_user_config_,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+  } break;
+  default:
+    break;
+  }
+
+  return false;
+}
+
+// to check if target feature bit is set in codec_config_
+static bool A2DP_IsFeatureInCodecConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr, uint8_t featureCode) {
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch(featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_AR:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_META:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LL:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+  } break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+  {
+    return LHDCV5_CHECK_IN_A2DP_SPEC(cfgsPtr->_codec_config_,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+  } break;
+  default:
+    break;
+  }
+
+  return false;
+}
+
+static void A2DP_UpdateFeatureToSpecLhdcV5(tA2DP_CODEC_CONFIGS_PACK* cfgsPtr,
+    uint16_t toCodecCfg, bool hasFeature, uint8_t toSpec, int64_t value) {
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return;
+  }
+
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CONFIG_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_config_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_local_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_selectable_capability_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_USER_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_user_config_, toSpec, hasFeature, value);
+  }
+  if (toCodecCfg & A2DP_LHDC_TO_A2DP_CODEC_AUDIO_) {
+    LHDC_SETUP_A2DP_SPEC(cfgsPtr->_codec_audio_config_, toSpec, hasFeature, value);
+  }
+}
+
+// to update feature bit value to target codec config's specific
+static void A2DP_UpdateFeatureToA2dpConfigLhdcV5(tA2DP_CODEC_CONFIGS_PACK *cfgsPtr,
+    uint8_t featureCode,  uint16_t toCodecCfg, bool hasFeature) {
+  if (cfgsPtr == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return;
+  }
+
+  switch(featureCode) {
+  case LHDCV5_FEATURE_CODE_JAS:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_JAS.inSpecBank, a2dp_lhdcv5_source_spec_JAS.value);
+    break;
+  case LHDCV5_FEATURE_CODE_AR:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_AR.inSpecBank, a2dp_lhdcv5_source_spec_AR.value);
+    break;
+  case LHDCV5_FEATURE_CODE_META:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_META.inSpecBank, a2dp_lhdcv5_source_spec_META.value);
+    break;
+  case LHDCV5_FEATURE_CODE_LL:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LL.inSpecBank, a2dp_lhdcv5_source_spec_LL.value);
+    break;
+  case LHDCV5_FEATURE_CODE_LLESS:
+    A2DP_UpdateFeatureToSpecLhdcV5(cfgsPtr, toCodecCfg, hasFeature,
+        a2dp_lhdcv5_source_spec_LLESS.inSpecBank, a2dp_lhdcv5_source_spec_LLESS.value);
+    break;
+  default:
+    break;
+  }
+}
+//
+// Utilities for LHDC configuration on A2DP specifics - END
+
+static const tA2DP_ENCODER_INTERFACE a2dp_encoder_interface_lhdcv5 = {
+    a2dp_vendor_lhdcv5_encoder_init,
+    a2dp_vendor_lhdcv5_encoder_cleanup,
+    a2dp_vendor_lhdcv5_feeding_reset,
+    a2dp_vendor_lhdcv5_feeding_flush,
+    a2dp_vendor_lhdcv5_get_encoder_interval_ms,
+    a2dp_vendor_lhdcv5_send_frames,
+    a2dp_vendor_lhdcv5_set_transmit_queue_length,
+};
+
+static const tA2DP_DECODER_INTERFACE a2dp_decoder_interface_lhdcv5 = {
+    a2dp_vendor_lhdcv5_decoder_init,
+    a2dp_vendor_lhdcv5_decoder_cleanup,
+    a2dp_vendor_lhdcv5_decoder_decode_packet,
+    a2dp_vendor_lhdcv5_decoder_start,
+    a2dp_vendor_lhdcv5_decoder_suspend,
+    a2dp_vendor_lhdcv5_decoder_configure,
+};
+
+UNUSED_ATTR static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
+    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info,
+    bool is_capability);
+
+
+// check if target version is supported right now
+static bool is_codec_version_supported(uint8_t version, bool is_source) {
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  if ((version & p_a2dp_lhdcv5_caps->version) != A2DP_LHDCV5_VER_NS) {
+    return true;
+  }
+
+  LOG_DEBUG( "%s: versoin unsupported! peer:%d local:%d",
+      __func__, version, p_a2dp_lhdcv5_caps->version);
+  return false;
+}
+
+// Builds the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. |media_type| is the media type |AVDT_MEDIA_TYPE_*|.
+// |p_ie| is a pointer to the LHDC Codec Information Element information.
+// The result is stored in |p_result|. Returns A2DP_SUCCESS on success,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_BuildInfoLhdcV5(uint8_t media_type,
+    const tA2DP_LHDCV5_CIE* p_ie,
+    uint8_t* p_result) {
+
+  const uint8_t* tmpInfo = p_result;
+  uint8_t para = 0;
+
+  if (p_ie == nullptr || p_result == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return A2DP_INVALID_PARAMS;
+  }
+
+  *p_result++ = A2DP_LHDCV5_CODEC_LEN;  //H0
+  *p_result++ = (media_type << 4);      //H1
+  *p_result++ = A2DP_MEDIA_CT_NON_A2DP; //H2
+
+  // Vendor ID(P0-P3) and Codec ID(P4-P5)
+  *p_result++ = (uint8_t)(p_ie->vendorId & 0x000000FF);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x0000FF00) >> 8);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0x00FF0000) >> 16);
+  *p_result++ = (uint8_t)((p_ie->vendorId & 0xFF000000) >> 24);
+  *p_result++ = (uint8_t)(p_ie->codecId & 0x00FF);
+  *p_result++ = (uint8_t)((p_ie->codecId & 0xFF00) >> 8);
+
+  para = 0;
+  // P6[5:0] Sampling Frequency
+  if ((p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK) != A2DP_LHDCV5_SAMPLING_FREQ_NS) {
+    para |= (p_ie->sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
+  } else {
+    LOG_ERROR( "%s: invalid sample rate (0x%02X)", __func__, p_ie->sampleRate);
+    return A2DP_INVALID_PARAMS;
+  }
+  // update P6
+  *p_result++ = para; para = 0;
+
+  // P7[2:0] Bit Depth
+  if ((p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK) != A2DP_LHDCV5_BIT_FMT_NS) {
+    para |= (p_ie->bitsPerSample & A2DP_LHDCV5_BIT_FMT_MASK);
+  } else {
+    LOG_ERROR( "%s: invalid bits per sample (0x%02X)", __func__, p_ie->bitsPerSample);
+    return A2DP_INVALID_PARAMS;
+  }
+  // P7[5:4] Max Target Bit Rate
+  para |= (p_ie->maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+  // P7[7:6] Min Target Bit Rate
+  para |= (p_ie->minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+  // update P7
+  *p_result++ = para; para = 0;
+
+  // P8[3:0] Codec SubVersion
+  if ((p_ie->version & A2DP_LHDCV5_VERSION_MASK) != A2DP_LHDCV5_VER_NS) {
+    para = para | (p_ie->version & A2DP_LHDCV5_VERSION_MASK);
+  } else {
+    LOG_ERROR( "%s: invalid codec subversion (0x%02X)", __func__, p_ie->version);
+    return A2DP_INVALID_PARAMS;
+  }
+  // P8[5:4] Frame Length Type
+  if ((p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK) != A2DP_LHDCV5_FRAME_LEN_NS) {
+    para = para | (p_ie->frameLenType & A2DP_LHDCV5_FRAME_LEN_MASK);
+  } else {
+    LOG_ERROR( "%s: invalid frame length type (0x%02X)", __func__, p_ie->frameLenType);
+    return A2DP_INVALID_PARAMS;
+  }
+  // update P8
+  *p_result++ = para; para = 0;
+
+  // P9[0] HasAR
+  // P9[1] HasJAS
+  // P9[2] HasMeta
+  // P9[6] HasLL
+  // P9[7] HasLossless
+  if (p_ie->hasFeatureAR) {
+    para |= A2DP_LHDCV5_FEATURE_AR;
+  }
+  if (p_ie->hasFeatureJAS) {
+    para |= A2DP_LHDCV5_FEATURE_JAS;
+  }
+  if (p_ie->hasFeatureMETA) {
+    para |= A2DP_LHDCV5_FEATURE_META;
+  }
+  if (p_ie->hasFeatureLL) {
+    para |= A2DP_LHDCV5_FEATURE_LL;
+  }
+  if (p_ie->hasFeatureLLESS) {
+    para |= A2DP_LHDCV5_FEATURE_LLESS;
+  }
+  // update P9
+  *p_result++ = para; para = 0;
+
+  // P10[0] AR ON/OFF
+  if (p_ie->featureOnAR) {
+    para |= A2DP_LHDCV5_AR_ON;
+  }
+  // update P10
+  *p_result++ = para; para = 0;
+
+  LOG_DEBUG( "%s: codec info built = H0-H2{%02X %02X %02X} P0-P3{%02X "
+      "%02X %02X %02X} P4-P5{%02X %02X} P6{%02X} P7{%02X} P8{%02X} P9{%02X} P10{%02X}", __func__,
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
+      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
+
+  return A2DP_SUCCESS;
+}
+
+// Parses the LHDC Media Codec Capabilities byte sequence beginning from the
+// LOSC octet. The result is stored in |p_ie|. The byte sequence to parse is
+// |p_codec_info|. If |is_capability| is true, the byte sequence is
+// codec capabilities, otherwise is codec configuration.
+// Returns A2DP_SUCCESS on success, otherwise the corresponding A2DP error
+// status code.
+static tA2DP_STATUS A2DP_ParseInfoLhdcV5(tA2DP_LHDCV5_CIE* p_ie,
+    const uint8_t* p_codec_info,
+    bool is_capability,
+    bool is_source) {
+  uint8_t losc;
+  uint8_t media_type;
+  tA2DP_CODEC_TYPE codec_type;
+  const uint8_t* tmpInfo = p_codec_info;
+  const uint8_t* p_codec_Info_save = p_codec_info;
+
+  if (p_ie == nullptr || p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return A2DP_INVALID_PARAMS;
+  }
+
+  // Codec capability length
+  losc = *p_codec_info++;
+  if (losc != A2DP_LHDCV5_CODEC_LEN) {
+    LOG_ERROR( "%s: wrong length %u", __func__, losc);
+    return A2DP_WRONG_CODEC;
+  }
+
+  media_type = (*p_codec_info++) >> 4;
+  codec_type = *p_codec_info++;
+
+  // Media Type and Media Codec Type
+  if (media_type != AVDT_MEDIA_TYPE_AUDIO ||
+      codec_type != A2DP_MEDIA_CT_NON_A2DP) {
+    LOG_ERROR( "%s: invalid media type 0x%X codec_type 0x%X", __func__, media_type, codec_type);
+    return A2DP_WRONG_CODEC;
+  }
+
+  // Vendor ID(P0-P3) and Codec ID(P4-P5)
+  p_ie->vendorId = (*p_codec_info & 0x000000FF) |
+      (*(p_codec_info + 1) << 8 & 0x0000FF00) |
+      (*(p_codec_info + 2) << 16 & 0x00FF0000) |
+      (*(p_codec_info + 3) << 24 & 0xFF000000);
+  p_codec_info += 4;
+  p_ie->codecId = (*p_codec_info & 0x00FF) | (*(p_codec_info + 1) << 8 & 0xFF00);
+  p_codec_info += 2;
+  if (p_ie->vendorId != A2DP_LHDC_VENDOR_ID ||
+      p_ie->codecId != A2DP_LHDCV5_CODEC_ID) {
+    LOG_ERROR( "%s: invalid vendorId 0x%X codecId 0x%X", __func__,
+        p_ie->vendorId, p_ie->codecId);
+    return A2DP_WRONG_CODEC;
+  }
+
+  // P6[5:0] Sampling Frequency
+  p_ie->sampleRate = (*p_codec_info & A2DP_LHDCV5_SAMPLING_FREQ_MASK);
+  if (p_ie->sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS) {
+    LOG_ERROR( "%s: invalid sample rate 0x%X", __func__, p_ie->sampleRate);
+    return A2DP_WRONG_CODEC;
+  }
+  p_codec_info += 1;
+
+  // P7[2:0] Bits Per Sample
+  p_ie->bitsPerSample = (*p_codec_info & A2DP_LHDCV5_BIT_FMT_MASK);
+  if (p_ie->bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS) {
+    LOG_ERROR( "%s: invalid bit per sample 0x%X", __func__, p_ie->bitsPerSample);
+    return A2DP_WRONG_CODEC;
+  }
+  // P7[5:4] Max Target Bit Rate
+  p_ie->maxTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MAX_BIT_RATE_MASK);
+  // P7[7:6] Min Target Bit Rate
+  p_ie->minTargetBitrate = (*p_codec_info & A2DP_LHDCV5_MIN_BIT_RATE_MASK);
+  p_codec_info += 1;
+
+  // Channel Mode: stereo only
+  p_ie->channelMode = A2DP_LHDCV5_CHANNEL_MODE_STEREO;
+
+  // P8[3:0] Codec SubVersion
+  p_ie->version = (*p_codec_info & A2DP_LHDCV5_VERSION_MASK);
+  if (p_ie->version == A2DP_LHDCV5_VER_NS) {
+    LOG_ERROR( "%s: invalid version 0x%X", __func__, p_ie->version);
+    return A2DP_WRONG_CODEC;
+  } else {
+    if (!is_codec_version_supported(p_ie->version, is_source)) {
+      LOG_ERROR( "%s: unsupported version 0x%X", __func__, p_ie->version);
+      return A2DP_WRONG_CODEC;
+    }
+  }
+  // P8[5:4] Frame Length Type
+  p_ie->frameLenType = (*p_codec_info & A2DP_LHDCV5_FRAME_LEN_MASK);
+  if (p_ie->frameLenType == A2DP_LHDCV5_FRAME_LEN_NS) {
+    LOG_ERROR( "%s: invalid frame length mode 0x%X", __func__, p_ie->frameLenType);
+    return A2DP_WRONG_CODEC;
+  }
+  p_codec_info += 1;
+
+  // Features:
+  // P9[0] HasAR
+  // P9[1] HasJAS
+  // P9[2] HasMeta
+  // P9[6] HasLL
+  // P9[7] HasLossless
+  p_ie->hasFeatureAR = ((*p_codec_info & A2DP_LHDCV5_FEATURE_AR) != 0) ? true : false;
+  p_ie->hasFeatureJAS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_JAS) != 0) ? true : false;
+  p_ie->hasFeatureMETA = ((*p_codec_info & A2DP_LHDCV5_FEATURE_META) != 0) ? true : false;
+  p_ie->hasFeatureLL = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LL) != 0) ? true : false;
+  p_ie->hasFeatureLLESS = ((*p_codec_info & A2DP_LHDCV5_FEATURE_LLESS) != 0) ? true : false;
+  p_codec_info += 1;
+
+  // P10[0] AR_ON_OFF
+  p_ie->featureOnAR = ((*p_codec_info & A2DP_LHDCV5_AR_ON) != 0) ? true : false;
+
+  LOG_DEBUG( "%s: codec info parsed = H0-H2{%02X %02X %02X} P0-P3{%02X "
+      "%02X %02X %02X} P4-P5{%02X %02X} P6{%02X} P7{%02X} P8{%02X} P9{%02X} P10{%02X}", __func__,
+      tmpInfo[0], tmpInfo[1], tmpInfo[2], tmpInfo[3], tmpInfo[4], tmpInfo[5], tmpInfo[6], tmpInfo[7],
+      tmpInfo[8], tmpInfo[9], tmpInfo[10], tmpInfo[11], tmpInfo[12], tmpInfo[A2DP_LHDCV5_CODEC_LEN]);
+
+  LOG_DEBUG( "%s: %s isCap{%d} SR{%02X} BPS{%02X} Ver{%02X} FL{%02X} "
+      "MBR{%02X} mBR{%02X} Feature{AR(%d) JAS(%d) META(%d) LL(%d) LLESS(%d)} AR_ON{%d}",
+      __func__,
+      (is_source?"SRC":"SNK"),
+      is_capability,
+      p_ie->sampleRate,
+      p_ie->bitsPerSample,
+      p_ie->version,
+      p_ie->frameLenType,
+      p_ie->maxTargetBitrate,
+      p_ie->minTargetBitrate,
+      p_ie->hasFeatureAR,
+      p_ie->hasFeatureJAS,
+      p_ie->hasFeatureMETA,
+      p_ie->hasFeatureLL,
+      p_ie->hasFeatureLLESS,
+      p_ie->featureOnAR);
+
+  //save decoder needed parameters
+#if 1
+  if (!is_source) {
+    if (!a2dp_lhdcv5_decoder_save_codec_info(p_codec_Info_save)) {
+      LOG_DEBUG( "%s: save decoder parameters error", __func__);
+    }
+  }
+#endif
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
+}
+bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
+}
+
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SRC) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) == A2DP_SUCCESS);
+}
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  /* Use a liberal check when parsing the codec info */
+  return (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, false, IS_SNK) == A2DP_SUCCESS) ||
+      (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SNK) == A2DP_SUCCESS);
+}
+
+// NOTE: Should be done only for local Sink codec
+bool A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
+      false) == A2DP_SUCCESS);
+}
+// NOTE: Should be done only for local Sink codec
+bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info) {
+  return (A2DP_CodecInfoMatchesCapabilityLhdcV5(&a2dp_lhdcv5_sink_caps, p_codec_info,
+      true) == A2DP_SUCCESS);
+}
+
+// Checks whether A2DP LHDC codec configuration matches with a device's codec
+// capabilities.
+//  |p_cap| is the LHDC local codec capabilities.
+//  |p_codec_info| is peer's codec capabilities acting as an A2DP source.
+// If |is_capability| is true, the byte sequence is codec capabilities,
+// otherwise is codec configuration.
+// Returns A2DP_SUCCESS if the codec configuration matches with capabilities,
+// otherwise the corresponding A2DP error status code.
+static tA2DP_STATUS A2DP_CodecInfoMatchesCapabilityLhdcV5(
+    const tA2DP_LHDCV5_CIE* p_cap, const uint8_t* p_codec_info, bool is_capability) {
+  tA2DP_STATUS status;
+  tA2DP_LHDCV5_CIE cfg_cie;
+
+  if (p_cap == nullptr || p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return A2DP_INVALID_PARAMS;
+  }
+
+  // parse configuration
+  status = A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, is_capability, IS_SNK);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: parsing failed %d", __func__, status);
+    return status;
+  }
+
+  // verify that each parameter is in range
+  LOG_DEBUG( "%s: FREQ peer: 0x%x, capability 0x%x", __func__,
+      cfg_cie.sampleRate, p_cap->sampleRate);
+
+  LOG_DEBUG( "%s: BIT_FMT peer: 0x%x, capability 0x%x", __func__,
+      cfg_cie.bitsPerSample, p_cap->bitsPerSample);
+
+  // sampling frequency
+  if ((cfg_cie.sampleRate & p_cap->sampleRate) == 0) return A2DP_NS_SAMP_FREQ;
+
+  // bits per sample
+  if ((cfg_cie.bitsPerSample & p_cap->bitsPerSample) == 0) return A2DP_NS_BIT_RATE;
+
+  return A2DP_SUCCESS;
+}
+
+bool A2DP_VendorUsesRtpHeaderLhdcV5(UNUSED_ATTR bool content_protection_enabled,
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  // TODO: Is this correct? The RTP header is always included?
+  return true;
+}
+
+const char* A2DP_VendorCodecNameLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info) {
+  return "LHDC V5";
+}
+
+bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
+    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV5_CIE lhdc_cie_a;
+  tA2DP_LHDCV5_CIE lhdc_cie_b;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
+    const uint8_t* p_codec_info_b) {
+  tA2DP_LHDCV5_CIE lhdc_cie_a;
+  tA2DP_LHDCV5_CIE lhdc_cie_b;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info_a == nullptr || p_codec_info_b == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_a, p_codec_info_a, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information of a: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  a2dp_status =
+      A2DP_ParseInfoLhdcV5(&lhdc_cie_b, p_codec_info_b, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information of b: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  // exam items that require to update codec config with peer if different
+  return (lhdc_cie_a.sampleRate == lhdc_cie_b.sampleRate) &&
+      (lhdc_cie_a.bitsPerSample == lhdc_cie_b.bitsPerSample) &&
+      (lhdc_cie_a.channelMode == lhdc_cie_b.channelMode) &&
+      (lhdc_cie_a.frameLenType == lhdc_cie_b.frameLenType) &&
+      //(lhdc_cie_a.hasFeatureAR == lhdc_cie_b.hasFeatureAR) &&
+      (lhdc_cie_a.hasFeatureLL == lhdc_cie_b.hasFeatureLL);
+}
+
+int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info) {
+  A2dpCodecConfig* current_codec = bta_av_get_a2dp_current_codec();
+  btav_a2dp_codec_config_t codec_config_ = current_codec->getCodecConfig();
+
+  if ((codec_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) ==
+      A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    switch ((int)(codec_config_.codec_specific_1 & 0xff)) {
+      case A2DP_LHDCV5_QUALITY_LOW0:
+        return 64000;
+      case A2DP_LHDCV5_QUALITY_LOW1:
+        return 128000;
+      case A2DP_LHDCV5_QUALITY_LOW2:
+        return 192000;
+      case A2DP_LHDCV5_QUALITY_LOW3:
+        return 256000;
+      case A2DP_LHDCV5_QUALITY_LOW4:
+        return 320000;
+      case A2DP_LHDCV5_QUALITY_LOW:
+        return 400000;
+      case A2DP_LHDCV5_QUALITY_MID:
+        return 500000;
+      case A2DP_LHDCV5_QUALITY_HIGH:
+        return 900000;
+      case A2DP_LHDCV5_QUALITY_HIGH1:
+        return 1000000;
+      case A2DP_LHDCV5_QUALITY_ABR:
+        return 9999999;
+      default:
+        return -1;
+    }
+  }
+  return 400000;
+}
+
+int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.sampleRate) {
+  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
+    return 44100;
+  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
+    return 48000;
+  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
+    return 96000;
+  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
+    return 192000;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.bitsPerSample) {
+  case A2DP_LHDCV5_BIT_FMT_16:
+    return 16;
+  case A2DP_LHDCV5_BIT_FMT_24:
+    return 24;
+  case A2DP_LHDCV5_BIT_FMT_32:
+    return 32;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+    return 1;
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+    return 2;
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return 2;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SNK);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+    return 1;
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+    return 3;
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return 3;
+  }
+
+  return -1;
+}
+
+int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return -1;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return -1;
+  }
+
+  switch (lhdc_cie.channelMode) {
+  case A2DP_LHDCV5_CHANNEL_MODE_MONO:
+  case A2DP_LHDCV5_CHANNEL_MODE_DUAL:
+  case A2DP_LHDCV5_CHANNEL_MODE_STEREO:
+    return lhdc_cie.channelMode;
+  default:
+    break;
+  }
+
+  return -1;
+}
+
+bool A2DP_VendorGetPacketTimestampLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+    const uint8_t* p_data,
+    uint32_t* p_timestamp) {
+  if (p_codec_info == nullptr || p_data == nullptr || p_timestamp == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // TODO: Is this function really codec-specific?
+  *p_timestamp = *(const uint32_t*)p_data;
+  return true;
+}
+
+bool A2DP_VendorBuildCodecHeaderLhdcV5(UNUSED_ATTR const uint8_t* p_codec_info,
+    BT_HDR* p_buf,
+    uint16_t frames_per_packet) {
+  uint8_t* p;
+
+  if (p_codec_info == nullptr || p_buf == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  p_buf->offset -= A2DP_LHDC_MPL_HDR_LEN;
+  p = (uint8_t*)(p_buf + 1) + p_buf->offset;
+  p_buf->len += A2DP_LHDC_MPL_HDR_LEN;
+
+  // Not support fragmentation
+  p[0] = ( uint8_t)( frames_per_packet & 0xff);
+  p[1] = ( uint8_t)( ( frames_per_packet >> 8) & 0xff);
+
+  return true;
+}
+
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info) {
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: A2DP_ParseInfoLhdcV5 fail:%d", __func__, a2dp_status);
+    return;
+  }
+
+  LOG_DEBUG( "\tsamp_freq: 0x%02X ", lhdc_cie.sampleRate);
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    LOG_DEBUG( "\tsamp_freq: (44100)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    LOG_DEBUG( "\tsamp_freq: (48000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    LOG_DEBUG( "\tsamp_freq: (96000)");
+  }
+  if (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    LOG_DEBUG( "\tsamp_freq: (19200)");
+  }
+
+  LOG_DEBUG( "\tbitsPerSample: 0x%02X ", lhdc_cie.bitsPerSample);
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    LOG_DEBUG( "\tbit_depth: (16)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    LOG_DEBUG( "\tbit_depth: (24)");
+  }
+  if (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    LOG_DEBUG( "\tbit_depth: (32)");
+  }
+
+  LOG_DEBUG( "\tchannelMode: 0x%02X ", lhdc_cie.channelMode);
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    LOG_DEBUG( "\tchannle_mode: (mono)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    LOG_DEBUG( "\tchannle_mode: (dual)");
+  }
+  if (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    LOG_DEBUG( "\tchannle_mode: (stereo)");
+  }
+}
+
+std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info) {
+  std::stringstream res;
+  std::string field;
+  tA2DP_STATUS a2dp_status;
+  tA2DP_LHDCV5_CIE lhdc_cie;
+
+  if (p_codec_info == nullptr) {
+    res << "A2DP_VendorCodecInfoStringLhdcV5 nullptr";
+    return res.str();
+  }
+
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    res << "A2DP_ParseInfoLhdcV5 fail: " << loghex(a2dp_status);
+    return res.str();
+  }
+
+  res << "\tname: LHDC V5\n";
+
+  // Sample frequency
+  field.clear();
+  AppendField(&field, (lhdc_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_NS), "NONE");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100),
+      "44100");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000),
+      "48000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000),
+      "96000");
+  AppendField(&field, (lhdc_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000),
+      "192000");
+  res << "\tsamp_freq: " << field << " (" << loghex(lhdc_cie.sampleRate)
+                                                                      << ")\n";
+
+  // bits per sample
+  field.clear();
+  AppendField(&field, (lhdc_cie.bitsPerSample == A2DP_LHDCV5_BIT_FMT_NS), "NONE");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16),
+      "16");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24),
+      "24");
+  AppendField(&field, (lhdc_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32),
+      "24");
+  res << "\tbits_depth: " << field << " bits (" << loghex((int)lhdc_cie.bitsPerSample)
+                                                                      << ")\n";
+
+  // Channel mode
+  field.clear();
+  AppendField(&field, (lhdc_cie.channelMode == A2DP_LHDCV5_CHANNEL_MODE_NS), "NONE");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO),
+      "Mono");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL),
+      "Dual");
+  AppendField(&field, (lhdc_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO),
+      "Stereo");
+  res << "\tch_mode: " << field << " (" << loghex(lhdc_cie.channelMode)
+                                                                      << ")\n";
+
+  // Version
+  field.clear();
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_NS), "NONE");
+  AppendField(&field, (lhdc_cie.version == A2DP_LHDCV5_VER_1),
+      "LHDC V5 Ver1");
+  res << "\tversion: " << field << " (" << loghex(lhdc_cie.version)
+                                                                      << ")\n";
+
+  // Max target bit rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_1000K),
+      "1000Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_900K),
+      "900Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_500K),
+      "500Kbps");
+  AppendField(&field, ((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) == A2DP_LHDCV5_MAX_BIT_RATE_400K),
+      "400Kbps");
+  res << "\tMax target-rate: " << field << " (" << loghex((lhdc_cie.maxTargetBitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK))
+                                                                      << ")\n";
+
+  // Min target bit rate...
+  field.clear();
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_400K),
+      "400Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_256K),
+      "256Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_128K),
+      "128Kbps");
+  AppendField(&field, ((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) == A2DP_LHDCV5_MIN_BIT_RATE_64K),
+      "64Kbps");
+  res << "\tMin target-rate: " << field << " (" << loghex((lhdc_cie.minTargetBitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK))
+                                                                      << ")\n";
+
+  return res.str();
+}
+
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info) {
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return NULL;
+  }
+
+  if (!A2DP_IsVendorSourceCodecValidLhdcV5(p_codec_info)) return NULL;
+
+  return &a2dp_encoder_interface_lhdcv5;
+}
+
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info) {
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return NULL;
+  }
+
+  if (!A2DP_IsVendorSinkCodecValidLhdcV5(p_codec_info)) return NULL;
+
+  return &a2dp_decoder_interface_lhdcv5;
+}
+
+bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE cfg_cie;
+  if (p_codec_info == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Nothing to do: just verify the codec info is valid
+  if (A2DP_ParseInfoLhdcV5(&cfg_cie, p_codec_info, true, IS_SRC) != A2DP_SUCCESS)
+    return false;
+
+  return true;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5;
+}
+
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(
+    UNUSED_ATTR const uint8_t* p_codec_info) {
+  return BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5;
+}
+
+const char* A2DP_VendorCodecIndexStrLhdcV5(void) { return "LHDC V5"; }
+
+const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void) { return "LHDC V5 SINK"; }
+
+bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg) {
+  if (p_cfg == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_source_caps,
+      p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  /* Content protection info - support SCMS-T */
+  uint8_t* p = p_cfg->protect_info;
+  *p++ = AVDT_CP_LOSC;
+  UINT16_TO_STREAM(p, AVDT_CP_SCMS_T_ID);
+  p_cfg->num_protect = 1;
+#endif
+
+  return true;
+}
+
+bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg) {
+  if (p_cfg == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &a2dp_lhdcv5_sink_caps,
+      p_cfg->codec_info) != A2DP_SUCCESS) {
+    return false;
+  }
+
+  return true;
+}
+
+UNUSED_ATTR static void build_codec_config(const tA2DP_LHDCV5_CIE& config_cie,
+    btav_a2dp_codec_config_t* result) {
+  if (result == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return;
+  }
+
+  // sample rate
+  result->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  if (config_cie.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+    result->sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+  // bits per sample
+  result->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  if (config_cie.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+    result->bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+  // channel mode
+  result->channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  if (config_cie.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO)
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+  if (config_cie.channelMode &
+      (A2DP_LHDCV5_CHANNEL_MODE_DUAL | A2DP_LHDCV5_CHANNEL_MODE_STEREO)) {
+    result->channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV5Source::A2dpCodecConfigLhdcV5Source(
+    btav_a2dp_codec_priority_t codec_priority)
+: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+    A2DP_VendorCodecIndexStrLhdcV5(),
+    codec_priority, true) {
+
+  // Compute the local capability
+  codec_local_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  if (a2dp_lhdcv5_source_caps.sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    codec_local_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+  }
+
+  codec_local_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+  if (a2dp_lhdcv5_source_caps.bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    codec_local_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+  }
+
+  codec_local_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_NONE;
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_MONO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_MONO;
+  }
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_DUAL) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+  if (a2dp_lhdcv5_source_caps.channelMode & A2DP_LHDCV5_CHANNEL_MODE_STEREO) {
+    codec_local_capability_.channel_mode |= BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  }
+}
+
+A2dpCodecConfigLhdcV5Source::~A2dpCodecConfigLhdcV5Source() {}
+
+bool A2dpCodecConfigLhdcV5Source::init() {
+  if (!isValid()) return false;
+
+  // Load the encoder
+  if (!A2DP_VendorLoadEncoderLhdcV5()) {
+    LOG_ERROR( "%s: cannot load the encoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV5Source::useRtpHeaderMarkerBit() const { return false; }
+
+//
+// Selects the best sample rate from |sampleRate|.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_sample_rate(uint8_t sampleRate,
+    tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+  if (p_codec_config == nullptr || p_result == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    return true;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+    p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio sample rate from |p_codec_audio_config|.
+// |sampleRate| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_sample_rate(
+    const btav_a2dp_codec_config_t* p_codec_audio_config, uint8_t sampleRate,
+    tA2DP_LHDCV5_CIE* p_result, btav_a2dp_codec_config_t* p_codec_config) {
+  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 48K > 44.1K > 96K > 192K > others(min to max)
+  switch (p_codec_audio_config->sample_rate) {
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      p_result->sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+      p_codec_config->sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+    break;
+  }
+  return false;
+}
+
+//
+// Selects the best bits per sample from |bitsPerSample|.
+// |bitsPerSample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_best_bits_per_sample(
+    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+
+  if (p_result == nullptr || p_codec_config == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 24 > 16 > 32
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+    return true;
+  }
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+    return true;
+  }
+  if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+    p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+    p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+    return true;
+  }
+  return false;
+}
+
+//
+// Selects the audio bits per sample from |p_codec_audio_config|.
+// |bitsPerSample| contains the capability.
+// The result is stored in |p_result| and |p_codec_config|.
+// Returns true if a selection was made, otherwise false.
+//
+static bool select_audio_bits_per_sample(
+    const btav_a2dp_codec_config_t* p_codec_audio_config,
+    uint8_t bitsPerSample, tA2DP_LHDCV5_CIE* p_result,
+    btav_a2dp_codec_config_t* p_codec_config) {
+
+  if (p_codec_audio_config == nullptr || p_result == nullptr || p_codec_config == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // LHDC V5 priority: 24 > 16 > 32
+  switch (p_codec_audio_config->bits_per_sample) {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+      p_codec_config->bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+      p_result->bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+      return true;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+    break;
+  }
+  return false;
+}
+
+static bool A2DP_MaxBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDCV5_MAX_BIT_RATE_MASK) {
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    *mode = A2DP_LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    *mode = A2DP_LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    *mode = A2DP_LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  }
+  return false;
+}
+
+static bool A2DP_MinBitRatetoQualityLevelLhdcV5(uint8_t *mode, uint8_t bitrate) {
+  if (mode == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  switch (bitrate & A2DP_LHDCV5_MIN_BIT_RATE_MASK) {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    *mode = A2DP_LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+  return false;
+}
+
+static std::string lhdcV5_sampleRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_SAMPLING_FREQ_44100:
+    return "44100";
+  case A2DP_LHDCV5_SAMPLING_FREQ_48000:
+    return "48000";
+  case A2DP_LHDCV5_SAMPLING_FREQ_96000:
+    return "96000";
+  case A2DP_LHDCV5_SAMPLING_FREQ_192000:
+    return "192000";
+  default:
+    return "Unknown Sample Rate";
+  }
+}
+
+static std::string lhdcV5_bitPerSample_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_BIT_FMT_16:
+    return "16";
+  case A2DP_LHDCV5_BIT_FMT_24:
+    return "24";
+  case A2DP_LHDCV5_BIT_FMT_32:
+    return "32";
+  default:
+    return "Unknown Bit Per Sample";
+  }
+}
+
+static std::string lhdcV5_frameLenType_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_FRAME_LEN_5MS:
+    return "5ms";
+  default:
+    return "Unknown frame length type";
+  }
+}
+
+static std::string lhdcV5_MaxTargetBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    return "900Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    return "500Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    return "400Kbps";
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    return "1000Kbps";
+  default:
+    return "Unknown Max Bit Rate";
+  }
+}
+
+static std::string lhdcV5_MinTargetBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    return "400Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    return "256Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
+    return "128Kbps";
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    return "64Kbps";
+  default:
+    return "Unknown Min Bit Rate";
+  }
+}
+
+static std::string lhdcV5_QualityModeBitRate_toString(uint8_t value) {
+  switch((int)value)
+  {
+  case A2DP_LHDCV5_QUALITY_ABR:
+    return "ABR";
+  case A2DP_LHDCV5_QUALITY_HIGH1:
+    return "HIGH 1 (1000 Kbps)";
+  case A2DP_LHDCV5_QUALITY_HIGH:
+    return "HIGH (900 Kbps)";
+  case A2DP_LHDCV5_QUALITY_MID:
+    return "MID (500 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW:
+    return "LOW (400 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW4:
+    return "LOW 4 (320 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW3:
+    return "LOW 3 (256 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW2:
+    return "LOW 2 (192 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW1:
+    return "LOW 1 (128 Kbps)";
+  case A2DP_LHDCV5_QUALITY_LOW0:
+    return "LOW 0 (64 Kbps)";
+  default:
+    return "Unknown Bit Rate Mode";
+  }
+}
+
+
+bool A2dpCodecConfigLhdcV5Base::setCodecConfig(const uint8_t* p_peer_codec_info,
+    bool is_capability,
+    uint8_t* p_result_codec_config) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDCV5_CIE sink_info_cie;
+  tA2DP_LHDCV5_CIE result_config_cie;
+  uint8_t sampleRate = 0;
+  uint8_t bitsPerSample = 0;
+  bool hasFeature = false;
+  bool hasUserSet = false;
+  uint8_t qualityMode = 0;
+  uint8_t bitRateQmode = 0;
+  tA2DP_STATUS status;
+
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_config = codec_config_;
+  btav_a2dp_codec_config_t saved_codec_capability = codec_capability_;
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  btav_a2dp_codec_config_t saved_codec_user_config = codec_user_config_;
+  btav_a2dp_codec_config_t saved_codec_audio_config = codec_audio_config_;
+  uint8_t saved_ota_codec_config[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  uint8_t saved_ota_codec_peer_config[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_config, ota_codec_config_, sizeof(ota_codec_config_));
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+      sizeof(ota_codec_peer_capability_));
+  memcpy(saved_ota_codec_peer_config, ota_codec_peer_config_,
+      sizeof(ota_codec_peer_config_));
+
+  tA2DP_CODEC_CONFIGS_PACK allCfgPack;
+  allCfgPack._codec_config_ = &codec_config_;
+  allCfgPack._codec_capability_ = &codec_capability_;
+  allCfgPack._codec_local_capability_ = &codec_local_capability_;
+  allCfgPack._codec_selectable_capability_ = &codec_selectable_capability_;
+  allCfgPack._codec_user_config_ = &codec_user_config_;
+  allCfgPack._codec_audio_config_ = &codec_audio_config_;
+
+  if (p_peer_codec_info == nullptr || p_result_codec_config == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    goto fail;
+  }
+
+  status = A2DP_ParseInfoLhdcV5(&sink_info_cie, p_peer_codec_info, is_capability, IS_SRC);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: can't parse peer's Sink capabilities: error = %d",
+        __func__, status);
+    goto fail;
+  }
+
+  //
+  // Build the preferred configuration
+  //
+  memset(&result_config_cie, 0, sizeof(result_config_cie));
+  result_config_cie.vendorId = p_a2dp_lhdcv5_caps->vendorId;
+  result_config_cie.codecId = p_a2dp_lhdcv5_caps->codecId;
+  result_config_cie.version = sink_info_cie.version;
+
+  //
+  // Select the sample frequency
+  //
+  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & sink_info_cie.sampleRate;
+  LOG_DEBUG( "%s: sampleRate Cap:{peer:0x%02X local:0x%02X result:0x%02X}",
+      __func__, sink_info_cie.sampleRate, p_a2dp_lhdcv5_caps->sampleRate, sampleRate);
+
+  codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+  switch (codec_user_config_.sample_rate) {
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_44100:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_44100;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_48000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_96000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_96000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_192000:
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_192000;
+      codec_capability_.sample_rate = codec_user_config_.sample_rate;
+      codec_config_.sample_rate = codec_user_config_.sample_rate;
+    }
+    break;
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_16000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_24000:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_88200:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_176400:
+  case BTAV_A2DP_CODEC_SAMPLE_RATE_NONE:
+    codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+    codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_NONE;
+    break;
+  }
+
+  // Select the sample frequency if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+      codec_selectable_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+    if (codec_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+      LOG_DEBUG( "%s: sample rate configured successfully 0x%02X",
+          __func__, result_config_cie.sampleRate);
+      break;
+    }
+    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
+
+    // Compute the common capability
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+    if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000)
+      codec_capability_.sample_rate |= BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+
+    // No user preference - try the codec audio config
+    if (select_audio_sample_rate(&codec_audio_config_, sampleRate,
+        &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select sample rate from audio: 0x%02X", __func__,
+          result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_sample_rate(
+        a2dp_lhdcv5_source_default_caps.sampleRate & sink_info_cie.sampleRate,
+        &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select sample rate from default: 0x%02X", __func__,
+          result_config_cie.sampleRate);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_sample_rate(sampleRate, &result_config_cie,
+        &codec_config_)) {
+      LOG_DEBUG( "%s: select sample rate from best match: 0x%02X", __func__,
+          result_config_cie.sampleRate);
+      break;
+    }
+  } while (false);
+
+  if (codec_config_.sample_rate == BTAV_A2DP_CODEC_SAMPLE_RATE_NONE) {
+    LOG_ERROR(
+        "%s: cannot match sample frequency: local caps = 0x%02X "
+        "peer info = 0x%02X",
+        __func__, p_a2dp_lhdcv5_caps->sampleRate, sink_info_cie.sampleRate);
+    goto fail;
+  }
+  LOG_DEBUG( "%s: => sample rate(0x%02X) = %s", __func__,
+      result_config_cie.sampleRate,
+      lhdcV5_sampleRate_toString(result_config_cie.sampleRate).c_str());
+
+  //
+  // Select the bits per sample
+  //
+  bitsPerSample = p_a2dp_lhdcv5_caps->bitsPerSample & sink_info_cie.bitsPerSample;
+  LOG_DEBUG( "%s: bitsPerSample:{peer:0x%02X local:0x%02X result:0x%02X}",
+      __func__, sink_info_cie.bitsPerSample, p_a2dp_lhdcv5_caps->bitsPerSample, bitsPerSample);
+
+  codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+  switch (codec_user_config_.bits_per_sample) {
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_16;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32:
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32) {
+      result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_32;
+      codec_capability_.bits_per_sample = codec_user_config_.bits_per_sample;
+      codec_config_.bits_per_sample = codec_user_config_.bits_per_sample;
+    }
+    break;
+  case BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE:
+    result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_NS;
+    codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+    codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE;
+    break;
+  }
+
+  // Select the bits per sample if there is no user preference
+  do {
+    // Compute the selectable capability
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+      codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+    if (codec_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+      LOG_DEBUG( "%s: bit_per_sample configured successfully 0x%02X",
+          __func__, result_config_cie.bitsPerSample);
+      break;
+    }
+    // Ignore follows if codec config is setup, otherwise pick a best one from default rules
+
+    // Compute the common capability
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_16)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_24)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+    if (bitsPerSample & A2DP_LHDCV5_BIT_FMT_32)
+      codec_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+
+    // No user preference - the the codec audio config
+    if (select_audio_bits_per_sample(&codec_audio_config_, bitsPerSample,
+        &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select bit per sample from audio: 0x%02X", __func__,
+          result_config_cie.bitsPerSample);
+      break;
+    }
+
+    // No user preference - try the default config
+    if (select_best_bits_per_sample(
+        a2dp_lhdcv5_source_default_caps.bitsPerSample & sink_info_cie.bitsPerSample,
+        &result_config_cie, &codec_config_)) {
+      LOG_DEBUG( "%s: select bit per sample from default: 0x%02X", __func__,
+          result_config_cie.bitsPerSample);
+      break;
+    }
+
+    // No user preference - use the best match
+    if (select_best_bits_per_sample(bitsPerSample, &result_config_cie,
+        &codec_config_)) {
+      LOG_DEBUG( "%s: select sample rate from best match: 0x%02X", __func__,
+          result_config_cie.bitsPerSample);
+      break;
+    }
+  } while (false);
+
+  if (codec_config_.bits_per_sample == BTAV_A2DP_CODEC_BITS_PER_SAMPLE_NONE) {
+    LOG_ERROR(
+        "%s: cannot match bits per sample: local caps = 0x%02X "
+        "peer info = 0x%02X",
+        __func__, p_a2dp_lhdcv5_caps->bitsPerSample,
+        sink_info_cie.bitsPerSample);
+    goto fail;
+  }
+  LOG_DEBUG( "%s: => bit per sample(0x%02X) = %s", __func__,
+      result_config_cie.bitsPerSample,
+      lhdcV5_bitPerSample_toString(result_config_cie.bitsPerSample).c_str());
+
+  // Select the channel mode
+  codec_user_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  codec_config_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+  LOG_DEBUG( "%s: channelMode = Only supported stereo", __func__);
+
+  // Update frameLenType
+  result_config_cie.frameLenType = sink_info_cie.frameLenType;
+  LOG_DEBUG( "%s: => frame length type(0x%02X) = %s", __func__,
+      result_config_cie.frameLenType,
+      lhdcV5_frameLenType_toString(result_config_cie.frameLenType).c_str());
+
+  // Update maxTargetBitrate
+  result_config_cie.maxTargetBitrate = sink_info_cie.maxTargetBitrate;
+  LOG_DEBUG( "%s: => peer Max Bit Rate(0x%02X) = %s", __func__,
+      result_config_cie.maxTargetBitrate,
+      lhdcV5_MaxTargetBitRate_toString(result_config_cie.maxTargetBitrate).c_str());
+
+  // Update minTargetBitrate
+  result_config_cie.minTargetBitrate = sink_info_cie.minTargetBitrate;
+  LOG_DEBUG( "%s: => peer Min Bit Rate(0x%02X) = %s", __func__,
+      result_config_cie.minTargetBitrate,
+      lhdcV5_MinTargetBitRate_toString(result_config_cie.minTargetBitrate).c_str());
+
+  //
+  // Update Feature/Capabilities to A2DP specifics
+  //
+  /*******************************************
+   * for features that can be enabled by user-control, exam features tag on the specific.
+   * current user-control enabling features:
+   *    Feature: AR
+   *    Feature: LL
+   *******************************************/
+  //features on specific 3
+  if ((codec_user_config_.codec_specific_3 & A2DP_LHDC_VENDOR_FEATURE_MASK) != A2DP_LHDC_FEATURE_MAGIC_NUM)
+  {
+    // reset the specific and apply tag
+    codec_user_config_.codec_specific_3 = A2DP_LHDC_FEATURE_MAGIC_NUM;
+
+    // get previous status of user-control enabling features from codec_config, then restore to user settings
+    //
+    // Feature: AR
+    hasUserSet = A2DP_IsFeatureInCodecConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_AR,
+        A2DP_LHDC_TO_A2DP_CODEC_USER_,
+        (hasUserSet?true:false));
+    LOG_DEBUG( "%s: LHDC features tag check fail, reset UI status[AR] => %s", __func__, hasUserSet?"true":"false");
+  }
+
+  /*************************************************
+   *  quality mode: caps-control enabling
+   *************************************************/
+  if ((codec_user_config_.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) != A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_ABR;
+    LOG_DEBUG( "%s: tag not match, use default Quality Mode: ABR", __func__);
+  }
+  qualityMode = (uint8_t)codec_user_config_.codec_specific_1 & A2DP_LHDCV5_QUALITY_MASK;
+
+  /*******************************************
+   *  JAS: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureJAS & sink_info_cie.hasFeatureJAS);
+    // reset first
+    result_config_cie.hasFeatureJAS = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_JAS,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ |
+            A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+            false);
+    // update
+    hasUserSet = true;  //caps-control enabling case => always true
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureJAS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_JAS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LOG_DEBUG( "%s: featureJAS: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureJAS?"Y":"N"),
+        sink_info_cie.hasFeatureJAS,
+        p_a2dp_lhdcv5_caps->hasFeatureJAS,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  AR: user-control/peer-OTA control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureAR & sink_info_cie.hasFeatureAR);
+    // reset first
+    result_config_cie.hasFeatureAR = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_AR,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_AR);
+
+    // default AR turning on condition: (customizable)
+    //  1. both sides have the capabilities
+    //  2. (UI on SRC side turns on) || (SNK set AR_ON in codec info)
+    if (hasFeature && (hasUserSet || sink_info_cie.featureOnAR)) {
+      result_config_cie.hasFeatureAR = true;  //decide to turn on feature in encoder
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_AR,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+
+      // reconfigure (48KHz sample rate + 24 bits per sample) to run AR
+      if (codec_user_config_.sample_rate != BTAV_A2DP_CODEC_SAMPLE_RATE_48000) {
+        codec_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_capability_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        codec_user_config_.sample_rate = BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+        result_config_cie.sampleRate = A2DP_LHDCV5_SAMPLING_FREQ_48000;
+        LOG_DEBUG( "%s: set 48KHz sample Rate for running AR", __func__);
+      }
+
+      if (codec_user_config_.bits_per_sample != BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24) {
+        codec_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_capability_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        codec_user_config_.bits_per_sample = BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+        result_config_cie.bitsPerSample = A2DP_LHDCV5_BIT_FMT_24;
+        LOG_DEBUG( "%s: set 24 bits per sample 24 for running AR", __func__);
+      }
+    }
+    LOG_DEBUG( "%s: featureAR: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s AR_ON:%s}", __func__,
+        (result_config_cie.hasFeatureAR?"Y":"N"),
+        sink_info_cie.hasFeatureAR,
+        p_a2dp_lhdcv5_caps->hasFeatureAR,
+        (hasUserSet?"Y":"N"),
+        (sink_info_cie.featureOnAR)?"Y":"N");
+  }
+
+  /*******************************************
+   *  META: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureMETA & sink_info_cie.hasFeatureMETA);
+    // reset first
+    result_config_cie.hasFeatureMETA = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_META,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    hasUserSet = true;  //caps-control enabling, always true
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureMETA = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_META,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LOG_DEBUG( "%s: featureMETA: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureMETA?"Y":"N"),
+        sink_info_cie.hasFeatureMETA,
+        p_a2dp_lhdcv5_caps->hasFeatureMETA,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  Low Latency: user-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLL & sink_info_cie.hasFeatureLL);
+    // reset first
+    result_config_cie.hasFeatureLL = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LL,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LL);
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLL = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LL,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LOG_DEBUG( "%s: featureLL: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureLL?"Y":"N"),
+        sink_info_cie.hasFeatureLL,
+        p_a2dp_lhdcv5_caps->hasFeatureLL,
+        (hasUserSet?"Y":"N"));
+  }
+
+  /*******************************************
+   *  LLESS: caps-control enabling
+   *******************************************/
+  {
+    hasFeature = (p_a2dp_lhdcv5_caps->hasFeatureLLESS & sink_info_cie.hasFeatureLLESS);
+    // reset first
+    result_config_cie.hasFeatureLLESS = false;
+    A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+        &allCfgPack,
+        LHDCV5_FEATURE_CODE_LLESS,
+        (A2DP_LHDC_TO_A2DP_CODEC_CONFIG_ | A2DP_LHDC_TO_A2DP_CODEC_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_),
+        false);
+    // update
+    //hasUserSet = true;  //caps-control enabling, always true
+    hasUserSet = A2DP_IsFeatureInUserConfigLhdcV5(&allCfgPack, LHDCV5_FEATURE_CODE_LLESS);  //UI-control
+    if (hasFeature && hasUserSet) {
+      result_config_cie.hasFeatureLLESS = true;
+      A2DP_UpdateFeatureToA2dpConfigLhdcV5(
+          &allCfgPack,
+          LHDCV5_FEATURE_CODE_LLESS,
+          (A2DP_LHDC_TO_A2DP_CODEC_CAP_ |
+              A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_ | A2DP_LHDC_TO_A2DP_CODEC_USER_),
+              true);
+    }
+    LOG_DEBUG( "%s: featureLLESS: enabled? <%s> {Peer:0x%02X Local:0x%02X User:%s}", __func__,
+        (result_config_cie.hasFeatureLLESS?"Y":"N"),
+        sink_info_cie.hasFeatureLLESS,
+        p_a2dp_lhdcv5_caps->hasFeatureLLESS,
+        (hasUserSet?"Y":"N"));
+  }
+
+
+  //
+  // quality mode re-adjustion in non-ABR cases
+  //
+  if (qualityMode != A2DP_LHDCV5_QUALITY_ABR) {
+    // get corresponding quality mode of the max target bit rate
+    if (!A2DP_MaxBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.maxTargetBitrate)) {
+      LOG_ERROR( "%s: get quality mode from maxTargetBitrate error", __func__);
+      goto fail;
+    }
+    // downgrade audio quality according to the max target bit rate
+    if (qualityMode > bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LOG_DEBUG( "%s: downgrade quality mode to 0x%02X", __func__, qualityMode);
+    }
+
+    // get corresponding quality mode of the min target bit rate
+    if (!A2DP_MinBitRatetoQualityLevelLhdcV5(&bitRateQmode, result_config_cie.minTargetBitrate)) {
+      LOG_ERROR( "%s: get quality mode from minTargetBitrate error", __func__);
+      goto fail;
+    }
+    // upgrade audio quality according to the min target bit rate
+    if (qualityMode < bitRateQmode) {
+      codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | bitRateQmode;
+      qualityMode = bitRateQmode;
+      LOG_DEBUG( "%s: upgrade quality mode to 0x%02X", __func__, qualityMode);
+    }
+
+    // specification rule: if sample rate >= 96KHz && qualityMode < 256kbps,
+    //  upgrade qualityMode to 256Kbps(LOW3)
+    if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_96000 ||
+        result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+      if (qualityMode < A2DP_LHDCV5_QUALITY_LOW3) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_LOW3;
+        qualityMode = A2DP_LHDCV5_QUALITY_LOW3;
+        LOG_DEBUG( "%s: upgrade quality mode to 0x%02X due to higher sample rates", __func__, qualityMode);
+      }
+    }
+
+    // specification rule: if (sample rate == 44.1/48KHz && qualityMode == 1000kbps(HIGH 1)),
+    //  downgrade qualityMode to 900kbps(HIGH)
+    if (result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_44100 ||
+        result_config_cie.sampleRate == A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+      if (qualityMode == A2DP_LHDCV5_QUALITY_HIGH1) {
+        codec_user_config_.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_HIGH;
+        qualityMode = A2DP_LHDCV5_QUALITY_HIGH;
+        LOG_DEBUG( "%s: downgrade quality mode to 0x%02X due to lower sample rates", __func__, qualityMode);
+      }
+    }
+  }
+
+  LOG_DEBUG( "%s: => final quality mode(0x%02X) = %s", __func__,
+      qualityMode,
+      lhdcV5_QualityModeBitRate_toString(qualityMode).c_str());
+
+  /* Setup final nego result config to peer */
+  if (A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+      p_result_codec_config) != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: A2DP build info fail", __func__);
+    goto fail;
+  }
+
+  //
+  // Copy the codec-specific fields if they are not zero
+  //
+  if (codec_user_config_.codec_specific_1 != 0)
+    codec_config_.codec_specific_1 = codec_user_config_.codec_specific_1;
+  if (codec_user_config_.codec_specific_2 != 0)
+    codec_config_.codec_specific_2 = codec_user_config_.codec_specific_2;
+  if (codec_user_config_.codec_specific_3 != 0)
+    codec_config_.codec_specific_3 = codec_user_config_.codec_specific_3;
+  if (codec_user_config_.codec_specific_4 != 0)
+    codec_config_.codec_specific_4 = codec_user_config_.codec_specific_4;
+
+  // Create a local copy of the peer codec capability, and the
+  // result codec config.
+  if (is_capability) {
+    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+        ota_codec_peer_capability_);
+  } else {
+    status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &sink_info_cie,
+        ota_codec_peer_config_);
+  }
+  CHECK(status == A2DP_SUCCESS);
+
+  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &result_config_cie,
+      ota_codec_config_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+  fail:
+  // Restore the internal state
+  codec_config_ = saved_codec_config;
+  codec_capability_ = saved_codec_capability;
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  codec_user_config_ = saved_codec_user_config;
+  codec_audio_config_ = saved_codec_audio_config;
+  memcpy(ota_codec_config_, saved_ota_codec_config, sizeof(ota_codec_config_));
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+      sizeof(ota_codec_peer_capability_));
+  memcpy(ota_codec_peer_config_, saved_ota_codec_peer_config,
+      sizeof(ota_codec_peer_config_));
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV5Base::setPeerCodecCapabilities(
+    const uint8_t* p_peer_codec_capabilities) {
+  std::lock_guard<std::recursive_mutex> lock(codec_mutex_);
+  tA2DP_LHDCV5_CIE peer_info_cie;
+  uint8_t sampleRate;
+  uint8_t bits_per_sample;
+  tA2DP_STATUS status;
+  const tA2DP_LHDCV5_CIE* p_a2dp_lhdcv5_caps =
+      (is_source_) ? &a2dp_lhdcv5_source_caps : &a2dp_lhdcv5_sink_caps;
+
+  // Save the internal state
+  btav_a2dp_codec_config_t saved_codec_selectable_capability =
+      codec_selectable_capability_;
+  uint8_t saved_ota_codec_peer_capability[AVDT_CODEC_SIZE];
+  memcpy(saved_ota_codec_peer_capability, ota_codec_peer_capability_,
+      sizeof(ota_codec_peer_capability_));
+
+  if (p_peer_codec_capabilities == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    goto fail;
+  }
+
+  status = A2DP_ParseInfoLhdcV5(&peer_info_cie, p_peer_codec_capabilities, true, IS_SRC);
+  if (status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: can't parse peer's capabilities: error = %d",
+        __func__, status);
+    goto fail;
+  }
+
+  // Compute the selectable capability - sample rate
+  sampleRate = p_a2dp_lhdcv5_caps->sampleRate & peer_info_cie.sampleRate;
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_44100;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_48000;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_96000;
+  }
+  if (sampleRate & A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    codec_selectable_capability_.sample_rate |=
+        BTAV_A2DP_CODEC_SAMPLE_RATE_192000;
+  }
+
+  // Compute the selectable capability - bits per sample
+  bits_per_sample = p_a2dp_lhdcv5_caps->bitsPerSample & peer_info_cie.bitsPerSample;
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_16) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_16;
+  }
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_24) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_24;
+  }
+  if (bits_per_sample & A2DP_LHDCV5_BIT_FMT_32) {
+    codec_selectable_capability_.bits_per_sample |= BTAV_A2DP_CODEC_BITS_PER_SAMPLE_32;
+  }
+
+  // Compute the selectable capability - channel mode
+  codec_selectable_capability_.channel_mode = BTAV_A2DP_CODEC_CHANNEL_MODE_STEREO;
+
+  status = A2DP_BuildInfoLhdcV5(AVDT_MEDIA_TYPE_AUDIO, &peer_info_cie,
+      ota_codec_peer_capability_);
+  CHECK(status == A2DP_SUCCESS);
+  return true;
+
+  fail:
+  // Restore the internal state
+  codec_selectable_capability_ = saved_codec_selectable_capability;
+  memcpy(ota_codec_peer_capability_, saved_ota_codec_peer_capability,
+      sizeof(ota_codec_peer_capability_));
+  return false;
+}
+
+////////
+// LHDC Extended API Start
+////////
+static bool swapInt64toByteArray(uint8_t *byteArray, int64_t integer64) {
+  if (byteArray == nullptr) {
+    LOG_DEBUG( "%s: null ptr", __func__);
+    return false;
+  }
+
+  byteArray[7] = ((integer64 & 0x00000000000000FF) >> 0);
+  byteArray[6] = ((integer64 & 0x000000000000FF00) >> 8);
+  byteArray[5] = ((integer64 & 0x0000000000FF0000) >> 16);
+  byteArray[4] = ((integer64 & 0x00000000FF000000) >> 24);
+  byteArray[3] = ((integer64 & 0x000000FF00000000) >> 32);
+  byteArray[2] = ((integer64 & 0x0000FF0000000000) >> 40);
+  byteArray[1] = ((integer64 & 0x00FF000000000000) >> 48);
+  byteArray[0] = ((integer64 & 0xFF00000000000000) >> 56);
+
+  return true;
+}
+
+static bool A2DP_LhdcV5GetFeatureInfoV2(uint8_t *featVector) {
+  uint8_t featNum = 0, idx = 0;
+
+  if(featVector == nullptr) {
+    LOG_DEBUG( "%s: null buffer!", __func__);
+    return false;
+  }
+
+  featNum = (sizeof(a2dp_lhdcv5_source_spec_all) / sizeof(tA2DP_LHDC_FEATURE_POS) );
+  if (featNum <= 0) {
+    //LOG_DEBUG( "%s: no any features recorded in specifics, nothing to do", __func__);
+    return true;
+  }
+
+  /* 2 bytes per info tuple
+   *  byte0:      featureCode
+   *  byte1[7-6]: inSpecBank
+   *  byte1[5-0]: bitPos in decimal(0~31)
+   */
+  for(int i=0; i<featNum; i++) {
+    featVector[idx] = a2dp_lhdcv5_source_spec_all[i].featureCode;
+    featVector[idx + 1] = (a2dp_lhdcv5_source_spec_all[i].inSpecBank | a2dp_lhdcv5_source_spec_all[i].bitPos);
+    idx += 2;
+  }
+
+  return true;
+}
+
+static bool A2DP_LhdcV5GetA2DPSpecificV2(btav_a2dp_codec_config_t *a2dpCfg,
+    uint8_t *buf, uint32_t len) {
+  if (len < LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2) {
+    LOG_DEBUG( "%s: payload size too small %d ",__func__, len);
+    return false;
+  }
+
+  /* retrieve specifics value */
+  if ( !(
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2], a2dpCfg->codec_specific_1) &&
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2], a2dpCfg->codec_specific_2) &&
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2], a2dpCfg->codec_specific_3) &&
+      swapInt64toByteArray(&buf[LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2], a2dpCfg->codec_specific_4)
+  )) {
+    LOG_DEBUG( "%s: copy specifics error",  __func__);
+    return false;
+  }
+
+  /* retrieve bitmap info of LHDCv5 features */
+  if (!A2DP_LhdcV5GetFeatureInfoV2(&buf[LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2])) {
+    LOG_DEBUG( "%s: get feature info error!",  __func__);
+    return false;
+  }
+  return true;
+}
+
+static int A2DP_getEncoderExtendFuncA2DPTypeLhdcV5(A2dpCodecConfig* codecCfg,
+    uint8_t *buf, uint32_t buflen) {
+  btav_a2dp_codec_config_t codec_config_tmp;
+  uint32_t exFuncVer = 0;
+  uint32_t exFuncCode = 0;
+
+  //check buf size
+  if (buflen < (LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE + LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE)) {
+    LOG_DEBUG( "%s: buf len too small %d",  __func__, buflen);
+    return BT_STATUS_FAIL;
+  }
+
+  exFuncVer = (((unsigned int) buf[3]) & ((unsigned int)0xff)) |
+      ((((unsigned int) buf[2]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) buf[1]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) buf[0]) & ((unsigned int)0xff)) << 24);
+  exFuncCode = (((unsigned int) buf[7]) & ((unsigned int)0xff)) |
+      ((((unsigned int) buf[6]) & ((unsigned int)0xff)) << 8)  |
+      ((((unsigned int) buf[5]) & ((unsigned int)0xff)) << 16) |
+      ((((unsigned int) buf[4]) & ((unsigned int)0xff)) << 24);
+
+  switch (exFuncCode) {
+  case LHDCV5_EXTEND_API_A2DP_SPEC_CODE:
+    switch(buf[LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD]) {
+    case LHDCV5_EXTEND_API_A2DP_SPEC_CFG:
+      codec_config_tmp = codecCfg->getCodecConfig();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_CAP:
+      codec_config_tmp = codecCfg->getCodecCapability();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP:
+      codec_config_tmp = codecCfg->getCodecLocalCapability();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP:
+      codec_config_tmp = codecCfg->getCodecSelectableCapability();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG:
+      codec_config_tmp = codecCfg->getCodecUserConfig();
+      break;
+    case LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG:
+      codec_config_tmp = codecCfg->getCodecAudioConfig();
+      break;
+    default:
+      LOG_DEBUG( "%s: unknown a2dp codec config",  __func__);
+      return BT_STATUS_FAIL;
+    }
+    break;
+    default:
+      LOG_DEBUG( "%s: invalid ext API command(0x%X)",  __func__, exFuncCode);
+      return BT_STATUS_FAIL;
+  }
+
+  switch (exFuncVer) {
+  case LHDCV5_EXTEND_API_A2DP_SPEC_VER2:
+    if (!A2DP_LhdcV5GetA2DPSpecificV2(&codec_config_tmp, buf, buflen)) {
+      LOG_DEBUG( "%s: get specifics error",  __func__);
+      return BT_STATUS_FAIL;
+    }
+    break;
+  default:
+    LOG_DEBUG( "%s: invalid ext API version(0x%X)",  __func__, exFuncVer);
+    return BT_STATUS_FAIL;
+  }
+
+  return BT_STATUS_SUCCESS;
+}
+
+int A2dpCodecConfigLhdcV5Base::getLhdcExtendAPIVersion(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    result = A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(buf, clen);
+  } else {
+    LOG_DEBUG( "%s: sink not supported", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  return result;
+}
+
+int A2dpCodecConfigLhdcV5Base::getLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+  int result = BT_STATUS_FAIL;
+  uint8_t *pucBuf = (uint8_t *) buf;
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    if (buf[LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD] == LHDCV5_EXTEND_API_CODE_A2DP_TYPE ) {
+      result = A2DP_getEncoderExtendFuncA2DPTypeLhdcV5(peerCodec, pucBuf, (uint32_t)clen);
+    } else if (buf[LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD] == LHDCV5_EXTEND_API_CODE_LIB_TYPE ){
+      result = A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(buf, clen);
+    }
+  } else {
+    LOG_DEBUG( "%s: sink not supported", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  return result;
+}
+
+int A2dpCodecConfigLhdcV5Base::setLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+  int result = BT_STATUS_FAIL;
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    result = A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(buf, clen);
+  } else {
+    LOG_DEBUG( "%s: sink not supported", __func__);
+    return BT_STATUS_FAIL;
+  }
+
+  return result;
+}
+
+bool A2dpCodecConfigLhdcV5Base::setLhdcExtendAPIData(A2dpCodecConfig* peerCodec,
+    const char* buf, const int clen) {
+
+  if (peerCodec == nullptr || buf == nullptr || clen <= 0) {
+    LOG_DEBUG( "%s: invalid input clen %d", __func__, clen);
+    return BT_STATUS_FAIL;
+  }
+
+  LOG_VERBOSE( "%s: %s:(buf:%p clen:%d)",
+      __func__, ((is_source_)?"SRC" :"SNK"), buf, clen);
+
+  if (is_source_) {
+    A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(buf, clen);
+    return true;
+  } else {
+    LOG_DEBUG( "%s: sink not supported", __func__);
+    return false;
+  }
+}
+////////
+// LHDC Extended API End
+////////
+
+////////
+//    class implementation for LHDC V5 Sink
+////////
+A2dpCodecConfigLhdcV5Sink::A2dpCodecConfigLhdcV5Sink(
+    btav_a2dp_codec_priority_t codec_priority)
+: A2dpCodecConfigLhdcV5Base(BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+    A2DP_VendorCodecIndexStrLhdcV5Sink(),
+    codec_priority, false) {}
+
+A2dpCodecConfigLhdcV5Sink::~A2dpCodecConfigLhdcV5Sink() {}
+
+bool A2dpCodecConfigLhdcV5Sink::init() {
+  if (!isValid()) return false;
+
+  // Load the decoder
+  if (!A2DP_VendorLoadDecoderLhdcV5()) {
+    LOG_ERROR( "%s: cannot load the decoder", __func__);
+    return false;
+  }
+
+  return true;
+}
+
+bool A2dpCodecConfigLhdcV5Sink::useRtpHeaderMarkerBit() const {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+bool A2dpCodecConfigLhdcV5Sink::updateEncoderUserConfig(
+    UNUSED_ATTR const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    UNUSED_ATTR bool* p_restart_input, UNUSED_ATTR bool* p_restart_output,
+    UNUSED_ATTR bool* p_config_updated) {
+  // TODO: This method applies only to Source codecs
+  return false;
+}
+
+uint64_t A2dpCodecConfigLhdcV5Sink::encoderIntervalMs() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+int A2dpCodecConfigLhdcV5Sink::getEffectiveMtu() const {
+  // TODO: This method applies only to Source codecs
+  return 0;
+}
+
+////////
+//    APIs for calling from encoder/decoder module - START
+////////
+bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  switch (lhdc_cie.maxTargetBitrate) {
+  case A2DP_LHDCV5_MAX_BIT_RATE_1000K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_900K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_500K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_MAX_BIT_RATE_400K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  }
+
+  return false;
+}
+
+bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, true, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  switch (lhdc_cie.minTargetBitrate) {
+  case A2DP_LHDCV5_MIN_BIT_RATE_400K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_256K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_128K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_MIN_BIT_RATE_64K:
+    *retval = (uint32_t)A2DP_LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+
+  return false;
+}
+
+bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  *retval = (uint32_t)lhdc_cie.version;
+
+  return true;
+}
+
+bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+
+  *retval = (uint32_t)lhdc_cie.bitsPerSample;
+
+  return true;
+}
+
+bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureJAS ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureAR ? 1 : 0;
+
+  return true;
+}
+
+bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info) {
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureMETA ? 1 : 0;
+
+  return true;
+}
+
+//orig A2DP_VendorGetLowLatencyStateLhdcV5
+bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info){
+  tA2DP_LHDCV5_CIE lhdc_cie;
+  tA2DP_STATUS a2dp_status;
+
+  if (p_codec_info == nullptr || retval == nullptr) {
+    LOG_ERROR( "%s: nullptr input", __func__);
+    return false;
+  }
+
+  // Check whether the codec info contains valid data
+  a2dp_status = A2DP_ParseInfoLhdcV5(&lhdc_cie, p_codec_info, false, IS_SRC);
+  if (a2dp_status != A2DP_SUCCESS) {
+    LOG_ERROR( "%s: cannot decode codec information: %d", __func__,
+        a2dp_status);
+    return false;
+  }
+  *retval = lhdc_cie.hasFeatureLL ? 1 : 0;
+
+  return true;
+}
+////////
+//    APIs for calling from encoder/decoder module - END
+////////
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
new file mode 100644
index 000000000..0202c7773
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_decoder.cc
@@ -0,0 +1,568 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv5_decoder"
+
+#include "a2dp_vendor_lhdcv5_decoder.h"
+
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcv5BT_dec.h>
+
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+
+
+#define A2DP_LHDC_FUNC_DISABLE		0
+#define A2DP_LHDC_FUNC_ENABLE		1
+
+#define LHDCV5_DEC_MAX_SAMPLES_PER_FRAME  256
+#define LHDCV5_DEC_MAX_CHANNELS           2
+#define LHDCV5_DEC_MAX_BIT_DEPTH          32
+#define LHDCV5_DEC_FRAME_NUM              16
+#define LHDCV5_DEC_BUF_BYTES              (LHDCV5_DEC_FRAME_NUM * \
+                                           LHDCV5_DEC_MAX_SAMPLES_PER_FRAME * \
+                                           LHDCV5_DEC_MAX_CHANNELS * \
+                                           (LHDCV5_DEC_MAX_BIT_DEPTH >> 3))
+#define LHDCV5_DEC_PACKET_NUM             8
+#define LHDCV5_DEC_INPUT_BUF_BYTES        1024
+#define LHDCV5_DEC_PKT_HDR_BYTES          2
+
+typedef struct {
+  pthread_mutex_t mutex;
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
+  uint32_t    sample_rate;
+  uint8_t     bits_per_sample;
+  lhdc_ver_t  version;
+  uint8_t     func_ar;
+  uint8_t     func_jas;
+  uint8_t     func_meta;
+
+  uint8_t     decode_buf[LHDCV5_DEC_PACKET_NUM][LHDCV5_DEC_BUF_BYTES];
+  uint32_t    dec_buf_idx;
+
+  uint8_t     dec_input_buf[LHDCV5_DEC_INPUT_BUF_BYTES];
+  uint32_t    dec_input_buf_bytes;
+
+  decoded_data_callback_t decode_callback;
+} tA2DP_LHDCV5_DECODER_CB;
+
+static tA2DP_LHDCV5_DECODER_CB a2dp_lhdcv5_decoder_cb;
+
+
+#define _V5DEC_REC_FILE_
+#if defined(_V5DEC_REC_FILE_)
+#define V5RAW_FILE_NAME "/sdcard/Download/lhdcv5dec.raw"
+#define V5PCM_FILE_NAME "/sdcard/Download/v5decoded.pcm"
+static FILE *rawFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+//
+// The LHDCV5 decoder shared library, and the functions to use
+//
+static const char* LHDC_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
+static void* lhdc_decoder_lib_handle = NULL;
+
+static const char* LHDCDEC_INIT_DECODER_NAME = "lhdcv5BT_dec_init_decoder";
+typedef int32_t (*tLHDCDEC_INIT_DECODER)(HANDLE_LHDCV5_BT *handle,
+    tLHDCV5_DEC_CONFIG *config);
+
+static const char* LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME =
+    "lhdcv5BT_dec_check_frame_data_enough";
+typedef int32_t (*tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)(const uint8_t *frameData,
+    uint32_t frameBytes, uint32_t *packetBytes);
+
+static const char* LHDCDEC_DECODE_NAME = "lhdcv5BT_dec_decode";
+typedef int32_t (*tLHDCDEC_DECODE)(const uint8_t *frameData, uint32_t frameBytes,
+    uint8_t* pcmData, uint32_t* pcmBytes, uint32_t bits_depth);
+
+static const char* LHDCDEC_DEINIT_DECODER_NAME = "lhdcv5BT_dec_deinit_decoder";
+typedef int32_t (*tLHDCDEC_DEINIT_DECODER)(HANDLE_LHDCV5_BT handle);
+
+static tLHDCDEC_INIT_DECODER lhdcv5dec_init_decoder;
+static tLHDCDEC_CHECK_FRAME_DATA_ENOUGH lhdcv5dec_check_frame_data_enough;
+static tLHDCDEC_DECODE lhdcv5dec_decode;
+static tLHDCDEC_DEINIT_DECODER lhdcv5dec_deinit_decoder;
+
+// LHDC V5 Codec Info:
+//  ----------------------------------------------------------------
+//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
+//  losc | mediaType | codecType | vendorId | codecId | SampRate |
+//  ----------------------------------------------------------------
+//  P7[2:0]   | P7[5:4]    | P7[7:6]       | P8[3:0] | P8[4]       |
+//  bit depth | MaxBitRate | MinBitRate    | Version | FrameLen5ms |
+//  ----------------------------------------------------------------
+//  P9[0] | P9[1]  | P9[2]   | P9[6] | P9[7]       | P10[0]      |
+//  HasAR | HasJAS | HasMeta | HasLL | HasLossless | FeatureOnAR |
+//  ----------------------------------------------------------------
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_1 (3+6)
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_2 (3+7)
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_3 (3+8)
+#define A2DP_LHDCV5_CODEC_INFO_ATTR_4 (3+9)
+
+
+bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info)
+{
+  if (p_codec_info == NULL) {
+    return false;
+  }
+
+  if (lhdc_decoder_lib_handle == NULL) {
+    return false;
+  }
+
+  // Sampling Frequency
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_44100) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 44100;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_48000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 48000;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_96000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 96000;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_1] &
+      A2DP_LHDCV5_SAMPLING_FREQ_192000) {
+    a2dp_lhdcv5_decoder_cb.sample_rate = 192000;
+  } else {
+    return false;
+  }
+
+  // Bit Depth
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_16) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 16;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_24) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 24;
+  } else if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_2] &
+      A2DP_LHDCV5_BIT_FMT_32) {
+    a2dp_lhdcv5_decoder_cb.bits_per_sample = 32;
+  } else {
+    return false;
+  }
+
+  // version
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_3] &
+      A2DP_LHDCV5_VER_1) {
+    a2dp_lhdcv5_decoder_cb.version = VERSION_5;
+  } else {
+    return false;
+  }
+
+  // AR
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_AR) {
+    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_ar = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // JAS
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_JAS) {
+    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_jas = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  // META
+  if (p_codec_info[A2DP_LHDCV5_CODEC_INFO_ATTR_4] &
+      A2DP_LHDCV5_FEATURE_META) {
+    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_ENABLE;
+  } else {
+    a2dp_lhdcv5_decoder_cb.func_meta = A2DP_LHDC_FUNC_DISABLE;
+  }
+
+  return true;
+}
+
+
+static void* load_func(const char* func_name) {
+
+  void* func_ptr = NULL;
+
+  if ((func_name == NULL) ||
+      (lhdc_decoder_lib_handle == NULL)) {
+    LOG_ERROR( "%s: null ptr", __func__);
+    return NULL;
+  }
+
+  func_ptr = dlsym(lhdc_decoder_lib_handle, func_name);
+
+  if (func_ptr == NULL) {
+    LOG_ERROR(
+        "%s: cannot find function '%s' in the encoder library: %s",
+        __func__, func_name, dlerror());
+    A2DP_VendorUnloadDecoderLhdcV5();
+    return NULL;
+  }
+
+  return func_ptr;
+}
+
+
+bool A2DP_VendorLoadDecoderLhdcV5(void) {
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    return true;  // Already loaded
+  }
+
+  // Initialize the control block
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  pthread_mutex_init(&(a2dp_lhdcv5_decoder_cb.mutex), NULL);
+
+  // Open the encoder library
+  lhdc_decoder_lib_handle = dlopen(LHDC_DECODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_decoder_lib_handle == NULL) {
+    LOG_ERROR( "%s: cannot open LHDCV5 decoder library %s", __func__, dlerror());
+    return false;
+  }
+
+  // Load all functions
+  lhdcv5dec_init_decoder = (tLHDCDEC_INIT_DECODER)load_func(LHDCDEC_INIT_DECODER_NAME);
+  if (lhdcv5dec_init_decoder == NULL) return false;
+
+  lhdcv5dec_check_frame_data_enough =
+      (tLHDCDEC_CHECK_FRAME_DATA_ENOUGH)load_func(LHDCDEC_CHECK_FRAME_DATA_ENOUGH_NAME);
+  if (lhdcv5dec_check_frame_data_enough == NULL) return false;
+
+  lhdcv5dec_decode = (tLHDCDEC_DECODE)load_func(LHDCDEC_DECODE_NAME);
+  if (lhdcv5dec_decode == NULL) return false;
+
+  lhdcv5dec_deinit_decoder =
+      (tLHDCDEC_DEINIT_DECODER)load_func(LHDCDEC_DEINIT_DECODER_NAME);
+  if (lhdcv5dec_deinit_decoder == NULL) return false;
+
+  LOG_DEBUG( "%s: LHDCV5 decoder library loaded", __func__);
+  return true;
+}
+
+
+void A2DP_VendorUnloadDecoderLhdcV5(void) {
+
+  a2dp_vendor_lhdcv5_decoder_cleanup();
+
+  pthread_mutex_destroy(&(a2dp_lhdcv5_decoder_cb.mutex));
+  memset(&a2dp_lhdcv5_decoder_cb, 0, sizeof(a2dp_lhdcv5_decoder_cb));
+
+  lhdcv5dec_init_decoder = NULL;
+  lhdcv5dec_check_frame_data_enough = NULL;
+  lhdcv5dec_decode = NULL;
+  lhdcv5dec_deinit_decoder = NULL;
+
+  if (lhdc_decoder_lib_handle != NULL) {
+    dlclose(lhdc_decoder_lib_handle);
+    lhdc_decoder_lib_handle = NULL;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL) {
+    fclose(rawFile);
+    rawFile = NULL;
+    remove(V5RAW_FILE_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5PCM_FILE_NAME);
+  }
+#endif
+  LOG_DEBUG( "%s: unload LHDC V5 decoder", __func__);
+}
+
+
+bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback) {
+  int32_t api_ret;
+  tLHDCV5_DEC_CONFIG lhdcdec_config;
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_init_decoder == NULL) ||
+      (lhdcv5dec_deinit_decoder == NULL)) {
+    return false;
+  }
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  LOG_DEBUG( "%s: has_lhdc_handle(%d) handle_base (%p) handle(%p)", __func__,
+      a2dp_lhdcv5_decoder_cb.has_lhdc_handle,
+      &(a2dp_lhdcv5_decoder_cb.lhdc_handle),
+      a2dp_lhdcv5_decoder_cb.lhdc_handle);
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR( "%s: fail to deinit decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+    a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+    LOG_DEBUG( "%s: handle cleaned", __func__);
+  }
+
+  lhdcdec_config.version = a2dp_lhdcv5_decoder_cb.version;
+  lhdcdec_config.sample_rate = a2dp_lhdcv5_decoder_cb.sample_rate;
+  lhdcdec_config.bits_depth = a2dp_lhdcv5_decoder_cb.bits_per_sample;
+  lhdcdec_config.bit_rate = 400000;  //TODO
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle == false &&
+      a2dp_lhdcv5_decoder_cb.lhdc_handle == NULL) {
+    LOG_DEBUG( "%s: to init decoder...", __func__);
+    api_ret = lhdcv5dec_init_decoder(&(a2dp_lhdcv5_decoder_cb.lhdc_handle), &lhdcdec_config);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR( "%s: falied to init decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return false;
+    }
+    a2dp_lhdcv5_decoder_cb.has_lhdc_handle = true;
+  }
+
+  a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+  a2dp_lhdcv5_decoder_cb.decode_callback = decode_callback;
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile == NULL) {
+    rawFile = fopen(V5RAW_FILE_NAME,"wb");
+    LOG_DEBUG( "%s: create recode file = %p", __func__, rawFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(V5PCM_FILE_NAME,"wb");
+    LOG_DEBUG( "%s: create recode file = %p", __func__, pcmFile);
+  }
+#endif
+
+  LOG_DEBUG( "%s: init LHDCV5 decoder success", __func__);
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  return true;
+}
+
+
+void a2dp_vendor_lhdcv5_decoder_cleanup(void) {
+  int32_t api_ret;
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  if (a2dp_lhdcv5_decoder_cb.has_lhdc_handle) {
+    api_ret = lhdcv5dec_deinit_decoder(a2dp_lhdcv5_decoder_cb.lhdc_handle);
+    if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+      LOG_ERROR( "%s: fail to deinit LHDCV5 decoder %d", __func__, api_ret);
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return;
+    }
+  }
+
+  a2dp_lhdcv5_decoder_cb.has_lhdc_handle = false;
+  a2dp_lhdcv5_decoder_cb.lhdc_handle = NULL;
+
+  LOG_DEBUG( "%s: deinit LHDCV5 decoder success", __func__);
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
+
+
+bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf) {
+  int32_t api_ret;
+  uint8_t *data;
+  size_t data_size;
+  uint32_t out_used = 0;
+  uint32_t dec_buf_idx;
+  uint8_t *ptr_src;
+  uint8_t *ptr_dst;
+  uint32_t packet_bytes;
+  uint32_t i;
+
+  LOG_DEBUG( "%s: enter", __func__);
+
+
+  if ((lhdc_decoder_lib_handle == NULL) ||
+      (lhdcv5dec_decode == NULL)) {
+    LOG_ERROR( "%s: lib not loaded!", __func__);
+    return false;
+  }
+
+  // check handle
+  if (!a2dp_lhdcv5_decoder_cb.has_lhdc_handle || !a2dp_lhdcv5_decoder_cb.lhdc_handle) {
+    LOG_ERROR( "%s: handle not existed!", __func__);
+    return false;
+  }
+
+  if (p_buf == NULL) {
+    return false;
+  }
+
+  pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+
+  data = p_buf->data + p_buf->offset;
+  data_size = p_buf->len;
+
+  if (data_size == 0) {
+    LOG_ERROR( "%s: Empty packet", __func__);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+
+  dec_buf_idx = a2dp_lhdcv5_decoder_cb.dec_buf_idx++;
+  if (a2dp_lhdcv5_decoder_cb.dec_buf_idx >= LHDCV5_DEC_PACKET_NUM) {
+    a2dp_lhdcv5_decoder_cb.dec_buf_idx = 0;
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (rawFile != NULL && data_size > 0) {
+    fwrite(data + LHDCV5_DEC_PKT_HDR_BYTES, sizeof(uint8_t),
+        data_size - LHDCV5_DEC_PKT_HDR_BYTES, rawFile);
+  }
+#endif
+
+  if ((a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes + data_size) > LHDCV5_DEC_INPUT_BUF_BYTES) {
+    // the data queued is useless
+    // discard them
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+
+    if (data_size > LHDCV5_DEC_INPUT_BUF_BYTES)
+    {
+      // input data is too big (more than buffer size)!!
+      // just ingore it, and do nothing
+      pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+      return true;
+    }
+  }
+
+  memcpy (&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+      data, data_size);
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+
+  packet_bytes = 0;
+  api_ret = lhdcv5dec_check_frame_data_enough(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+      &packet_bytes);
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    LOG_ERROR( "%s: fail to check frame data! %d", __func__, api_ret);
+    // clear the data in the input buffer
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+  if (packet_bytes != (a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes - LHDCV5_DEC_PKT_HDR_BYTES)) {
+    // strange!
+    // queued data is NOT exactly equal to one packet!
+    // maybe wrong data in buffer
+    // discard data queued previously, and save input data
+    LOG_ERROR( "%s: queued data is NOT exactly equal to one packet! packet (%d),  input (%d)",
+        __func__, packet_bytes, a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes);
+
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+    memcpy(&(a2dp_lhdcv5_decoder_cb.dec_input_buf[a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes]),
+        data,
+        data_size);
+    a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes += data_size;
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return true;
+  }
+
+  out_used = sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]);
+  api_ret = lhdcv5dec_decode(a2dp_lhdcv5_decoder_cb.dec_input_buf,
+      a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes,
+      a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+      &out_used,
+      a2dp_lhdcv5_decoder_cb.bits_per_sample);
+
+  // finish decoding
+  // clear the data in the input buffer
+  a2dp_lhdcv5_decoder_cb.dec_input_buf_bytes = 0;
+
+  if (api_ret != LHDCV5BT_DEC_API_SUCCEED) {
+    LOG_ERROR( "%s: fail to decode lhdc stream! %d", __func__, api_ret);
+    pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+    return false;
+  }
+
+  if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 24) { //PCM_24_BIT_PACKCED
+    ptr_src = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+      *ptr_dst++ = *ptr_src++;
+      *ptr_dst++ = *ptr_src++;
+      *ptr_dst++ = *ptr_src++;
+      ptr_src++;
+    }
+    out_used = (out_used >> 2) * 3;
+  } else if (a2dp_lhdcv5_decoder_cb.bits_per_sample == 32) {
+    ptr_dst = a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx];
+
+    for (i = 0; i < (out_used >> 2) ; i++) {
+      ptr_dst[3] = ptr_dst[2];
+      ptr_dst[2] = ptr_dst[1];
+      ptr_dst[1] = ptr_dst[0];
+      ptr_dst[0] = 0;
+      ptr_dst+=4;
+    }
+  }
+
+#if defined(_V5DEC_REC_FILE_)
+  if (pcmFile != NULL && out_used > 0 &&
+      out_used <= sizeof(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx])) {
+    int write_bytes;
+    write_bytes = fwrite(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx],
+        sizeof(uint8_t), out_used, pcmFile);
+  }
+#endif
+
+  a2dp_lhdcv5_decoder_cb.decode_callback(
+      reinterpret_cast<uint8_t*>(a2dp_lhdcv5_decoder_cb.decode_buf[dec_buf_idx]), out_used);
+
+  pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  return true;
+}
+
+void a2dp_vendor_lhdcv5_decoder_start(void) {
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG("%s", __func__);
+  // do nothing
+
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
+
+void a2dp_vendor_lhdcv5_decoder_suspend(void) {
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG("%s", __func__);
+  // do nothing
+}
+
+void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info) {
+  if (p_codec_info == NULL) {
+    LOG_DEBUG("%s: p_codec_info is NULL", __func__);
+    return;
+  }
+  //pthread_mutex_lock(&(a2dp_lhdcv5_decoder_cb.mutex));
+  LOG_DEBUG("%s", __func__);
+  //pthread_mutex_unlock(&(a2dp_lhdcv5_decoder_cb.mutex));
+}
diff --git a/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
new file mode 100644
index 000000000..c21a825f6
--- /dev/null
+++ b/system_bt/stack/a2dp/a2dp_vendor_lhdcv5_encoder.cc
@@ -0,0 +1,1260 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "a2dp_vendor_lhdcv5_encoder"
+#define ATRACE_TAG ATRACE_TAG_AUDIO
+
+#include "a2dp_vendor_lhdcv5_encoder.h"
+
+#ifndef OS_GENERIC
+#include <cutils/trace.h>
+#endif
+#include <dlfcn.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <lhdcv5BT.h>
+
+#include "a2dp_vendor.h"
+#include "a2dp_vendor_lhdcv5.h"
+#include "bt_common.h"
+#include "common/time_util.h"
+#include "osi/include/log.h"
+#include "osi/include/osi.h"
+
+//
+// Encoder for LHDC Source Codec
+//
+
+#define LHDCV5_SRC_EXT_API_ENABLE // LHDC extended API implementation
+
+//
+// The LHDC encoder shared library, and the functions to use
+//
+static const char* LHDC_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
+static void* lhdc_encoder_lib_handle = nullptr;
+
+static const char* LHDC_GET_HANDLE_NAME = "lhdcv5BT_get_handle";
+typedef int32_t (*tLHDC_GET_HANDLE)(uint32_t version, HANDLE_LHDCV5_BT *hLhdcParam);
+
+static const char* LHDC_FREE_HANDLE_NAME = "lhdcv5BT_free_handle";
+typedef int32_t (*tLHDC_FREE_HANDLE)(HANDLE_LHDCV5_BT hLhdcParam);
+
+static const char* LHDC_GET_BITRATE_NAME = "lhdcv5BT_get_bitrate";
+typedef int32_t (*tLHDC_GET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *bitrate);
+
+static const char* LHDC_SET_BITRATE_NAME = "lhdcv5BT_set_bitrate";
+typedef int32_t (*tLHDC_SET_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t bitrateInx);
+
+static const char* LHDC_SET_MAX_BITRATE_NAME = "lhdcv5BT_set_max_bitrate";
+typedef int32_t (*tLHDC_SET_MAX_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t maxBitrateInx);
+
+static const char* LHDC_SET_MIN_BITRATE_NAME = "lhdcv5BT_set_min_bitrate";
+typedef int32_t (*tLHDC_SET_MIN_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t minBitrateInx);
+
+static const char* LHDC_AUTO_ADJUST_BITRATE_NAME = "lhdcv5BT_adjust_bitrate";
+typedef int32_t (*tLHDC_AUTO_ADJUST_BITRATE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t queueLength);
+
+static const char* LHDC_SET_EXT_FUNC = "lhdcv5BT_set_ext_func_state";
+typedef int32_t (*tLHDC_SET_EXT_FUNC)(HANDLE_LHDCV5_BT hLhdcParam,
+    LHDCV5_EXT_FUNC_T field, bool enabled, void *priv, uint32_t privDataLen);
+
+static const char* LHDC_INIT_ENCODER_NAME = "lhdcv5BT_init_encoder";
+typedef int32_t (*tLHDC_INIT_ENCODER)(HANDLE_LHDCV5_BT hLhdcParam,
+    uint32_t samplingFreq, uint32_t bitsPerSample, uint32_t bitrateInx,
+    uint32_t mtu, uint32_t interval);
+
+static const char* LHDC_GET_BLOCK_SIZE = "lhdcv5BT_get_block_Size";
+typedef int32_t (*tLHDC_GET_BLOCK_SIZE)(HANDLE_LHDCV5_BT hLhdcParam, uint32_t *samplesPerFrame);
+
+static const char* LHDC_ENCODE_NAME = "lhdcv5BT_encode";
+typedef int32_t (*tLHDC_ENCODE)(HANDLE_LHDCV5_BT hLhdcParam,
+    void *pInPcm, uint32_t pcmBytes, uint8_t *pOutBuf, uint32_t outBufBytes,
+    uint32_t *pOutByte, uint32_t *pOut_frames);
+
+//
+// LHDC extend function API
+//
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+static const char* LHDCV5_EXT_SET_CONFIG_NAME = "lhdcv5BT_set_user_exconfig";
+typedef int (*tLHDCV5_EXT_SET_CONFIG)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+
+static const char* LHDCV5_EXT_GET_CONFIG_NAME = "lhdcv5BT_get_user_exconfig";
+typedef int (*tLHDCV5_EXT_GET_CONFIG)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+
+static const char* LHDC_EXT_SET_DATA_NAME = "lhdcv5BT_set_user_exdata";
+typedef void (*tLHDCV5_EXT_SET_DATA)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+
+static const char* LHDCV5_EXT_GET_APIVER_NAME = "lhdcv5BT_get_user_exApiver";
+typedef int (*tLHDCV5_EXT_GET_APIVER)(HANDLE_LHDCV5_BT hLhdcParam, const char* userBuf, const int bufLen);
+#endif
+
+static tLHDC_GET_HANDLE lhdc_get_handle;
+static tLHDC_FREE_HANDLE lhdc_free_handle;
+static tLHDC_GET_BITRATE lhdc_get_bitrate;
+static tLHDC_SET_BITRATE lhdc_set_bitrate;
+static tLHDC_SET_MAX_BITRATE lhdc_set_max_bitrate;
+static tLHDC_SET_MIN_BITRATE lhdc_set_min_bitrate;
+static tLHDC_AUTO_ADJUST_BITRATE lhdc_auto_adjust_bitrate;
+static tLHDC_SET_EXT_FUNC lhdc_set_ext_func;
+static tLHDC_INIT_ENCODER lhdc_init_encoder;
+static tLHDC_GET_BLOCK_SIZE lhdc_get_block_size;
+static tLHDC_ENCODE lhdc_encode_func;
+
+//
+// LHDC extend function API
+//
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+static tLHDCV5_EXT_GET_APIVER lhdcv5_ext_get_ApiVer;
+static tLHDCV5_EXT_GET_CONFIG lhdcv5_ext_get_config;
+static tLHDCV5_EXT_SET_CONFIG lhdcv5_ext_set_config;
+static tLHDCV5_EXT_SET_DATA lhdcv5_ext_set_data;
+#endif
+
+// A2DP LHDC encoder interval in milliseconds
+#define A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS 10
+#define A2DP_LHDC_ENCODER_INTERVAL_MS 20
+
+// offset
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN + 1)
+#else
+#define A2DP_LHDC_OFFSET (AVDT_MEDIA_OFFSET + A2DP_LHDC_MPL_HDR_LEN)
+#endif
+
+typedef struct {
+  tA2DP_SAMPLE_RATE sample_rate;
+  uint32_t bits_per_sample;
+  uint32_t quality_mode_index;
+  uint32_t pcm_fmt;
+  uint32_t max_target_bitrate;
+  uint32_t min_target_bitrate;
+  uint8_t isLLEnabled;
+} tA2DP_LHDCV5_ENCODER_PARAMS;
+
+typedef struct {
+  uint32_t counter;
+  uint32_t bytes_per_tick; /* pcm bytes read each media task tick */
+  uint64_t last_frame_us;
+} tA2DP_LHDCV5_FEEDING_STATE;
+
+typedef struct {
+  uint64_t session_start_us;
+
+  uint32_t media_read_total_expected_packets;
+  uint32_t media_read_total_expected_reads_count;
+  uint32_t media_read_total_expected_read_bytes;
+
+  uint32_t media_read_total_dropped_packets;
+  uint32_t media_read_total_actual_reads_count;
+  uint32_t media_read_total_actual_read_bytes;
+} a2dp_lhdcv5_encoder_stats_t;
+
+typedef struct {
+  a2dp_source_read_callback_t read_callback;
+  a2dp_source_enqueue_callback_t enqueue_callback;
+  uint32_t TxAaMtuSize;
+  uint32_t TxQueueLength;
+
+  bool use_SCMS_T;
+  bool is_peer_edr;          // True if the peer device supports EDR
+  bool peer_supports_3mbps;  // True if the peer device supports 3Mbps EDR
+  uint16_t peer_mtu;         // MTU of the A2DP peer
+  uint32_t timestamp;        // Timestamp for the A2DP frames
+
+  HANDLE_LHDCV5_BT lhdc_handle;
+  bool has_lhdc_handle;  // True if lhdc_handle is valid
+
+  tA2DP_FEEDING_PARAMS feeding_params;
+  tA2DP_LHDCV5_ENCODER_PARAMS lhdc_encoder_params;
+  tA2DP_LHDCV5_FEEDING_STATE lhdc_feeding_state;
+
+  a2dp_lhdcv5_encoder_stats_t stats;
+  uint32_t buf_seq;
+  uint32_t bytes_read;
+} tA2DP_LHDCV5_ENCODER_CB;
+
+#define _V5ENC_REC_FILE_
+#if defined(_V5ENC_REC_FILE_)
+#define V5ENC_RAW_NAME "/sdcard/Download/lhdcv5.raw"
+#define V5ENC_PCM_NAME     "/sdcard/Download/sourcev5.pcm"
+static FILE  *recFile = NULL;
+static FILE *pcmFile = NULL;
+#endif
+
+static tA2DP_LHDCV5_ENCODER_CB a2dp_lhdc_encoder_cb;
+
+static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
+    A2dpCodecConfig* a2dp_codec_config,
+    bool* p_restart_input,
+    bool* p_restart_output,
+    bool* p_config_updated);
+
+static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
+    uint8_t* num_of_frames,
+    uint64_t timestamp_us);
+
+static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame);
+
+static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read);
+
+static std::string quality_mode_index_to_name(uint32_t quality_mode_index);
+
+
+static void* load_func(const char* func_name) {
+  if(!func_name) return NULL;
+
+  void* func_ptr = dlsym(lhdc_encoder_lib_handle, func_name);
+  if (func_ptr == NULL) {
+    LOG_ERROR(
+        "%s: cannot find function '%s' in the encoder library: %s",
+        __func__, func_name, dlerror());
+    if (!A2DP_VendorUnloadEncoderLhdcV5()) {
+      LOG_ERROR( "%s: unload encoder error", __func__);
+    }
+    return nullptr;
+  }
+  return func_ptr;
+}
+
+bool A2DP_VendorLoadEncoderLhdcV5(void) {
+  if (lhdc_encoder_lib_handle != nullptr) return true;  // Already loaded
+
+  // Initialize the control block
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  // Open the encoder library
+  lhdc_encoder_lib_handle = dlopen(LHDC_ENCODER_LIB_NAME, RTLD_NOW);
+  if (lhdc_encoder_lib_handle == nullptr) {
+    LOG_ERROR( "%s: cannot open LHDC encoder library %s: %s", __func__,
+        LHDC_ENCODER_LIB_NAME, dlerror());
+    return false;
+  }
+
+  lhdc_get_handle = nullptr;
+  lhdc_free_handle = nullptr;
+  lhdc_get_bitrate = nullptr;
+  lhdc_set_bitrate = nullptr;
+  lhdc_set_max_bitrate = nullptr;
+  lhdc_set_min_bitrate = nullptr;
+  lhdc_auto_adjust_bitrate = nullptr;
+  lhdc_set_ext_func = nullptr;
+  lhdc_init_encoder = nullptr;
+  lhdc_get_block_size =nullptr;
+  lhdc_encode_func = nullptr;
+
+  //
+  // LHDC extend function API
+  //
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+  lhdcv5_ext_get_ApiVer = nullptr;
+  lhdcv5_ext_get_config = nullptr;
+  lhdcv5_ext_set_config = nullptr;
+  lhdcv5_ext_set_data = nullptr;
+#endif
+
+  // Load all APIs
+  lhdc_get_handle = (tLHDC_GET_HANDLE)load_func(LHDC_GET_HANDLE_NAME);
+  if (lhdc_get_handle == nullptr) return false;
+  lhdc_free_handle = (tLHDC_FREE_HANDLE)load_func(LHDC_FREE_HANDLE_NAME);
+  if (lhdc_free_handle == nullptr) return false;
+  lhdc_get_bitrate = (tLHDC_GET_BITRATE)load_func(LHDC_GET_BITRATE_NAME);
+  if (lhdc_get_bitrate == nullptr) return false;
+  lhdc_set_bitrate = (tLHDC_SET_BITRATE)load_func(LHDC_SET_BITRATE_NAME);
+  if (lhdc_set_bitrate == nullptr) return false;
+  lhdc_set_max_bitrate = (tLHDC_SET_MAX_BITRATE)load_func(LHDC_SET_MAX_BITRATE_NAME);
+  if (lhdc_set_max_bitrate == nullptr) return false;
+  lhdc_set_min_bitrate = (tLHDC_SET_MIN_BITRATE)load_func(LHDC_SET_MIN_BITRATE_NAME);
+  if (lhdc_set_min_bitrate == nullptr) return false;
+  lhdc_auto_adjust_bitrate = (tLHDC_AUTO_ADJUST_BITRATE)load_func(LHDC_AUTO_ADJUST_BITRATE_NAME);
+  if (lhdc_auto_adjust_bitrate == nullptr) return false;
+  lhdc_set_ext_func = (tLHDC_SET_EXT_FUNC)load_func(LHDC_SET_EXT_FUNC);
+  if (lhdc_set_ext_func == nullptr) return false;
+  lhdc_init_encoder = (tLHDC_INIT_ENCODER)load_func(LHDC_INIT_ENCODER_NAME);
+  if (lhdc_init_encoder == nullptr) return false;
+  lhdc_get_block_size = (tLHDC_GET_BLOCK_SIZE)load_func(LHDC_GET_BLOCK_SIZE);
+  if (lhdc_get_block_size == nullptr) return false;
+  lhdc_encode_func = (tLHDC_ENCODE)load_func(LHDC_ENCODE_NAME);
+  if (lhdc_encode_func == nullptr) return false;
+
+  //
+  // LHDC extend function API
+  //
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+  lhdcv5_ext_get_ApiVer = (tLHDCV5_EXT_GET_APIVER)load_func(LHDCV5_EXT_GET_APIVER_NAME);
+  if (lhdcv5_ext_get_ApiVer == nullptr) return false;
+  lhdcv5_ext_get_config = (tLHDCV5_EXT_GET_CONFIG)load_func(LHDCV5_EXT_GET_CONFIG_NAME);
+  if (lhdcv5_ext_get_config == nullptr) return false;
+  lhdcv5_ext_set_config = (tLHDCV5_EXT_SET_CONFIG)load_func(LHDCV5_EXT_SET_CONFIG_NAME);
+  if (lhdcv5_ext_set_config == nullptr) return false;
+  lhdcv5_ext_set_data = (tLHDCV5_EXT_SET_DATA)load_func(LHDC_EXT_SET_DATA_NAME);
+  if (lhdcv5_ext_set_data == nullptr) return false;
+#endif
+
+  return true;
+}
+
+bool A2DP_VendorUnloadEncoderLhdcV5(void) {
+  if (lhdc_encoder_lib_handle == nullptr) return true;  // Already unload
+
+  // Cleanup any LHDC-related state
+  LOG_DEBUG( "%s: has_lhdc_handle %d",
+      __func__, a2dp_lhdc_encoder_cb.has_lhdc_handle);
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && lhdc_free_handle != nullptr) {
+    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (ret < 0) {
+      LOG_ERROR( "%s: free handle error %d", __func__, ret);
+      return false;
+    }
+  } else {
+    LOG_ERROR( "%s: unload encoder error", __func__);
+    return false;
+  }
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  lhdc_get_handle = nullptr;
+  lhdc_free_handle = nullptr;
+  lhdc_get_bitrate = nullptr;
+  lhdc_set_bitrate = nullptr;
+  lhdc_set_max_bitrate = nullptr;
+  lhdc_set_min_bitrate = nullptr;
+  lhdc_auto_adjust_bitrate = nullptr;
+  lhdc_set_ext_func = nullptr;
+  lhdc_init_encoder = nullptr;
+  lhdc_get_block_size =nullptr;
+  lhdc_encode_func = nullptr;
+
+  //
+  // LHDC extend function API
+  //
+#ifdef LHDCV5_SRC_EXT_API_ENABLE
+  lhdcv5_ext_get_ApiVer = nullptr;
+  lhdcv5_ext_get_config = nullptr;
+  lhdcv5_ext_set_config = nullptr;
+  lhdcv5_ext_set_data = nullptr;
+#endif
+
+  dlclose(lhdc_encoder_lib_handle);
+  lhdc_encoder_lib_handle = nullptr;
+
+  return true;
+}
+
+//tA2DP_ENCODER_INTERFACE::(encoder_init)
+void a2dp_vendor_lhdcv5_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback) {
+
+  if (p_peer_params == nullptr || a2dp_codec_config == nullptr ||
+      read_callback == nullptr || enqueue_callback == nullptr) {
+    LOG_ERROR( "%s: null input", __func__);
+    return;
+  }
+
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    int32_t ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (ret < 0) {
+      LOG_ERROR( "%s: free handle error %d", __func__, ret);
+      return;
+    }
+  }
+
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+  a2dp_lhdc_encoder_cb.stats.session_start_us = bluetooth::common::time_get_os_boottime_us();
+
+  a2dp_lhdc_encoder_cb.read_callback = read_callback;
+  a2dp_lhdc_encoder_cb.enqueue_callback = enqueue_callback;
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+
+  a2dp_lhdc_encoder_cb.use_SCMS_T = false;  // TODO: should be a parameter
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  a2dp_lhdc_encoder_cb.use_SCMS_T = true;
+#endif
+
+  // NOTE: Ignore the restart_input / restart_output flags - this initization
+  // happens when the connection is (re)started.
+  bool restart_input = false;
+  bool restart_output = false;
+  bool config_updated = false;
+  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu,
+      a2dp_codec_config, &restart_input,
+      &restart_output, &config_updated);
+}
+
+//
+// LHDC Extended API
+//
+#ifndef LHDCV5_SRC_EXT_API_ENABLE
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(const char* version, const int clen) {
+  return BT_STATUS_FAIL;
+}
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen) {
+  return BT_STATUS_FAIL;
+}
+int A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen) {
+  return BT_STATUS_FAIL;
+}
+bool A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(const char* codecData, const int clen) {
+  return false;
+}
+#else
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserApiVer(const char* version, const int clen)
+{
+  if (version == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_get_ApiVer != nullptr) {
+    LOG_VERBOSE( "%s: lhdc_ext_API(GetApiVer): clen:%d", __func__, clen);
+    return lhdcv5_ext_get_ApiVer(a2dp_lhdc_encoder_cb.lhdc_handle, version, clen);
+  } else {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV5Source::getEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if (userConfig == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_get_config != nullptr) {
+    LOG_VERBOSE( "%s: lhdc_ext_API(GetConfig): clen:%d", __func__, clen);
+    return lhdcv5_ext_get_config(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  } else {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+int A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserConfig(const char* userConfig, const int clen)
+{
+  if (userConfig == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_set_config != nullptr) {
+    LOG_VERBOSE( "%s: lhdc_ext_API(SetConfig): clen:%d", __func__, clen);
+    return lhdcv5_ext_set_config(a2dp_lhdc_encoder_cb.lhdc_handle, userConfig, clen);
+  } else {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return BT_STATUS_FAIL;
+  }
+}
+
+bool A2dpCodecConfigLhdcV5Source::setEncoderExtendFuncUserData(const char* codecData, const int clen)
+{
+  if (codecData == nullptr) {
+    return BT_STATUS_FAIL;
+  }
+
+  if(lhdcv5_ext_set_data != nullptr) {
+    LOG_VERBOSE( "%s: lhdc_ext_API(SetData): clen:%d", __func__, clen);
+    lhdcv5_ext_set_data(a2dp_lhdc_encoder_cb.lhdc_handle, codecData, clen);
+    return true;
+  } else {
+    LOG_DEBUG( "%s: lib func not found", __func__);
+    return false;
+  }
+}
+#endif  //LHDCV5_SRC_EXT_API_ENABLE
+
+bool A2dpCodecConfigLhdcV5Source::updateEncoderUserConfig(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params, bool* p_restart_input,
+    bool* p_restart_output, bool* p_config_updated) {
+
+  if (p_peer_params == nullptr || p_restart_input == nullptr ||
+      p_restart_output == nullptr || p_config_updated == nullptr) {
+    LOG_ERROR( "%s: null input", __func__);
+    return false;
+  }
+
+  a2dp_lhdc_encoder_cb.is_peer_edr = p_peer_params->is_peer_edr;
+  a2dp_lhdc_encoder_cb.peer_supports_3mbps = p_peer_params->peer_supports_3mbps;
+  a2dp_lhdc_encoder_cb.peer_mtu = p_peer_params->peer_mtu;
+  a2dp_lhdc_encoder_cb.timestamp = 0;
+
+  if (a2dp_lhdc_encoder_cb.peer_mtu == 0) {
+    LOG_ERROR(
+        "%s: Cannot update the codec encoder for %s: "
+        "invalid peer MTU",
+        __func__, name().c_str());
+    return false;
+  }
+
+  a2dp_vendor_lhdcv5_encoder_update(a2dp_lhdc_encoder_cb.peer_mtu, this,
+      p_restart_input, p_restart_output,
+      p_config_updated);
+  return true;
+}
+
+// wrap index mapping from bt stack to codec library
+static bool a2dp_vendor_lhdcv5_qualitymode_wrapper(uint32_t *out, uint32_t in) {
+  if (!out) return false;
+
+  switch(in) {
+  case A2DP_LHDCV5_QUALITY_ABR:
+    *out = LHDCV5_QUALITY_AUTO;
+    return true;
+  case A2DP_LHDCV5_QUALITY_HIGH1:
+    *out = LHDCV5_QUALITY_HIGH1;
+    return true;
+  case A2DP_LHDCV5_QUALITY_HIGH:
+    *out = LHDCV5_QUALITY_HIGH;
+    return true;
+  case A2DP_LHDCV5_QUALITY_MID:
+    *out = LHDCV5_QUALITY_MID;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW:
+    *out = LHDCV5_QUALITY_LOW;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW4:
+    *out = LHDCV5_QUALITY_LOW4;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW3:
+    *out = LHDCV5_QUALITY_LOW3;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW2:
+    *out = LHDCV5_QUALITY_LOW2;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW1:
+    *out = LHDCV5_QUALITY_LOW1;
+    return true;
+  case A2DP_LHDCV5_QUALITY_LOW0:
+    *out = LHDCV5_QUALITY_LOW0;
+    return true;
+  }
+
+  return false;
+}
+
+
+// Update the A2DP LHDC encoder.
+// |peer_mtu| is the peer MTU.
+// |a2dp_codec_config| is the A2DP codec to use for the update.
+static void a2dp_vendor_lhdcv5_encoder_update(uint16_t peer_mtu,
+    A2dpCodecConfig* a2dp_codec_config,
+    bool* p_restart_input,
+    bool* p_restart_output,
+    bool* p_config_updated) {
+
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  uint8_t codec_info[AVDT_CODEC_SIZE];
+  uint32_t verCode = 0;
+  int32_t lib_ret = 0;
+  uint8_t ret_value8 = 0;
+  uint32_t mtu_size = 0;
+  uint32_t max_mtu_len = 0;
+  uint32_t newValue_bt = 0, newValue_lib = 0;
+  tA2DP_FEEDING_PARAMS* p_feeding_params;
+
+  const uint8_t *p_codec_info;
+
+  *p_restart_input = false;
+  *p_restart_output = false;
+  *p_config_updated = false;
+
+  if (!a2dp_codec_config->copyOutOtaCodecConfig(codec_info)) {
+    LOG_ERROR(
+        "%s: Cannot update the codec encoder for %s: "
+        "invalid codec config",
+        __func__, a2dp_codec_config->name().c_str());
+    return;
+  }
+  p_codec_info = codec_info;
+
+  btav_a2dp_codec_config_t codec_config = a2dp_codec_config->getCodecConfig();
+  //btav_a2dp_codec_config_t codec_config_user = a2dp_codec_config->getCodecUserConfig();
+
+  // get version
+  if (!A2DP_VendorGetVersionLhdcV5(&verCode, p_codec_info)) {
+    LOG_ERROR( "%s: get version error!", __func__);
+    goto fail;
+  }
+  LOG_DEBUG( "%s: get version: %d" , __func__, verCode);
+
+  // get new handle
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+    a2dp_lhdc_encoder_cb.lhdc_handle = nullptr;
+    lib_ret = lhdc_get_handle(verCode, &a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR( "%s: [lib_ret] lhdc_get_handle error %d", __func__, lib_ret);
+      goto fail;
+    }
+
+    if (a2dp_lhdc_encoder_cb.lhdc_handle == nullptr) {
+      LOG_ERROR( "%s: Cannot get LHDC encoder handle", __func__);
+      goto fail;
+    }
+    a2dp_lhdc_encoder_cb.has_lhdc_handle = true;
+  }
+  LOG_DEBUG( "%s: lhdc handle addr = %p", __func__, a2dp_lhdc_encoder_cb.lhdc_handle);
+
+  //
+  // setup feeding parameters for encoder feeding process
+  //
+  p_feeding_params = &a2dp_lhdc_encoder_cb.feeding_params;
+  // sample rate (uint32_t)
+  p_feeding_params->sample_rate = A2DP_VendorGetTrackSampleRateLhdcV5(p_codec_info);
+  if (p_feeding_params->sample_rate < 0) {
+    LOG_ERROR( "%s: get track sample rate error", __func__);
+    goto fail;
+  }
+
+  // bit per sample (uint8_t)
+  p_feeding_params->bits_per_sample = A2DP_VendorGetTrackBitsPerSampleLhdcV5(p_codec_info);
+  if (p_feeding_params->bits_per_sample < 0) {
+    LOG_ERROR( "%s: get bit per sample error", __func__);
+    goto fail;
+  }
+
+  //channel count (uint8_t)
+  p_feeding_params->channel_count = A2DP_VendorGetTrackChannelCountLhdcV5(p_codec_info);
+  if (p_feeding_params->channel_count < 0) {
+    LOG_ERROR( "%s: get channel count error", __func__);
+    goto fail;
+  }
+  LOG_DEBUG( "%s: (feeding param) sample_rate=%u bits_per_sample=%u channel_count=%u",
+      __func__, p_feeding_params->sample_rate,
+      p_feeding_params->bits_per_sample,
+      p_feeding_params->channel_count);
+
+  //
+  // setup encoder parameters for configuring encoder
+  //
+  // sample rate tA2DP_SAMPLE_RATE(uint32_t)
+  p_encoder_params->sample_rate = a2dp_lhdc_encoder_cb.feeding_params.sample_rate;
+
+  // default mtu size (uint32_t)
+  mtu_size = (BT_DEFAULT_BUFFER_SIZE - A2DP_LHDC_OFFSET - sizeof(BT_HDR));
+  // allowed mtu size (uint32_t)
+  a2dp_lhdc_encoder_cb.TxAaMtuSize = (mtu_size < peer_mtu) ? mtu_size : (uint32_t)peer_mtu;
+  // real mtu size (uint32_t)
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  max_mtu_len = (uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  // max target bit rate
+  if (!A2DP_VendorGetMaxBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
+    LOG_ERROR( "%s: get max_target_bitrate error", __func__);
+    goto fail;
+  }
+  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+    LOG_ERROR( "%s: wrap MBR qualiity mode error", __func__);
+    goto fail;
+  }
+  p_encoder_params->max_target_bitrate = newValue_lib;
+
+  // min target bit rate
+  if (!A2DP_VendorGetMinBitRateLhdcV5(&newValue_bt, p_codec_info) ) {
+    LOG_ERROR( "%s: get min_target_bitrate error", __func__);
+    goto fail;
+  }
+  if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+    LOG_ERROR( "%s: wrap mBR qualiity mode error", __func__);
+    goto fail;
+  }
+  p_encoder_params->min_target_bitrate = newValue_lib;
+
+  // Low latency mode
+  if (!A2DP_VendorHasLLFlagLhdcV5(&(p_encoder_params->isLLEnabled), p_codec_info)){
+    LOG_ERROR( "%s: get Low latency enable error", __func__);
+    goto fail;
+  }
+
+  // bit per sample
+  switch((int)p_feeding_params->bits_per_sample) {
+  case 16:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S16;
+    break;
+  case 24:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S24;
+    break;
+  case 32:
+    p_encoder_params->pcm_fmt = LHDCV5BT_SMPL_FMT_S32;
+    break;
+  }
+
+  // quality mode
+  if ((codec_config.codec_specific_1 & A2DP_LHDC_VENDOR_CMD_MASK) == A2DP_LHDC_QUALITY_MAGIC_NUM) {
+    newValue_bt = (codec_config.codec_specific_1 & A2DP_LHDCV5_QUALITY_MASK);
+    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+      LOG_ERROR( "%s: wrap quality mode error", __func__);
+      goto fail;
+    }
+    if (newValue_lib != p_encoder_params->quality_mode_index) {
+      p_encoder_params->quality_mode_index = newValue_lib;
+    }
+  } else {
+    //default: LOW (400 Kbps)
+    codec_config.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDCV5_QUALITY_LOW;
+    //codec_config_user.codec_specific_1 = A2DP_LHDC_QUALITY_MAGIC_NUM | A2DP_LHDC_QUALITY_LOW;
+
+    newValue_bt = A2DP_LHDCV5_QUALITY_LOW;
+    if (!a2dp_vendor_lhdcv5_qualitymode_wrapper(&newValue_lib, newValue_bt)) {
+      LOG_ERROR( "%s: (default) wrap quality mode error", __func__);
+      goto fail;
+    }
+    p_encoder_params->quality_mode_index = newValue_lib;
+  }
+
+  LOG_DEBUG( "%s: (encode param) sample_rate=%u pcm_fmt=%d peer_mtu=%d mtu=%d "
+      "maxBitRateIdx=%u minBitRateIdx=%u isLLEnabled=%u quality_mode=%s(%d)", __func__,
+      p_encoder_params->sample_rate,                //44100, 48000, ...
+      p_encoder_params->pcm_fmt,                    //16, 24, 32...
+      peer_mtu, max_mtu_len,                        //number of bytes
+      p_encoder_params->max_target_bitrate,         //index
+      p_encoder_params->min_target_bitrate,         //index
+      p_encoder_params->isLLEnabled,
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str(),
+      p_encoder_params->quality_mode_index);
+
+  // setup features to encoder
+  if (A2DP_VendorHasARFlagLhdcV5(&ret_value8, p_codec_info)) {
+    lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_AR, (bool)ret_value8, NULL, 0);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR( "%s: [lib_ret] lhdc_set_ext_func AR(0x%X) %d", __func__, LHDCV5_EXT_FUNC_AR, lib_ret);
+      goto fail;
+    }
+  }
+
+  if (A2DP_VendorHasJASFlagLhdcV5(&ret_value8, p_codec_info)) {
+    lib_ret = lhdc_set_ext_func(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_EXT_FUNC_JAS, (bool)ret_value8, NULL, 0);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR( "%s: [lib_ret] lhdc_set_ext_func JAS(0x%X) %d", __func__, LHDCV5_EXT_FUNC_JAS, lib_ret);
+      goto fail;
+    }
+  }
+
+  // Initialize the encoder.
+  // NOTE: MTU in the initialization must include the AVDT media header size.
+  lib_ret = lhdc_init_encoder(
+      a2dp_lhdc_encoder_cb.lhdc_handle,
+      p_encoder_params->sample_rate,
+      p_encoder_params->pcm_fmt,
+      p_encoder_params->quality_mode_index,
+      max_mtu_len,
+      (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms());
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR( "%s: [lib_ret] lhdc_init_encoder %d", __func__, lib_ret);
+    goto fail;
+  }
+
+  // setup after encoder initialized
+  lib_ret = lhdc_set_max_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->max_target_bitrate);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR( "%s: [lib_ret] set_max_bitrate %d", __func__, lib_ret);
+    goto fail;
+  }
+  lib_ret = lhdc_set_min_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->min_target_bitrate);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR( "%s: [lib_ret] set_min_bitrate %d", __func__, lib_ret);
+    goto fail;
+  }
+  lib_ret = lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, p_encoder_params->quality_mode_index);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_ERROR( "%s: [lib_ret] set_bitrate %d", __func__, lib_ret);
+    goto fail;
+  }
+
+#if defined(_V5ENC_REC_FILE_)
+  if (recFile == NULL) {
+    recFile = fopen(V5ENC_RAW_NAME,"wb");
+    LOG_DEBUG( "%s: create recode file = %p", __func__, recFile);
+  }
+  if (pcmFile == NULL) {
+    pcmFile = fopen(V5ENC_PCM_NAME,"wb");
+    LOG_DEBUG( "%s: create recode file = %p", __func__, pcmFile);
+  }
+#endif
+  return;
+
+  fail:
+  if (a2dp_lhdc_encoder_cb.lhdc_handle) {
+    a2dp_vendor_lhdcv5_encoder_cleanup();
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(encoder_cleanup)
+void a2dp_vendor_lhdcv5_encoder_cleanup(void) {
+  if (a2dp_lhdc_encoder_cb.has_lhdc_handle && a2dp_lhdc_encoder_cb.lhdc_handle) {
+    int32_t lib_ret = lhdc_free_handle(a2dp_lhdc_encoder_cb.lhdc_handle);
+    if (lib_ret != LHDCV5_FRET_SUCCESS) {
+      LOG_ERROR( "%s: free handle error %d", __func__, lib_ret);
+      return;
+    }
+  } else {
+    LOG_DEBUG( "%s: nothing to clean", __func__);
+    return;
+  }
+  memset(&a2dp_lhdc_encoder_cb, 0, sizeof(a2dp_lhdc_encoder_cb));
+
+#if defined(_V5ENC_REC_FILE_)
+  if (recFile != NULL) {
+    fclose(recFile);
+    recFile = NULL;
+    remove(V5ENC_RAW_NAME);
+  }
+  if (pcmFile != NULL) {
+    fclose(pcmFile);
+    pcmFile = NULL;
+    remove(V5ENC_PCM_NAME);
+  }
+#endif
+
+  LOG_DEBUG( "%s: encoder cleaned up", __func__);
+}
+
+//tA2DP_ENCODER_INTERFACE::(feeding_reset)
+void a2dp_vendor_lhdcv5_feeding_reset(void) {
+  /* By default, just clear the entire state */
+  memset(&a2dp_lhdc_encoder_cb.lhdc_feeding_state, 0,
+      sizeof(a2dp_lhdc_encoder_cb.lhdc_feeding_state));
+
+  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick =
+      (a2dp_lhdc_encoder_cb.feeding_params.sample_rate *
+          a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8 *
+          a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+          encoder_interval) / 1000;
+  a2dp_lhdc_encoder_cb.buf_seq = 0;
+  a2dp_lhdc_encoder_cb.bytes_read = 0;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = 0;
+
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    if(lhdc_set_bitrate != NULL && a2dp_lhdc_encoder_cb.has_lhdc_handle) {
+      LOG_DEBUG("%s: reset ABR!", __func__);
+      lhdc_set_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, LHDCV5_QUALITY_RESET_AUTO);
+    }
+  }
+
+  LOG_DEBUG( "%s: PCM bytes per tick %u, reset timestamp", __func__,
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick);
+}
+
+//tA2DP_ENCODER_INTERFACE::(feeding_flush)
+void a2dp_vendor_lhdcv5_feeding_flush(void) {
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter = 0;
+  LOG_DEBUG( "%s", __func__);
+}
+
+//tA2DP_ENCODER_INTERFACE::(get_encoder_interval_ms)
+uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void) {
+  LOG_DEBUG( "%s: A2DP_LHDC_ENCODER_INTERVAL_MS %u",  __func__,
+      a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled ? A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS : A2DP_LHDC_ENCODER_INTERVAL_MS);
+
+  if (a2dp_lhdc_encoder_cb.lhdc_encoder_params.isLLEnabled){
+    return A2DP_LHDC_ENCODER_SHORT_INTERVAL_MS;
+  }else{
+    return A2DP_LHDC_ENCODER_INTERVAL_MS;
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(send_frames)
+void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us) {
+  uint8_t nb_frame = 0;
+  uint8_t nb_iterations = 0;
+
+  a2dp_lhdcv5_get_num_frame_iteration(&nb_iterations, &nb_frame, timestamp_us);
+  LOG_VERBOSE( "%s: Sending %d frames per iteration, %d iterations",
+      __func__, nb_frame, nb_iterations);
+
+  if (nb_frame == 0) return;
+
+  for (uint8_t counter = 0; counter < nb_iterations; counter++) {
+    // Transcode frame and enqueue
+    a2dp_lhdcV5_encode_frames(nb_frame);
+  }
+}
+
+// Obtains the number of frames to send and number of iterations
+// to be used. |num_of_iterations| and |num_of_frames| parameters
+// are used as output param for returning the respective values.
+static void a2dp_lhdcv5_get_num_frame_iteration(uint8_t* num_of_iterations,
+    uint8_t* num_of_frames,
+    uint64_t timestamp_us) {
+
+  uint32_t result = 0;
+  uint8_t nof = 0;
+  uint8_t noi = 1;
+  uint32_t pcm_bytes_per_frame = 0;
+  uint32_t samples_per_frame = 0;
+  int32_t lib_ret = 0;
+
+  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_DEBUG( "%s: get block size error %d", __func__, lib_ret);
+    return;
+  }
+
+  pcm_bytes_per_frame = samples_per_frame *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  uint32_t encoder_interval = (uint32_t)a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+  uint32_t us_this_tick = encoder_interval * 1000;
+  uint64_t now_us = timestamp_us;
+
+  // not the first time, calculate time offset
+  if (a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us != 0) {
+    us_this_tick = (now_us - a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us);
+  }
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.last_frame_us = now_us;
+
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.bytes_per_tick * us_this_tick /
+      (encoder_interval * 1000);
+
+  result =
+      a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter / pcm_bytes_per_frame;
+  a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter -=
+      result * pcm_bytes_per_frame;
+  nof = result;
+
+  LOG_DEBUG( "%s: samples_per_frame=%u pcm_bytes_per_frame=%u nb_frame=%u",
+      __func__, samples_per_frame, pcm_bytes_per_frame, nof);
+
+  *num_of_frames = nof;
+  *num_of_iterations = noi;
+}
+
+static BT_HDR *bt_buf_new( void) {
+  BT_HDR *p_buf = ( BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE);
+  if ( p_buf == NULL) {
+    // LeoKu(C): should not happen
+    LOG_ERROR(  "%s: bt_buf_new failed!", __func__);
+    return NULL;
+  }
+
+  p_buf->offset = A2DP_LHDC_OFFSET;
+  p_buf->len = 0;
+  p_buf->layer_specific = 0;
+  return p_buf;
+}
+
+static void a2dp_lhdcV5_encode_frames(uint8_t nb_frame){
+  static float mtu_usage = 0;
+  static int mtu_usage_cnt = 0;
+  static uint32_t time_prev = bluetooth::common::time_get_os_boottime_ms();
+  static uint32_t all_send_bytes = 0;
+  uint8_t read_buffer[LHDCV5_MAX_SAMPLE_FRAME * 2 * 4];
+  uint32_t samples_per_frame = 0;
+  uint32_t out_frames = 0;
+  uint8_t remain_nb_frame = nb_frame;
+  uint32_t written = 0;
+  uint32_t bytes_read = 0;
+  uint8_t *packet = nullptr;
+  BT_HDR *p_buf = nullptr;
+  int32_t lib_ret = 0;
+  uint32_t pcm_bytes_per_frame = 0;
+  uint32_t max_mtu_len = 0;
+
+  uint32_t written_frame = 0;
+  uint32_t temp_bytes_read = 0;
+
+  lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_DEBUG( "%s: [lib_ret] lhdc_get_block_size error %d", __func__, lib_ret);
+    return;
+  }
+  pcm_bytes_per_frame = samples_per_frame *
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+
+  if (pcm_bytes_per_frame > sizeof(read_buffer)) {
+    LOG_ERROR( "%s: expected read size error", __func__);
+    return;
+  }
+
+  // check codec handle existed
+  if (!a2dp_lhdc_encoder_cb.has_lhdc_handle || !a2dp_lhdc_encoder_cb.lhdc_handle) {
+    LOG_ERROR( "%s: encoder handle invalid error", __func__);
+    return;
+  }
+
+#if (BTA_AV_CO_CP_SCMS_T == TRUE)
+  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN - 1);
+#else
+  max_mtu_len = ( uint32_t)( a2dp_lhdc_encoder_cb.TxAaMtuSize - A2DP_LHDC_MPL_HDR_LEN);
+#endif
+
+  while (nb_frame) {
+    // create a temp output buffer
+    if ((p_buf = bt_buf_new()) == NULL) {
+      LOG_ERROR( "%s: create buf error", __func__);
+      return;
+    }
+
+    written_frame = 0;
+    do {
+      temp_bytes_read = 0;
+      // read from feeding buffer
+      if (a2dp_lhdcv5_read_feeding(read_buffer, &temp_bytes_read)) {
+        a2dp_lhdc_encoder_cb.bytes_read += temp_bytes_read;
+        packet = (uint8_t*)(p_buf + 1) + p_buf->offset + p_buf->len;
+
+#if defined(_V5ENC_REC_FILE_)
+        if (pcmFile != NULL) {
+          fwrite(read_buffer, sizeof(uint8_t), pcm_bytes_per_frame, pcmFile);
+        }
+#endif
+
+        LOG_DEBUG( "%s: nb_frame(%d) to encode...", __func__, nb_frame);
+        // to encode
+        lib_ret = lhdc_encode_func(a2dp_lhdc_encoder_cb.lhdc_handle,
+            read_buffer, temp_bytes_read,
+            packet, (BT_DEFAULT_BUFFER_SIZE-(p_buf->offset + p_buf->len + sizeof(BT_HDR))),
+            &written, &out_frames);
+
+        if (lib_ret != LHDCV5_FRET_SUCCESS) {
+          LOG_ERROR( "%s: [lib_ret] lhdc_encode_func error %d", __func__, lib_ret);
+          a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
+          osi_free(p_buf);
+          return;
+        }
+
+#if defined(_V5ENC_REC_FILE_)
+        if (recFile != NULL && written > 0) {
+          fwrite(packet, sizeof(uint8_t), written, recFile);
+        }
+#endif
+        LOG_DEBUG( "%s: nb_frame(%d) - written:%d, out_frames:%d", __func__,
+            nb_frame, written, out_frames);
+        p_buf->len += written;
+        all_send_bytes += written;
+        nb_frame--;
+        written_frame += out_frames;  // added a frame to the buffer
+      } else {
+        LOG_DEBUG( "%s: nb_frame(%d) - underflow", __func__, nb_frame);
+        a2dp_lhdc_encoder_cb.lhdc_feeding_state.counter +=
+            nb_frame * samples_per_frame *
+            a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+            a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+        // no more pcm to read
+        nb_frame = 0;
+      }
+    } while ((written == 0) && nb_frame);
+
+    if (p_buf->len) {
+      /*
+       * Timestamp of the media packet header represent the TS of the
+       * first frame, i.e the timestamp before including this frame.
+       */
+      p_buf->layer_specific = a2dp_lhdc_encoder_cb.buf_seq++;
+      p_buf->layer_specific <<= 8;
+      p_buf->layer_specific |= ((written_frame << A2DP_LHDC_HDR_NUM_SHIFT));
+
+      *( ( uint32_t*)( p_buf + 1)) = a2dp_lhdc_encoder_cb.timestamp;
+      LOG_VERBOSE( "%s: Timestamp (%d)", __func__, a2dp_lhdc_encoder_cb.timestamp);
+
+      a2dp_lhdc_encoder_cb.timestamp += (written_frame * samples_per_frame);
+
+      remain_nb_frame = nb_frame;
+      LOG_DEBUG( "%s: nb_frame(%d) - remain_nb_frame:%d", __func__, (nb_frame+1), remain_nb_frame);
+
+      mtu_usage += ((float)p_buf->len) / max_mtu_len;
+      mtu_usage_cnt++;
+
+      LOG_DEBUG( "%s: Bytes read for pkt(%d)", __func__, a2dp_lhdc_encoder_cb.bytes_read);
+      LOG_DEBUG( "%s: Output frames(%d) encoded pkt len(%d)", __func__, written_frame, p_buf->len);
+      bytes_read = a2dp_lhdc_encoder_cb.bytes_read;
+      a2dp_lhdc_encoder_cb.bytes_read = 0;
+
+      if (!a2dp_lhdc_encoder_cb.enqueue_callback(p_buf, 1, bytes_read))
+        return;
+    } else {
+      LOG_DEBUG( "%s: free buffer len(%d)", __func__, p_buf->len);
+      a2dp_lhdc_encoder_cb.stats.media_read_total_dropped_packets++;
+      osi_free(p_buf);
+    }
+  }
+
+  // for statistics
+  uint32_t now_ms = bluetooth::common::time_get_os_boottime_ms();
+  if (now_ms - time_prev >= 1000 ) {
+    LOG_DEBUG( "%s: current data rate about %d kbps, packet usage %.2f%%", __func__,
+        (all_send_bytes * 8) / 1000, (mtu_usage * 100)/mtu_usage_cnt);
+    all_send_bytes = 0;
+    mtu_usage_cnt = 0;
+    mtu_usage = 0;
+    time_prev = now_ms;
+  }
+}
+
+static bool a2dp_lhdcv5_read_feeding(uint8_t* read_buffer, uint32_t *bytes_read) {
+  uint32_t read_size = 0;
+  uint32_t samples_per_frame = 0;
+  uint32_t bytes_per_sample =
+      a2dp_lhdc_encoder_cb.feeding_params.channel_count *
+      a2dp_lhdc_encoder_cb.feeding_params.bits_per_sample / 8;
+  uint32_t nb_byte_read;
+
+  if (read_buffer == nullptr || bytes_read == nullptr) {
+    LOG_ERROR( "%s: null input", __func__);
+    return false;
+  }
+
+  int32_t lib_ret = lhdc_get_block_size(a2dp_lhdc_encoder_cb.lhdc_handle, &samples_per_frame);
+  if (lib_ret != LHDCV5_FRET_SUCCESS) {
+    LOG_DEBUG( "%s: [lib_ret] lhdc_get_block_size error %d", __func__, lib_ret);
+    return false;
+  }
+  read_size = samples_per_frame * bytes_per_sample;
+
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_reads_count++;
+  a2dp_lhdc_encoder_cb.stats.media_read_total_expected_read_bytes += read_size;
+
+  /* Read Data from UIPC channel */
+  nb_byte_read =
+      a2dp_lhdc_encoder_cb.read_callback(read_buffer, read_size);
+  LOG_DEBUG( "%s: expected read bytes %u, actual read bytes %u",
+      __func__, read_size, nb_byte_read);
+
+  //TODO: what to do if not alignment?
+  if ((nb_byte_read % bytes_per_sample) != 0) {
+    LOG_DEBUG( "%s: PCM data not alignment. The audio sample is shfit %d bytes!",
+        __func__, (nb_byte_read % bytes_per_sample));
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_read_bytes += nb_byte_read;
+
+  // if actual read < want to read
+  if (nb_byte_read < read_size) {
+    if (nb_byte_read == 0) return false;
+
+    /* Fill the unfilled part of the read buffer with silence (0) */
+    memset(((uint8_t*)read_buffer) + nb_byte_read, 0, read_size - nb_byte_read);
+    nb_byte_read = read_size;
+  }
+  a2dp_lhdc_encoder_cb.stats.media_read_total_actual_reads_count++;
+  *bytes_read = nb_byte_read;
+
+  return true;
+}
+
+// library index mapping: quality mode index
+static std::string quality_mode_index_to_name(uint32_t quality_mode_index) {
+  switch (quality_mode_index) {
+  case LHDCV5_QUALITY_HIGH1:
+    return "HIGH1_1000";
+  case LHDCV5_QUALITY_HIGH:
+    return "HIGH_900";
+  case LHDCV5_QUALITY_MID:
+    return "MID_500";
+  case LHDCV5_QUALITY_LOW:
+    return "LOW_400";
+  case LHDCV5_QUALITY_LOW4:
+    return "LOW_320";
+  case LHDCV5_QUALITY_LOW3:
+    return "LOW_256";
+  case LHDCV5_QUALITY_LOW2:
+    return "LOW_192";
+  case LHDCV5_QUALITY_LOW1:
+    return "LOW_128";
+  case LHDCV5_QUALITY_LOW0:
+    return "LOW_64";
+  case LHDCV5_QUALITY_AUTO:
+    return "ABR";
+  default:
+    return "Unknown";
+  }
+}
+
+//tA2DP_ENCODER_INTERFACE::(set_transmit_queue_length)
+void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length) {
+  int32_t lib_ret = 0;
+
+  a2dp_lhdc_encoder_cb.TxQueueLength = transmit_queue_length;
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params = &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+  LOG_VERBOSE( "%s: transmit_queue_length %zu", __func__, transmit_queue_length);
+
+  if (p_encoder_params->quality_mode_index == LHDCV5_QUALITY_AUTO) {
+    LOG_VERBOSE( "%s: Auto Bitrate Enabled!", __func__);
+    if (lhdc_auto_adjust_bitrate != NULL) {
+      lib_ret = lhdc_auto_adjust_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, (uint32_t)transmit_queue_length);
+      if (lib_ret != LHDCV5_FRET_SUCCESS){
+        LOG_ERROR( "%s: [lib_ret] lhdc_auto_adjust_bitrate error %d", __func__, lib_ret);
+      }
+    }
+  }
+}
+
+uint64_t A2dpCodecConfigLhdcV5Source::encoderIntervalMs() const {
+  return a2dp_vendor_lhdcv5_get_encoder_interval_ms();
+}
+
+int A2dpCodecConfigLhdcV5Source::getEffectiveMtu() const {
+  return a2dp_lhdc_encoder_cb.TxAaMtuSize;
+}
+
+void A2dpCodecConfigLhdcV5Source::debug_codec_dump(int fd) {
+  a2dp_lhdcv5_encoder_stats_t* stats = &a2dp_lhdc_encoder_cb.stats;
+  tA2DP_LHDCV5_ENCODER_PARAMS* p_encoder_params =
+      &a2dp_lhdc_encoder_cb.lhdc_encoder_params;
+
+  uint32_t lib_value = 0;
+  int32_t lib_ret = 0;
+
+  A2dpCodecConfig::debug_codec_dump(fd);
+
+  dprintf(fd,
+      "  Packet counts (expected/dropped)                        : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_packets,
+      (size_t)stats->media_read_total_dropped_packets);
+
+  dprintf(fd,
+      "  PCM read counts (expected/actual)                       : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_reads_count,
+      (size_t)stats->media_read_total_actual_reads_count);
+
+  dprintf(fd,
+      "  PCM read bytes (expected/actual)                        : %zu / "
+      "%zu\n",
+      (size_t)stats->media_read_total_expected_read_bytes,
+      (size_t)stats->media_read_total_actual_read_bytes);
+
+  dprintf(fd,
+      "  LHDC quality mode                                       : %s\n",
+      quality_mode_index_to_name(p_encoder_params->quality_mode_index).c_str());
+
+  lib_ret = lhdc_get_bitrate(a2dp_lhdc_encoder_cb.lhdc_handle, &lib_value);
+  if (lib_ret == LHDCV5_FRET_SUCCESS) {
+    dprintf(fd,
+        "  LHDC transmission bitrate (Kbps)                        : %d\n",
+        lib_value);
+  }
+
+  dprintf(fd,
+      "  LHDC saved transmit queue length                        : %zu\n",
+      (size_t)a2dp_lhdc_encoder_cb.TxQueueLength);
+}
+
diff --git a/system_bt/stack/include/a2dp_codec_api.h b/system_bt/stack/include/a2dp_codec_api.h
index 3297c5c78..84c945bac 100644
--- a/system_bt/stack/include/a2dp_codec_api.h
+++ b/system_bt/stack/include/a2dp_codec_api.h
@@ -255,6 +255,20 @@ class A2dpCodecConfig {
   // The information is written in user-friendly form to file descriptor |fd|.
   virtual void debug_codec_dump(int fd);
 
+  // Savitech LHDC EXT API -- START
+  virtual int getLhdcExtendAPIVersion(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
+
+  virtual int getLhdcExtendAPIConfig(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
+
+  virtual int setLhdcExtendAPIConfig(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return 0; }
+
+  virtual bool setLhdcExtendAPIData(
+      A2dpCodecConfig* peerCodec, const char* buf, const int clen) { return true; }
+  // Savitech LHDC EXT API -- END
+
   std::recursive_mutex codec_mutex_;
   const btav_a2dp_codec_index_t codec_index_;  // The unique codec index
   const std::string name_;                     // The codec name
@@ -454,6 +468,24 @@ class A2dpCodecs {
   // The information is written in user-friendly form to file descriptor |fd|.
   void debug_codec_dump(int fd);
 
+  // Savitech LHDC EXT API -- START
+  int getLHDCCodecUserApiVer(
+      A2dpCodecConfig* peerCodec,
+      const char* codecConfig, const int clen);
+
+  int getLHDCCodecUserConfig(
+      A2dpCodecConfig* peerCodec,
+      const char* codecConfig, const int clen);
+
+  int setLHDCCodecUserConfig(
+      A2dpCodecConfig* peerCodec,
+      const char* codecConfig, const int clen);
+
+  bool setLHDCCodecUserData(
+      A2dpCodecConfig* peerCodec,
+      const char* codecData, const int clen);
+  // Savitech LHDC EXT API -- END
+
  private:
   struct CompareBtBdaddr
       : public std::binary_function<RawAddress, RawAddress, bool> {
diff --git a/system_bt/stack/include/a2dp_vendor_lhdc_constants.h b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
new file mode 100644
index 000000000..69e3c3bad
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdc_constants.h
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDC_CONSTANTS_H
+#define A2DP_VENDOR_LHDC_CONSTANTS_H
+#define A2DP_LHDC_SILENCE_LEVEL  1.0f
+#define A2DP_LHDC_VERSION_NUMBER    0x01
+#define A2DP_LHDC_VENDOR_CMD_MASK    0xC000
+#define A2DP_LHDC_VENDOR_FEATURE_MASK    (0xFF000000)
+
+// LHDC Quality Mode Index
+//LHDC not supported auto bit rate now.
+#define A2DP_LHDC_QUALITY_MAGIC_NUM 0x8000
+
+/* LHDC quality supportting new bit rate */
+/* 256kbps, 192kbps, 128kbps, 96kbps, 64kbps */
+#define A2DP_LHDC_QUALITY_MASK   0xFF
+#define A2DP_LHDC_QUALITY_ABR    9   // ABR mode
+#define A2DP_LHDC_QUALITY_HIGH1  8   // 1000kbps (supported in LHDCV5 or higher version)
+#define A2DP_LHDC_QUALITY_HIGH   7   // Equal to LHDCBT_EQMID_HQ 900kbps
+#define A2DP_LHDC_QUALITY_MID    6   // Equal to LHDCBT_EQMID_SQ 500kbps
+#define A2DP_LHDC_QUALITY_LOW    5   // Equal to LHDCBT_EQMID_MQ 400kbps
+#define A2DP_LHDC_QUALITY_LOW4   4   // 320
+#define A2DP_LHDC_QUALITY_LOW3   3   // 256
+#define A2DP_LHDC_QUALITY_LOW2   2   // 192
+#define A2DP_LHDC_QUALITY_LOW1   1   // 128
+#define A2DP_LHDC_QUALITY_LOW0   0   // 64
+
+#define A2DP_LHDC_LATENCY_MAGIC_NUM 0xC000
+#define A2DP_LHDC_LL_ENABLE	  1	// LL enabled
+#define A2DP_LHDC_LL_DISABLE	0	// LL disabled
+
+#define A2DP_LHDC_LATENCY_LOW	0	// 50-100 ms
+#define A2DP_LHDC_LATENCY_MID	1	// default value, 150-200 ms
+#define A2DP_LHDC_LATENCY_HIGH	2	// 300-500 ms
+
+
+// Length of the LHDC Media Payload header
+#define A2DP_LHDC_MPL_HDR_LEN 2
+
+// LHDC Media Payload Header
+#define A2DP_LHDC_HDR_F_MSK 0x80
+#define A2DP_LHDC_HDR_S_MSK 0x40
+#define A2DP_LHDC_HDR_L_MSK 0x20
+
+#define A2DP_LHDCV3_HDR_NUM_MSK 0x0F
+#define A2DP_LHDCV2_HDR_NUM_MSK 0x7
+#define A2DP_LHDCV1_HDR_NUM_MSK 0x7
+#define A2DP_LHDC_HDR_NUM_SHIFT 2
+#define A2DP_LHDCV3_HDR_NUM_MAX 8
+#define A2DP_LHDCV2_HDR_NUM_MAX 7
+#define A2DP_LHDCV1_HDR_NUM_MAX 7
+
+#define A2DP_LHDC_HDR_LATENCY_LOW   0x00
+#define A2DP_LHDC_HDR_LATENCY_MID   0x01
+#define A2DP_LHDC_HDR_LATENCY_HIGH  0x02
+#define A2DP_LHDC_HDR_LATENCY_MSK   0x03
+
+// LHDC codec specific settings
+//#define A2DP_LHDCV3_CODEC_LEN 12
+#define A2DP_LHDCV3_CODEC_LEN 11
+#define A2DP_LHDCV2_CODEC_LEN 11
+#define A2DP_LHDCV1_CODEC_LEN 9
+#define A2DP_LHDC_LL_CODEC_LEN 9
+#define A2DP_LHDCV5_CODEC_LEN 13
+
+// [Octet 0-3] Vendor ID
+#define A2DP_LHDC_VENDOR_ID 0x0000053a
+// [Octet 4-5] Vendor Specific Codec ID
+#define A2DP_LHDCV2_CODEC_ID 0x4C32
+#define A2DP_LHDCV3_CODEC_ID 0x4C33
+#define A2DP_LHDCV1_CODEC_ID 0x484C
+#define A2DP_LHDCV1_LL_CODEC_ID 0x4C4C
+#define A2DP_LHDCV5_CODEC_ID 0x4C35
+
+// [Octet 6], [Bits 0-3] Sampling Frequency
+#define A2DP_LHDC_SAMPLING_FREQ_MASK 0x0F
+#define A2DP_LHDC_SAMPLING_FREQ_44100 0x08
+#define A2DP_LHDC_SAMPLING_FREQ_48000 0x04
+#define A2DP_LHDC_SAMPLING_FREQ_88200 0x02
+#define A2DP_LHDC_SAMPLING_FREQ_96000 0x01
+// [Octet 6], [Bits 3-4] Bit dipth
+#define A2DP_BAD_BITS_PER_SAMPLE    0xff
+#define A2DP_LHDC_BIT_FMT_MASK 	 0x30
+#define A2DP_LHDC_BIT_FMT_24	 0x10
+#define A2DP_LHDC_BIT_FMT_16	 0x20
+
+// [Octet 6], [Bits 6-7] Bit dipth
+#define A2DP_LHDC_FEATURE_AR		0x80
+#define A2DP_LHDC_FEATURE_JAS		0x40
+
+//[Octet 7:bit0..bit3]
+#define A2DP_LHDC_VERSION_MASK 0x0F
+//#define A2DP_LHDC_VERSION_2    0x01
+//#define A2DP_LHDC_VERSION_3    0x02
+//Supported version
+typedef enum {
+    A2DP_LHDC_VER2_BES  = 0,
+    A2DP_LHDC_VER2 = 1,
+    A2DP_LHDC_VER3 = 0x01,
+    A2DP_LHDC_VER4 = 0x02,
+    A2DP_LHDC_VER5 = 0x04,
+    A2DP_LHDC_VER6 = 0x08,
+    A2DP_LHDC_ERROR_VER,
+
+    A2DP_LHDC_LAST_SUPPORTED_VERSION = A2DP_LHDC_VER4,
+} A2DP_LHDC_VERSION;
+
+//[Octet 7:bit4..bit5]
+#define A2DP_LHDC_MAX_BIT_RATE_MASK       0x30
+#define A2DP_LHDC_MAX_BIT_RATE_900K       0x00
+#define A2DP_LHDC_MAX_BIT_RATE_500K       0x10		//500~600K
+#define A2DP_LHDC_MAX_BIT_RATE_400K       0x20
+//[Octet 7:bit6]
+#define A2DP_LHDC_LL_MASK             0x40
+#define A2DP_LHDC_LL_NONE             0x00
+#define A2DP_LHDC_LL_SUPPORTED        0x40
+
+//[Octet 7:bit7]
+#define A2DP_LHDC_FEATURE_LLAC		0x80
+
+//[Octet 8:bit0..bit3]
+#define A2DP_LHDC_CH_SPLIT_MSK        0x0f
+#define A2DP_LHDC_CH_SPLIT_NONE       0x01
+#define A2DP_LHDC_CH_SPLIT_TWS        0x02
+#define A2DP_LHDC_CH_SPLIT_TWS_PLUS   0x04
+
+//[Octet 8:bit4..bit7]
+#define A2DP_LHDC_FEATURE_META		0x10
+#define A2DP_LHDC_FEATURE_MIN_BR	0x20
+#define A2DP_LHDC_FEATURE_LARC		0x40
+#define A2DP_LHDC_FEATURE_LHDCV4	0x80
+
+//For LL used
+#define A2DP_LHDC_CHANNEL_SEPARATION  0x40
+
+
+//Only supported stereo
+#define A2DP_LHDC_CHANNEL_MODE_STEREO 0x03
+
+#define A2DP_LHDC_BITRATE_900K		0x01
+#define A2DP_LHDC_BITRATE_600K		0x02
+#define A2DP_LHDC_BITRATE_400K		0x04
+#define A2DP_LHDC_BITRATE_320K		0x08
+#define A2DP_LHDC_BITRATE_256K		0x10
+#define A2DP_LHDC_BITRATE_192K		0x20
+#define A2DP_LHDC_BITRATE_128K		0x40
+#define A2DP_LHDC_BITRATE_64K		0x80
+#define A2DP_LHDC_BITRATE_ALL		0xff
+
+
+#define A2DP_LHDC_FEATURE_MAGIC_NUM (0x4C000000)
+//LHDC Features: codec config specific field bitmap definition
+//specific2
+#define A2DP_LHDC_LL_ENABLED		0x1ULL
+//specific3
+#define A2DP_LHDC_JAS_ENABLED		0x1ULL
+#define A2DP_LHDC_AR_ENABLED		0x2ULL
+#define A2DP_LHDC_META_ENABLED		0x4ULL
+#define A2DP_LHDC_LLAC_ENABLED		0x8ULL
+#define A2DP_LHDC_MBR_ENABLED		0x10ULL
+#define A2DP_LHDC_LARC_ENABLED		0x20ULL
+#define A2DP_LHDC_V4_ENABLED		0x40ULL
+/* Define the ?th bit(from least significant bit) in the specific, sync with the bitmap definition
+ *  ex: A2DP_LHDC_AR_ENABLED = (2^A2DP_LHDC_AR_SPEC_BIT_POS)
+ * */
+//default in specific2
+#define A2DP_LHDC_LL_SPEC_BIT_POS        (0x0)
+//default in specific3
+#define A2DP_LHDC_JAS_SPEC_BIT_POS       (0x0)
+#define A2DP_LHDC_AR_SPEC_BIT_POS        (0x01)
+#define A2DP_LHDC_META_SPEC_BIT_POS      (0x02)
+#define A2DP_LHDC_LLAC_SPEC_BIT_POS      (0x03)
+#define A2DP_LHDC_MBR_SPEC_BIT_POS       (0x04)
+#define A2DP_LHDC_LARC_SPEC_BIT_POS      (0x05)
+#define A2DP_LHDC_V4_SPEC_BIT_POS        (0x06)
+
+/* bitmap for A2DP codec config selecting */
+#define A2DP_LHDC_TO_A2DP_CODEC_CONFIG_         0x1ULL      //codec_config_
+#define A2DP_LHDC_TO_A2DP_CODEC_CAP_            0x2ULL      //codec_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_LOCAL_CAP_      0x4ULL      //codec_local_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_SELECT_CAP_     0x8ULL      //codec_selectable_capability_
+#define A2DP_LHDC_TO_A2DP_CODEC_USER_           0x10ULL     //codec_user_config_
+#define A2DP_LHDC_TO_A2DP_CODEC_AUDIO_          0x20ULL     //codec_audio_config_
+
+#define SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
+} while(0)
+
+#define CHECK_IN_A2DP_SPEC(cfg, spec, value)  do{   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+    return (cfg->codec_specific_1 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+    return (cfg->codec_specific_2 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+    return (cfg->codec_specific_3 & value);   \
+  if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+    return (cfg->codec_specific_4 & value);   \
+  return false;   \
+} while(0)
+
+// TODO: return version macro to replace LHDC_CHECK_IN_A2DP_SPEC
+#define LHDCV3_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
+  bool marco_ret = false; \
+  do{   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX ) \
+      marco_ret = (cfg->codec_specific_1 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX ) \
+      marco_ret = (cfg->codec_specific_2 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX ) \
+      marco_ret = (cfg->codec_specific_3 & value);   \
+    if( spec == LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX ) \
+      marco_ret = (cfg->codec_specific_4 & value);   \
+    } while(0);  \
+  marco_ret;   \
+})
+
+//
+// Savitech - LHDC aDSP configuration
+//
+// Lhdcv5Version: 1 << (below value-1)
+#define A2DP_OFFLOAD_LHDCV2_VER_1                   0x01
+#define A2DP_OFFLOAD_LHDCV3_V3_ONLY                 0x02
+#define A2DP_OFFLOAD_LHDCV3_V4_ONLY                 0x03
+#define A2DP_OFFLOAD_LHDCV3_LLAC                    0x04
+#define A2DP_OFFLOAD_LHDCV5_VER_1                   0x01
+
+// Lhdcv5QualityIndex
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW0            0x01
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW1            0x02
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW2            0x04
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW3            0x08
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW4            0x10
+#define A2DP_OFFLOAD_LHDC_QUALITY_LOW             0x20
+#define A2DP_OFFLOAD_LHDC_QUALITY_MID             0x40
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH            0x80
+#define A2DP_OFFLOAD_LHDC_QUALITY_HIGH1           0x100
+#define A2DP_OFFLOAD_LHDC_QUALITY_ABR             0x8000
+
+// Lhdcv5FrameDuration
+#define A2DP_OFFLOAD_LHDC_FRAME_DURATION_5000US   0x01
+
+// Lhdcv5DataInterval
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_20MS      0x01
+#define A2DP_OFFLOAD_LHDC_DATA_INTERVAL_10MS      0x02
+
+// Lhdcv5Specific
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_AR     0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_JAS    0x02
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_META   0x04
+
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_ACTION_AR_ON   0x01
+#define A2DP_OFFLOAD_LHDC_SPECIFIC_FEATURE_SPLIT  0x80
+
+// Lhdcv5Parameters
+#define A2DP_OFFLOAD_LHDC_CFG_VER                   6
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_L             7
+#define A2DP_OFFLOAD_LHDC_CFG_BITRATE_H             8
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_L          9
+#define A2DP_OFFLOAD_LHDC_CFG_MAXBITRATE_H          10
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_L          11
+#define A2DP_OFFLOAD_LHDC_CFG_MINBITRATE_H          12
+#define A2DP_OFFLOAD_LHDC_CFG_FRAMEDUR              13
+#define A2DP_OFFLOAD_LHDC_CFG_INTERVAL              14
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC1                 15
+#define A2DP_OFFLOAD_LHDC_CFG_SPEC2                 16
+#define A2DP_OFFLOAD_LHDC_CFG_META                  17
+
+#endif  // A2DP_VENDOR_LHDC_CONSTANTS_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv2.h b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
new file mode 100644
index 000000000..5576d12fb
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv2.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDC
+//
+
+#ifndef A2DP_VENDOR_LHDCV2_H
+#define A2DP_VENDOR_LHDCV2_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+
+class A2dpCodecConfigLhdcV2 : public A2dpCodecConfig {
+ public:
+  bool copySinkCapability(uint8_t * codec_info);
+  A2dpCodecConfigLhdcV2(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV2();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+  void debug_codec_dump(int fd) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV2();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV2(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV2(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV2(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV2(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV2(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV2(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV2(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV2(const uint8_t* p_codec_info);
+
+// New feature to check codec info is supported Channel Separation.
+int8_t A2DP_VendorGetChannelSplitModeLhdcV2(const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetLowLatencyStateLhdcV2(const uint8_t* p_codec_info);
+int16_t A2DP_VendorGetMaxDatarateLhdcV2(const uint8_t* p_codec_info);
+uint8_t A2DP_VendorGetVersionLhdcV2(const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV2(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV2(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV2(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV2(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV2(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+
+bool A2DP_VendorInitCodecConfigLhdcV2(AvdtpSepConfig* p_cfg);
+// Gets the track bitrate value for the A2DP LHDCV2 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV2(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV2_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv2_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv2_encoder.h
new file mode 100644
index 000000000..0d762cd8a
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv2_encoder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV2_ENCODER_H
+#define A2DP_VENDOR_LHDCV2_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV2(void);
+
+// Unloads the A2DP LHDC encoder.
+void A2DP_VendorUnloadEncoderLhdcV2(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv2_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv2_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv2_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv2_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv2_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv2_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv2_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV2_ENCODER_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3.h b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
new file mode 100644
index 000000000..dd8afaf17
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv3.h
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDC
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_H
+#define A2DP_VENDOR_LHDCV3_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+#ifdef LOG_NDEBUG
+#undef LOG_NDEBUG
+#define LOG_NDEBUG 1	//set 0 to turn on VERBOSE LOG
+#endif
+
+/** Start of LHDC A2DP-Related API definition ***************************************/
+#define EXTEND_FUNC_CODE_GET_SPECIFIC                   ((unsigned int) 0x0A010001)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V1                 ((unsigned int) 0x01000000)
+#define EXTEND_FUNC_VER_GET_SPECIFIC_V2                 ((unsigned int) 0x02000000)
+#define LHDC_EXTEND_FUNC_CODE_A2DP_TYPE_MASK            (0x0A)
+#define LHDC_EXTEND_FUNC_CODE_LIB_TYPE_MASK             (0x0C)
+
+/* ************************************************************************
+ * Version info: EXTEND_FUNC_CODE_GET_SPECIFIC
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V1:  Total Size: 41 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+ * EXTEND_FUNC_VER_GET_SPECIFIC_V2:  Total Size: 64 bytes
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Code:        (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Capabilities Metadata sub fields:  (7*2 bytes)
+     * sub[0~1]:    JAS
+     * sub[2~3]:    AR
+     * sub[4~5]:    META
+     * sub[6~7]:    LLAC
+     * sub[8~9]:    MBR
+     * sub[10~11]:  LARC
+     * sub[12~13]:  LHDCV4
+   * Padded:                        (2 bytes)
+ * ************************************************************************/
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE        4       /* API version */
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE           4       /* API index code */
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE       1       /* A2DP codec config code */
+#define LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2             7       /* V2 Reserved bytes */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE          8       /* Specific 1 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE          8       /* Specific 2 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE          8       /* Specific 3 */
+#define LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE          8       /* Specific 4 */
+/* Capabilities metadata fields(2 bytes for each tuple) */
+#define LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2         (7<<1)  /* V2 Capabilities */
+#define LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2          2       /* V2 Padded Fields */
+
+/* Total size of buffer */
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V1    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE)
+#define LHDC_EXTEND_FUNC_CONFIG_TOTAL_FIXED_SIZE_V2    (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_API_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_RESERVED_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC1_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC2_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC3_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_SPECIFIC4_SIZE + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2 + \
+                                                          LHDC_EXTEND_FUNC_CONFIG_PADDED_SIZE_V2)
+/* Head of each field */
+#define LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD        (0)
+#define LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD           (LHDC_EXTEND_FUNC_CONFIG_API_VERSION_HEAD + 4)  //4
+#define LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD       (LHDC_EXTEND_FUNC_CONFIG_API_CODE_HEAD + 4)     //8
+/* Following part in V1 */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~16
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V1 + 8)  //17~24
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V1 + 8)  //25~32
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V1        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V1 + 8)  //33~40
+/* Following part in V2 */
+#define LHDC_EXTEND_FUNC_A2DP_RESERVED_HEAD_V2          (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 1) //9~15
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2        (LHDC_EXTEND_FUNC_CONFIG_A2DPCFG_CODE_HEAD + 8) //16~23
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS1_HEAD_V2 + 8)  //24~31
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS2_HEAD_V2 + 8)  //32~39
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2        (LHDC_EXTEND_FUNC_A2DP_SPECIFICS3_HEAD_V2 + 8)  //40~47
+#define LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2           (LHDC_EXTEND_FUNC_A2DP_SPECIFICS4_HEAD_V2 + 8)  //48~61
+#define LHDC_EXTEND_FUNC_A2DP_PADDED_HEAD_V2            (LHDC_EXTEND_FUNC_A2DP_CAPMETA_HEAD_V2 + LHDC_EXTEND_FUNC_CONFIG_CAPMETA_SIZE_V2)   //62~63
+
+
+/* code definition mapping to A2DP codec specific in a2dp_codec_api.h
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CFG          (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_FINAL_CAP          (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_LOCAL_CAP          (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_SELECTABLE_CAP     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_USER_CFG           (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_TYPE_SPECIFICS_AUDIO_CFG          (0x06)
+
+
+/************************
+ * Capability Meta Format: (denotes where source capabilities bits are stored in specifics)
+   * Capability Code:                   (1 byte)
+   * Saving Position Info:              (1 byte)
+ ************************/
+/* Capabilities's code: */
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_JAS_CODE      (0x01)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_AR_CODE       (0x02)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_META_CODE     (0x03)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LLAC_CODE     (0x04)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_MBR_CODE      (0x05)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_LARC_CODE     (0x06)
+#define LHDC_EXTEND_FUNC_A2DP_LHDC_V4_CODE       (0x07)
+
+/* Capabilities's saving position Info:
+ *  1. in which specific                        (represented in leftmost 2-bits)
+ *  2. at which bit position of the specific    (represented in rightmost 6-bits)
+ * */
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC1_INDEX    (0x00)     //2-bit:00
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC2_INDEX    (0x40)     //2-bit:01
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC3_INDEX    (0x80)     //2-bit:10
+#define LHDC_EXTEND_FUNC_A2DP_SPECIFIC4_INDEX    (0xC0)     //2-bit:11
+/** End of LHDC A2DP-Related API definition ***************************************/
+
+
+class A2dpCodecConfigLhdcV3 : public A2dpCodecConfig {
+ public:
+  bool copySinkCapability(uint8_t * codec_info);
+  A2dpCodecConfigLhdcV3(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV3();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+  static int getEncoderExtendFuncUserApiVer(const char* version, const int clen);
+  static int getEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static int setEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static bool setEncoderExtendFuncUserData(const char* userData, const int clen);
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+  void debug_codec_dump(int fd) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV3();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV3(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV3(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV3(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV3(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV3(const uint8_t* p_codec_info);
+
+// New feature to check codec info is supported Channel Separation.
+int8_t A2DP_VendorGetChannelSplitModeLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetLowLatencyStateLhdcV3(const uint8_t* p_codec_info);
+int16_t A2DP_VendorGetMaxDatarateLhdcV3(const uint8_t* p_codec_info);
+uint8_t A2DP_VendorGetVersionLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasV4FlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLACFlagLhdcV3(const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasJASFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasARFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasMETAFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasMinBRFlagLhdcV3(const uint8_t* p_codec_info);
+bool A2DP_VendorHasLARCFlagLhdcV3(const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV3(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV3(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV3(AvdtpSepConfig* p_cfg);
+
+bool A2DP_VendorGetSrcCapVectorLhdcv3(uint8_t* capVector);
+
+// Gets the track bitrate value for the A2DP LHDCV3 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV3(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV3_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
new file mode 100644
index 000000000..697ca3b69
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_dec.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for low complexity subband codec (SBC)
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_DEC_H
+#define A2DP_VENDOR_LHDCV3_DEC_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "avdt_api.h"
+
+class A2dpCodecConfigLhdcV3Base : public A2dpCodecConfig {
+ protected:
+  A2dpCodecConfigLhdcV3Base(btav_a2dp_codec_index_t codec_index,
+                         const std::string& name,
+                         btav_a2dp_codec_priority_t codec_priority,
+                         bool is_source)
+      : A2dpCodecConfig(codec_index, name, codec_priority),
+        is_source_(is_source) {}
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool is_source_;  // True if local is Source
+};
+
+
+class A2dpCodecConfigLhdcV3Sink : public A2dpCodecConfigLhdcV3Base {
+ public:
+  A2dpCodecConfigLhdcV3Sink(btav_a2dp_codec_priority_t codec_priority);
+  virtual ~A2dpCodecConfigLhdcV3Sink();
+
+  bool init() override;
+  uint64_t encoderIntervalMs() const override;
+  int getEffectiveMtu() const override;
+//  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+//                      uint8_t* p_result_codec_config) override;
+//  bool setPeerCodecCapabilities(
+//      const uint8_t* p_peer_codec_capabilities) override;
+
+ private:
+  bool useRtpHeaderMarkerBit() const override;
+  bool updateEncoderUserConfig(
+      const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+      bool* p_restart_input, bool* p_restart_output,
+      bool* p_config_updated) override;
+};
+
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorSinkCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether A2DP SBC Sink codec is supported.
+// |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
+bool A2DP_IsVendorSinkCodecSupportedLhdcV3(const uint8_t* p_codec_info);
+
+// Checks whether an A2DP SBC Source codec for a peer Source device is
+// supported.
+// |p_codec_info| contains information about the codec capabilities of the
+// peer device.
+// Returns true if the A2DP SBC Source codec for a peer Source device is
+// supported, otherwise false.
+bool A2DP_IsPeerSourceCodecSupportedLhdcV3(const uint8_t* p_codec_info);
+
+// Initialize state with the default A2DP SBC codec.
+// The initialized state with the codec capabilities is stored in
+// |p_codec_info|.
+void A2DP_InitDefaultCodecLhdcV3Sink(uint8_t* p_codec_info);
+
+// Gets the A2DP SBC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                             const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP SBC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not SBC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV3Sink(const uint8_t* p_codec_info_a,
+                         const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP SBC codec.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP SBC codec.
+// The actual value is codec-specific - see |A2DP_SBC_IE_CH_MD_*|.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the channel type for the A2DP SBC Sink codec:
+// 1 for mono, or 3 for dual/stereo/joint.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel type on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV3Sink(const uint8_t* p_codec_info,
+                                const uint8_t* p_data, uint32_t* p_timestamp);
+
+// Builds A2DP SBC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+/*bool A2DP_VendorBuildCodecHeaderLhdcV3Sink(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                              uint16_t frames_per_packet);
+*/
+// Decodes A2DP SBC codec info into a human readable string.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV3Sink(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
+// packets - see |tA2DP_DECODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV3(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP SBC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV3Sink(uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_SourceCodecIndexSbc(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV3(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC V3 Sink codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV3Sink(void);
+
+// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV3Sink(AvdtpSepConfig* p_cfg);
+
+#endif  // A2DP_VENDOR_LHDCV3_DEC_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_decoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_decoder.h
new file mode 100644
index 000000000..58b8f1437
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_decoder.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC V3 Decoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_DECODER_H
+#define A2DP_VENDOR_LHDCV3_DECODER_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+
+
+
+// Save CODEC information
+// Return true on success, otherwise false.
+bool save_codec_info (const uint8_t* p_codec_info);
+
+// Loads the A2DP LHDC V3 decoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadDecoderLhdcV3(void);
+
+// Unloads the A2DP LHDC V3 decoder.
+void A2DP_VendorUnloadDecoderLhdcV3(void);
+
+// Initialize the A2DP LHDC V3 decoder.
+bool a2dp_vendor_lhdcv3_decoder_init(decoded_data_callback_t decode_callback);
+
+// Cleanup the A2DP LHDC V3 decoder.
+void a2dp_vendor_lhdcv3_decoder_cleanup(void);
+
+// Decodes |p_buf|. Calls |decode_callback| passed into |a2dp_lhdcv3_decoder_init|
+// if decoded frames are available.
+bool a2dp_vendor_lhdcv3_decoder_decode_packet(BT_HDR* p_buf);
+
+// Start the A2DP LHDCV3 decoder.
+void a2dp_vendor_lhdcv3_decoder_start(void);
+
+// Suspend the A2DP LHDCV3 decoder.
+void a2dp_vendor_lhdcv3_decoder_suspend(void);
+
+// A2DP LHDCV3 decoder configuration.
+void a2dp_vendor_lhdcv3_decoder_configure(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV3_DECODER_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv3_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv3_encoder.h
new file mode 100644
index 000000000..e9ea55f9c
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv3_encoder.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV3_ENCODER_H
+#define A2DP_VENDOR_LHDCV3_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+typedef enum {
+  BTAV_A2DP_CODEC_LHDC_CONFIG_NOTUSED = 0,
+  BTAV_A2DP_CODEC_LHDC_CONFIG_AR,
+  BTAV_A2DP_CODEC_LHDC_CONFIG_META,
+} btav_a2dp_codec_lhdc_ConfigCfg_t;
+
+typedef enum {
+  BTAV_A2DP_CODEC_LHDC_DATA_NOTUSED = 0,
+  BTAV_A2DP_CODEC_LHDC_DATA_GYRO_XY,
+} btav_a2dp_codec_lhdc_DataCfg_t;
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV3(void);
+
+// Unloads the A2DP LHDC encoder.
+void A2DP_VendorUnloadEncoderLhdcV3(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv3_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv3_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv3_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv3_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv3_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV3_ENCODER_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5.h b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
new file mode 100644
index 000000000..f579b28cd
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5.h
@@ -0,0 +1,292 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP Codec API for LHDCV5
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_H
+#define A2DP_VENDOR_LHDCV5_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv5_constants.h"
+#include "avdt_api.h"
+
+#define IS_SRC  (true)
+#define IS_SNK  (false)
+
+class A2dpCodecConfigLhdcV5Base : public A2dpCodecConfig {
+ protected:
+  	 A2dpCodecConfigLhdcV5Base(btav_a2dp_codec_index_t codec_index,
+                         const std::string& name,
+                         btav_a2dp_codec_priority_t codec_priority,
+                         bool is_source)
+      : A2dpCodecConfig(codec_index, name, codec_priority),
+        is_source_(is_source) {}
+  bool setCodecConfig(const uint8_t* p_peer_codec_info, bool is_capability,
+                      uint8_t* p_result_codec_config) override;
+  bool setPeerCodecCapabilities(
+      const uint8_t* p_peer_codec_capabilities) override;
+
+  int getLhdcExtendAPIVersion(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+  int getLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+  int setLhdcExtendAPIConfig(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+  bool setLhdcExtendAPIData(A2dpCodecConfig* peerCodec, const char* buf, const int clen);
+
+ private:
+  bool is_source_;  // True if local is Source
+};
+
+class A2dpCodecConfigLhdcV5Source : public A2dpCodecConfigLhdcV5Base {
+ public:
+	A2dpCodecConfigLhdcV5Source(btav_a2dp_codec_priority_t codec_priority);
+	virtual ~A2dpCodecConfigLhdcV5Source();
+
+	bool init() override;
+	uint64_t encoderIntervalMs() const override;
+	int getEffectiveMtu() const override;
+
+  static int getEncoderExtendFuncUserApiVer(const char* version, const int clen);
+  static int getEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static int setEncoderExtendFuncUserConfig(const char* userConfig, const int clen);
+  static bool setEncoderExtendFuncUserData(const char* userData, const int clen);
+
+ private:
+	bool useRtpHeaderMarkerBit() const override;
+	bool updateEncoderUserConfig(
+		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+		 bool* p_restart_input, bool* p_restart_output,
+		 bool* p_config_updated) override;
+	void debug_codec_dump(int fd) override;
+};
+
+class A2dpCodecConfigLhdcV5Sink : public A2dpCodecConfigLhdcV5Base {
+public:
+ A2dpCodecConfigLhdcV5Sink(btav_a2dp_codec_priority_t codec_priority);
+ virtual ~A2dpCodecConfigLhdcV5Sink();
+
+ bool init() override;
+ uint64_t encoderIntervalMs() const override;
+ int getEffectiveMtu() const override;
+
+private:
+ bool useRtpHeaderMarkerBit() const override;
+ bool updateEncoderUserConfig(
+		 const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+		 bool* p_restart_input, bool* p_restart_output,
+		 bool* p_config_updated) override;
+};
+
+bool A2DP_VendorGetLowLatencyEnabledLhdcV5();
+// Checks whether the codec capabilities contain a valid A2DP LHDC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP LHDC Sink
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid LHDC
+// codec, otherwise false.
+bool A2DP_IsVendorPeerSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the A2DP data packets should contain RTP header.
+// |content_protection_enabled| is true if Content Protection is
+// enabled. |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP data packets should contain RTP header, otherwise
+// false.
+bool A2DP_VendorUsesRtpHeaderLhdcV5(bool content_protection_enabled,
+                                  const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// have the same type.
+// Returns true if the two codecs have the same type, otherwise false.
+bool A2DP_VendorCodecTypeEqualsLhdcV5(const uint8_t* p_codec_info_a,
+                                    const uint8_t* p_codec_info_b);
+
+// Checks whether two A2DP LHDC codecs |p_codec_info_a| and |p_codec_info_b|
+// are exactly the same.
+// Returns true if the two codecs are exactly the same, otherwise false.
+// If the codec type is not LHDC, the return value is false.
+bool A2DP_VendorCodecEqualsLhdcV5(const uint8_t* p_codec_info_a,
+                                const uint8_t* p_codec_info_b);
+
+// Gets the track sample rate value for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track sample rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackSampleRateLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the bits per audio sample for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the bits per audio sample on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackBitsPerSampleLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the channel count for the A2DP LHDC codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel count on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetTrackChannelCountLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the channel mode code for the A2DP LHDC codec.
+// The actual value is codec-specific - see |A2DP_LHDC_CHANNEL_MODE_*|.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the channel mode code on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetChannelModeCodeLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC audio data timestamp from an audio packet.
+// |p_codec_info| contains the codec information.
+// |p_data| contains the audio data.
+// The timestamp is stored in |p_timestamp|.
+// Returns true on success, otherwise false.
+bool A2DP_VendorGetPacketTimestampLhdcV5(const uint8_t* p_codec_info,
+                                       const uint8_t* p_data,
+                                       uint32_t* p_timestamp);
+
+// Builds A2DP LHDC codec header for audio data.
+// |p_codec_info| contains the codec information.
+// |p_buf| contains the audio data.
+// |frames_per_packet| is the number of frames in this packet.
+// Returns true on success, otherwise false.
+bool A2DP_VendorBuildCodecHeaderLhdcV5(const uint8_t* p_codec_info, BT_HDR* p_buf,
+                                     uint16_t frames_per_packet);
+
+// Decodes A2DP LHDC codec info into a human readable string.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns a string describing the codec information.
+std::string A2DP_VendorCodecInfoStringLhdcV5(const uint8_t* p_codec_info);
+
+// Parse codec info and get the quality mode of the max target bit rate
+// |p_codec_info_| contains the codec information.
+// the translated quality mode from max target bit rate.
+// Returns true if successfully
+bool A2DP_VendorGetMaxBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorGetMinBitRateLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+
+bool A2DP_VendorGetVersionLhdcV5(uint32_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorGetBitPerSampleLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+
+bool A2DP_VendorHasJASFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasARFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasMETAFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+bool A2DP_VendorHasLLFlagLhdcV5(uint8_t *retval, const uint8_t* p_codec_info);
+
+// Decodes and displays LHDC codec info (for debugging).
+// |p_codec_info| is a pointer to the LHDC codec_info to decode and display.
+void A2DP_VendorDumpCodecInfoLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC encoder interface that can be used to encode and prepare
+// A2DP packets for transmission - see |tA2DP_ENCODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP LHDC encoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_ENCODER_INTERFACE* A2DP_VendorGetEncoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Adjusts the A2DP LHDC codec, based on local support and Bluetooth
+// specification.
+// |p_codec_info| contains the codec information to adjust.
+// Returns true if |p_codec_info| is valid and supported, otherwise false.
+bool A2DP_VendorAdjustCodecLhdcV5(uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSourceCodecIndexLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC Source codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV5(void);
+
+// Initializes A2DP LHDC Source codec information into |tAVDT_CFG|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV5(AvdtpSepConfig* p_cfg);
+
+bool A2DP_VendorGetSrcCapVectorLhdcV5(uint8_t* capVector);
+
+
+
+// Checks whether the codec capabilities contain a valid A2DP LHDC V3 Sink codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorSinkCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether the codec capabilities contain a valid peer A2DP SBC Source
+// codec.
+// NOTE: only codecs that are implemented are considered valid.
+// Returns true if |p_codec_info| contains information about a valid SBC codec,
+// otherwise false.
+bool A2DP_IsVendorPeerSourceCodecValidLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether A2DP SBC Sink codec is supported.
+// |p_codec_info| contains information about the codec capabilities.
+// Returns true if the A2DP SBC Sink codec is supported, otherwise false.
+bool A2DP_IsVendorSinkCodecSupportedLhdcV5(const uint8_t* p_codec_info);
+
+// Checks whether an A2DP SBC Source codec for a peer Source device is
+// supported.
+// |p_codec_info| contains information about the codec capabilities of the
+// peer device.
+// Returns true if the A2DP SBC Source codec for a peer Source device is
+// supported, otherwise false.
+bool A2DP_IsPeerSourceCodecSupportedLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC codec name for a given |p_codec_info|.
+const char* A2DP_VendorCodecNameLhdcV5Sink(const uint8_t* p_codec_info);
+
+// Gets the channel type for the A2DP SBC Sink codec:
+// 1 for mono, or 3 for dual/stereo/joint.
+// |p_codec_info| is a pointer to the SBC codec_info to decode.
+// Returns the channel type on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetSinkTrackChannelTypeLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC decoder interface that can be used to decode received A2DP
+// packets - see |tA2DP_DECODER_INTERFACE|.
+// |p_codec_info| contains the codec information.
+// Returns the A2DP SBC decoder interface if the |p_codec_info| is valid and
+// supported, otherwise NULL.
+const tA2DP_DECODER_INTERFACE* A2DP_VendorGetDecoderInterfaceLhdcV5(
+    const uint8_t* p_codec_info);
+
+// Gets the A2DP SBC Sink codec index for a given |p_codec_info|.
+// Returns the corresponding |btav_a2dp_codec_index_t| on success,
+// otherwise |BTAV_A2DP_CODEC_INDEX_MAX|.
+btav_a2dp_codec_index_t A2DP_VendorSinkCodecIndexLhdcV5(const uint8_t* p_codec_info);
+
+// Gets the A2DP LHDC V3 Sink codec name.
+const char* A2DP_VendorCodecIndexStrLhdcV5Sink(void);
+
+// Initializes A2DP SBC Sink codec information into |AvdtpSepConfig|
+// configuration entry pointed by |p_cfg|.
+bool A2DP_VendorInitCodecConfigLhdcV5Sink(AvdtpSepConfig* p_cfg);
+
+// Gets the track bitrate value for the A2DP LHDCV5 codec.
+// |p_codec_info| is a pointer to the LHDC codec_info to decode.
+// Returns the track bit rate on success, or -1 if |p_codec_info|
+// contains invalid codec information.
+int A2DP_VendorGetBitRateLhdcV5(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV5_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
new file mode 100644
index 000000000..b405d9225
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_constants.h
@@ -0,0 +1,255 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// A2DP constants for LHDC codec
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_CONSTANTS_H
+#define A2DP_VENDOR_LHDCV5_CONSTANTS_H
+
+////////////////////////////////////////////////////////////////////
+// LHDCV5 codec info format:
+// SubVersion: A2DP_LHDCV5_VER1
+// Total Length: A2DP_LHDCV5_CODEC_LEN + 1(losc)
+//  ----------------------------------------------------------------
+//  H0   |    H1     |    H2     |  P0-P3   | P4-P5   | P6[5:0]  |
+//  losc | mediaType | codecType | vendorId | codecId | SampRate |
+//  ----------------------------------------------------------------
+//  P7[2:0]   | P7[5:4]    | P7[7:6]       | P8[3:0] | P8[4]       |
+//  bit depth | MaxBitRate | MinBitRate    | Version | FrameLen5ms |
+//  ----------------------------------------------------------------
+//  P9[0] | P9[1]  | P9[2]   | P9[6] | P9[7]       | P10[0]      |
+//  HasAR | HasJAS | HasMeta | HasLL | HasLossless | FeatureOnAR |
+//  ----------------------------------------------------------------
+
+// P0-P3 Vendor ID: (0x0000053a)
+// P4-P5 Vendor Specific Codec ID: (0x4C35)
+// P6[5:0] Sampling Frequency
+#define A2DP_LHDCV5_SAMPLING_FREQ_MASK    (0x35)
+#define A2DP_LHDCV5_SAMPLING_FREQ_44100   (0x20)
+#define A2DP_LHDCV5_SAMPLING_FREQ_48000   (0x10)
+#define A2DP_LHDCV5_SAMPLING_FREQ_96000   (0x04)
+#define A2DP_LHDCV5_SAMPLING_FREQ_192000  (0x01)
+#define A2DP_LHDCV5_SAMPLING_FREQ_NS      (0x00)
+
+// P7[2:0] Bit depth
+#define A2DP_LHDCV5_BIT_FMT_MASK  (0x07)
+#define A2DP_LHDCV5_BIT_FMT_16    (0x04)
+#define A2DP_LHDCV5_BIT_FMT_24    (0x02)
+#define A2DP_LHDCV5_BIT_FMT_32    (0x01)
+#define A2DP_LHDCV5_BIT_FMT_NS    (0x00)
+
+// P7[5:4] Max Bit Rate Type
+#define A2DP_LHDCV5_MAX_BIT_RATE_MASK   (0x30)
+#define A2DP_LHDCV5_MAX_BIT_RATE_900K   (0x30)
+#define A2DP_LHDCV5_MAX_BIT_RATE_500K   (0x20)
+#define A2DP_LHDCV5_MAX_BIT_RATE_400K   (0x10)
+#define A2DP_LHDCV5_MAX_BIT_RATE_1000K  (0x00)
+
+// P7[7:6] Min Bit Rate Type
+#define A2DP_LHDCV5_MIN_BIT_RATE_MASK   (0xC0)
+#define A2DP_LHDCV5_MIN_BIT_RATE_400K   (0xC0)
+#define A2DP_LHDCV5_MIN_BIT_RATE_256K   (0x80)
+#define A2DP_LHDCV5_MIN_BIT_RATE_128K   (0x40)
+#define A2DP_LHDCV5_MIN_BIT_RATE_64K    (0x00)
+
+// P8[3:0] Codec SubVersion (bitmap)
+#define A2DP_LHDCV5_VERSION_MASK    (0x0F)
+#define A2DP_LHDCV5_VER_1           (0x01)
+#define A2DP_LHDCV5_VER_NS          (0x00)
+
+// P8[5:4] Frame Length Type
+#define A2DP_LHDCV5_FRAME_LEN_MASK  (0x10)
+#define A2DP_LHDCV5_FRAME_LEN_5MS   (0x10)
+#define A2DP_LHDCV5_FRAME_LEN_NS    (0x00)
+
+// P9[0] HasAR
+// P9[1] HasJAS
+// P9[2] HasMeta
+// P9[6] HasLowLatency
+// P9[7] HasLossless
+#define A2DP_LHDCV5_FEATURE_MASK      (0xC7)
+#define A2DP_LHDCV5_FEATURE_LLESS     (0x80)
+#define A2DP_LHDCV5_FEATURE_LL        (0x40)
+#define A2DP_LHDCV5_FEATURE_META      (0x04)
+#define A2DP_LHDCV5_FEATURE_JAS       (0x02)
+#define A2DP_LHDCV5_FEATURE_AR        (0x01)
+
+// P10[0] AR ON/OFF
+#define A2DP_LHDCV5_AR_ON        (0x01)
+////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////
+//  attributes which not in codec info format
+//    channel mode
+//    channel separation mode
+////////////////////////////////////////////////////////////////////
+// channel mode:
+#define A2DP_LHDCV5_CHANNEL_MODE_MASK   (0x07)
+#define A2DP_LHDCV5_CHANNEL_MODE_MONO   (0x04)
+#define A2DP_LHDCV5_CHANNEL_MODE_DUAL   (0x02)
+#define A2DP_LHDCV5_CHANNEL_MODE_STEREO (0x01)
+#define A2DP_LHDCV5_CHANNEL_MODE_NS     (0x00)
+
+// LHDC Quality Mode Index
+#define A2DP_LHDCV5_QUALITY_MASK   (0x0F)
+#define A2DP_LHDCV5_QUALITY_ABR    (0x09)  // Adaptive Bit Rate
+#define A2DP_LHDCV5_QUALITY_HIGH1  (0x08)  // 1000kbps
+#define A2DP_LHDCV5_QUALITY_HIGH   (0x07)  // 900kbps
+#define A2DP_LHDCV5_QUALITY_MID    (0x06)  // 500kbps
+#define A2DP_LHDCV5_QUALITY_LOW    (0x05)  // 400kbps
+#define A2DP_LHDCV5_QUALITY_LOW4   (0x04)  // 320kbps
+#define A2DP_LHDCV5_QUALITY_LOW3   (0x03)  // 256kbps
+#define A2DP_LHDCV5_QUALITY_LOW2   (0x02)  // 192kbps
+#define A2DP_LHDCV5_QUALITY_LOW1   (0x01)  // 128kbps
+#define A2DP_LHDCV5_QUALITY_LOW0   (0x00)  // 64kbps
+////////////////////////////////////////////////////////////////////
+
+/************************************************
+ * LHDC Feature Capabilities on A2DP specifics:
+   * feature id:                          (1 byte)
+   * target specific index:               (2 bits)
+   * target bit index on a specific:      (decimal: 0~63)
+************************************************/
+// feature code:
+#define LHDCV5_FEATURE_CODE_MASK     (0xFF)
+#define LHDCV5_FEATURE_CODE_NA       (0x00)
+#define LHDCV5_FEATURE_CODE_JAS      (0x01)
+#define LHDCV5_FEATURE_CODE_AR       (0x02)
+#define LHDCV5_FEATURE_CODE_META     (0x03)
+#define LHDCV5_FEATURE_CODE_LL       (0x08)
+#define LHDCV5_FEATURE_CODE_LLESS    (0x09)
+
+// target specific index:
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1    (0x00)     //2-bit:00
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2    (0x40)     //2-bit:01
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3    (0x80)     //2-bit:10
+#define LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4    (0xC0)     //2-bit:11
+
+// target bit index on the specific:
+//  specific@1
+#define LHDCV5_FEATURE_QM_SPEC_BIT_POS        (0x00)
+//  specific@2
+#define LHDCV5_FEATURE_LL_SPEC_BIT_POS        (0x00)
+//  specific@3
+#define LHDCV5_FEATURE_JAS_SPEC_BIT_POS       (0x00)
+#define LHDCV5_FEATURE_AR_SPEC_BIT_POS        (0x01)
+#define LHDCV5_FEATURE_META_SPEC_BIT_POS      (0x02)
+#define LHDCV5_FEATURE_LLESS_SPEC_BIT_POS     (0x07)
+// Notice: the highest bit position is limited by A2DP_LHDC_FEATURE_MAGIC_NUM(0x4C000000)
+//  ie., available range in a specific: int64[24:0]
+#define LHDCV5_FEATURE_MAX_SPEC_BIT_POS       (0x19)
+
+#define LHDC_SETUP_A2DP_SPEC(cfg, spec, has, value)  do{   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
+    (has) ? (cfg->codec_specific_1 |= value) : (cfg->codec_specific_1 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
+    (has) ? (cfg->codec_specific_2 |= value) : (cfg->codec_specific_2 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
+    (has) ? (cfg->codec_specific_3 |= value) : (cfg->codec_specific_3 &= ~value);   \
+  if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
+    (has) ? (cfg->codec_specific_4 |= value) : (cfg->codec_specific_4 &= ~value);   \
+} while(0)
+
+#define LHDCV5_CHECK_IN_A2DP_SPEC(cfg, spec, value)  ({ \
+  bool marco_ret = false; \
+  do{   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_1 ) \
+      marco_ret = (cfg->codec_specific_1 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_2 ) \
+      marco_ret = (cfg->codec_specific_2 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_3 ) \
+      marco_ret = (cfg->codec_specific_3 & value);   \
+    if( spec == LHDCV5_FEATURE_ON_A2DP_SPECIFIC_4 ) \
+      marco_ret = (cfg->codec_specific_4 & value);   \
+    } while(0);  \
+  marco_ret;   \
+})
+
+//
+// Savitech - LHDC Extended API Start
+//
+/* LHDC Extend API Category */
+// A2DP Type API: handled in bt stack
+#define LHDCV5_EXTEND_API_CODE_A2DP_TYPE            (0x0A)
+// Lib Type API: handled by codec lib
+#define LHDCV5_EXTEND_API_CODE_LIB_TYPE             (0x0C)
+
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_HEAD       (4)   /* position of API command code in buffer field */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_ID_HEAD         (8)   /* position of codec config id in buffer field */
+
+//
+// A2DP Type API: Get info from A2DP codec config's specifics
+//
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE      (0x0A010001)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_VER2      (0x02000000)
+
+/* id for A2DP codec config
+ * 0x01: codec_config_
+ * 0x02: codec_capability_
+ * 0x03: codec_local_capability_
+ * 0x04: codec_selectable_capability_
+ * 0x05: codec_user_config_
+ * 0x06: codec_audio_config_
+ */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CFG                (0x01)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CAP                (0x02)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_LOCAL_CAP          (0x03)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_SELECT_CAP         (0x04)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_USER_CFG           (0x05)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_AUDIO_CFG          (0x06)
+/* ************************************************************************
+ * Fields in buffer for LHDCV5_EXTEND_API_VER_GET_SPECIFIC_V2
+ * total 64 bytes:
+   * API Version:                   (4 bytes)
+   * API Code:                      (4 bytes)
+   * A2DP Codec Config Id:          (1 bytes)
+   * Reserved:                      (7 bytes)
+   * A2dp Specific1:                (8 bytes)
+   * A2dp Specific2:                (8 bytes)
+   * A2dp Specific3:                (8 bytes)
+   * A2dp Specific4:                (8 bytes)
+   * Info fields:                   (5*2 bytes)
+     * [0~1]: AR
+     * [2~3]: JAS
+     * [4~5]: META
+     * [6~7]: Low Latency
+     * [8~9]: Loss Less
+   * Pad:                           (6 bytes)
+ * ************************************************************************/
+#define LHDCV5_EXTEND_API_A2DP_SPEC_VER_SIZE        4       /* API version */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CODE_SIZE       4       /* API index code */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_CFGID_SIZE      1       /* A2DP codec config code */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_RSVD_V2         7       /* Reserved bytes */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_1_SIZE          8       /* Specific 1 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_2_SIZE          8       /* Specific 2 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_3_SIZE          8       /* Specific 3 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_4_SIZE          8       /* Specific 4 */
+#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_SIZE_V2    (5<<1)  /* Info fields */
+// total size of buffer fields (64)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_TOTAL_SIZE_V2   (64)
+
+#define LHDCV5_EXTEND_API_A2DP_SPEC1_HEAD_V2        (16)
+#define LHDCV5_EXTEND_API_A2DP_SPEC2_HEAD_V2        (24)
+#define LHDCV5_EXTEND_API_A2DP_SPEC3_HEAD_V2        (32)
+#define LHDCV5_EXTEND_API_A2DP_SPEC4_HEAD_V2        (40)
+#define LHDCV5_EXTEND_API_A2DP_SPEC_INFO_HEAD_V2    (48)
+
+//
+// Savitech - LHDC Extended API End
+//
+#endif  // A2DP_VENDOR_LHDCV5_CONSTANTS_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
new file mode 100644
index 000000000..ba5be9825
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_decoder.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2022 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC V5 Decoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_DECODER_H
+#define A2DP_VENDOR_LHDCV5_DECODER_H
+
+#include "a2dp_codec_api.h"
+#include "a2dp_vendor_lhdc_constants.h"
+#include "a2dp_vendor_lhdcv5_constants.h"
+
+
+// Save CODEC information
+// Return true on success, otherwise false.
+bool a2dp_lhdcv5_decoder_save_codec_info (const uint8_t* p_codec_info);
+
+// Loads the A2DP LHDC V5 decoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadDecoderLhdcV5(void);
+
+// Unloads the A2DP LHDC V5 decoder.
+void A2DP_VendorUnloadDecoderLhdcV5(void);
+
+// Initialize the A2DP LHDC V5 decoder.
+bool a2dp_vendor_lhdcv5_decoder_init(decoded_data_callback_t decode_callback);
+
+// Cleanup the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_cleanup(void);
+
+// Decode LHDC V5 packet to PCM
+bool a2dp_vendor_lhdcv5_decoder_decode_packet(BT_HDR* p_buf);
+
+// Start the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_start(void);
+
+// Suspend the A2DP LHDC V5 decoder.
+void a2dp_vendor_lhdcv5_decoder_suspend(void);
+
+// A2DP LHDC V5 decoder configuration.
+void a2dp_vendor_lhdcv5_decoder_configure(const uint8_t* p_codec_info);
+
+#endif  // A2DP_VENDOR_LHDCV5_DECODER_H
diff --git a/system_bt/stack/include/a2dp_vendor_lhdcv5_encoder.h b/system_bt/stack/include/a2dp_vendor_lhdcv5_encoder.h
new file mode 100644
index 000000000..84b53d276
--- /dev/null
+++ b/system_bt/stack/include/a2dp_vendor_lhdcv5_encoder.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+//
+// Interface to the A2DP LHDC Encoder
+//
+
+#ifndef A2DP_VENDOR_LHDCV5_ENCODER_H
+#define A2DP_VENDOR_LHDCV5_ENCODER_H
+
+#include "a2dp_codec_api.h"
+
+// Loads the A2DP LHDC encoder.
+// Return true on success, otherwise false.
+bool A2DP_VendorLoadEncoderLhdcV5(void);
+
+// Unloads the A2DP LHDC encoder.
+bool A2DP_VendorUnloadEncoderLhdcV5(void);
+
+// Initialize the A2DP LHDC encoder.
+// |p_peer_params| contains the A2DP peer information
+// The current A2DP codec config is in |a2dp_codec_config|.
+// |read_callback| is the callback for reading the input audio data.
+// |enqueue_callback| is the callback for enqueueing the encoded audio data.
+void a2dp_vendor_lhdcv5_encoder_init(
+    const tA2DP_ENCODER_INIT_PEER_PARAMS* p_peer_params,
+    A2dpCodecConfig* a2dp_codec_config,
+    a2dp_source_read_callback_t read_callback,
+    a2dp_source_enqueue_callback_t enqueue_callback);
+
+// Cleanup the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_encoder_cleanup(void);
+
+// Reset the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_feeding_reset(void);
+
+// Flush the feeding for the A2DP LHDC encoder.
+void a2dp_vendor_lhdcv5_feeding_flush(void);
+
+// Get the A2DP LHDC encoder interval (in milliseconds).
+uint64_t a2dp_vendor_lhdcv5_get_encoder_interval_ms(void);
+
+// Prepare and send A2DP LHDC encoded frames.
+// |timestamp_us| is the current timestamp (in microseconds).
+void a2dp_vendor_lhdcv5_send_frames(uint64_t timestamp_us);
+
+// Set transmit queue length for the A2DP LHDC ABR(Adaptive Bit Rate) mechanism.
+void a2dp_vendor_lhdcv5_set_transmit_queue_length(size_t transmit_queue_length);
+
+#endif  // A2DP_VENDOR_LHDCV5_ENCODER_H
diff --git a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
index 5b3848abd..8f017bad1 100644
--- a/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
+++ b/system_bt/stack/test/fuzzers/a2dp/codec/a2dpCodecHelperFunctions.h
@@ -28,11 +28,20 @@ static const std::vector<const btav_a2dp_codec_index_t> CODEC_INDEX_ENUM_VALS =
      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX,
      BTAV_A2DP_CODEC_INDEX_SOURCE_APTX_HD,
      BTAV_A2DP_CODEC_INDEX_SOURCE_LDAC,
+     // Savitech Patch - START
+     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3,
+     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2,
+     BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5,
+     // Savitech Patch - END
      BTAV_A2DP_CODEC_INDEX_SOURCE_MAX,
      BTAV_A2DP_CODEC_INDEX_SINK_MIN,
      BTAV_A2DP_CODEC_INDEX_SINK_SBC,
      BTAV_A2DP_CODEC_INDEX_SINK_AAC,
      BTAV_A2DP_CODEC_INDEX_SINK_LDAC,
+     // Savitech Patch - START
+     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3,
+     BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5,
+     // Savitech Patch - END
      BTAV_A2DP_CODEC_INDEX_SINK_MAX,
      BTAV_A2DP_CODEC_INDEX_MIN,
      BTAV_A2DP_CODEC_INDEX_MAX};
diff --git a/system_bt/stack/test/stack_a2dp_test.cc b/system_bt/stack/test/stack_a2dp_test.cc
index 2c1e38739..2cb351a30 100644
--- a/system_bt/stack/test/stack_a2dp_test.cc
+++ b/system_bt/stack/test/stack_a2dp_test.cc
@@ -209,6 +209,14 @@ static const char* APTX_ENCODER_LIB_NAME = "libaptX_encoder.so";
 static const char* APTX_HD_ENCODER_LIB_NAME = "libaptXHD_encoder.so";
 static const char* LDAC_ENCODER_LIB_NAME = "libldacBT_enc.so";
 static const char* LDAC_DECODER_LIB_NAME = "libldacBT_dec.so";
+// Savitech Patch - START
+static const char* LHDCV2_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static const char* LHDCV3_ENCODER_LIB_NAME = "liblhdcBT_enc.so";
+static const char* LHDCV5_ENCODER_LIB_NAME = "liblhdcv5BT_enc.so";
+static const char* LHDCV3_DECODER_LIB_NAME = "liblhdcBT_dec.so";
+static const char* LHDCV5_DECODER_LIB_NAME = "liblhdcv5BT_dec.so";
+// Savitech Patch - END
+
 
 static bool has_shared_library(const char* name) {
   void* lib_handle = dlopen(name, RTLD_NOW);
@@ -253,6 +261,23 @@ class StackA2dpTest : public ::testing::Test {
           // shared library installed.
           supported = has_shared_library(LDAC_ENCODER_LIB_NAME);
           break;
+          // Savitech Patch - START  Offload
+        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV3:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV3_ENCODER_LIB_NAME);
+          break;
+        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV2:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV2_ENCODER_LIB_NAME);
+          break;
+        case BTAV_A2DP_CODEC_INDEX_SOURCE_LHDCV5:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV5_ENCODER_LIB_NAME);
+          break;
+          // Savitech Patch - END
         case BTAV_A2DP_CODEC_INDEX_SINK_SBC:
           supported = true;
           break;
@@ -264,6 +289,18 @@ class StackA2dpTest : public ::testing::Test {
           // shared library installed.
           supported = has_shared_library(LDAC_DECODER_LIB_NAME);
           break;
+        // Savitech Patch - START  Offload
+        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV3:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV3_DECODER_LIB_NAME);
+          break;
+        case BTAV_A2DP_CODEC_INDEX_SINK_LHDCV5:
+          // Codec LDAC is supported only if the device has the corresponding
+          // shared library installed.
+          supported = has_shared_library(LHDCV5_DECODER_LIB_NAME);
+          break;
+        // Savitech Patch - END
         case BTAV_A2DP_CODEC_INDEX_MAX:
           // Needed to avoid using "default:" case so we can capture when
           // a new codec is added, and it can be included here.
